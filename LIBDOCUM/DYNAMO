1************
 *DYNAML/DYN*
 ************
0DYNAML/DYNAMO/DYNAMD
 --------------------
01.      PURPOSE
 ---------------
0   (A)  ALLOWS DYNAMIC OVERLAYS AND HENCE WHEN THE VARIOUS
         ROUTINES ARE NO LONGER REQUIRED. THEY CAN BE DISCARDED
         TO MAKE CORE STORAGE SPACE AVAILABLE TO OTHER ROUTINES.
0   (B)  COMMON SUBROUTINES CAN BE LINK EDITED ONTO A LIBRARY AND
         CAN BE DYNAMICALLY CALLED INTO CORE BY THE VARIOUS
         INDIVIDUAL PROGRAMS THAT REQUIRE THEM.  HENCE IF THE
         SUBROUTINE HAS TO BE MODIFIED AT ANY TIME, THE USER
         PROGRAMS DO NOT HAVE TO BE RECOMPILED.
02.      LIMITATIONS
 -------------------
0   (A)  THE DYNAMICALLY LOADED MODULES WILL ONLY REMAIN IN CORE
         FOR THE DURATION OF THE TASK (JOB STEP).
0   (B)  THE LOAD MODULE TO BE CALLED MUST HAVE A NAME OR ALIAS
         THAT IS THE SAME AS THE ENTRY POINT NAME OF THE MODULE.
03.      INPUT DATA
 ------------------
0        DETERMINED BY THE CALLED MODULE.
04.      OUTPUT DATA
 -------------------
0        DETERMINED BY THE CALLED MODULE.
05.      OPERATION
 -----------------
0        THE CALLING SEQUENCE IN A COBOL PROGRAM IS
0   (A)  ENTER LINKAGE.
         CALL 'DYNAML' USING NAME.
         ENTER COBOL.
0        NAME IS AN 8 BYTE FIELD DEFINED IN THE DATA DIVISION OF
         THE COBOL PROGRAM AND WILL CONTAIN THE IDENTIFYING NAME
         OF THE ROUTINE TO BE DYNAMICALLY CALLED INTO CORE.  NAME
         MUST BE PADDED WITH BLANKS WHENEVER THE IDENTIFYING NAME
         IS LESS THAN EIGHT BYTES IN LENGTH.
0        THE ABOVE CALL WILL CAUSE THE ROUTINE IN NAME TO BE DYNAMIC
         LOADED INTO CORE.  CONTROL WILL THEN BE RETURNED TO THE
         COBOL PROGRAM.
0   (B)  ENTER LINKAGE.
         CALL 'DYNAMO' USING NAME, PAR-2, PAR-3, ..... ETC.
         ENTER COBOL.
0        NAME IS AS DEFINED ABOVE (A).  PAR-2. PAR-3. .... ETC ARE
         PARAMETER INFORMATION TO BE PASSED TO THE DYNAMICALLY CALLED
         ROUTINE.  THE FIELD CONTAINING THE IDENTIFYING NAME OF THE
         ROUTINE TO BE LOADED (NAME) MUST ALWAYS BE THE FIRST
         PARAMETER OF THE USING STATEMENT.
1************
 *DYNAML/DYN*
 ************
0        PAR-2, PAR-3, ... ETC ARE DETERMINED BY THE CALLED ROUTINE
0        THE ABOVE CALL WILL CAUSE THE ROUTINE IN NAME TO BE
         DYNAMICALLY CALLED INTO CORE.  PARAMETERS PAR-2. PAR-3.
         ... ETC. ARE PASSED TO THE ROUTINE.  THE ROUTINE IS THEN
         EXECUTED. AND AFTER EXECUTION, IS DELETED FROM CORE.  CONTROL
         IS THEN RETURNED TO THE COBOL PROGRAM.
0   (C)  ENTER LINKAGE.
         CALL 'DYNAMO' USING NAME.
         ENTER COBOL.
0        NAME IS AS DEFINED ABOVE (A).
0        THE ABOVE CALL WILL CAUSE THE ROUTINE IDENTIFIED IN NAME,
         TO BE DELETED FROM CORE.
0        DYNAML AND DYNAMO BOTH CAUSE THE MACRO LOAD TO BE EXECUTED.
    WHEN LOAD IS EXECUTED, A RESPONSIBILITY COUNT IS INCREASED BY 1.
    THE MODULE TO BE LOADED IS ONLY LITERALLY LOADED INTO CORE WHEN
    THE RESPONSIBILITY COUNT FOR THAT MODULE IS ZERO.
0        DYNAMO AND DYNAMD BOTH CAUSE THE MACRO DELETE TO BE
    EXECUTED.  WHEN DELETE IS EXECUTED, THE RESPONSIBILITY COUNT IS
    REDUCED BY 1.  WHEN THE RESPONSIBILITY COUNT REACHES ZERO. THE
    MODULE IS DELETED FROM CORE.
0        A LOAD MODULE WILL BE DELETED FROM CORE IF (A) RESPONSIBILITY
    COUNT REACHES ZERO, OR (B) THE TASK IS COMPLETED (I,E: FOR PCP, END
    OF JOB STEP).
0   EXAMPLES OF USE
 ------------------
0        ROUTINES TO BE DYNAMICALLY CALLED CAN BE CONTROLLED EXTERNALL
    E.G: DATA OR CONTROL CARDS.
0        READ CARD-DATA AT END GO TO CARRY-ON.
         MOVE PROGRAM-NO TO NAME.
         ENTER LINKAGE.
         CALL 'DYNAMO' USING NAME.
         ENTER COBOL.
0        DYNAMO CAUSES ONE LOAD AND ONE DELETE TO BE EXECUTED,
    GIVING A RESPONSIBILITY COUNT OF 1+ (-1) = ZERO, THEREFORE THE
    MODULE IDENTIFIED IN NAME IS DELETED, WHEN CONTROL IS RETURNED TO
    THE COBOL PROGRAM.
0        DYNAMO SHOULD ONLY BE CALLED BY ITSELF IF THE ROUTINE TO BE
    LOADED IS REQUIRED ONCE ONLY.  THIS IS BECAUSE DYNAMO LITERALLY
    CAUSES A SEARCH OF PROGRAM LIBRARIES AND THEN A LOAD.  THIS OF
    COURSE CAN CAUSE THE PROCESS TIME OF THE MASTER PROGRAM TO BE VERY
    SLOW INDEED.
1************
 *DYNAML/DYN*
 ************
0             TO PREVENT DYNAMO DELETING THE CALLED MODULE (WHICH
    HAS THE NAME EFFECT AS PREVENTING THE MODULE BEING LITERALLY LOAD
    EVERY TIME). THE USER HAS TO ENSURE THAT THE RESPONSIBILITY COUNT
    FOR THAT MODULE DOES NOT REACH ZERO UNTIL THE MODULE IS NO LONGER
    REQUIRED.
0             TO EFFECT THIS, THE FOLLOWING TECHNIQUE SHOULD BE ADOPTED:-
                      .
                      .
                      .
0   FIRST.         CALL 'DYNAML' USING NAME.
                      .
                      .
0   NEXT.          CALL 'DYNAMO' USING NAME.
                      .
                      .
                   (NORMAL COBOL PROCESSING IF REQUIRED).
                      .
                      .
                   GO TO NEXT.
0   END-OF-RTN.       CALL 'DYNAMO' USING NAME.
                      GO TO FIRST.
0             USE DYNAML TO INITIALLY CALL THE REQUIRED ROUTINE, THIS
    WILL EXECUTE A LOAD AND WILL SET THE RESPONSIBILITY COUNT TO 1.
    THEN USE DYNAMO, WHICH WILL NOT LITERALLY LOAD THE ROUTINE INTO
    CORE AS IT IS ALREADY PRESENT, BUT WILL INCREASE THE RESPONSIBILITY
    COUNT BY 1, WILL EXECUTE THE ROUTINE, AND WILL THEN EXECUTE A
    DELETE WHICH WILL REDUCE THE RESPONSIBILITY COUNT BY 1. (WHICH OF
    COURSE LEAVES A VALUE OF 1 AS SET UP BY DYNAML).
0                  RECURRING USE OF DYNAMO WILL THEREFORE GIVE THE SAME
    EFFECT AS A BRANCH.
0             WHEN THE CALLED MODULE IS NO LONGER REQUIRED, DYNAMD
    SHOULD BE USED WHICH WILL CAUSE A DELETE TO BE EXECUTED WHICH WILL
    REDUCE THE RESPONSIBILITY COUNT BY 1.  (WHICH, BY USING THIS
    TECHNIQUE. WILL LEAVE A VALUE OF ZERO, AND WILL CAUSE THE MODULE
    TO BE DELETED).
0   DYNAML    CREATES A RESPONSIBILITY COUNT VALUE OF (+1)
    DYNAMO    CREATES A RESPONSIBILITY COUNT VALUE OF ZERO
    DYNAMD    CREATES A RESPONSIBILITY COUNT VALUE OF (-1)
