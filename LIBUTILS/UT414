B1801    START 0
*  PROGRAM NAME B1801
*  PROGRAMMER   D.F.HOFFMANN
*  DATE WRITTEN OCT. 1970
*  NOTE-
*      SIGNIFICANT CHANGES WERE INCORPORATED BY G. L. AUPPERLE DURING
*      OCTOBER 1973 TO ALLOW-
*           1- MULTIPLE OUTPUT DATA SETS ON SELECT RUNS  (OUTDD=)
*           2- DEFAULT DATA SET TO WRITE DELETED RECORDS
*              ON SELECT RUNS  (DEFAULT)
*           3- PROCESSING OF IMS LOG RECORDS ON SELECT RUNS  (LOGID=)
*           4- PROCESSING OF SPANNED RECORDS  (VS OR VBS)
*
*  PROGRAM PURPOSE-
*      PROVIDE A MEANS OF SELECTING, DELETING OR MODIFING RECORDS OF A
*      SEQUENTIALLY ORGANIZED FILE IF THE RECORDS CAN BE IDENTIFIED BY
*      THEIR CONTENTS. CONTROL CARDS SPECIFY WHAT TYPE OF RUN IS BEING
*      MADE AND THE CONDITIONS FOR SELECTING, DELETING OR MODIFING
*      RECORDS.
*      CONTROL CARD FORMAT-
*
*      MMMMMM,C,PPPPP,T'A...A'
*         *   *   *   *   *
*         *   *   *   *   * ARGUMENT TO BE COMPARED TO RECORD.
*         *   *   *   * TYPE OF ARGUMENT- C CHAR, P PACKED, X HEX.
*         *   *   * POSITION OF FIELD IN RECORD TO BE COMPARED.
*         *   * CONDITIONAL OPERATOR- E EQ, G GT, L LT, U UE.
*         * MODE OF RUN- SELECT, DELETE, MODIFY.
*
*      IF MODE OF RUN IS SELECT, THE FOLLOWING OPTIONAL POSITIONAL
*      PARAMETERS MAY BE SPECIFIED-
*
*      SELECT(,OUTDD=XXXXXXXX)(,DEFAULT)(,LOGID=NN),C,PPPPP,T'A...A'
*                       *          *            *
*                       *          *            * 1 OR 2 DIGIT IMS LOG
*                       *          *              RECORD TYPE (1-67)
*                       *          * SPECIFIES DELETED RECORDS ARE TO
*                       *            BE WRITTEN TO SYSUT2  (VALID
*                       *            ONLY WHEN OUTDD IS SPECIFIED
*                       *            AND IF LOGID IS NOT SPECIFIED)
*                       * ANY VALID JCL DDNAME OTHER THAN SYSUT1 OR
*                         SYSUT2
*      NOTE-
*           IF LOGID WAS SPECIFIED, ALL FIELD OFFSETS WILL BE TREATED
*           AS RELATIVE TO 0  (FIRST BYTE OF SDW)
*
*       IF MODE OF RUN IS MODIFY AN INSERT CONTROL CARD MUST FOLLOW-
*
*      INSERT,PPPPP,T'L...L'
*         *     *   *   *
*         *     *   *   * LITERAL TO BE INSERTED INTO SPECIFIED RECORD.
*         *     *   * TYPE OF LITERAL- C CHAR, P PACKED, X HEX.
*         *     * POSITION IN RECORD WHERE LITERAL IS TO BE INSERTED.
*         * CONTROL CARD TYPE IDENTIFIER.
*
*      AN ENTRY IS CONSTRUCTED IN CORE FOR EACH ARGUMENT OR LITERAL.
*      A GETMAIN IS ISSUED FOR EACH ENTRY AND THEN CHAINED TO PREVIOUS
*      ENTRY. THE FORMAT OF THE ENTRY IN CORE FOLLOWS-
*
*      EDDDPPLCTA...A
*      * * * ***  *
*      * * * ***  * ARGUMENT OR LITERAL.
*      * * * *** THIS BYTE INDICATES THE TYPE OF RUN AND ARGUMENT/LIT-
*      * * * ** CONDITIONAL OPERATOR 80=E,              SELECT ENTRY 8X
*      * * * *                       70=U,              DELETE ENTRY 4X
*      * * * * LENGTH -1 OF          40=L,              MODIFY ENTRY 2X
*      * * *   ARGUMENT/LITERAL.     20=G.              INSERT ENTRY 1X
*      * * * OFFSET OF FIELD IN RECORD.                 NUMR LITERAL X8
*      * * ADDRESS OF NEXT ENTRY.                       PACK LITERAL X4
*          LO-ORDER BIT IS ON IF DEFAULT WAS SPECIFIED
*      * BIT 0 IS ON IF END OF SET                      HEX  LITERAL X2
*        BITS 1-7 ARE SET TO OUTPUT FILE INDEX          CHAR LITERAL X1
*        IF OUTDD WAS SPECIFIED  (VALUE=0-127)
*
*      AN ENTRY IS CONSTRUCTED IN GETMAINED CORE FOR EACH OUTPUT
*      DATA SET IF OUTDD WAS SPECIFIED.  THE FORMAT FOLLOWS-
*
*      ABBBCDDDEEEEEEEEFFFF
*      * * * *    *     *
*      * * * *    *     * OUTPUT RECORD COUNTER
*      * * * *    * OUTPUT FILE DDNAME
*      * * * * ADDRESS OF OUTPUT FILE DCB
*      * * * SET TO X'01' IF RECORD PREVIOUSLY WRITTEN
*      * * ADDRESS OF NEXT ENTRY (ZERO IF LAST ENTRY)
*      * OUTPUT FILE INDEX (X'00'-X'7F')
*
*      THIS PROGRAM IS DIVIDED INTO TWO PHASES OF LOGIC.
*      PHASE 1 READS AND EDITS THE CONTROL CARDS AND CONSTRUCTS THE
*      ENTRY IN CORE FOR EACH ARGUMENT/LITERAL.
*
*      PHASE 1 REGISTER USAGE-
*
X0       EQU   0   USED BY SYSTEM.
X1       EQU   1   USED BY SYSTEM AND UTILITY USE.
XPARM    EQU   2   ADDRESS OF CTL CD PARAMETER LEFT MOST BYTE.
X2       EQU   2
XSCAN    EQU   3   ADDRESS OF END OF PARAMETER PLUS ONE.
X3       EQU   3
XLENGTH  EQU   4   LENGTH OF PARAMETER.
X4       EQU   4
XLIMIT   EQU   5   END OF CARD- COL 72.
XTABLE   EQU   6   ADDRESS OF OUTPUT TABLE
XBASE1   EQU   7   2ND BASE REGISTER.
XCURR    EQU   8   ADDRESS OF CURRENT ENTRY FROM GETMAIN.
XPREV    EQU   9   ADDRESS OF PREVIOUS ENTRY FROM GETMAIN.
XRETURN  EQU   10  RETURN ADDRESS FOR SUBROUTINES.
XBASE    EQU   11  BASE REGISTER.
XQUOTE   EQU   12  COUNT NUMBER OF QUOTES IN LITERAL SCAN.
X12      EQU   12  USED IN LINKAGE SAVE REGISTERS.
X13      EQU   13  USED BY SYSTEM.
X14      EQU   14  USED BY SYSTEM.
X15      EQU   15  USED BY SYSTEM.
*
ON       EQU   255
OFF      EQU   0
         EJECT
         STM   X14,X12,12(X13)     STORE REGISTERS BACK
         USING B1801,XBASE,XBASE1  ESTABLISH ADDRESSIBILITY
         LR    XBASE,X15           LOAD ENTRY POINT INTO BASE
         LA    XBASE1,4095(XBASE)  SET UP 2ND BASE
         LA    XBASE1,1(XBASE1)
         LR    X15,X13             HOLD SYSTEM SAVE ADDRESS
         BAL   X13,*+76            LOAD SAVE AREA ADDRESS AND HOP OVER
SAVE     DC    18F'0'              MY SAVE AREA
         ST    X13,8(X15)          CRISS-CROSS SAVE AREA POINTERS
         ST    X15,4(X13)
         ST    X1,PARMSAVE         STORE EXEC PARM POINTER
         BAL   XRETURN,PARMANAL    ANALYSE EXEC PARAMETER
OPEN     OPEN  (CARDIN,(INPUT),DATAIN,(INPUT),MSGOUT,(OUTPUT))
         TM    DATAIN+36,X'48'     IS SYSUT1 RECFM VARIABLE SPANNED
         BNO   BYPSCHNG            NO, DCBBFTEK IS OK
         CLOSE (DATAIN,REREAD)     CLOSE SYSUT1 FOR REREAD
         FREEPOOL DATAIN           FORCE NEW BUFFERS FOR SPANNED RCDS
         OI    DATAIN+32,X'60'     INDICATE LOGICAL RECORD INTERFACE
         OPEN  (DATAIN,(INPUT))    RE-OPEN SYSUT1 FOR SPANNED RECORDS
BYPSCHNG EQU   *
         MVC   MSG(34),STARTMSG    PUT OUT STARTING MESSAGE
         BAL   XRETURN,PRINT
         LA    XCURR,ENTPOINT
         SR    XTABLE,XTABLE       CLEAR REG 6
         EJECT
*******************************************************************
*        ISSUE ERROR MESSAGE FOR INVALID EXEC PARAMETER           *
*******************************************************************
         SPACE 3
         CLI   PARMERSW,C'Y'       TEST IF PARM ERROR
         BNE   GETMODE             NO - BRANCH
         MVC   MSG(40),PARMEMSG    MOVE ERROR MESSAGE
         PUT   MSGOUT,MSG          PRINT ERROR MESSAGE
         MVC   MSG,BLANK           CLEAR MESSAGE RECORD AREA
         MVC   RETURNCD,=X'0004'   SET RETURN CODE FOR TERMINATION
         B     GETMODE
***********************************************************************
*        GET 1ST PARAMETER FROM CONTROL CARD. IT SHOULD BE THE RUN MODE
*
GETMODE  BAL   XRETURN,READPARM    GET MODE PARAMETER
         CH    XLENGTH,=H'6'       IS PARM LENGTH 6.
         BE    MODEVER             YES- OK
ERROR01  BAL   XRETURN,ERROR       NO-  WRITE ERROR MESSAGE
MSG01    DC    C'INVALID MODE',X'FF'
*
MODEVER  CLC   SEL,0(XPARM)        MODE = SELECT
         BE    SELR
         CLC   DEL,0(XPARM)               DELETE
         BE    DELR
         CLC   MOD,0(XPARM)                      MODIFY
         BE    MODR
         CLC   INS,0(XPARM)                             INSERT
         BNE   ERROR01             NONE OF THE ABOVE. WRITE ERROR MSG.
INSR     CLI   SETTYPE,X'20'       INSERT CARD TEST FOR PREV MODIFY
         MVI   SETTYPE,X'10'       SET ENTRY TYPE TO 1X FOR INSERT RUN
         BE    STRMODE                 PREVIOUS CARD MUST BE MODIFY CRD
ERROR02  BAL   XRETURN,ERROR
MSG02    DC    C'INSERT CARD NOT PRECEEDED BY MODIFY CARD',X'FF'
*
MODR     CLI   SETTYPE,X'10'       MODIFY CARD TEST FOR PREV INSERT
         MVI   SETTYPE,X'20'       SET ENTRY TYPE TO 2X FOR MODIFY RUN
         BE    STRMODE                 PREVIOUS CARD MUST BE INSERT CRD
ERROR03  BAL   XRETURN,ERROR
MSG03    DC    C'MODIFY CARD NOT PRECEEDED BY INSERT CARD',X'FF'
SELR     CLI   SETTYPE,X'80'       SELECT CARD TEST FOR PREV SELECT
         MVI   SETTYPE,X'80'       SET ENTRY TYPE TO 8X FOR SELECT RUN
         BE    STRMODE             BRANCH IF TYPE RUN CONSISTENT
         B     FIRSTSW             ERROR UNLESS FIRST TIME THRU
DELR     CLI   SETTYPE,X'40'       DELETE CARD TEST FOR PREV DELETE
         MVI   SETTYPE,X'40'       SET ENTRY TYPE TO 4X FOR DELETE RUN
         BE    STRMODE             BRANCH IF TYPE RUN CONSISTENT
FIRSTSW  B     STRMODE             NOP IF NOT 1ST TIME THRU
ERROR04  BAL   XRETURN,ERROR
MSG04    DC    C'INCONSISTENT TYPE RUN SPECIFIED',X'FF'
*
         EJECT
***********************************************************************
*        IF SELECT CARD, CHECK FOR OPTIONAL PARAMETERS
*        OUTDD, DEFAULT, AND LOGID
*
STRMODE  EQU   *
         USING TBLENTRY,XTABLE
         MVI   DFLTIND,X'00'       ZERO OUT DEFAULT INDICATOR
         CLI   SETTYPE,X'80'       IS THIS A SELECT CARD BEING SCANNED
         BNE   BYPASEL             NO, BYPASS OPTIONAL PARAMETER CHECK
         BAL   XRETURN,GETPARM     GET FIRST CONTROL CARD PARAMETER
         CLC   0(6,XPARM),=C'OUTDD=' IS THIS OUTDD=
         BNE   CHKDFLT             NO, LOOK FOR DEFAULT
         CLI   FIRSTSW+1,X'F0'     IS THIS FIRST CONTROL CARD
         BE    MSG04A+LNG04A       YES, BRANCH
         TM    OUTOPTS,MULTOUT     OUTDD SPECIFIED ON PREVIOUS CARD(S)
         BO    MSG04A+LNG04A+4     YES, BRANCH
ERROR04A BAL   XRETURN,ERROR
MSG04A   DC    C'INCONSISTENT SPECIFICATION OF OUTDD',X'FF'
         DS    0H
LNG04A   EQU   *-MSG04A
         OI    OUTOPTS,MULTOUT     INDICATE OUTDD SPECIFIED
         CLC   6(6,XPARM),=C'SYSUT2'    IS OUTDD=SYSUT2
         BNE   MSG04B+LNG04B       NO, CHECK LENGTH OF DDNAME
ERROR04B BAL   XRETURN,ERROR
MSG04B   DC    C'''OUTDD=SYSUT2'' INVALID SPECIFICATION',X'FF'
         DS    0H
LNG04B   EQU   *-MSG04B
         SH    XLENGTH,=H'6'       GET LENGTH OF KEYWORD
         CH    XLENGTH,=H'8'       DOES DDNAME EXCEED 8 CHARACTERS
         BCTR  XLENGTH,0           SUBTACT 1 TO GET RELATIVE LENGTH
         BNH   MSG04C+LNG04C       NO, SEE IF ANOTHER ENTRY IS NEEDED
ERROR04C BAL   XRETURN,ERROR
MSG04C   DC    C'DDNAME EXCEEDS 8 CHARACTERS',X'FF'
         DS    0H
LNG04C   EQU   *-MSG04C
         XC    DDNAMSAV,DDNAMSAV   CLEAR OUT DDNAME WORK AREA
         EX    XLENGTH,MOVEDDNM    MOVE THE DDNAME
         OC    DDNAMSAV,=CL8' '  BLANK OUT REMAINDER OF FIELD
         B     BYPSMOVE            GO AND COMPARE DDNAMES
MOVEDDNM MVC   DDNAMSAV(0),6(XPARM) MOVE IN DDNAME
BYPSMOVE LTR   XTABLE,XTABLE       IS THERE A PREVIOUS ENTRY
         BZ    GETENTRY            NO, GO AND GET ONE
         ST    XTABLE,PTRSAVE      SAVE ADDRESS OF PREVIOUS ENTRY
         L     XTABLE,TABLEPTR     GET ADDRESS OF FIRST TABLE ENTRY
TABLLOOP CLC   DDNAMSAV,TBLDDNAM   COMPARE DDNAME'S
         BNE   NXTTABL             NO, LOOK AT NEXT ENTRY
         MVC   CURRINDX(1),TBLINDEX USE SAME ENTRY INDEX
         L     XTABLE,PTRSAVE      RESTORE ADDRESS OF LAST ENTRY
         B     GETDFLT             GO AND GET ANOTHER PARAMETER
NXTTABL  L     XTABLE,TBLLINK      LOAD NEXT ENTRY ADDRESS
         LA    XTABLE,0(,XTABLE)   CLEAR HI-ORDER BYTE
         LTR   XTABLE,XTABLE       ANY MORE ENTRIES
         BNZ   TABLLOOP            YES, LOOK AT IT
         IC    XTABLE,INDXCNT      GET THE INDEX COUNT
         CH    XTABLE,=H'127'      IS INDEX COUNT AT MAXIMUM
         BL    MSG04C1+LNG04C1     NO, INCREMENT INDEX
ERROR4C1 BAL   XRETURN,ERROR
MSG04C1  DC    C'MAXIMUM OUTDD PARAMETERS EXCEEDED',X'FF'
         DS    0H
LNG04C1  EQU   *-MSG04C1
         LA    XTABLE,1(,XTABLE)   BUMP IT BY 1
         STC   XTABLE,INDXCNT      PUT IT BACK
         MVC   CURRINDX(1),INDXCNT USE THE CURRENT INDEX COUNT
         L     XTABLE,PTRSAVE      RESTORE ADDRESS OF LAST ENTRY
GETENTRY LA    X0,TBLENTSZ         LOAD REG 0 WITH ENTRY SIZE
         GETMAIN R,LV=(0)
         XC    0(TBLENTSZ,X1),0(X1)  ZERO OUTPUT ENTRY
         LTR   XTABLE,XTABLE       PREVIOUS GETMAIN ISSUED
         BNZ   STORLINK            YES, SET UP LINK FIELD
         ST    X1,TABLEPTR         SAVE POINTER TO FIRST ENTRY
         B     BYPSLINK            BYPASS SET-UP ON LINK FIELD
STORLINK O     X1,TBLLINK          SAVE INDEX FROM PREVIOUS ENTRY
         ST    X1,TBLLINK          SET-UP ENTRY LINK FIELD
BYPSLINK LR    XTABLE,X1           LOAD ENTRY POINTER
         MVC   TBLDDNAM,DDNAMSAV   MOVE DDNAME INTO TABLE ENTRY
         MVC   TBLINDEX(1),CURRINDX MOVE INDEX INTO ENTRY
         MVI   TBLRECNT+3,X'0C'    PUT SIGN IN RECORD COUNTER
GETDFLT  BAL   XRETURN,GETPARM     GET ANOTHER CONTROL CARD PARAMETER
CHKDFLT  CLC   0(7,XPARM),=C'DEFAULT' IS THIS DEFAULT
         BNE   CHKLOGID            NO, LOOK FOR LOGID
         CH    XLENGTH,=H'7'       IS PARM LENGTH 7 BYTES
         BE    MSG04D+LNG04D       YES, BRANCH
ERROR04D BAL   XRETURN,ERROR
MSG04D   DC    C'DEFAULT PARAMETER INVALID',X'FF'
         DS    0H
LNG04D   EQU   *-MSG04D
         TM    OUTOPTS,MULTOUT     WAS OUTDD SPECIFIED
         BO    MSG04E+LNG04E       YES, BRANCH
ERROR04E BAL   XRETURN,ERROR
MSG04E   DC    C'DEFAULT PARAMETER INVALID, OUTDD NOT SPECIFIED',X'FF'
         DS    0H
LNG04E   EQU   *-MSG04E
         OI    OUTOPTS,DFLTOUT     INDICATE DEFAULT SPECIFIED
         MVI   DFLTIND,X'01'       SET DEFAULT INDICATOR FOR THIS SET
         BAL   XRETURN,GETPARM     GET NEXT CONTROL CARD PARAMETER
CHKLOGID CLC   0(6,XPARM),=C'LOGID=' IS THIS LOGID=
         BNE   BYPASEL             NO, BRANCH
         TM    OUTOPTS,DFLTOUT     WAS DEFAULT SPECIFIED
         BNO   MSG04F+LNG04F       NO, BRANCH
ERROR04F BAL   XRETURN,ERROR
MSG04F   DC    C'DEFAULT AND ''LOGID='' INCOMPATIBLE PARAMETERS',X'FF'
         DS    0H
LNG04F   EQU   *-MSG04F
         SH    XLENGTH,=H'6'       GET LENGTH OF KEYWORD
         CH    XLENGTH,=H'2'       DOES LOG ID EXCEED 2 CHARACTERS
         BNH   MSG04G+LNG04G       NO, SET UP ARGUMENT
ERROR04G BAL   XRETURN,ERROR
MSG04G   DC    C'LOGID PARAMETER INVALID',X'FF'
         DS    0H
LNG04G   EQU   *-MSG04G
         CLI   FIRSTSW+1,X'F0'     IS THIS FIRST CONTROL CARD
         BE    MSG04H+LNG04H       YES, LOGID IS VALID
         TM    OUTOPTS,IMSOUT      WAS LOGID SPECIFIED ON FIRST CARD
         BO    MSG04H+LNG04H
ERROR04H BAL   XRETURN,ERROR
MSG04H   DC    C'INCONSISTENT SPECIFICATION OF LOGID',X'FF'
         DS    0H
LNG04H   EQU   *-MSG04H
         OI    OUTOPTS,IMSOUT      INDICATE LOGID SPECIFIED
         MVC   LOGIDSAV,6(XPARM)   SAVE LOG ID
         S     XSCAN,=F'10'        BACK UP PARM SCAN
         MVC   0(10,XSCAN),=C',E,4,X''  ''' MOVE IN ARGUMENT SKELETON
         CH    XLENGTH,=H'2'       IS LOG ID 2 CHARACTERS
         BNE   MOVEID1             NO, ONLY 1 CHARACTER
         MVC   7(2,XSCAN),LOGIDSAV MOVE LOG ID INTO ARGUMENT
         B     BYPASEL             GET OUT
MOVEID1  MVI   7(XSCAN),C'0'       MOVE IN CHARACTER ZERO
         MVC   8(1,XSCAN),LOGIDSAV MOVE LOG ID INTO ARGUMENT
         DROP  XTABLE
BYPASEL  NI    FIRSTSW+1,X'0F'     NOP 1ST TIME SWITCH
         CLI   SETTYPE,X'80'       IS THIS A SELECT CARD BEING SCANNED
         BNE   CLEARENT            NO, DON'T ADJUST SCAN POINTER
         TM    OUTOPTS,IMSOUT      WAS LOGID SPECIFIED
         BO    CLEARENT            YES, SCAN POINTER OK
         S     XSCAN,=F'2'         NO, BACK-UP SCAN POINTER 2 BYTES
CLEARENT XC    ENTRY(9),ENTRY      CLEAR ENTRY BUILD AREA
         MVC   ENTTYPE,SETTYPE     SET ENTRY TYPE
         CLI   SETTYPE,X'10'       IS THIS AN INSERT CARD BEING SCANNED
         BE    GETPOS              YES- SKIP CONDITION SCAN
         EJECT
***********************************************************************
*        GET NEXT PARM FROM CONTROL CARD. IT SHOULD BE CONDITIONAL
*        OPERATOR.
*
GETCOND  BAL   XRETURN,GETPARM     GET PARM CONDITION- E, L, G, U.
         CH    XLENGTH,=H'1'       PARM LENGTH OF 1
         BNE   ERROR05             NO- WRITE ERROR
         CLI   0(XPARM),C'U'       PARM = U
         BNE   TRYE                    SET COND OPERATOR TO '70'
         MVI   ENTCOND,X'70'
         B     GETPOS
TRYE     CLI   0(XPARM),C'E'       PARM = E
         BNE   TRYL                    SET COND OPERATOR TO '80'
         MVI   ENTCOND,X'80'
         B     GETPOS
TRYL     CLI   0(XPARM),C'L'       PARM = L
         BNE   TRYG                    SET COND OPERATOR TO '40'
         MVI   ENTCOND,X'40'
         B     GETPOS
TRYG     CLI   0(XPARM),C'G'       PARM = G
         BNE   ERROR05                 SET COND OPERATOR TO '20'
         MVI   ENTCOND,X'20'
         B     GETPOS
ERROR05  BAL   XRETURN,ERROR
MSG05    DC    C'CONDITIONAL OPERATOR INVALID',X'FF'
         EJECT
***********************************************************************
*        GET NEXT PARM FROM CONTROL CARD. IT SHOULD BE POSITION OF
*        FIELD IN RECORD
*
GETPOS   BAL   XRETURN,GETPARM     GET POSITION PARM
         CH    XLENGTH,=H'5'       IT CAN'T BE MORE THAN 5 DIGITS
         BH    ERROR06                 IN LENGTH
         BAL   XRETURN,EDPAKCVB    EDIT AND PACK POSITION PARAMETER
         CVB   X1,DWORD            CONVERT POSITION PARMATER TO BINARY
         CH    X1,=H'32760'        VALUE MUST NOT EXCEED 32760
         BH    ERROR06
         TM    OUTOPTS,IMSOUT      WAS LOGID SPECIFIED
         BO    STOREPOS            YES, POSITION IS ALREADY RELATIVE
         BCTR  X1,0
STOREPOS STH   X1,ENTPOS           STORE IN ENTRY
         B     GETLIT
ERROR06  BAL   XRETURN,ERROR
MSG06    DC    C'POSITION FIELD MUST BE NUMERIC VALUE 1 TO 32760',X'FF'
         EJECT
***********************************************************************
*        GET NEXT PARM FROM CONTROL CARD. IT SHOULD BE A LITERAL
*
GETLIT   MVI   LITSW,ON            SET LITERAL SCAN SWITCH ON
         BAL   XRETURN,GETPARM     GET LITERAL PARAMETER
         MVI   LITYPE,C'C'         SET LITERAL TYPE TO DEFAULT TO CHAR
         CLI   0(XPARM),X'7D'      IS 1ST POSITION OF PARM A QUOTE
         BE    CKENDQTE                YES- BRANCH
         MVC   LITYPE,0(XPARM)         NO- 1ST POSITION MUST BE TYPE
         LA    XPARM,1(XPARM)          SAVE IT AND STEP TO NEXT POSIT'N
         BCTR  XLENGTH,0               AND STEP PARM LENGTH DOWN BY 1
         CLI   0(XPARM),X'7D'      IS SECOND POSITION OF PARM A QUOTE
         BNE   ERROR08                 NO- INVALID LITERAL PARAMETER
*
CKENDQTE S     XLENGTH,=F'2'       ADJUST PARM LENGTH FOR QUOTES
         LA    X1,1(XPARM,XLENGTH) FIND LAST POSITION OF PARM
         CLI   0(X1),X'7D'         IS LAST POSITION A QUOTE
         BE    QUOTEOK                 YES- BRANCH
ERROR08  BAL   XRETURN,ERROR           NO- INVALID LITERAL PARAMETER
MSG08    DC    C'LITERAL NOT ENCLOSED IN QUOTES',X'FF'
*
QUOTEOK  LA    XPARM,1(XPARM)      ADJ POINTER TO POS PAST 1ST QUOTE
         CLI   LITYPE,C'C'
         BE    CHAR                LITERAL TYPE CHARACTER
         CLI   LITYPE,C'P'
         BE    PACKED                           PACKED
         CLI   LITYPE,C'X'
         BE    HEX                              HEX
         CLI   LITYPE,C'N'
         BNE   ERROR09
         OI    ENTTYPE,X'08'                    NUMERIC
         B     SIGNTEST
ERROR09  BAL   XRETURN,ERROR           NO- PUT OUT MESSAGE
MSG09    DC    C'INVALID LITERAL TYPE',X'FF'
         EJECT
***********************************************************************
*        LITERAL IS PACKED. CHECK FOR SIGN, EDIT FOR NUMERIC AND PACK.
*
PACKED   OI    ENTTYPE,X'04'       INDICATE THIS LITERAL IS PACKED TYPE
SIGNTEST CLI   0(XPARM),C'+'       IS SIGN PRESENT
         BE    PLUS                    BRANCH IS PLUS
         CLI   0(XPARM),C'-'
         BNE   PACKIT              BRANCH IF NO SIGN. FALLTHRU IF MINUS
MINUS    MVI   SIGN,X'DF'          MINUS SIGN PRESENT. STORE AND
         B     CHAPIT              BRANCH.
PLUS     MVI   SIGN,X'CF'          PLUS SIGN PRESENT.
CHAPIT   BCTR  XLENGTH,0           CHAP LENGTH BY 1 FOR SIGN.
         LA    XPARM,1(XPARM)      STEP PAST SIGN POSITION.
PACKIT   BAL   XRETURN,EDPAKCVB    CONVERT TO PACKED
         MVI   SIGN,X'FF'          RESET SIGN.
         TM    ENTTYPE,X'08'       ED FIELD.
         BO    NUMERIC             BRANCH IS NUMERIC FIELD
         LR    XPARM,X1            SET PARM TO PACKED FIELD
         STC   XLENGTH,MASK        LENGTH SHOULD BE ODD NUMBER OF BYTES
         LR    XLENGTH,X0          SET XLENGTH TO LENGTH OF PACKED
         TM    MASK,X'01'
         BO    ODDOK               ODD- YES O.K.
         MVC   MSG(77),WARNMSGP       - NO WARN MESSAGE
         BAL   XRETURN,PRINT
         MVC   RETURNCD,=X'0004'        SET RETURN CODE
ODDOK    LA    XLENGTH,1(XLENGTH)
         B     STORENT
NUMERIC  CLI   SETTYPE,X'10'       IS THIS A NUMERIC INSERT
         BE    STORENT             YES- STORE IT
         LR    XPARM,X1            NO- POINT TO PACKED FIELD AND
         B     STORENT             STORE IT.
         EJECT
***********************************************************************
*        CONVERT EACH 2 BYTES TO 1 HEX BYTE. EDIT FOR 0-9 OR A-F.
*
HEX      OI    ENTTYPE,X'02'       INDICATE LITERAL IS IN HEX
         ST    XLENGTH,DWORD       HEX LITERAL LENGTH
         TM    DWORD+3,X'01'           MUST BE EVEN. IS IT.
         BZ    ZERONE                  YES- BRANCH
         LA    XLENGTH,1(XLENGTH)      NO- RIGHT ADJUST. LITERAL LENGTH
         BCTR  XPARM,0                 GOES UP BY ONE. BACK DOWN PARM
         MVI   0(XPARM),X'F0'          POINTER BY ONE. PUT A ZERO THERE
         MVC   MSG(73),WARNMSGH    WARN OF ODD NUMBER OF DIGITS IN
         BAL   XRETURN,PRINT       HEX LITERAL
         MVC   RETURNCD,=X'0004'   SET RETURN CODE
ZERONE   SR    X1,X1               ZERO X1 WHICH WILL BE LENGTH CONTROL
HEXLOOP  SR    X0,X0               ZERO X0
         IC    X0,0(XPARM,X1)      PICKUP 1ST CHARACTER INTO X0
         CH    X0,=H'193'          IS IT LESS THAN 'C1'
         BL    ERROR10             YES- ERROR
         CH    X0,=H'199'          NO- IS IT LESS THAN 'C7'
         BL    HEXATOF             YES- IT IS BETWEEN A AND F
         CH    X0,=H'240'          NO- IS IT LESS THAN 'F0'
         BL    ERROR10             YES- ERROR
         CH    X0,=H'249'          NO- IS IT GREATER THAN 'F9'
         BH    ERROR10             YES- ERROR
HEX0TO9  SH    X0,=H'57'           NO- IT IS BETWEEN 0 AND 9. SUBTRACT
HEXATOF  SH    X0,=H'183'          TOTAL OF 240. A-F SUBTRACT 183.
         LA    X1,1(X1)            STEP LENGTH BY ONE.
         STC   X1,MASK             HAVE WE PROCESSED AN EVEN NUMBER OF
         TM    MASK,X'01'          BYTES.
         BZ    EVEN                YES- BRANCH
         SLL   X0,4                NO- SHIFT TO ZONE POSITION
         STC   X0,HEXBYTE          STORE IT AND GO GET THE NUMERIC
         B     HEXLOOP             PORTION.
EVEN     AH    X0,HEXHALF          COMBINE TO HALFS TOGETHER
         SRL   X1,1                DIVIDE LENGTH BY 2
         STC   X0,0(XPARM,X1)      STORE CONVERTED BYTE BACK IN PARM
         SLL   X1,1                MULTIPLY LENGTH BY 2 TO ACTUAL
         CR    X1,XLENGTH          HAVE WE PROCESSED ENTIRE PARM FIELD
         BL    HEXLOOP             NO- GO BACK FOR MORE
         LA    XPARM,1(XPARM)      CONVERTED BYTES START AT 2ND POSIT'N
         SRL   XLENGTH,1           OF PARM. DIVIDE ACTUAL LENGTH OF
         B     STORENT             PARM BY 2. GO TO STORE ROUTINE.
*
ERROR10  BAL   XRETURN,ERROR
MSG10    DC    C'HEX LITERAL CONTAINS OTHER THAN 0 THRU 9 OR A THRU F'
         DC    X'FF'
         EJECT
***********************************************************************
*        STORE ARGUMENT/LITERAL ENTRY IN CORE.
*
CHAR     OI    ENTTYPE,X'01'       INDICATE LITERAL IS CHARACTER TYPE.
*
STORENT  LH    X1,ENTPOS           LOAD POSITION OF FIELD IN RECORD
         AR    X1,XLENGTH          ADD LENGTH OF LITERAL.
         CH    X1,DATAIN+82        THIS ADDRESS CANNOT EXTEND BEYOND
         BNH   STOREIT             THE END OF INPUT RECORD.
ERROR15  BAL   XRETURN,ERROR
MSG15    DC    C'POSITION IN RECORD PLUS LITERAL LENGTH GREATER THAN '
         DC    C'INPUT LRECL',X'FF'
STOREIT  LR    XPREV,XCURR         CURR POINTER BECOMES PREVIOUS
         LA    X0,9(XLENGTH)       WE NEED 9 BYTES PLUS LITERAL LENGTH.
         GETMAIN R,LV=(0)          GET IT, IT WILL BE ROUNDED UP TO
         LR    XCURR,X1            DOUBLE WORD. LOAD CURR POINTER.
         O     XCURR,0(XPREV)      SAVE END INDICATOR, OUTPUT INDEX,
*                                  AND DEFAULT INDICATOR
         ST    XCURR,0(XPREV)      STORE ADD OF CURRENT ENTRY IN PREV
*                                  ENTRY AND REPLACE END INDICATOR,
*                                  OUTPUT INDEX, AND DEFAULT INDICATOR
         N     XCURR,INDXMASK      RESET OUTPUT INDEX AND DEFAULT
*                                  INDICATOR IF PRESENT
         LA    XCURR,0(,XCURR)     CLEAR END INDICATOR FOR CURRENT
         BCTR  XLENGTH,0           REDUCE LITERAL LENGTH BY ONE AND
         STC   XLENGTH,ENTLEN      STORE IN ENTRY LENGTH. MOVE ENTRY
         MVC   0(9,XCURR),ENTRY    TO CURRENT TABE SLOT.
         STC   XLENGTH,STOREMVC+1  AND STUFF INTO THE MOVE
STOREMVC MVC   9(0,XCURR),0(XPARM) MOVE LITERAL INTO TABLE ENTRY.
         MVC   0(1,XCURR),CURRINDX MOVE IN INDEX, ZERO IF NOT OUTDD
         OC    3(1,XCURR),DFLTIND  OR DEFAULT INDICATOR INTO ENTRY,
*                                  ZERO IF DEFAULT NOT SPECIFIED
         CLI   ENDSETSW,OFF        IS END OF SET SWITCH IS OFF.
         BE    CLEARENT            YES- CONTINUE TO BUILD SET.
         OI    0(XCURR),X'80'      NO- INDICATE THIS ENTRY IS END OF
         B     GETMODE                 SET.    START NEXT SET.
         EJECT
*******************************************************************
*        ANALYSE EXEC PARAMETER                                   *
*******************************************************************
         SPACE 3
PARMANAL SUBIN SAVE=(X2,X3,X4)
         L     X1,PARMSAVE         LOAD PARAMETER ADDRESS POINTER
         L     XPARM,0(0,X1)       LOAD ADDRESS OF PARM FIELD
         LH    XLENGTH,0(0,XPARM)  LOAD PARM FIELD LENGTH
         LA    XSCAN,2(0,XPARM)    ADDRESS OF FIRST CHARACTER
         SPACE 1
PARMPROC EQU   *
         LTR   XLENGTH,XLENGTH     IS PARM LENGTH ZERO
         BZ    PARMANAX            YES - GO END PARAM ANALYSE
         CLI   0(XSCAN),C','       TEST IF DELIMITTER CHARACTER
         BNE   *+12                NO - BYPASS FORWARD CHAINING
         SH    XLENGTH,=H'1'       DECREMENT PARM LENGTH BY 1
         LA    XSCAN,1(0,XSCAN)    INCREMENT POINTER PAST ','
         CLC   0(6,XSCAN),=C'UNLIKE'    UNLIKE REQUESTED?
         BE    PARMUNLK            YES - BRANCH
         MVI   PARMERSW,C'Y'       SET PARM ERROR SWITCH TO YES
         B     PARMANAX            RETURN
         SPACE 1
PARMUNLK EQU   *
         MVI   UT1LIST,X'85'       SET SYSUT1 EXIT TO GO
         SH    XLENGTH,=H'6'       DECREMENT PARM LENGTH BY 6
         LA    XSCAN,6(0,XSCAN)    INCREMENT POINTER PAST 'UNLIKE'
         B     PARMPROC            GO TEST NEXT PARM
         SPACE 1
PARMANAX EQU   *
         SUBOUT RETURN=(XRETURN),RESTORE=(X2,X3,X4)
         EJECT
*******************************************************************
*        DCB EXIT WHEN UNLIKE DEVICE ATTRIBUTES                   *
*        REQUESTED FOR CONCATENETED SYSUT1 INPUTS                 *
*******************************************************************
         SPACE 3
UT1UNLK  EQU   *
         USING IHADCB,X1           ESTABLISH DCB ADDRESSABILITY
         CLI   UT1RRSW,X'00'       FIRST TIME AROUND
         BNE   UT1OTHTM            NO - GO SET RRSW
         MVI   UT1RRSW,C'0'        SET FIRST TIME TO REREAD SWITCH
         OI    DCBOFLGS,X'08'      SET UNLIKE FLAG ON IN DCB
         BR    14                  RETURN TO OPEN
         SPACE 1
UT1OTHTM EQU   *
         MVI   UT1RRSW,C'1'        TURN ON REREAD SWITCH
         BR    14                  RETURN TO OPEN
         DROP  X1                  DROP DCB ADDRESSABILITY
         EJECT
***********************************************************************
*        PHASE 2.
*        PHASE 2 IS THE ACTUAL PROCESSING OF DATA RECORDS BASED ON
*        SPECIFICATIONS SET UP IN PHASE 1 FROM CONTROL CARDS.
*
*        PHASE 2 REGISTER USAGE IF DIFFERENT THAN PHASE 1.
*
XTRUE    EQU   2   ADDRESS OF ROUTINE TO EXECUTE IF COMPARISON IS TRUE.
XFALSE   EQU   3   ADDRESS OF ROUTINE TO EXECUTE IF COMPARISON IS FALSE
XTABL    EQU   5   ADDRESS OF OUTPUT TABLE
XIN      EQU   6   POINTER TO CURRENT INPUT RECORD.
XDCB     EQU   9   ADDRESS OF OUTPUT DCB LIST
XOUT     EQU   12  POINTER TO CURRENT OUTPUT RECORD.
         USING TBLENTRY,XTABL
         USING IHADCB,X1
         EJECT
***********************************************************************
*        LAST MINUTE SETUP BEFORE DATA RECORD PROCESSING.
*        SET TRUE AND FALSE REGISTERS FOR SELECT, DELETE OR MODIFY.
*        SET SWITCHES BASED ON DCB INFO SUPPLIED AS TO WHETHER THE
*        RECORD LENGTH IS TO BE CHANGED AND WHAT RECFM WAS SPECIFIED.
*
PHASE2   CLI   SETTYPE,X'80'       SET THE ADDRESSES OF THE DESIRED
         BE    SETSEL              ROUTINES IN THE REGISTER USED IF A
         CLI   SETTYPE,X'40'       TRUE COMPARISON IS ENCOUNTERED AND
         BE    SETDEL              THE REGISTER USE IF COMPARE IS FALSE
SETMOD   LA    XTRUE,MODIFY        MODIFY- COMPARE TRUE GO TO MODIFY
         LA    XFALSE,WRITE                COMPARE FALSE GO TO WRITE
         B     OPENDATA
SETDEL   LA    XTRUE,DELETE        DELETE- COMPARE TRUE GO TO DELETE
         LA    XFALSE,WRITE                COMPARE FALSE GO TO WRITE
         B     OPENDATA
SETSEL   LA    XTRUE,WRITE         SELECT- COMPARE TRUE GO TO WRITE
         LA    XFALSE,DELETE               COMPARE FALSE GO TO DELETE
         TM    OUTOPTS,MULTOUT     WAS OUTDD SPECIFIED
         BNO   OPENDATA            NO, DON'T NEED ADDITIONAL DCB'S
         SR    X1,X1               CLEAR REG 1
         IC    X1,INDXCNT          GET NUMBER OF OUTPUT DATA SETS
         LA    X0,1(,X1)           ADD 1 FOR ACTUAL NUMBER
         SLL   X0,2                MULTIPLY BY 4
         GETMAIN R,LV=(0)          GET CORE FOR DCB LIST
         LR    XDCB,X1             REG 9 = DCB LIST ADDRESS
         ST    XDCB,DCBLIST        SAVE DCB LIST ADDRESS
         L     XTABL,TABLEPTR      GET ADDRESS OF FIRST OUTPUT ENTRY
DCBLOOP  LA    X0,DCBLNGTH         GET LENGTH OF OUTPUT DCB
         GETMAIN R,LV=(0)          GET CORE FOR OUTPUT DCB
         ST    X1,0(,XDCB)         STORE ADDRESS IN DCB LIST
         ST    X1,TBLDCBPT         STORE DCB ADDRESS IN OUTPUT ENTRY
         MVI   0(XDCB),X'0F'       SET OUTPUT OPTION FOR OPEN
         MVC   IHADCB(DCBLNGTH),DATAOUT  DUPLICATE SYSUT2 DCB
         MVC   DCBDDNAM,TBLDDNAM   MOVE IN DDNAME
         TM    DATAIN+36,X'48'     IS RECFM VARIABLE SPANNED
         BNO   BYPBFTEK            NO, GO AND LOOK FOR NEXT ENTRY
         OI    DCBBFTEK,X'60'      INDICATE LOGICAL RECORD INTERFACE
BYPBFTEK L     XTABL,TBLLINK       GET ADDRESS OF NEXT OUTPUT ENTRY
         LA    XTABL,0(,XTABL)     CLEAR HI-ORDER BYTE
         LTR   XTABL,XTABL         IS THIS LAST ENTRY
         BZ    DCBEND              YES, GO AND END LIST
         LA    XDCB,4(,XDCB)       BUMP DCB LIST TO NEXT ENTRY
         B     DCBLOOP             GET ANOTHER DCB
DCBEND   OI    0(XDCB),X'80'       SET END-OF-LIST INDICATION
         L     X1,DCBLIST          LOAD ADDRESS OF DCB OPEN LIST
         OPEN  ,MF=(E,(1))         OPEN OUTPUT DATA SETS
         TM    OUTOPTS,DFLTOUT     WAS DEFAULT SPECIFIED
         BO    OPENDATA            YES, NEED TO OPEN SYSUT2
         B     SETSPIE             NO, DON'T OPEN SYSUT2
OPENDATA TM    DATAIN+36,X'48'     IS RECFM VARIABLE SPANNED
         BNO   OPENOUT             NO, GO AND OPEN SYSUT2 AS IT IS
         OI    DATAOUT+32,X'60'    INDICATE LOGICAL RECORD INTERFACE
OPENOUT  OPEN  (DATAOUT,(OUTPUT))  OPEN SYSUT2
SETSPIE  SPIE  SPIEXIT,(7)         INTERCEPT 0C7'S
         CLI   RECFMIN,X'80'      DETERMINE THE RECORD FORM
         BL    RECFMV
         BH    RECFMU
RECFMF   TM    OUTOPTS,MULTOUT     WAS OUTDD SPECIFIED
         BNO   RECFMF1             NO, USE SYSUT2 DCB
         L     X1,DCBSAVE          LOAD ADDRESS OF FIRST OUTPUT DCB
         B     RECFMF2             GO AND COMPARE LRECL'S
RECFMF1  LA    X1,DATAOUT          LOAD ADDRESS OF SYSUT2 DCB
RECFMF2  CLC   DATAIN+82,DCBLRECL  FIXED LENGTH RECORDS- CHANGING
         BE    GET                     LENGTH- NO- GO TO MAIN PROCESING
         BH    SHORTN                  YES- SHORTEN RECORDS
EXTEND   NI    EXTENDSW+1,X'0F'        YES- LENGTHEN RECORDS, SET
         B     GET                     EXTEND SWITCH. GO TO MAIN PROC.
SHORTN   NI    SHORTNSW+1,X'0F'        SET SHORTEN SWITCH.
         B     GET                     GOTO MAIN PROCESSING.
RECFMV   TM    OUTOPTS,IMSOUT      WAS LOGID SPECIFIED
         BO    GET                 YES, GO TO MAIN PROCESSING
         NI    RECFMVSW+1,X'0F'    VARIABLE LENGTH- SET SWITCH
         MVC   RDW,=F'4'          SET RDW TO 4.
         B     GET                     GO TO MAIN PROCESSING.
RECFMU   NI    RECFMUSW+1,X'0F'        UNDEFINED RECORDS- SET SWITCH
         B     GET                     GO TO MAIN PROCESSING.
         DROP  X1
         EJECT
***********************************************************************
*        READ NEXT LOGICAL RECORD. IF ENTERED AT DELETE A DELETE COUNT
*        IS ACCUMULATED AND THEN THE NEXT RECORD IS READ.
*
         USING IHADCB,XDCB
DELETE   BC    0,GETCHECK          NOP ON FIRST DELETE PER RECORD
         TM    SETTYPE,X'80'       IS THIS A SELECT RUN
         BNO   COUNTDEL            NO, COUNT DELETE
         TM    DFLTIND,X'01'       WAS DEFAULT SPECIFIED FOR THIS SET
         BO    COUNTDEL            YES, ADD TO DELETE COUNTER
         TM    TRUEIND,X'01'       WAS THERE AT LEAST ONE TRUE COMPARE
         BO    GETCHECK            YES, SEE IF ANOTHER GET IS NECESSARY
COUNTDEL AP    DELETECT,=P'1'      ADD ONE TO DELETE COUNT
         L     XTABL,ENTSAVE       LOAD TABLE ENTRY POINTER
         L     XTABL,0(,XTABL)     LOAD FIRST WORD OF ENTRY
         ST    XTABL,ENTSAVE       STORE IT BACK
         TM    DFLTIND,X'01'       WAS DEFAULT SPECIFIED FOR THIS SET
         BNO   GETCHECK            SEE IF ANOTHER GET IS NECESSARY
         LA    XDCB,DATAOUT        LOAD ADDRESS OF SYSUT2 DCB
         LR    X1,XDCB             LOAD ADDRESS OF SYSUT2 DCB
         LH    XLENGTH,DATAIN+82   LOAD INPUT LRECL
         OI    DELETE+1,X'F0'      ALLOW ONLY ONE DELETE PER RECORD
         B     RECFMUSW            GO TO THE WRITE ROUTINE
GETCHECK TM    OUTOPTS,MULTOUT     WAS OUTDD SPECIFIED
         BNO   GET                 NO, GET ANOTHER RECORD
         L     XIN,RECSAVE         LOAD ADDRESS OF INPUT RECORD
         LTR   XCURR,XCURR         IS THIS END OF TABLE ENTRY CHAIN
         BNZ   COMPLOOP            NO, LOOK AT NEXT SET
         B     GET                 GET ANOTHER RECORD
GET      GET   DATAIN              GET NEXT RECORD
         CLI   UT1RRSW,C'1'        IS REREAD REQ FOR UNLIKE INPUT
         BNE   *+12                NO - BYPASS FORWARD CHAINING
         MVI   UT1RRSW,C'0'        TURN OF REREAD SWITCH
         B     GET                 GO REREAD NEXT RECORD
         LR    XIN,X1              LOAD ADDRESS POINTER INTO XIN
         A     XIN,RDW            ALLOW FOR RDW 4 BYTES IF RECFM V.
         ST    XIN,RECSAVE         SAVE POINTER TO RECORD
         NI    DELETE+1,X'0F'      ALLOW ONE DELETE PER RECORD
         MVI   TRUEIND,X'00'       CLEAR TRUE COMPARE INDICATOR
         AP    INPUTCT,=P'1'       COUNT RECORDS READ
         MVI   MODCON,X'0C'        RESET MODIFY CONSTANT
         LA    XCURR,ENTPOINT      START RUNNING CHAIN OF TABLE ENTRIES
         TM    OUTOPTS,MULTOUT     WAS OUTDD SPECIFIED
         BNO   TRUE                NO, DON'T PASS THROUGH OUTPUT TABLE
         L     XTABL,TABLEPTR      GET ADDRESS OF FIRST OUTPUT ENTRY
CLRLOOP  MVI   TBLDCBPT,X'00'      CLEAR PREVIOUS WRITE INDICATOR
         L     XTABL,TBLLINK       GET ADDRESS OF NEXT ENTRY
         LA    XTABL,0(XTABL)      CLEAR HI-ORDER BYTE
         LTR   XTABL,XTABL         IS THIS LAST ENTRY
         BNZ   CLRLOOP             NO, GET NEXT ENTRY
         EJECT
***********************************************************************
*        THIS ROUTINE RUNS THRU THE CHAIN OF ARGUMENTS AND THEIR
*        ASSOCIATED PARAMETERS AND COMPARES EACH LITERAL TO THE
*        CURRENT INPUT RECORD.
*
TRUE     ST    XCURR,ENTSAVE       SAVE TABLE ENTRY POINTER
         L     XCURR,0(,XCURR)     LOAD POINTER TO NEXT TABLE ENTRY
         N     XCURR,INDXMASK      RESET ANY OUTPUT INDEX BITS
         LTR   XCURR,XCURR         TEST FOR END OF CHAIN OF TABLE ENTRY
         BP    COMPLOOP            NO- CONTINUE COMPARE
         MVI   TRUEIND,X'01'       INDICATE AT LEAST ONE TRUE COMPARE
         BR    XTRUE               YES- GO TO ROUTINE FOR TRUE CONDIT'N
COMPLOOP MVC   CONDBR+1(1),7(XCURR) GET COMPARE CONDITION FROM ENTRY
         MVI   DFLTIND,X'00'       CLEAR DEFAULT INDICATOR
         LH    X1,4(XCURR)         PICKUP RECORD POSITION FOR COMPARE
         LA    X1,0(X1,XIN)        AND COMBINE IT WITH RECORD ADDRESS
         TM    8(XCURR),X'03'      IS THE LITERAL EITHER PACKED OR NUM-
         BZ    PACKNUMR            ERIC. YES- GO TO PACKED-NUMERIC CODE
         MVC   CHARCOMP+1(1),6(XCURR) SET LENGTH FOR CHARACTER COMPARE
CHARCOMP CLC   0(0,X1),9(XCURR)    COMPARE INPUT RECORD TO LITERAL
CONDBR   BC    0,TRUE              ENTRY. BRANCH ON MODIFIED CONDITION.
FALSE    ST    XCURR,ENTSAVE       SAVE TABLE ENTRY POINTER
         TM    3(XCURR),X'01'      WAS DEFAULT SPECIFIED FOR THIS SET
         BNO   NODFLT              NO, GET POINTER TO NEXT ENTRY
         MVI   DFLTIND,X'01'       INDICATE DEFAULT SPECIFIED
NODFLT   L     XCURR,0(,XCURR)     LOAD POINTER TO NEXT TABLE ENTRY
         N     XCURR,INDXMASK      RESET ANY OUTPUT INDEX BITS
         LTR   XCURR,XCURR         TEST FOR END OF CONDITION SET
         BP    FALSE               NO- SPIN THRU CHAIN
         BCR   8,XFALSE            ZERO- END OF ALL CONDITION SETS
         TM    8(XCURR),X'10'      IS THE CURRENT ENTRY TYPE AN INSERT
         BO    FALSE               YES- SPIN THRU CHAIN FOR END OF SET
         TM    DFLTIND,X'01'       IS DEFAULT INDICATED
         BO    DELETE              YES, WRITE RECORD TO DEFAULT FILE
         B     COMPLOOP            NO- TRY NEXT COMPARE SET
PACKNUMR IC    XLENGTH,6(XCURR)    GET LENGTH-1 OF ARGUMENT LITERAL
         TM    8(XCURR),X'04'      IS THE COMPARE PACKED OR NUMERIC
         BO    PACKCOMP                PACKED- BRANCH
         LA    XLENGTH,1(XLENGTH)      NUMERIC- PACK NUMERIC FIELD IN
         BAL   XRETURN,PACKRTN         RECORD INTO DWORD
         LR    XLENGTH,X0              LENGTH-1 OF PACKED FIELD
PACKCOMP LR    X0,XLENGTH          CONVERT LENGTH TO LL FOR LENGTH OF
         SLL   XLENGTH,4           A AND B FIELD THEN
         AR    XLENGTH,X0              STUFF INTO LENGTH BYTE
         STC   XLENGTH,CP+1                OF COMPARE PACK
CP       CP    0(0,X1),9(0,XCURR)              INSTRUCTION.
         B     CONDBR              BRANCH TO CONDITIONAL TEST.
         EJECT
***********************************************************************
*        THIS ROUTINE IS ENTERED AFTER A RECORD HAS MET THE REQUIREMENT
*        OF THE MODIFY STATEMENT. THE LITERAL IS INSERTED INTO THE
*        CURRENT INPUT RECORD.
*
MODIFY   MVI   MODCON,X'1C'       SET MOD CONSTANT TO 1 FOR MOD REC CNT
MODLOOP  LH    X1,4(XCURR)        GET INSERT FIELD POSITION FROM ENTRY
         LA    X1,0(X1,XIN)       COMBINE WITH RECORD ADDRESS INTO X1.
         MVC   MODMVC+1(1),6(XCURR) PUT LITERAL LENGTH INTO MOVE.
MODMVC   MVC   0(0,X1),9(XCURR)   MOVE INSERT LITERAL INTO RECORD.
         L     XCURR,0(XCURR)     GET ADDRESS OF NEXT TABLE ENTRY
         LTR   XCURR,XCURR        ANY MORE LITERALS TO INSERT INTO REC.
         BP    MODLOOP            YES- GO INSERT IT.
         BM    COMPLOOP           NO- BUT THERE ARE MORE MODIFY ENTRIES
         BR    XFALSE             NO- THRE ARE NO MORE ENTRIES IN TABLE
         EJECT
***********************************************************************
*        THIS IS THE WRITE ROUTINE. ACCUMULATE COUNT FOR RECORDS WRIT-
*        TEN AND FOR RECORDS MODIFIED. PUT OUTPUT RECORD AND THEN MOVE
*        INPUT RECORD TO OUTPUT AREA. LENGTH OF INPUT RECORD DEPENDS
*        ON WHAT RECFM WAS SPECIFIED. IF RECFM F THEN LRECL MAY CHANGE
*        RECORD LENGTH.
*
WRITE    TM    OUTOPTS,MULTOUT     WAS OUTDD SPECIFIED
         BNO   BYPSTABL            NO, DON'T USE OUTPUT TABLE
         L     XTABL,ENTSAVE       LOAD TABLE ENTRY POINTER
         L     XTABL,0(,XTABL)     LOAD FIRST WORD OF ENTRY
         ST    XTABL,ENTSAVE       STORE IT BACK
         NI    ENTSAVE,X'7F'       ALLOW ONLY OUTPUT INDEX
         L     XTABL,TABLEPTR      GET ADDRESS OF FIRST OUTPUT ENTRY
TBLSRCH  CLC   ENTSAVE(1),TBLINDEX IS THIS THE RIGHT OUTPUT ENTRY
         BE    TBLFND              YES, GO HANDLE IT
         L     XTABL,TBLLINK       GET ADDRESS OF NEXT ENTRY
         LA    XTABL,0(,XTABL)     CLEAR HI-ORDER BYTE
         LTR   XTABL,XTABL         IS THIS LAST ENTRY
         BNZ   TBLSRCH             NO, LOOK AT THIS ONE
         MVC   MSG(45),TBLERMSG    MOVE IN ERROR MESSAGE
         B     ERRORPRT            PRINT AND TERMINATE JOB
TBLFND   TM    TBLDCBPT,X'01'      WAS THIS RECORD PREVIOUSLY WRITTEN
         MVI   TBLDCBPT,X'01'      INDICATE RECORD PREVIOUSLY WRITTEN
         BO    GETCHECK            YES, SEE IF ANOTHER GET IS NEEDED
         AP    TBLRECNT,=P'1'      COUNT RECORD WRITTEN
         L     XDCB,TBLDCBPT       LOAD DCB ADDRESS
         LR    X1,XDCB             LOAD DCB ADDRESS
         B     BYPSUT2             BYPASS SYSUT2 DCB
BYPSTABL AP    WRITECT,=P'1'       COUNT RECORD WRITTEN
         LA    XDCB,DATAOUT        LOAD ADDRESS OF SYSUT2 DCB
         LR    X1,XDCB             LOAD ADDRESS OF SYSUT2 DCB
BYPSUT2  AP    MODIFYCT,MODCON     COUNT IF RECORD WAS MODIFIED
         LH    XLENGTH,DATAIN+82  LOAD INPUT LRECL
RECFMUSW B     PUTDATA            NOP IF RECFM U WAS SPECIFIED
         STH   XLENGTH,DCBLRECL    STORE OUTPUT LRECL
         STH   XLENGTH,DCBBLKSI    STORE OUTPUT BLKSIZE
PUTDATA  PUT   (1)                 PUT OUTPUT DATA FILE
         LR    XOUT,X1            LOAD OUTPUT BUFFER ADDRESS
SHORTNSW B     RECFMVSW           NOP IF RECFM F AND OUTPUT LRECL
         LH    XLENGTH,DCBLRECL    SHORTER THAN INPUT LRECL
RECFMVSW B     MOVEREC            NOP IF RECFM V WAS SPECIFIED
         S     XIN,RDW            ADJ FOR RDW 4 BYTES IF RECFM V.
         LH    XLENGTH,0(XIN)     GET RECORD LENGTH FROM RECORD
MOVEREC  LA    X1,256             X1 = CONSTANT OF 256.
MOVELOOP CR    XLENGTH,X1         IS RECORD LENGTH GREATER THAN 256
         BH    MOVE256            YES- GO MOVE 256 BYTES AND COME BACK
         BCTR  XLENGTH,0          STEP LENGTH DOWN BY 1 FOR MOVE
         STC   XLENGTH,LASTMOVE+1 INSTRUCTION LENGTH
LASTMOVE MVC   0(0,XOUT),0(XIN)   MOVE RECORD
EXTENDSW B     GETCHECK            NOP IF RECFM F AND OUTPUT LRECL
*                                 LONGER THAN INPUT LRECL.
         LA    XOUT,1(XOUT,XLENGTH) YES- LENGTHEN OUTPUT RECORD
         LH    XLENGTH,DCBLRECL    SET REMAINDER OF RECORD TO HEX ZERO
         SH    XLENGTH,DATAIN+82    LENGTH OF EXTENTION
ZEROLOOP CR    XLENGTH,X1           LENGTH MORE THAN 256 BYTES
         BH    ZERO256              YES- GO ZERO 256
         BCTR  XLENGTH,0            NO- REDUCE LENGTH BY ONE AND STUFF
         STC   XLENGTH,ZEROLAST+1   IT INTO THE ZERO INSTRUCTION.
ZEROLAST XC    0(0,XOUT),0(XOUT)    ZERO EXTENTION
         B     GETCHECK            SEE IF ANOTHER GET IS NEEDED
ZERO256  XC    0(256,XOUT),0(XOUT)  ZERO 256 BYTES OF EXTENSION
         AR    XOUT,X1              STEP UP OUTPUT POINTER
         SR    XLENGTH,X1           REDUCE EXTENSION LENGTH BY 256
         B     ZEROLOOP             GO BACK TO FINISH RECORD EXTENSION.
MOVE256  MVC   0(256,XOUT),0(XIN)  MOVE 256 BYTES OF INPUT RECORD OUT.
         AR    XIN,X1              STEP UP INPUT & OUTPUT POINTERS 256.
         AR    XOUT,X1             REDUCE BY 256 THE LENGTH OF RECORD
         SR    XLENGTH,X1          STILL TO BE MOVED.
         B     MOVELOOP            GO BACK TO FINISH THE RECORD MOVE.
         DROP  XDCB
         EJECT
***********************************************************************
*        THIS IS THE END OF FILE ROUTINE FOR THE INPUT DATA FILE.
*        PUT OUT END OF JOB MESSAGES, CLOSE FILES, RETURN TO OS.
*
DATAEOF  TM    OUTOPTS,MULTOUT     WAS OUTDD SPECIFIED
         BNO   CLOSEUT2            NO, CLOSE SYSUT2 DCB
         L     XDCB,DCBLIST        LOAD ADDRESS OF OUTPUT DCB LIST
         LR    X1,XDCB             LOAD REG 1 WITH ADDRESS OF START
LISTLOOP NI    0(XDCB),X'80'       TORN OFF OPEN OPTIONS
         TM    0(XDCB),X'80'       IS THIS LAST ENTRY
         BO    CLOSEOUT            YES, GO AND CLOSE OUTPUT DCB'S
         LA    XDCB,4(,XDCB)       BUMP TO NEXT ENTRY
         B     LISTLOOP            DO NEXT ENTRY
CLOSEOUT CLOSE ,MF=(E,(1))         CLOSE OUTPUT DCB'S
         TM    OUTOPTS,DFLTOUT     WAS DEFAULT SPECIFIED
         BNO   BYPSCLOS            NO, SYSUT2 DCB NOT OPEN
CLOSEUT2 CLOSE (DATAOUT)           CLOSE SYSUT2 DCB
BYPSCLOS MVC   MSG(51),=C'-* * * * *  C O N T R O L    T O T A L S  * *C
                * * *'
         BAL   XRETURN,PRINT       PRINT LINE
         TM    OUTOPTS,MULTOUT     WAS OUTDD SPECIFIED
         BNO   BYPSHDNG            NO, BYPASS HEADING
         MVC   MSG(41),=C'0                  TOTALS   OUTPUT DDNAME'
         BAL   XRETURN,PRINT       PRINT LINE
BYPSHDNG MVC   MSG(25),EDITMASK    WRITE RECORD COUNT TOTALS
         MVI   MSG,C'0'            SET DOUBLE SPACE FOR NEXT LINE
         ED    MSG+17(8),INPUTCT       RECORDS READ
         BAL   XRETURN,PRINT
         MVC   MSG(25),EDITMASK
         MVC   MSG+9(8),MODIFIED       RECORDS MODIFIED
         ED    MSG+17(8),MODIFYCT
         BAL   XRETURN,PRINT
         MVC   MSG(25),EDITMASK
         MVC   MSG+9(8),DELETED        RECORDS DELETED
         ED    MSG+17(8),DELETECT
         TM    OUTOPTS,DFLTOUT     WAS DEFAULT SPECIFIED
         BNO   BYPSDFLT            NO, BYPASS MESSAGE SUFFIX
         MVC   MSG+28(23),=C'SYSUT2   (DEFAULT FILE)'
BYPSDFLT BAL   XRETURN,PRINT
         TM    OUTOPTS,MULTOUT     WAS OUTDD SPECIFIED
         BNO   BYPMULMS            NO, BYPASS MULTIPLE COUNTS WRITTEN
         L     XTABL,TABLEPTR      GET FIRST OUTPUT TABLE ENTRY
MULTLOOP MVC   MSG(25),EDITMASK
         MVC   MSG+9(8),WRITTEN    RECORDS WRITTEN
         ED    MSG+17(8),TBLRECNT
         MVC   MSG+28(8),TBLDDNAM
         BAL   XRETURN,PRINT
         L     XTABL,TBLLINK       GET ADDRESS OF NEXT ENTRY
         LA    XTABL,0(,XTABL)     CLEAR HI-ORDER BYTE
         LTR   XTABL,XTABL         IS THIS LAST ENTRY
         BNZ   MULTLOOP            NO, NEED WRITE COUNT FOR THIS FILE
         B     PRINTERM            YES, GO TO END OF RUN
BYPMULMS MVC   MSG(25),EDITMASK
         MVC   MSG+9(8),WRITTEN        RECORDS WRITTEN
         ED    MSG+17(8),WRITECT
         BAL   XRETURN,PRINT
PRINTERM MVC   MSG(37),STARTMSG    MOVE END OF RUN MESSAGE TO PRINT
         MVI   MSG,C'-'            SET TRIPLE SPACE FOR NEXT LINE
         MVC   MSG+27(10),=C'TERMINATED' RUN TERMINATED OR RUN ENDED
         MVC   MSG+38(16),=CL16'CONDITION CODE ='
         LH    X1,RETURNCD               PRINT RETURN CODE
         CVD   X1,DWORD
         UNPK  DWORD(4),DWORD+6(2)
         OI    DWORD+3,X'F0'
         MVC   MSG+55(4),DWORD
         CLC   RETURNCD,=X'0004'         COMP CODE 0 OR 4 CAUSES THE
         BH    PRINTEND                   'ENDED' MESSAGE
         MVC   MSG+27(10),=CL10'ENDED'
PRINTEND BAL   XRETURN,PRINT             PRINT LINE
CLOSE1   CLOSE (CARDIN,,DATAIN,,MSGOUT) CLOSE FILES OPENED IN PHASE 1.
*
RETURN   L     X13,4(X13)
         LH    X15,RETURNCD        SET CONDITION CODE IN REG 15.
         RETURN (14,12),T,RC=(15)  RETURN CONTROL TO OS
         EJECT
***********************************************************************
*        THIS IS THE END OF FILE ROUTINE FOR THE CARD INPUT FILE.
*
CARDEOF  MVI   0(XCURR),X'00'      INDICATE LAST ENTRY
         OC    0(1,XCURR),CURRINDX OR IN CURRENT OUTPUT INDEX
         MVI   ENDFILSW,ON         SET END FILE SW ON
         CLI   CARDSW,ON           WERE ANY CONTROL CARDS READ
         BE    CONTEST             YES- GO TO CONTINUATION TEST
         MVC   MSG(45),NOCTLMSG    NO- WRITE INFO MESSAGE
         BAL   XRETURN,PRINT       PRINT LINE
         B     SETSEL              GO TO PHASE 2.
CONTEST  CLC   RETURNCD,=X'0004'   HAVE SERIOUS ERRORS BEEN ENCOUNTERED
         BH    PRINTERM            YES- TERIMINATE
         CLI   CONTSW,ON           WAS A CONTINUATION CARD EXPECTED
         BE    ERROR13             YES- THIS CAN'T BE RIGHT
         CLI   ENDSETSW,ON         END OF SET SWITCH MUST BE ON
         BE    MODCK               O.K.
ERROR13  BAL   XRETURN,ERROR
MSG13    DC    C'CONTINUATION ERROR OR INCOMPLETE CONTROL CARD',X'FF'
MODCK    CLI   SETTYPE,X'20'       WAS THE LAST CARD READ A MODIFY CARD
         BNE   PHASE2              NO- O.K.
ERROR14  BAL   XRETURN,ERROR       YES- PRINT ERROR
MSG14    DC    C'MODIFY CARD NOT FOLLOWED BY AN INSERT CARD',X'FF'
         EJECT
***********************************************************************
*        THIS ROUTINE READS THE CONTROL CARDS AND PASSES A SINGLE
*        PARAMETER TO THE CALLING ROUTINE EACH TIME THE ROUTINE IS
*        ENTERED. THERE ARE 2 ENTRY POINTS-
*        READPARM - READS CTL CARD AND START SCAN FOR 1ST PARM.
*        GETPARM  - SCANS FOR NEXT PARM, IF LAST PARM ON CARD IS FOLLOW
*        ED BY A COMMA THEN NEXT CARD IS READ AND SCANNED FOR PARM.
*
READCONT MVI   CONTSW,ON           ENTER HERE IF PREV CARD CONTINUED.
READPARM GET   CARDIN              READ CONTROL CARD. FIRST READ.
         LR    XSCAN,X1            SET SCAN POINTER TO CARD.
         MVI   CONTSW,OFF          SET CONTINUATION SWITCH OFF.
         ST    XRETURN,DWORD       SAVE RETURN ADDRESS
         CLI   FIRSTSW+1,X'F0'     IS THIS FIRST CONTROL CARD
         BNE   BYPCTLHD            NO, DON'T WRITE CONTROL CARD HEADING
         MVC   MSG(60),=C'-* * * * *  C O N T R O L    C A R D S    R EC
                A D  * * * * *'
         BAL   XRETURN,PRINT       PRINT LINE
         MVI   MSG,C'0'            SET DOUBLE SPACE FOR NEXT LINE
         LR    X1,XSCAN            RESTORE REGISTER 1
BYPCTLHD LA    XLIMIT,71(,X1)      LIMIT TO END OF CARD
         MVC   MSG+1(80),0(X1)     WRITE CONTROL CARD ON MESSAGE FILE.
         BAL   XRETURN,PRINT       PRINT LINE
         L     XRETURN,DWORD       RESTORE RETURN ADDRESS
         MVI   CARDSW,ON           INDICATE THAT A CONTROL CARD PRESENT
         MVI   ENDSETSW,OFF        NO LONGER END OF SET
LEADBLKS CLI   0(XSCAN),C' '       SPIN THRU LEAD BLANKS.
         BNE   STEPDOWN            GET OUT ON FIRST NON-BLANK
         LA    XSCAN,1(XSCAN)
         B     LEADBLKS
STEPDOWN BCTR  XSCAN,0             BACKOFF INITIAL ONE.
*
GETPARM  SR    XQUOTE,XQUOTE       RESET QUOTE COUNTER. NORMAL ENTRY.
         LA    XPARM,1(XSCAN)      SET XPARM TO FIRST BYTE OF NEXT PARM
PARMLOOP LA    XSCAN,1(XSCAN)      STEP UP SCAN ADDRESS
         CR    XSCAN,XLIMIT        HAS THE SCAN EXCEEDED COL 71.
         BNL   BACKDOWN            YES- STOP SCAN
         CLI   0(XSCAN),X'7D'      NO- IS THIS CHARACTER A QUOTE
         BNE   COMMACK             NO- BRANCH
         LA    XQUOTE,1(XQUOTE)    YES- COUNT IT.
COMMACK  CLI   0(XSCAN),C','       IS THIS CHARACTER A COMMA
         BNE   PARMLOOP            NO- LOOK AT NEXT CHARACTER
         CLI   LITSW,ON            YES- IS THIS A LITERAL SCAN
         BNE   PARMEND             NO- THEN A COMMA IS THE DELIMITER
         CH    XQUOTE,=H'2'        YES- HAVE WE ENCOUNTERED 2 QUOTES
         BL    QUOTEMSG            NO- IT COULD BE AN IMBEDDED COMMA
         BCTR  XSCAN,0             YES- IS THE COMMA PRECEEDED BY A
         CLI   0(XSCAN),X'7D'      QUOTE.
         LA    XSCAN,1(XSCAN)      RESET SCAN TO COMMA POSITION
         BE    PARMEND             YES- THIS IS VALID LITERAL DELIMITER
QUOTEMSG MVC   MSG(53),WARNMSG     NO- WARN OF IMBEDDED COMMA.
         ST    XRETURN,DWORD       SAVE RETURN ADDRESS
         BAL   XRETURN,PRINT       PRINT LINE
         L     XRETURN,DWORD       RESTORE RETURN ADDRESS
         B     PARMLOOP
*
BACKDOWN BCTR  XSCAN,0             BACKDOWN THE CARD TO FIND THE
         CLI   0(XSCAN),C' '       LAST SIGNIFICANT CHARACTER.
         BE    BACKDOWN
*
         CLI   0(XSCAN),C','       WAS THAT A COMMA.
         BE    READCONT            YES- THEN READ NEXT
         MVI   ENDSETSW,ON         NO- THEN THIS SHOULD BE END OF SET.
         LA    XSCAN,1(XSCAN)
PARMEND  LR    XLENGTH,XSCAN       GET PARM LENGTH.
         SR    XLENGTH,XPARM
         BP    PARMEXIT            PARAMETER LENGTH OF ZERO OR MINUS
ERROR12  BAL   XRETURN,ERROR       IS TROUBLE.
MSG12    DC    C'MISSING PARAMETER OR INCOMPLETE CARD',X'FF'
*
PARMEXIT MVI   LITSW,OFF           RESET LITERAL SWITCH
         BR    XRETURN
         EJECT
***********************************************************************
*        INTERCEPT OC7'S WHICH INDICATE AN INVALID PACKED OR NUMERIC
*        FIELD IN A RECORD. PRINT FIRST 80 BYTES OF RECORD FOR IDENTI-
*        FICATION THEN PRINT INVALID FIELD.
*
SPIEXIT  MVC   8(4,1),OC7ACON      CHANGE OPSW TO OC7 ROUTINE
         BR    X14                 RETURN TO CONTROL PROGRAM
OC7ACON  DC    A(OC7RTN)
OC7RTN   MVC   MSG,DE1             PRINT DATA EXCEPTION MESSAGE NO 1.
         BAL   XRETURN,PRINT
         IC    XLENGTH,6(XCURR)    PICK UP LENGTH OF FIELD BEING COMP'D
         LH    XOUT,4(XCURR)       PICK UP STARTING BYTE OF FIELD
         LA    XOUT,1(XOUT)        STEP UP TO ACTUAL POSITION
         CVD   XOUT,DWORD              CONVERT STARTING BYTE AND PUT
         UNPK  DE2+102(5),DWORD+5(3)   IT IN 2ND HEADING LINE.
         LA    X1,0(XOUT,XLENGTH)      CONVERT ENDING BYTE OF FIELD
         CVD   X1,DWORD                AND PUT IT IN 2ND HEADING LINE.
         UNPK  DE2+113(5),DWORD+5(3)
         OI    DE2+106,X'F0'           BLANK OUT SIGNS
         OI    DE2+117,X'F0'
         MVC   MSG,DE2                 PRINT MESSAGE LINE NO 2.
         BAL   XRETURN,PRINT
         BCTR  XOUT,0              STEP STARTING POSITION BACK DOWN
         LA    XOUT,0(XOUT,XIN)    XOUT = ADDRESS OF FIELD IN RECORD
         MVC   MSG+1(9),=C'CHARACTER'
         MVC   MSG+11(80),0(XIN)   MOVE 1ST 80 BYTES OF RECORD
         MVC   DEI1+1(1),6(XCURR)  MOVE FIELD LENGTH
DEI1     MVC   MSG+95(0),0(XOUT)   MOVE FIELD TO MESSAGE
         BAL   XRETURN,PRINT       PRINT CHARACTER LINE
         MVC   MSG+1(9),=C'HEX ZONES'
         BAL   XRETURN,TRANSLAT    TRANSLATE TO HEX ZONES
HEXZ     DC    16C'0',16C'1',16C'2',16C'3',16C'4',16C'5',16C'6',16C'7'
         DC    16C'8',16C'9',16C'A',16C'B',16C'C',16C'D',16C'E',16C'F'
         BAL   XRETURN,PRINT       PRINT HEX ZONE LINE
         MVC   MSG+1(9),=C' NUMERICS'
         BAL   XRETURN,TRANSLAT    TRANSLATE TO HEX NUMERIC
HEXN     DC    16C'0123456789ABCDEF'
         BAL   XRETURN,PRINT       PRINT HEX NUMERIC LINE
         MVC   RETURNCD,=X'0008'   SET RETURN CODE FOR TERMINATION.
         B     DATAEOF             GO TO TERMINATE RUN.
*
TRANSLAT MVC   MSG+11(80),0(XIN)     MOVE 80 BYTES TO MESSAGE
         TR    MSG+11(80),0(XRETURN) TRANSLATE TO EITHER HEX ZONES OR
         MVC   DEI2+1(1),6(XCURR)    NUMERIC DEPENDING ON XRETURN
         MVC   DEI3+1(1),6(XCURR)    SET UP INSTRUCTIONS WITH FIELD
DEI2     MVC   MSG+95(0),0(XOUT)     LENGTH AND MOVE FIELD TO MESSAGE
DEI3     TR    MSG+95(0),0(XRETURN)  AND TRANSLATE
         B     256(XRETURN)
         EJECT
***********************************************************************
*        THIS ROUTINE EDITS A NUMERIC FIELD ON A CONTROL CARD, PACKS IT
*        AND CONVERTS THE NUMBER TO BINARY.
*
EDPAKCVB LA    X1,0(XPARM,XLENGTH) FIND PARM END ADDRESS +1
EDLOOP   BCTR  X1,0                DECREMENT END ADDRESS BY 1
         CR    X1,XPARM            HAS ENTIRE NUMERIC PARM BEEN SCANNED
         BL    PAKCVT              YES- BR TO ROUTINE THAT WILL PACK IT
         CLI   0(X1),C'0'          NO- CHARACTERS
         BL    ERROR07                 LESS THAN ZERO
         CLI   0(X1),C'9'                  AND GREATER THAN
         BH    ERROR07                         NINE ARE INVALID
         B     EDLOOP
ERROR07  BAL   XRETURN,ERROR       WRITE INVALID MESSAGE
MSG07    DC    C'NUMERIC FIELD INVALID',X'FF'
*        PREPARE TO PACK AND CONVERT TO BINARY
PAKCVT   LA    X1,0(XPARM,XLENGTH) FIND PARM END +1.
         BCTR  X1,0                FIND LAST BYTE OF PARM.
         NC    0(1,X1),SIGN        SET SIGN IN LAST BYTE.
         LR    X1,XPARM            X1 BEGINNING OF FIELD TO BE PACKED
PACKRTN  LR    X0,XLENGTH          X0 LENGTH OF FIELD TO BE PACKED
         CH    X0,=H'17'           NUMERIC FIELD IS 17 DIGIT
         BH    ERROR07                 MAXIMUM.
         CH    X0,=H'16'           IS IT 16 OR 17 DIGITS LONG.
         BL    PACKLEN                 NO- IT CAN BE PACKED IN 1 INSTR.
         SH    X0,=H'15'               YES- PACK EXCESS DIGITS INTO
         STC   X0,PACKA+1              BYTE IN FRONT OF DWORD AND THE
         OI    PACKA+1,X'10'           1ST BYTE OF DWORD WHICH WILL BE
PACKA    PACK  DWORD-1(2),0(0,X1)      OVERLAID BY NEXT PACK INSTRUCTN.
         AR    X1,X0                   STEP PAST DIGITS JUST PACKED.
         LH    X0,=H'15'               15 MORE DIGITS TO PACK.
PACKLEN  BCTR  X0,0                REDUCE LENGTH BY ONE.
         STC   X0,PACK+1           STORE AS LENGTH OF A FIELD IN PACK.
         OI    PACK+1,X'70'        STORE AS LENGTH OF B FIELD IN PACK.
PACK     PACK  DWORD,0(0,X1)       PACK INTO DWORD.
         LR    X0,XLENGTH          GET LENGTH OF UNPACKED FIELD.
         SRL   X0,1                DIVIDE BY 2 FOR PACKED LENGTH -1.
         LA    X1,DWORD+7          ADDRESS OF END OF PACKED FIELD MINUS
         SR    X1,X0               (LENGTH-1) OF PACKED = BEGIN PACKED
         BR    XRETURN             FIELD. RETURN TO CALLER.
         EJECT
***********************************************************************
*        THIS ROUTINE SETS UP ERROR MESSAGES FOR PRINT. XRETURN POINTS
*        TO THE MESSAGE TO BE PRINTED.
*        PRINT IS THE ENTRY POINT FOR ALL PRINT MESSAGES ON MSGOUT.
*
ERROR    MVC   MSG(33),ERRMSG      SET UP ERROR MESSAGE
         LR    X1,XRETURN          SCAN ERROR MESSAGE TO FIND THE
ERRLOOP  LA    X1,1(X1)            END OF MESSAGE (X'FF').
         CLI   0(X1),X'FF'
         BNE   ERRLOOP
         BCTR  X1,0
         SR    X1,XRETURN          CALCULATE MESSAGE LENGTH AND MOVE
         STC   X1,ERRMVC+1         MESSAGE TO OUTPUT RECORD AREA.
ERRMVC   MVC   MSG+34,0(XRETURN)
ERRORPRT BAL   XRETURN,PRINT       PRINT ERROR MESSAGE
         MVC   RETURNCD,=X'0008'   SET RETURN CODE FOR TERMINATION.
         CLI   ENDFILSW,ON         HAVE ALL CONTROL CARDS BEEN READ
         BE    PRINTERM            YES- TERMINATE
SKIPLOOP BAL   XRETURN,READPARM    READ NEW CONTROL CARD UNTIL
         CH    XLENGTH,=H'6'       A NEW SET IS ENCOUNTERED.
         BNE   SKIPLOOP
         CLC   SEL,0(XPARM)
         BE    SELR
         CLC   DEL,0(XPARM)
         BE    DELR
         CLC   MOD,0(XPARM)
         BE    MODR
         CLC   INS,0(XPARM)
         BE    INSR
         B     SKIPLOOP
PRINT    PUT   MSGOUT,MSG          PUT MESSAGE OUT
         MVC   MSG,BLANK           CLEAR MESSAGE RECORD AREA
         BR    XRETURN             RETURN
         EJECT
***********************************************************************
*        THIS IS AN EXIT ROUTINE EXECUTED DURING THE OPEN OF THE
*        OUTPUT FILE AFTER JCL DCB INFO HAS BEEN MERGED INTO DCB.
*
         USING IHADCB,X1
MODLIST  DS    0F                  DATAOUT MOD LIST
         DC    X'85'               LAST ENTRY. EXIT 5 AFTER JCL PARMS
         DC    AL3(DCBMOD)         MERGED BUT BEFORE OPEN OF FILE.
DCBMOD   BC    0,COPYDCB           UNCONDITIONAL BRANCH ON FIRST PASS
         NC    RECFMIN,DATAIN+36   SAVE INPUT RECFM
         NC    RECFMOUT,DCBRECFM   SAVE OUTPUT RECFM
         CLI   RECFMOUT,X'00'      WAS OUTPUT RECFM SPECIFIED IN JCL
         BE    PUTRECFM            NOT SPECIFIED- BRANCH
         CLC   RECFMIN,RECFMOUT    SPECIFIED- IS IT THE SAME AS INPUT
         BE    CKRECFMU            YES- BRANCH
         TM    OUTOPTS,MULTOUT     WAS OUTDD SPECIFIED
         BNO   SNGLERR             NO, USE NORMAL RECFM ERROR MESSAGE
         MVC   MSG(46),MRECFMSG    MOVE IN OPTIONAL RECFM ERROR MSG
         L     XTABL,TABLEPTR      ENSURE FIRST TABLE ENTRY
         MVC   MSG+12(8),TBLDDNAM  MOVE IN DDNAME
         B     ERRORPRT            PRINT AND TERMINATE JOB
SNGLERR  MVC   MSG(44),RECFMSG     PUT OUT INVALID RECFM MESSAGE
         B     ERRORPRT            PRINT AND TERMINATE JOB
PUTRECFM MVC   DCBRECFM(1),DATAIN+36 MOVE INPUT RECFM TO OUTPUT RECFM
CKRECFMU CLI   RECFMIN,X'C0'           UNDEFINED RECORDS
         BE    MOVEBLK                 YES- FORCE SAME BLKSIZE AS INPUT
CKRECFMV TM    OUTOPTS,IMSOUT      WAS LOGID SPECIFIED
         BO    SETSPAN             YES, FORCE SAME LRECL & BLKSIZE
         TM    DCBRECFM,X'48'      IS RECFM VARIABLE SPANNED
         BO    SETSPAN             YES, FORCE SAME LRECL & BLKSIZE
         CLI   RECFMIN,X'40'       VARIABLE RECORDS
         BE    MOVELREC            YES- FORCE SAME LRECL AS INPUT
         B     BYPSVBS             BYPASS VS/VBS CODE
SETSPAN  MVC   DCBBLKSI,DATAIN+62  COPY BLKSIZE FOR SPANNED RECORDS
         MVC   DCBLRECL,DATAIN+82  COPY LRECL FOR SPANNED RECORDS
         B     ENDMOD              GO AND RETURN
BYPSVBS  CLC   DCBLRECL,=X'0000'   FIXED RECORDS- WAS LRECL IN JCL
         BNE   CKBLKSZE                YES- FINE
MOVELREC MVC   DCBLRECL,DATAIN+82  NO- INPUT LRECL TO OUTPUT LRECL
CKBLKSZE CLC   DCBBLKSI,=X'0000'   WAS BLKSIZE IN OUTPUT JCL
         BNE   ENDMOD                  YES- FINE
MOVEBLK  MVC   DCBBLKSI,DATAIN+62  NO- INPUT BLKSIZE TO OUTPUT DCB
ENDMOD   TM    OUTOPTS,MULTOUT     WAS OUTDD SPECIFIED
         BNO   EXITRTN             NO,GET OUT
         ST    X1,DCBSAVE          SAVE ADDRESS OF FIRST DCB
*18/08/76MVI   DCBMOD+1,X'F0'      SET UNCONDITIONAL BRANCH *TSG BXL*
EXITRTN  BR    X14                 RETURN TO COMPLETE OPEN
COPYDCB  L     XDCB,DCBSAVE        GET ADDRESS OF FIRST DCB
         MVC   DCBRECFM(1),36(XDCB) COPY RECFM
         MVC   DCBBLKSI(2),62(XDCB) COPY BLKSIZE
         MVC   DCBLRECL(2),82(XDCB) COPY LRECL
         B     EXITRTN             GET OUT
         DROP  X1
         EJECT
DWORDM1  DS    X             INSURE 1 UNUSED BYTE INFRONT OF DWORD.
DWORD    DC    D'0'          DOUBLE WORD WORK AREA
ENTPOINT DC    F'0'          ADDRESS OF 1ST ENTRY IN CHAIN.
HEXHALF  DC    H'0'          WORK HALF WORD TO MANIPULATE HEX
HEXBYTE  EQU   HEXHALF+1     CONVERSION
RETURNCD DC    H'0'                SAVE RETURN CODE FOR END OF JOB.
RDW      DC    F'0'          CONTAINS 4 IF RECFM V.
ENTRY    DS    0F                  ENTRY BUILD AREA
ENTFLGS  DC    AL1(0)              ENTRY FLAGS
ENDSET   EQU   128                 END-OF-SET INDICATOR
LOFILE   EQU   0                   LOW OUTPUT FILE INDEX
HIFILE   EQU   127                 HIGH OUTPUT FILE INDEX
ENTLINK  DC    AL3(0)              POINTER TO NEXT ENTRY
*                                  LO-ORDER BIT IS ON IF DEFAULT WAS
*                                  SPECIFIED
ENTPOS   DS    H             BYTE-1 FROM BEGINNING OF RECORD
ENTLEN   DS    X             LENGTH-1 OF LITERAL
ENTCOND  DS    X             CONDITIONAL OPERATOR- 80=E, 40=L, 20=G
ENTTYPE  DS    X             TYPE ENTRY AND TYPE LITERAL 8X SELECT ENT
*                                                        4X DELETE ENT
*                                                        2X MODIFY ENT
*                                                        1X INSERT ENT
*                                                        X8 CHAR   LIT
*                                                        X4 PACKED LIT
*                                                        X2 HEX    LIT
MASK     DC    X'00'         WORK BYTE TO TEST UNDER MASK
LITYPE   DC    C'C'          TYPE OF LITERAL
CARDSW   DC    X'0'          ON IF ANY CONTROL CARDS HAVE BEEN READ.
ENDSETSW DC    X'FF'         ON IF LAST PARM IN CARD NOT CONTINUED.
CONTSW   DC    X'0'          ON IF CARD CONTINUED
LITSW    DC    X'0'          ON IF SCANNING FOR LITERAL
ENDFILSW DC    X'0'                ON AFTER CARD EOF
SETTYPE  DC    X'10'         SELECT 80,DELETE 40,MODIFY 20,INSERT10.
MODCON   DC    P'1'          CONTAINS 1 IF RECORD MODIFIED
SEL      DC    C'SELECT'
DEL      DC    C'DELETE'
MOD      DC    C'MODIFY'
INS      DC    C'INSERT'
SIGN     DC    X'FF'
RECFMIN  DC    X'C0'         INPUT HOLD AREA FOR RECFM- F,V,U
RECFMOUT DC    X'C0'         OUTPUT HOLD AREA FOR RECFM- F,V,U
LISTLINE DS    0CL122
BLANK    DC    CL1' '
MSG      DC    CL121' '
ERRMSG   DC    C' ****** CONTROL CARD ERROR ******'
STARTMSG DC    C' UTILITY PROGRAM B1801 RUN STARTED'
RECFMSG  DC    C' SYSUT1 AND SYSUT2 DCB RECFM IS INCONSISTENT'
MRECFMSG DC    C' SYSUT1 AND '
MSGDDNAM DC    CL8' '
         DC    C' DCB RECFM IS INCONSISTENT'
TBLERMSG DC    C' UNABLE TO FIND CORRESPONDING OUTPUT DATA SET'
LOGERMSG DC    C' INVALID DCB PARAMETERS SPECIFIED FOR SYSUT1 WHEN IMS X
               LOG IS IMPLIED'
WARNMSG  DC    C' ****** WARNING- A LITERAL CONTAINS AN IMBEDDED COMMA'
WARNMSGP DC    C' ****** WARNING- LEFT ZERO ADDED TO PACKED LITERAL '
         DC    C'WITH EVEN NUMBER OF DIGITS'
WARNMSGH DC    C' ****** WARNING- LEFT ZERO ADDED TO HEX LITERAL '
         DC    C'WITH ODD NUMBER OF DIGITS'
NOCTLMSG DC    C' NO CONTROL CARDS PRESENT. ASSUME TOTAL COPY.'
DE1      DC    CL50' DATA EXCEPTION (OC7) ENCOUNTERED IN FOLLOWING REC'
         DC    CL50'ORD. FIRST 80 BYTES PRINTED ALONG WITH INVALID PAC'
         DC    CL21'KED OR NUMERIC FIELD '
DE2      DC    CL50'           *********1*********2*********3*********'
         DC    CL50'4*********5*********6*********7*********8  POSITIO'
         DC    CL21'N XXXXX THRU XXXXX   '
EDITMASK DC    C' RECORDS READ    ',X'4021202020202020'
MODIFIED DC    C'MODIFIED'
DELETED  DC    C'DELETED '
WRITTEN  DC    C'WRITTEN '
INPUTCT  DC      PL4'0'        RECORD COUNTERS
DELETECT DC      PL4'0'
MODIFYCT DC      PL4'0'
WRITECT  DC      PL4'0'
TABLEPTR DC    F'0'                POINTER TO FIRST OUTPUT ENTRY
PTRSAVE  DC    F'0'                SAVE AREA FOR LAST ENTRY ADDRESS
DCBLIST  DC    F'0'                POINTER TO DCB LIST
DCBSAVE  DC    F'0'                POINTER TO FIRST OUTPUT DCB
ENTSAVE  DC    F'0'                TABLE ENTRY SAVE AREA
RECSAVE  DC    F'0'                SAVE AREA FOR INPUT RECORD ADDRESS
INDXMASK DC    XL4'80FFFFFE'       MASK TO RESET OUTPUT INDEX AND
*                                  DEFAULT INDICATOR BITS
LOGIDSAV DC    H'0'                TEMPORARY SAVE FOR LOG ID
DDNAMSAV DC    CL8' '              WORK AREA FOR DDNAME
OUTOPTS  DC    AL1(0)              OUTPUT DATA SET OPTIONS
IMSOUT   EQU   X'80'               LOGID SPECIFIED ON SELECT CARD
MULTOUT  EQU   X'40'               OUTDD SPECIFIED ON SELECT CARD
DFLTOUT  EQU   X'20'               DEFAULT SPECIFIED ON SELECT CARD
CURRINDX DC    AL1(0)              INDEX TO CURRENT OUTPUT TABLE ENTRY
INDXCNT  DC    AL1(0)              OUTPUT TABLE ENTRY INDEX COUNTER
DFLTIND  DC    AL1(0)              DEFAULT INDICATOR
TRUEIND  DC    AL1(0)              TRUE COMPARE INDICATOR
PARMSAVE DS    F                   PARAMETER ADDRESS POINTER
UT1LIST  DC    X'80',AL3(UT1UNLK)
UT1RRSW  DC    X'00'
PARMERSW DC    C'N'
PARMEMSG DC    CL40'****** EXEC PARAMETER ERROR ******'
         EJECT
CARDIN   DCB   DDNAME=SYSIN,DSORG=PS,MACRF=(GL),RECFM=FB,              C
               EODAD=CARDEOF,LRECL=80
DATAIN   DCB   DDNAME=SYSUT1,DSORG=PS,MACRF=(GL),EODAD=DATAEOF,        C
               EXLST=UT1LIST
DATAOUT  DCB   DDNAME=SYSUT2,DSORG=PS,MACRF=(PL),EXLST=MODLIST
MSGOUT   DCB     DDNAME=SYSPRINT,DSORG=PS,MACRF=(PM),BUFNO=2,RECFM=FA, C
               LRECL=121,BLKSIZE=121
         LTORG
         EJECT
TBLENTRY DSECT                     OUTPUT FILE REFERENCE ENTRY
TBLLINK  DS    F                   POINTER TO NEXT ENTRY
TBLINDEX EQU   TBLLINK             OUTPUT FILE INDEX
TBLDCBPT DS    F                   POINTER TO OUTPUT FILE DCB
*                                  HI-ORDER BYTE SET TO X'01' IF
*                                  RECORD PREVIOUSLY WRITTEN
TBLDDNAM DS    CL8                 OUTPUT FILE DDNAME
TBLRECNT DS    PL4                 OUTPUT FILE RECORD COUNTER
TBLENTSZ EQU   *-TBLENTRY          SIZE OF EACH ENTRY
         EJECT
         DCBD  DSORG=PS
DCBLNGTH EQU   DCBEOB-IHADCB+4     LENGTH OF OUTPUT DCB
         END
