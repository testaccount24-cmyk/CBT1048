         MACRO
&NAME    IOM   &SUBTYPE,&PARM1,&PARM2,&PARM3,&PARM4,&TYPE=,&LOOP=,&RTN=
.*
.*       EQUATES,MAXDD
.*
.*       DCBSW,DDNAME,DCBNAME,INPUT ,MANDAT
.*       DCBSW,DDNAME,DCBNAME,OUTPUT,MANDAT
.*
.*       PUT,DCBSW,(REG),PRINT,LNECNT,RTN=HEADING
.*
.*       PUTM,DCBSW,(REG)
.*
.*       GET,DCBSW,(REG)
.*
.*       GETM,DCBSW,(REG)
.*
.*       OPEN,TYPE=DEF
.*       CLOSE,TYPE=DEF
.*       TIOTSCAN,TYPE=DEF
.*
.*       OPEN,DCBSW,LOOP=1,RTN=OPEN
.*       OPEN,DCBSW,LOOP=N,RTN=NAME
.*
.*       CLOSE,DCBSW,LOOP=1,RTN=CLOSE
.*       CLOSE,DCBSW,LOOP=N,RTN=NAME
.*
.*       TIOTSCAN,DCBSW,LOOP=1,RTN=TIOTSCAN
.*       TIOTSCAN,DCBSW,LOOP=N,RTN=NAME
.*
.*       SUMMARY,DCBSW,(REG),PRESENT,RTN=NAME,LOOP=N
.*
.*       AUDIT,DCBSW,(REG),ENDJOB,RTN=NAME,LOOP=N
.*
.*       EOF,DCBSW
.*
.*       BLKSZRTN,TYPE=DEF
.*
.*       IOERROR,(REG),PRINTRTN,EOJRTN,TYPE=DEF
.*
         LCLA  &MAXDD
         LCLC  &BIT0,&BIT1,&DCB
         LCLC  &B
         LCLC  &LABEL,&RTNE,&REG
         LCLC  &EOJRTNE
         LCLC  &LNECNT
         AIF   ('&SUBTYPE' NE 'EQUATES').B00
IOSWMAND EQU   128 0               DDNAME MANDATORY
IOSWINPT EQU   64 0                INPUT DATA SET (DEFAULT)
IOSWOUTP EQU   191 0               OUTPUT DATA SET            (NI ONLY)
IOSWPRES EQU   32 0                DDNAME PRESENT
IOSWOPEN EQU   16 0                DCB NOW OPEN
IOSWCLOS EQU   239 0               CLOSE DCB                  (NI ONLY)
IOSWEOF  EQU   8 0                 EOF DETECTED
IOSWIOER EQU   4 0                 I/O ERROR DETECTED
IOSWOPNH EQU   2 0                 DCB HAS BEEN OPENED
IOSWEOP  EQU   1 0                 PRINT DATA SET WITH EOP ROUTINE
IOPSSW   EQU   0 0                 DISPLACEMENT IN DCBSW OF SWITCH
IOPSDCB  EQU   0 0                 DISPLACEMENT IN DCBSW OF DCB ADDR
IOPSDDN  EQU   4 0                 DISPLACEMENT IN DCBSW OF DD NAME
IOPSRECA EQU   12 0                DISPLACEMENT IN DCBSW OF REC ADDR
IOPSRCNT EQU   16 0                DISPLACEMENT IN DCBSW OF REC COUNT
IOPSR4SA EQU   20                  DISPLACEMENT IN DCBSW OF R4 S/AREA
IOPSLGTH EQU   24                  LENGTH OF DCBSW
         AIF   ('&PARM1' EQ '').A06
         AIF   (T'&PARM1 NE 'N').A01
&MAXDD   SETA  &PARM1
IOMMAXDD EQU   &MAXDD 0            MAX NO. OF DD STATEMENTS
         AGO   .A06
.A01     MNOTE 4,'MAX NO OF DD STATEMENTS IS NON-NUMERIC'
.A06     ANOP
&MAXDD   SETA  60                  SET DEFAULT LINE COUNT
         AIF   ('&PARM2' EQ '').A05
&MAXDD   SETA  &PARM2
.A05     ANOP
IOPSLCNT DC    P'&MAXDD' ^         DEFAULT LINES / PAGE
.A02     ANOP
         AIF   ('&PARM3' NE '').A03
         AIF   ('&PARM4' NE '').A03
         AIF   ('&TYPE' NE '').A03
         AIF   ('&LOOP' NE '').A03
         AIF   ('&RTN' NE '').A03
         AGO   .A04
.A03     MNOTE *,'THE SUPERFLUOUS OPERANDS CODED WERE IGNORED'
.A04     MEXIT
.B00     AIF   ('&SUBTYPE' NE 'DCBSW').C00
         AIF   ('&PARM1' NE '').B01
         MNOTE 16,'NO DDNAME SUPPLIED FOR DCBSW OPERATION'
         MEXIT
.B01     AIF   ('&PARM2' NE '').B02
&DCB     SETC  '&PARM1'
         MNOTE *,'NO DCB NAME SUPPLIED - DDNAME ASSUMED'
         AGO   .B03
.B02     ANOP
&DCB     SETC  '&PARM2'
.B03     ANOP
&BIT0    SETC  '0'
&BIT1    SETC  '1'
         AIF   ('&PARM3' EQ '').B04
         AIF   ('&PARM3' EQ 'INPUT').B05
         AIF   ('&PARM3' NE 'OUTPUT').B10
&BIT1    SETC  '0'
         AGO   .B05
.B04     MNOTE *,'I/O TYPE NOT SPECIFIED - INPUT ASSUMED'
.B05     AIF   ('&PARM4' EQ '').B06
         AIF   ('&PARM4' NE 'MANDAT').B10
&BIT0    SETC  '1'
         AGO   .B07
.B06     MNOTE *,'DD STATEMENT IS OPTIONAL'
.B07     ANOP
&B       SETC  '000000'
         CNOP  0,4 0               ENSURE CORRECT ALIGNMENT
&NAME    DC    B'&BIT0&BIT1&B',AL3(&DCB),CL8'&PARM1',A(0),PL4'0',A(0)
         AIF   ('&TYPE' NE '').A03
         AIF   ('&LOOP' NE '').A03
         AIF   ('&RTN' NE '').A03
         MEXIT
.B10     MNOTE 16,'UNKNOWN POSITIONAL PARAMETER'
         MEXIT
.C00     AIF   ('&SUBTYPE' EQ 'PUT').C01
         AIF   ('&SUBTYPE' NE 'GET').D00
.C01     AIF   ('&PARM1' NE '').C021
.C011    MNOTE 16,'MANDATORY DCBSW ADDRESS NOT SUPPLIED'
         MEXIT
.C021    ANOP
&NAME    TM    &PARM1.+IOPSSW,IOSWPRES 0IS DD STATEMENT PRESENT
         BZ    IOMC&SYSNDX 0       BYPASS I/O IF NO DD STATEMENT
         TM    &PARM1.+IOPSSW,IOSWOPEN 0 TEST IF DCB OPEN
         BO    IOME&SYSNDX 0       BRANCH IF OPEN
         ST    R4,&PARM1.+IOPSR4SA 0 PRESERVE R4 RETUR  ADDRESS
         LA    R2,&PARM1 ^         POINT R2 AT DCBSW
         CBAL  R4,OPEN 0           OPEN DATA SET
         L     R4,&PARM1.+IOPSR4SA 0 RESTORE SAVED R4 VALUE
IOME&SYSNDX EQU * 0                BYPASS OPEN PROCESSING
         AIF   ('&SUBTYPE' NE 'GET').C023
         TM    &PARM1.+IOPSSW,IOSWEOF 0TEST FOR END OF FILE ALREADY
         BO    IOMC&SYSNDX 0       BR IF EOF ALREADY REACHED
.C023    ANOP
         AIF   ('&SUBTYPE' NE 'PUTM').C024
         LR    R0,&REG ^           POINT R0 AT DATA
         L     R1,&PARM1.+IOPSDCB ^POINT R1 AT DCB ADDRESS
         L     R15,48(0,R1) ^      LOAD PUT ROUTINE ADDRESS
         BALR  R14,R15 ^           LINK TO PUT ROUTINE
         AGO   .C05
.C024    ANOP
         AIF   ('&SUBTYPE' NE 'GETM').C025
         L     R1,&PARM1.+IOPSDCB ^POINT R1 AT DCB ADDRESS
         LR    R0,&REG ^           POINT R0 AT DESTINATION
         L     R15,48(0,R1) ^      LOAD GET ROUTINE ADDRESS
         BALR  R14,R15 ^           LINK TO GET ROUTINE
         AGO   .C05
.C025    ANOP
         AIF   ('&PARM3' NE 'PRINT' OR '&RTN' NE'').C022
IOMD&SYSNDX EQU * 0                LOOP BACK FOR EOP POOCESSING
.C022    ANOP
         L     R1,&PARM1.+IOPSDCB ^POINT R1 AT DCB ADDRESS
         L     R15,48(,R1) 0       GET I/O RTN ADDRESS
         BALR  R14,R15 ^           LINK TO I/O ROUTINE
         ST    R1,&PARM1.+IOPSRECA STORE BUFFER ADDRESS
         AIF   ('&PARM2' EQ '').C05
         AIF   ('&PARM2'(1,1) EQ '(').C04
.C031    MNOTE 16,'INVALID REGISTER SPECIFICATION FOR &SUBTYPE'
         MEXIT
.C04     LR    &PARM2(1),R1 0      SET BUFFER ADDRESS IN WORK REGISTER
.C05     AP    &PARM1.+IOPSRCNT(4),=P'1' 0 INCREMENT RECORD COUNT
         AIF   ('&PARM3' NE 'PRINT').C9
&LNECNT  SETC  '&PARM4'
         AIF   ('&PARM4' NE '').C6
         MNOTE *,'NO LINE COUNT SUPPLIED - DEFAULT ASSUMED'
         CP    &PARM1.+IOPSRCNT(4),IOPSLCNT TEST FOR END OF PAGE
         AGO   .C64
.C6      CP    &PARM1.+IOPSRCNT(4),=P'&LNECNT' 0TEST FOR END OF PAGE
.C64     BL    IOMC&SYSNDX ^       BRANCJ IF NOT
         ZAP   &PARM1.+IOPSRCNT(4),=P'0' 0 ZEROISE LINE COUNT
         OI    &PARM1.+IOPSSW,IOSWEOP 0 SHOW EOP RTN IN USE
         AIF   ('&RTN' NE '').C7
         MNOTE *,'NO EOP ROUTINE SUPPLIED - PAGE SKIP FORCED'
         MVI   0(R1),PAGESKIP 0    ESTABLISH PAGE SKIP
         NI    &PARM1.+IOPSSW,FF-IOSWEOP SET OFF EOP SWITCH
         B     IOMD&SYSNDX 0       SKIP TO NEW PAGE
.C62     ANOP
IOMC&SYSNDX EQU * 0                END OF ROUTINE
.C8      AIF   ('&TYPE' NE '').A03
         AIF   ('&LOOP' NE '').A03
         MEXIT
.C7      ST    R4,IOMD&SYSNDX 0    PRESERVE RETURN ADDRESS
         CBAL  R4,&RTN 0           PERFORM HEADING ROUTINE
         NI    &PARM1.+IOPSSW,FF-IOSWEOP ^SET OFF EOP FLAG
         L     R4,IOMD&SYSNDX 0    RESTORE RETURN ADDRESS
         B     IOMC&SYSNDX 0       BRANCH OVER SAVE AREA
IOMD&SYSNDX DS F 0                 SAVE AREA FOR R4
IOMC&SYSNDX EQU * 0                END OF ROUTINE
         AGO   .C8
.C9      ANOP
IOMC&SYSNDX EQU * 0                 END OF ROUTINE
         AIF   ('&PARM3' NE '').A03
         AIF   ('&PARM4' NE '').A03
         AIF   ('&TYPE' NE '').A03
         AIF   ('&LOOP' NE '').A03
         AIF   ('&RTN' NE '').A03
         MEXIT
.D00     AIF   ('&SUBTYPE' NE 'OPEN').E00
         AIF   ('&TYPE' EQ '').D04
         AIF   ('&TYPE' EQ 'DEF').D02
.D01     MNOTE 16,'UNKNOWN TYPE OPERAND'
         MEXIT
.D02     ANOP
&LABEL   SETC  'OPEN'
         AIF   ('&NAME' EQ '').D03
&LABEL   SETC  '&NAME'
.D03     ANOP
&LABEL   DS    0H 0                ENTRY TO OPEN SUBROUTINE
         L     R1,IOPSDCB(,R2) 0   GET DCB ADDRESS
         TM    IOPSSW(R2),IOSWPRES TEST IF DD STATEMENT PRESENT
         BNO   0(R4) 0             RETURN IF NOT
         TM    IOPSSW(R2),IOSWOPEN 0 TEST IF DATA SET OPEN
         BO    0(R4) 0             RETURN IF DATA STE OPEN
         CNOP  0,4 0               ENSURE CORRECT ALIGNMENT
         ST    R1,*+8 0            STORE DCB ADDRESS
         CBAL  R1,*+8 0            LOAD REG 1 WITH LIST ADDRESS
         DC    A(0) 0              DCB ADDRESS
         TM    IOPSSW(R2),IOSWINPT 0 TEST IF INPUT
         BO    IOMD&SYSNDX 0       BRANCH IF YES
         MVI   0(R1),143 0         SET OPTION BYTE FOR INPUT
         B     *+8 0               GO TO SVC
IOMD&SYSNDX MVI 0(R1),128 ^        SET OPTION BYTE
         SVC   19 0                ISSUE OPEN SVC
         OI IOPSSW(R2),IOSWOPEN+IOSWOPNH INDICATE DATA SET OPEN
         BR    R4 0                RETURN TO MAIN-LINE
.D031    AIF   ('&PARM1' NE '').A03
         AIF   ('&PARM2' NE '').A03
         AIF   ('&PARM3' NE '').A03
         AIF   ('&PARM4' NE '').A03
         AIF   ('&LOOP' NE '').A03
         AIF   ('&RTN' NE '').A03
         MEXIT
.D04     AIF   ('&PARM1' EQ '').C011
         AIF   ('&LOOP' EQ '').D05
&NAME    LA    R10,&LOOP 0         ESTABLISH LOOP
.D05     ANOP
&LABEL   SETC  '&NAME'
         AIF   ('&LOOP' EQ '').D06
&LABEL   SETC  ' '
.D06     ANOP
&LABEL   LA    R2,&PARM1 0         POINT AT DCBSW
         AIF   ('&RTN' EQ '').D07
&RTNE    SETC  '&RTN'
         AGO   .D09
.D07     AIF   ('&SUBTYPE' EQ 'CLOSE').D08
&RTNE    SETC  'OPEN'
         AIF   ('&SUBTYPE' EQ 'OPEN').D09
&RTNE    SETC  'TIOTSCAN'
         AGO   .D09
.D08     ANOP
&RTNE    SETC  'CLOSE'
.D09     ANOP
IOMD&SYSNDX CBAL R4,&RTNE 0        PERFORM SUB-ROUTINE
         AIF   ('&LOOP' EQ '').D10
         LA    R2,IOPSLGTH(,R2) 0  INCREMENT TO NEXT DCBSW
         BCT   R10,IOMD&SYSNDX 0   LOOP BACK TO PROCESS NEXT
.D10     AIF   ('&PARM2' NE '').A03
         AIF   ('&PARM3' NE '').A03
         AIF   ('&PARM4' NE '').A03
         MEXIT
.E00     AIF   ('&SUBTYPE' NE 'CLOSE').F00
         AIF   ('&TYPE' EQ 'DEF').E01
         AIF   ('&TYPE' EQ '').D04
         AGO   .D01
.E01     ANOP
         AIF   ('&SUBTYPE' EQ 'OPEN').D09
&RTNE    SETC  'TIOTSCAN'
&LABEL   SETC  'CLOSE'
         AIF   ('&NAME' EQ '').E02
&LABEL   SETC  '&NAME'
.E02     ANOP
&LABEL   DS    0H 0                ENTRY TO CLOSE SUBROUTINE
         TM    IOPSSW(R2),IOSWOPEN TEST IF DATA SET OPEN
         BZ    0(R4) 0             RETURN IF NOT
         L     R1,IOPSDCB(R2) 0    GET DCB ADDRESS
         CNOP  0,4 0               ENSURE CORRECT ALIGNMENT
         ST    R1,*+8 0            STORE DCB ADDRESS
         CBAL  R1,*+8 0            POINT R1 AT PARM LIST
         DC    A(0) 0              DCB ADDRESS
         MVI   0(R1),128 0         SET OPTION BYTE
         SVC   20 0                ISSUE CLOSE SVC
         L     R1,IOPSDCB(R2) ^    GET DCB ADDRESS
       FREEPOOL (R1) ^             FREE ACQUIRED BUFFER POOL
         NI    IOPSSW(R2),IOSWCLOS INDICATE CLOSED
         BR    R4 0                RETURN TO MAIN-LINE
         AIF   ('&PARM1' NE '').A03
         AIF   ('&PARM2' NE '').A03
         AIF   ('&PARM3' NE '').A03
         AIF   ('&PARM4' NE '').A03
         AIF   ('&LOOP' NE '').A03
         AIF   ('&RTN' NE '').A03
         MEXIT
.F00     AIF   ('&SUBTYPE' NE 'EOF').G00
         AIF   ('&PARM1' EQ '').C011
&NAME    OI    &PARM1.+IOPSSW,IOSWEOF INDICATE EOF
         L     R1,DBUFF ^          POINT R1 AT DUMMY BUFFER
         ST    R1,&PARM1.+IOPSRECA 0PRESERVE DUMMY BUFFER ADDRESS
         AGO   .A02
.G00     AIF   ('&SUBTYPE' NE 'TIOTSCAN').H00
         AIF   ('&TYPE' EQ 'DEF').G01
         AIF   ('&TYPE' NE '').D01
         AGO   .D04
.G01     ANOP
&LABEL   SETC  'TIOTSCAN'
         AIF   ('&NAME' EQ '').G02
&LABEL   SETC  '&NAME'
.G02     ANOP
&LABEL   DS    0H 0                ENTRY TO TIOT SCAN ROUTINE
         BC    0,IOMG&SYSNDX 0     FIRST TIME SWITCH
         OI    *-3,X'F0' 0         SET FIRST TIME SWITCH
         EXTRACT IOMATIOT,'S',FIELDS=TIOT ^OBTAIN ADDRESS OF TOOT
         B     IOMG&SYSNDX ^       BRANCH AROUND SAVE AREAS
IOMATIOT DS    F 0                 ADDRESS OF TIOT
IOMTIOT1 DS    F 0                 SAVE AREA FOR R3
IOMTIOT2 DS    F 0                 SAVE AREA FOR R10
IOMG&SYSNDX EQU * 0                SUBSEQUENT PROCESSING
         ST    R3,IOMTIOT1 0       PRESERVE CONTENTS
         ST    R10,IOMTIOT2 0       OF R3 AND R10
         L     R3,IOMATIOT 0       GET ADDRESS OF TIOT
         LA    R3,24(,R3) 0        POINT AT FIRST DD ENTRY
IOMH&SYSNDX CLC 0(4,R3),=F'0' 0     TEST FOR END OF TIOT
         BE    IOMI&SYSNDX.+4      RETURN IF YES
         CLC   4(8,R3),IOPSDDN(R2) TEST FOR DDNAME MATCH
         BE    IOMI&SYSNDX 0       BRANCH IF YES
         SR    R10,R10 0           ZEROISE WORK REGISTER
         IC    R10,0(R3) 0         INSERT ENTRY LENGTH
         AR    R3,R10 0            INCREMENT TO NEXT ENTRY
         B     IOMH&SYSNDX 0       LOOP TO PROCESS NEXT ENTRY
IOMI&SYSNDX OI IOPSSW(R2),IOSWPRES INDICATE DD STATEMENT PRESENT
         L     R3,IOMTIOT1 0       RETRIEVE CONTENTS
         L     R10,IOMTIOT2 0       OF R3 AND R10
         BR    R4 0                RETURN TO MAIN LINE
         AGO   .D031
.H00     AIF   ('&SUBTYPE' NE 'BLKSZRTN').I00
         AIF   ('&TYPE' EQ 'DEF').H02
         AIF   ('&TYPE' NE '').D01
         MNOTE 16,'INCOMPLETE BLKSIZE REQUEST'
         MEXIT
.H02     ANOP
&LABEL   SETC  'BLKSZRTN'
         AIF   ('&NAME' EQ '').H01
&LABEL   SETC  '&NAME'
.H01     ANOP
&LABEL   DS    0H 0                SUPPLY DEFAULT IF NO BLOCK SIZE
         USING IHADCB,R1 0         ESTABLISH DCB ADDRESSABILITY
         CLI   DCBRECFM,X'00' ^    WAS RECFM SUPPLIED
         BNE   *+8 ^               BR IF RECFM SUPPLIED
         OI    DCBRECFM,DCBRECF+DCBRECBR FORCE 'RECFM=FB' IN NOT SUPPLD
         CLC   DCBBLKSI,=F'0' 0    TEST IF BLKSIZE SUPPLIED
         BNE   0(R14) 0            RETURN TO OPEN IF YES
         MVC   DCBBLKSI,DCBLRECL 0 MOVE LRECL TO BLKSIZE
         BR    R14 0               RETURN TO OS OPEN ROUTINE
         DROP  R1 0                DROP DCB ADDRESSABILITY
         AGO   .D031
.I00     AIF   ('&SUBTYPE' NE 'SUMMARY').J00
         AIF   ('&PARM1' EQ '').C011
         AIF   ('&PARM2' NE '').I01
.I001    MNOTE 16,'MANDATORY REGISTER SPECIFICATION IS MISSING'
         MEXIT
.I01     AIF   ('&PARM2'(1,1) NE '(').C031
         AIF   ('&RTN' NE '').I02
.I011    MNOTE 16,'MANDATORY RTN NAME IS MISSING'
         MEXIT
.I02     ANOP
&NAME    DS    0H 0                PRINT SUMMARY OF D/S ACTIVITY
         LA    R2,&PARM1 0         GET DCBSW ADDRESS
         AIF   ('&LOOP' EQ '').I03
         LA    R10,&LOOP 0         ESTABLISH LOOP
IOMI&SYSNDX EQU * 0                RETURN POINT FOR LOOP
.I03     AIF   ('&PARM3' EQ '').I05
         AIF   ('&PARM3' NE 'PRESENT').B10
         TM    IOPSSW(R2),IOSWPRES TEST IF DD STATEMENT PRESENT
         BZ    IOMJ&SYSNDX 0       BYPASS PROCESSING IF NOT
.I05     ANOP
&REG     SETC  '&PARM2(1)'
         TM    IOPSSW(R2),IOSWEOP ^TEST IF PRINT DATA SET
         BO    IOMJ&SYSNDX ^       BYPASS PROCESSING IF YES
         MVC   LINE12DD,IOPSDDN(R2) ADD DDNAME TO MESSAGE
         MVC   LINE12M2,LINE12M ^  MOVE EDIT MASK TO LINE
         ED    LINE12M2,IOPSRCNT(R2) EDIT THE RECORD COUNT
         MVC   LINE12M1,LINE12R ^  ASSUME IT IS AN INPUT DATA SET
         TM    IOPSSW(R2),IOSWINPT TEST IF INPUT DATA SET
         BO    *+10 ^              BR IF INPUT D/S
         MVC   LINE12M1,LINE12W ^  SHOW OUTPUT DATA SET
         MVC   5(L'LINE12,&REG),LINE12 MOVE MESSAGE TO PRINT LINE
         CBAL  R4,&RTN 0           PERFORM PRINT ROUTINE
IOMJ&SYSNDX EQU * 0                BYPASS BRANCH ADDRESS
.I06     AIF   ('&LOOP' EQ '').I07
         LA    R2,IOPSLGTH(,R2) 0  INCREMENT TO NEXT DCBSW
         BCT   R10,IOMI&SYSNDX 0   LOOP TO PROCESS NEXT
.I07     AIF   ('&PARM4' NE '').A03
         AIF   ('&TYPE' NE '').A03
         MEXIT
.J00     AIF   ('&SUBTYPE' NE 'AUDIT').K00
         AIF   ('&PARM1' EQ '').C011
         AIF   ('&PARM3' NE '').J001
         MNOTE *,'NO END-OF-JOB ROUTINE ADDRESS SUPPLIED'
         MNOTE *,'PROGRAM WILL ABEND WITH 0C1 IF MANDATORY STATEMENT MI$
               SSING'
.J001    ANOP
         AIF   ('&PARM2' EQ '').I001
         AIF   ('&PARM2'(1,1) NE '(').C031
         AIF   ('&RTN' EQ '').I011
&NAME    DS    0H 0                REPORT ON PRESENCE OF DD STATEMENTS
         LA    R2,&PARM1 ^         GET DCBSW ADDRESS
         AIF   ('&LOOP' EQ '').J01
         LA    R10,&LOOP 0         ESTABLISH LOOP
IOMJ&SYSNDX EQU * 0                RETURN POINT FOR LOOP
.J01     ANOP
&REG     SETC  '&PARM2(1)'
         MVC   LINE13M2,IOPSDDN(R2) MOVE DDNAME TO MESSAGE
         MVC   LINE13M1,LINE13MA ^ ASSUME DDNAME IS MANDATORY
         MVC   LINE13M3,LINE13PR ^ ASSUME DDNAME IS PRESENT
         TM    IOPSSW(R2),IOSWMAND TEST IF DDNAME IS MANDATORY
         BO    *+10 ^              BR IF YES
         MVC   LINE13M1,LINE13OP ^ SHOW DDNAME IS OPTIONAL
         TM    IOPSSW(R2),IOSWPRES TEST IF DDNAME IS PRESENT
         BO    *+10 ^              BR IF YES
         MVC   LINE13M3,LINE13MI ^ SHOW THAT DDNAME IS MISSING
         MVC   5(L'LINE13,&REG),LINE13 MOVE MESSAGE TO LINE
         CBAL  R4,&RTN 0           PERFORM PRINT ROUTINE
         TM    IOPSSW(R2),IOSWMAND TEST IF MANDATORY
         BZ    IOMK&SYSNDX 0       BRANCH IF NOT
         TM    IOPSSW(R2),IOSWPRES TEST IF PRESENT
         BO    IOMK&SYSNDX 0       BRANCH IF YES
         MVC   COMPCODE,COND16 0   SET CONDITION CODE TO 16
         OI    IOML&SYSNDX.+1,X'F0' 0    SET TO BRANCH AT END OF JOB
         MVC   IOMM&SYSNDX.+27(8),IOPSDDN(R2) ADD DD NAME TO WRO
IOMM&SYSNDX WTO 'MANDATORY DATA SET ******** MISSING'
IOMK&SYSNDX EQU * 0
         AIF   ('&LOOP' EQ '').J02
         LA    R2,IOPSLGTH(,R2) 0  POINT AT NEXT DCBSW
         BCT   R10,IOMJ&SYSNDX 0   LOOP BACK TO PROCESS
.J02     ANOP
&RTNE    SETC  '*+2'
         AIF   ('&PARM3' NE '').J03
         MNOTE *,'NO END-OF-JOB ADDRESS SUPPLIED'
         AGO   .J04
.J03     ANOP
&RTNE    SETC  '&PARM3'
.J04     ANOP
IOML&SYSNDX BC 0,&RTNE 0           GO TO END-OF-JOB IF MAND MISSING
         AGO   .I07
.K00     AIF   ('&SUBTYPE' NE 'IOERROR').L00
         AIF   ('&TYPE' EQ 'DEF').K01
         AIF   ('&TYPE' NE '').D01
         MNOTE 16,'INVALID I/O ERROR REQUEST'
         MEXIT
.K01     ANOP
&RTNE    SETC  'PRINT'
&EOJRTNE SETC  'PRINTCDE'
&REG     SETC  'R5'
&LABEL   SETC  'IOERROR'
         AIF   ('&NAME' EQ '').K02
&LABEL   SETC  '&NAME'
.K02     AIF   ('&PARM3' NE '').K03
         MNOTE *,'NO END-OF-JOB ADDRESS SUPPLIED - ''PRINTCDE'' ASSUMD'
         AGO   .K04
.K03     ANOP
&EOJRTNE SETC  '&PARM3'
.K04     AIF   ('&PARM2' NE '').K05
         MNOTE *,'NO PRINT ROUTINE ADDRESS - ''PRINT'' ASSUMED'
         AGO   .K06
.K05     ANOP
&RTNE    SETC  '&PARM2'
.K06     AIF   ('&PARM1' EQ '').K07
         AIF   ('&PARM1'(1,1) NE '(').C031
&REG     SETC  '&PARM1(1)'
         AGO   .K08
.K07     MNOTE *,'NO REGISTER SPECIFIED - R5 ASSUMED'
.K08     ANOP
&LABEL   DS    0H 0                ENSURE ALIGNMENT
         MVC   COMPCODE,COND16 0   SET COMPLETION CODE
        SYNADAF ACSMETH=QSAM 0     CALL ANALYSIS ROUTINE
         MVC   IOML&SYSNDX.+12(86),50(R1) ADD RESULT OF ANALYSIS
        SYNADRLS , 0               RELEASE OS BUFFER
         WTO   MF=(E,IOML&SYSNDX) 0TELL OPERATOR OF ERROR
         MVI   0(&REG),SPCE2AFT 0  ESTABLISH DOUBLE BLANK LINES
         CBAL  R4,&RTNE 0           AND WRITE THEM
         MVC   5(98,&REG),IOMM&SYSNDX 0 MOVE IN ERROR MESSAGE
         CBAL  R4,&RTNE 0          WRITE ERROR MESSAGE
        SUBOUT RETURN=&EOJRTNE 0   TERMINATE JOB
         SPACE 1
IOML&SYSNDX DS 0F
         DC    AL2(102),H'0'
IOMM&SYSNDX DC CL98'I/O ERROR - '
         MEXIT
.L00     AIF   ('&SUBTYPE' NE 'PUTM').M00
.L01     ANOP
         AIF   ('&PARM1' EQ '').C011
&REG     SETC  'R1'
         AIF   ('&PARM2' EQ '').C021
         AIF   ('&PARM2'(1,1) NE '(').C031
&REG     SETC  '&PARM2(1)'
         AGO   .C021
.M00     AIF   ('&SUBTYPE' EQ 'GETM').L01
         MEND
         EJECT
         MACRO
&NAME    SUBIN &SAVE=,&PREFIX=
         GBLA  &SUBINC
         LCLA  &N,&S
         LCLC  &R,&P,&PP
&SUBINC SETA   &SUBINC+1
&NAME    DS    0H
&N       SETA  N'&SAVE
         AIF   (&N GT 0).C1
         MEXIT
.C1      ANOP
&P       SETC  '&PREFIX'
         AIF   ('&P' EQ '').C2
&PP      SETC  '&P.SAVE'
         AGO   .C3
.C2      ANOP
&PP      SETC  '$&SUBINC'
.C3      ANOP
&S       SETA  &S+1
         AIF   (&S GT &N).C4
         ST    &SAVE(&S),&PP&SAVE(&S) 0      PRESERVE REGISTER
         AIF   ('&SYSECT' NE 'BUDGIE3').C3
         AIF   ('&SAVE(&S)' NE 'R4').C3
         ST    R11,&PP.R11 ^       PRESERVE REGISTER 11
         AGO   .C3
.C4      ANOP
         B     &PP.XIT 0           BRANCH OVER SAVE AREAS
&S       SETA  0
.C5      ANOP
&S       SETA  &S+1
         AIF   (&S GT &N).C6
&PP&SAVE(&S) DS F 0                SAVE AREA
         AIF   ('&SYSECT' NE 'BUDGIE3').C5
         AIF   ('&SAVE(&S)' NE 'R4').C5
&PP.R11  DS    F ^                 SAVE AREA FOR REGISTER 11
         AGO   .C5
.C6      ANOP
&PP.XIT  EQU   * 0                 ROUTINE EXIT
         MEND
         EJECT
         MACRO
&NAME   SUBOUT &RESTORE=,&PREFIX=,&RETURN=
         GBLA  &SUBINC
         LCLA  &N,&S
         LCLC  &R,&P,&PP,&B
         AIF   ('&NAME' EQ '').NONAME
&NAME    DS    0H 0
.NONAME  ANOP
&N       SETA  N'&RESTORE
         AIF   (&N NE 0).C3
.C1      ANOP
&B       SETC  'R4'
         AIF   ('&RETURN' EQ '').C2
         AIF   ('&RETURN'(1,1) NE '(').C11
&B       SETC  '&RETURN(1)'
         AGO   .C2
.C11     ANOP
&B       SETC  '&RETURN'
         B     &B 0                RETURN TO CALLER
         MEXIT
.C2      BR    &B 0                RETURN TO CALLER
         MEXIT
.C3      ANOP
&P       SETC  '&PREFIX'
         AIF   ('&P' EQ '').C4
&PP      SETC  '&P.SAVE'
         AGO   .C5
.C4      ANOP
&PP      SETC  '$&SUBINC'
.C5      ANOP
&S       SETA  &S+1
         AIF   (&S GT &N).C1
         L     &RESTORE(&S),&PP&RESTORE(&S) 0     RESTORE REGISTER
         AIF   ('&SYSECT' NE 'BUDGIE3').C5
         AIF   ('&RESTORE(&S)' NE 'R4').C5
         L     R11,&PP.R11 ^       RESTORE REGISTER 11
         AGO   .C5
         MEND
         EJECT
         MACRO
&NAME    SUBLR &R,&S
         GBLA  &SUBINC
         LCLC  &P,&PP
&P       SETC  '&R'
         AIF   ('&S' EQ '').A01
&P       SETC  '&S'
.A01     ANOP
&PP      SETC  '$&SUBINC'
&NAME    L     &R,&PP&P ^          RESTORE REGISTER FRO MSUBIN AREA
         MEND
         SPACE 5
         MACRO
&NAME    ADDR  &FLD,&C,&T
         LCLC  &R
&R       SETC  'R1'
         AIF   ('&T' EQ '').A01
&R       SETC  '&T'
.A01     ANOP
&NAME    L     &R,VBUDG3&C 0       GET ADDRESS OF CSECT CONTAINING FLD
         LA    &R,&FLD.-BUDGIE3&C.(,&R) POINT REGISTER AT FIELD
         MEND
         SPACE 5
         MACRO
&NAME    PTR   &FLD1,&FLD2
         LCLC  &NME
&NME     SETC '&NAME'
         AIF   ('&FLD1' EQ '').A00
&NME     SR    R6,R6 ^             ZEROISE WORK REGISTER
&NME     SETC  ' '
         IC    R6,&FLD1 ^          GET POSN OF FIELD
         BCTR  R6,0 ^              DECREMENT POSN TO DISPLACEMENT
         A     R6,SYSUT1+IOPSRECA ^ADD REC ADDR TO POINT AT FIELD
.A00     AIF   ('&FLD2' EQ '').A01
&NME     SR    R1,R1 ^             ZEROISE WORK REGISTER
         IC    R1,&FLD2 ^          RETRIEVE LENGTH OF FIELD
         BCTR  R1,0 ^              DECREMENT FOR EXECUTE
.A01     ANOP
         MEND
         EJECT
         MACRO
&NAME    LINE  &LNE,&DISP,&REG,&S=,&P=
         LCLC  &D,&R,&L
         LCLC  &NAME1
&NAME1   SETC  '&NAME'
&D       SETC  '5'
         AIF   ('&DISP' EQ '').C1
&D       SETC  '&DISP'
.C1      ANOP
&R       SETC  'R5'
         AIF   ('&REG' EQ '').C3
         AIF   ('&REG'(1,1) EQ '(').C02
         MNOTE 4,'INVALID REGISTER SPECIFICATION'
         MEXIT
.C02     ANOP
&R       SETC   '&REG(1)'
.C3      AIF   ('&LNE' EQ '').C31
&L       SETC  'L'''
&NAME    MVC   &D.(&L&LNE,&R),&LNE 0MOVE MESSAGE TO LINE
&NAME1   SETC  ' '
.C31     AIF   ('&S' EQ '').C5
 AIF ('&S' EQ '0' OR '&S' EQ '1' OR '&S' EQ '2' OR '&S' EQ '3').C4
         AIF   ('&S' EQ 'P').C32
         MNOTE 4,'INVALID SPACE SPECIFICATION'
         AGO   .C5
.C32     ANOP
&NAME1   MVI   0(&R),PAGESKIP 0    ESTABLISH PAGE SKIP
&NAME1   SETC  ' '
         AGO   .C5
.C4      ANOP
&NAME1   MVI   0(&R),SPCE&S.AFT 0  SET CARRIAGE SPACING
&NAME1   SETC  ' '
.C5      AIF   ('&P' EQ '').C6
         AIF   ('&P' EQ 'N').C7
         AIF   ('&P' EQ 'Y').C6
         AIF   ('&P' EQ 'Z').C51
         AIF   ('&P' EQ 'L').C8
         MNOTE 4,'INVALID PRINT REQUEST'
         AGO   .C7
.C8      ANOP
&NAME1   CBAL  R4,PRINTLOG 0       PRINT LINE OF  LOG STATUS REPORT
&NAME1   SETC  ' '
         AGO   .C7
.C51     ANOP
&NAME1   CBAL  R4,PRINTBBL 0       PRINT LINE OF B/B REPORT
&NAME1   SETC  ' '
         AGO   .C7
.C6      ANOP
         AIF   ('&SYSECT' NE 'BUDGIE3C').C61
&NAME1   CBAL  R4,PRINT3C ^        PRINT LINE OF SYSPRINT
&NAME1   SETC  ' '
         AGO   .C7
.C61     AIF   ('&SYSECT' NE 'BUDGIE3G').C62
&NAME1   CBAL  R4,PRINT3G ^        PRINT LINE OF SYSPRINT
&NAME1   SETC  ' '
         AGO   .C7
.C62     AIF   ('&SYSECT' NE 'BUDGIE3H').C63
&NAME1   CBAL  R4,PRINT3H ^        PRINT LINE OF SYSPRINT
&NAME1   SETC  ' '
         AGO   .C7
.C63     ANOP
&NAME1   CBAL  R4,PRINT 0          PRINT LINE TO SYSPRINT
&NAME1   SETC  ' '
.C7      ANOP
         MEND
         EJECT
         MACRO
&NAME NUMERIC  &FLD,&LEN,&SIGNED
         LCLC  &R
         LCLC  &L
         AIF   ('&FLD'(1,1) NE '(').C1
&R       SETC  '&FLD(1)'
&NAME    LA    R1,0(,&R) 0         POINT R1 AT FIELD
         AGO   .C2
.C1      ANOP
&NAME    LA    R1,&FLD 0           POINT R1 AT FIELD
.C2      AIF   ('&LEN' EQ '').C3
         LA    R15,&LEN 0          SET LENGTH IN R15
         AGO   .C4
.C3      ANOP
&L       SETC  'L'''
         LA    R15,&L&FLD ^        SET LENGTH IN  R15
.C4      AIF   ('&SYSECT' NE 'BUDGIE3F').C5
         AIF   ('&SIGNED' NE 'SIGNED').C8
         CBAL  R4,NUMERCSF ^       TEST FIELD FOR NUMERIC
         MEXIT
.C8      ANOP
         CBAL  R4,NUMERICF         INVOKE SUBROUTINE
         MEXIT
.C5      AIF   ('&SYSECT' NE 'BUDGIE3C').C6
         AIF   ('&SIGNED' NE 'SIGNED').C9
         CBAL  R4,NUMERCSC ^       TEST FIELD FOR NUMERIC
         MEXIT
.C9      CBAL  R4,NUMERICC ^       TEST FIELD FOR NUMERIC
         MEXIT
.C6      AIF   ('&SYSECT' EQ 'BUDGIE3H').C11
         AIF   ('&SYSECT' EQ 'BUDGIE3K').C11
         AGO   .C7
.C11     ANOP
         AIF   ('&SIGNED' NE 'SIGNED').C10
         CBAL  R4,NUMERCSH ^       TEST FIELD FOR NUMERIC
         MEXIT
.C10     CBAL  R4,NUMERICH ^       TEST FIELD FOR NUMERIC
         MEXIT
.C7      CBAL  R4,NUMERIC ^        TEST FIELD FOR NUMERIC
         MEND
         EJECT
         MACRO
&NAME    CBAL  &R,&ROUTINE         PERFORM SUB-ROUTINE
         LCLC  &CSECT,&ROOT,&C
         LCLC  &NAME1
&NAME1   SETC  '&NAME'
&C       SETC  'BUDGIE3A'
         AIF   ('&ROUTINE'(1,4) EQ 'WORK').C
&C       SETC  'BUDGIE3B'
         AIF   ('&ROUTINE' EQ 'TESTINTL').SETH
         AIF   ('&ROUTINE'(1,4) EQ 'TEST').C
         AIF   ('&ROUTINE' EQ 'NUMERIC').C
         AIF   ('&ROUTINE' EQ 'NUMERICS').C
         AIF   ('&ROUTINE'(1,5) EQ 'UT458').C
         AIF   ('&ROUTINE' EQ 'UNDRSCOR').C
         AIF   ('&ROUTINE' EQ 'ADDCLOS').C
         AIF   ('&ROUTINE' EQ 'SFVERIFY').C
         AIF   ('&ROUTINE' EQ 'SETINDS').C
         AIF   ('&ROUTINE' EQ 'COMPARE').C
.SETH    ANOP
&C       SETC  'BUDGIE3K'
         AIF   ('&ROUTINE' EQ 'CCMS33').C
         AIF   ('&ROUTINE' EQ 'CCMS34').C
         AIF   ('&ROUTINE' EQ 'CCMS36').C
         AIF   ('&ROUTINE' EQ 'CCMS37').C
&C       SETC  'BUDGIE3H'
         AIF   ('&ROUTINE' EQ 'TESTINTL').C
         AIF   ('&ROUTINE' EQ 'NUMERICH').C
         AIF   ('&ROUTINE' EQ 'CCMS20').C
         AIF   ('&ROUTINE' EQ 'CCMS21').C
         AIF   ('&ROUTINE' EQ 'CCMS30').C
         AIF   ('&ROUTINE' EQ 'CCMS31').C
         AIF   ('&ROUTINE' EQ 'CCMS32').C
         AIF   ('&ROUTINE' EQ 'CCMS40').C
         AIF   ('&ROUTINE' EQ 'CCMS41').C
&C       SETC  'BUDGIE3C'
         AIF   ('&ROUTINE'(1,4) EQ 'CCMS').C
         AIF   ('&ROUTINE' EQ 'CCREAD').C
&C       SETC  'BUDGIE3H'
         AIF   ('&ROUTINE'(1,4) EQ 'PARM').C
         AIF   ('&ROUTINE'(1,4) EQ 'INIT').C
&C       SETC  'BUDGIE3M'
         AIF   ('&ROUTINE' EQ 'CCLINK00').C
&C       SETC  'BUDGIE3D'
         AIF   ('&ROUTINE' EQ 'OPEN').C
         AIF   ('&ROUTINE' EQ 'CLOSE').C
         AIF   ('&ROUTINE' EQ 'TIOTSCAN').C
         AIF   ('&ROUTINE' EQ 'READUT1').C
         AIF   ('&ROUTINE' EQ 'READIN').C
         AIF   ('&ROUTINE' EQ 'PRINT').C
         AIF   ('&ROUTINE' EQ 'PRINTBBL').C
         AIF   ('&ROUTINE' EQ 'HEADBB').C
         AIF   ('&ROUTINE' EQ 'PRINTLOG').C
         AIF   ('&ROUTINE' EQ 'HEADLOG').C
         AIF   ('&ROUTINE' EQ 'BLKSZRTN').C
         AIF   ('&ROUTINE' EQ 'UT1LRECL').C
         AIF   ('&ROUTINE' EQ 'UT2LRECL').C
         AIF   ('&ROUTINE' EQ 'WRKLRECL').C
         AIF   ('&ROUTINE' EQ 'PUTUT2').C
         AIF   ('&ROUTINE' EQ 'PUTSUSP').C
         AIF   ('&ROUTINE' EQ 'PUTDLETE').C
         AIF   ('&ROUTINE' EQ 'PUTMOVE').C
         AIF   ('&ROUTINE' EQ 'PUTLOG').C
         AIF   ('&ROUTINE' EQ 'GETLOG').C
         AIF   ('&ROUTINE' EQ 'GETSUSP').C
         AIF   ('&ROUTINE' EQ 'READLIN').C
         AIF   ('&ROUTINE' EQ 'ISRANDM').C
         AIF   ('&ROUTINE' EQ 'ISOPEN').C
         AIF   ('&ROUTINE' EQ 'ISCLOSE').C
         AIF   ('&ROUTINE' EQ 'PUTDUP').C
         AIF   ('&ROUTINE' EQ 'PUTINTRD').C
&C       SETC  'BUDGIE3E'
         AIF   ('&ROUTINE'(1,5) EQ 'BATCH').C
&C       SETC  'BUDGIE3F'
         AIF   ('&ROUTINE'(1,4) EQ 'URTN').C
         AIF   ('&ROUTINE' EQ 'PPLPL').C
         AIF   ('&ROUTINE' EQ 'PPLLPL').C
         AIF   ('&ROUTINE' EQ 'PPPLLPL').C
         AIF   ('&ROUTINE' EQ 'PPPLPL').C
&C       SETC  'BUDGIE3G'
         AIF   ('&ROUTINE' EQ 'BCSCAN').C
         AIF   ('&ROUTINE' EQ 'DCSCAN').C
         AIF   ('&ROUTINE' EQ 'PRINTCDE').C
         AIF   ('&ROUTINE' EQ 'PRINTERM').C
&C       SETC  'BUDGIE3J'
         AIF   ('&ROUTINE'(1,5) EQ 'JTEST').C
&C       SETC  'BUDGIE3O'
         AIF   ('&ROUTINE'(1,5) EQ 'OTEST').C
&C       SETC  'BUDGIE3L'
         AIF   ('&ROUTINE'(1,6) EQ 'DETAIL').C
         AIF   ('&ROUTINE'(1,5) EQ 'DETAL').C
&C       SETC  'BUDGIE3N'
         AIF   ('&ROUTINE' EQ 'INTIL02').C
.*                                 ASSUME THAT EITHER THE SUB-ROUTINE
.*                                  IS IN THE MAIN CSECT, OR IS IN
.*                                  THE SAME SUB-CSECT.
         AIF   ('&R' NE '').C2
&NAME1   B     &ROUTINE ^          TRANSFER CONTROL TO LABEL
         MEXIT
.C2      ANOP
&NAME1   BAL   &R,&ROUTINE 0       PERFORM SUB-ROUTINE
         MEXIT
.C       AIF   ('&C' NE '&SYSECT').C1
.*                                 SUB-ROUTINE IS IN SAME SUB-CSECT
         AIF   ('&R' NE '').C3
&NAME    B     &ROUTINE ^          TRANSFER CONTROL TO LABEL
         MEXIT
.C3      ANOP
&NAME    BAL   &R,&ROUTINE ^       PERFORM SUB-ROUTINE
         MEXIT
.C1      ANOP
&CSECT   SETC  '&C'(8,1)
         AIF   ('&SYSECT' EQ 'BUDGIE3').A1
         AIF   ('&R' EQ '').A1
         CNOP  0,4 0               ENSURE FULLWORG AIGNMENT
&NAME1   ST    R11,*+20 0          PRESERVE CURRENT BASE REGISTER
&NAME1   SETC  ' '
.A1      ANOP
&NAME1   L     R11,VBUDG3&CSECT 0  GET CSECT ENTRY POINT ADDRESS
         USING BUDGIE3&CSECT,R11 0 ESTABLISH SUB-CSECT ADDRESSABILITY
         AIF   ('&R' NE '').A3
         B     &ROUTINE ^          TRANSFER CONTROL TO LABEL
         AGO   .A4
.A3      ANOP
         BAL   &R,&ROUTINE 0       PERFORM SUB-ROUTINE
.A4      ANOP
         DROP  R11 0               DROP SUB-CSECT ADDRESSABILITY
         AIF   ('&SYSECT' EQ 'BUDGIE3').A2
         AIF   ('&R' EQ '').A5
         L     R11,8(R4) 0         RETRIEVE CURRENT BASE REGISTER
.A5      ANOP
         USING &SYSECT,R11 0       RE-ESTABLISH CURRENT ADDRESSABILITY
         AIF   ('&R' EQ '').A2
         B     *+8 0               BRANCH AROUND SAVE AREA
         DS    F 0                 SAVE AREA FOR CURRENT BASE REGISTER
.A2      ANOP
         MEND
         EJECT
         MACRO
        SCSECT &A
BUDGIE3&A CSECT
         USING BUDGIE3&A,R11 0     ESTABLISH SUB-CSECT ADDRESSABILITY
         MEND
         SPACE 5
         MACRO
&NAME POOLGEN  &CSECT              GENERATE DESCRIPTICE SUB-BLOCK
         LCLC  &P
&P       SETC  'VBUDG3'
&P&CSECT DC    V(BUDGIE3&CSECT) 0  ADDRESS OF SUB-CSECT
         DC    A(LGTH&CSECT-BUDGIE3&CSECT) 0 LENGTH OF CSECT
         DC    A(0) 0              CAPACITY IN WORK RECORDS
         DC    A(0) 0              PTR TO NEXT AVAILABLE SLOT
         MEND
         SPACE 5
         MACRO
&NAME    CCNO  &FLD,&CB
.*
.*       ADD CONTROL CARD REC NO FROM CURRENT C/B TO ERR MESSAGE
.*
         LCLC  &CBLK
&NAME    MVC   WORKAREA(4),EDITPATN MOVE EDIT MASK TO WORK AREA
&CBLK    SETC  '&CB'
         AIF   ('&CB' NE '').A01
&CBLK    SETC  'CB20'
.A01     ANOP
         ED    WORKAREA(4),&CBLK.CCNO EDIT CONTROL CARD SEQUENCE NUMBER
         MVC   &FLD.(4),WORKAREA ^ MOVE EDITED NUMBER TO ERROR MESSAGE
         MEND
         EJECT
         MACRO
&NAME   PGMOUT &RC=,&DC=
         AIF   ('&NAME' EQ '').C1
&NAME    DS    0H
.C1      AIF   ('&RC' EQ '(15)').C7
         AIF   ('&RC' EQ 'COMPCODE' AND '&DC' EQ 'YES').C6
         AIF   ('&RC' NE '').C2
         SR    15,15
         AGO   .C7
.C2      AIF   ('&RC'(1,1) NE '(').C3
         LR    15,&RC(1)
         AGO   .C7
.C3      AIF   ('&RC'(1,1) LT '0').C4
         LA    15,&RC.(0,0)
         AGO   .C7
.C4      AIF   (T'&RC EQ 'F').C5
         AIF   (T'&RC EQ 'H').C6
         MNOTE 4,'FIELD SPECIFED BY RC IS NOT FULL- OR HALF-WORD'
         MEXIT
.C5      L     15,&RC
         AGO   .C7
.C6      SR    15,15
         LH    15,&RC
.C7      L     13,4(13)
         L     14,12(13)
         LM    0,12,20(13)
         BR    14
         AIF   ('&DC' EQ '').C9
         AIF   ('&DC' EQ 'YES').C8
         MNOTE 4,'UNKNOWN DC OPERAND'
         MEXIT
.C8      ANOP
         SPACE 1
COMPCODE DC    H'0' 0              COMPLETION CODE
COND4    DC    H'4' 0              COMPLETION CODE OF 4
COND8    DC    H'8' 0              COMPLETION CODE OF 8
COND12   DC    H'12' 0             COMPLETION CODE OF 12
COND16   DC    H'16' ^             COMPLETION CODE OF 16
.C9      ANOP
         MEND
         EJECT
         MACRO
&NAME    COUNT &DCBSW,&NO
         AIF   ('&NO' NE '').A01
         MNOTE 16,'NO LINE COUNT SUPPLIED'
         MEXIT
.A01     AIF   ('&DCBSW' NE '').A02
         MNOTE 16,'NO DCBSW SUPPLIED'
         MEXIT
.A02     AIF   ('&NO' NE '0').A03
&NAME    ZAP   &DCBSW.+IOPSRCNT(4),=P'0' 0 ZEROISE LINE COUNTER
         MEXIT
.A03     ANOP
&NAME    AP    &DCBSW.+IOPSRCNT(4),=P'&NO' 0 INCRENENT LINE COUNT
         MEND
         SPACE 5
         MACRO
&NAME    MVCD  &DISP,&FLD
         LCLC  &L
&L       SETC  'L'''
&NAME    MVC   &DISP.(&L&FLD,R5),&FLD 0ADD MESSAGE TO LINE
         MEND
         SPACE 5
         MACRO
&NAME    BBMESS &N
&NAME    MVC   DTBBEMSS(L'BBMESS&N),BBMESS&N MOVE MESSAGE TO LINE
         MEND
         EJECT
         MACRO
&NAME    BLANK &P1,&LEN,&SKIP
         LCLC  &L,&R,&LL
         AIF   ('&NAME' EQ '').A00
&NAME    DS    0H 0                ENSURE ALIGNMENT
.A00     AIF   ('&P1'(1,1) NE '(').A01
&R       SETC  '&P1(1)'
         AGO   .A02
.A01     AIF   ('&P1' EQ '').A011
         MVI   &P1,C' ' 0          INSERT LEADING BLANK
&LL      SETC  'L''&P1'
         MVC   &P1.+1(&LL.-1),&P1 0 AND PROPAGATE SPACES
.A011    L     R1,&P1.+IOPSRECA 0  GET BUFFER ADDRESS
&R       SETC  'R1'
.A02     ANOP
&L       SETC  '&LEN'
         AIF   ('&LEN' NE '').A03
&L       SETC  '133'
.A03     MVI   0(&R),C' ' 0        MOVE SPACE TO START OF RECORD
         MVC   1(&L.-1,&R),0(&R) 0 PROPAGATE SPACES
         AIF   ('&SKIP' NE '').A04
         MEXIT
.A04     MVI   0(&R),&SKIP ^       MOVE IN SKIP CHATACTER
         MEND
         SPACE 5
         MACRO
&NAME    PL    &PPLL,&IN,&OUT
&NAME    LA    R2,&IN 0            POINT AT EBCDIC FIELDS
         LA    R3,&OUT 0           POINT AT BINARY PL
          AIF  ('&SYSECT' NE 'BUDGIE3C').A01
          CBAL R4,&PPLL.PLC ^      CONVERT BUNARY TO EBCDIC PL
         MEXIT
.A01     ANOP
         CBAL  R4,&PPLL.PL 0       CONVERT EBCDIC TO BINARY PL
         MEND
         EJECT
         MACRO
&NAME    CCTST &ID
&NAME    CLC   0(4,R6),=C'&ID' 0  TEST FOR MATCHING ID
         AIF   ('&ID' GT 'MS19').C01
         BE    CC&ID 0            PROCESS IF YES
         MEXIT
.C01     BNE   CCLB&SYSNDX ^       BRANCH IF NOT
         CBAL  ,CC&ID ^            GO PROCESS CONTROL CARD
CCLB&SYSNDX EQU *                  CONTINUE CONTROL CARD PROCESSING
         MEND
         SPACE 5
         MACRO
&NAME    GETCB &CBN
.*
.*       ACQUIRE CORE FOR, AND CHAIN, A NEW CONTROL BLOCK
.*
&NAME    CBAL  R4,GETMAIN ^        ACQUIRE CORE FOR CONTROL BLOCK
         LR    R8,R1 ^             PRESERVE ADDRESS OF NEW BLOCK
         L     R1,PTR&CBN ^        RETRIEVE CURRENT C/B POINTER
         ST    R8,PTR&CBN ^        ESTABLISH NEW AS CURRENT
         MVC   &CBN&CBN-&CBN.NTRY+1(3,R1),PTR&CBN+1 POINT LAST AT THIS
         MVI   &CBN.FLAG,FLAG&CBN ^IDENTIFY CURRENT C/B
         ZAP   &CBN.CCNO,SYSIN+IOPSRCNT(4) MOVE CONTROL CARD SEQ NO
         MEND
         SPACE 5
         MACRO
&NAME    DEFREE &T
.*
.*       DEFINE OPERATION CODING TO BE RELEASED IF UNUSED
.*
&NAME    DC    AL1(0),AL3(FREE&T.S),A(FREE&T.X-FREE&T.S)
         MEND
         EJECT
         MACRO
&NAME    TEST  &T,&FLD
.*
.*       PERFORM ANY REQUIRED TEST ( THAT IS DEFINED IN A 'SFXX' LABEL
.*        UPON A FILED IN A CONTROL RECORD.
.*
         LCLA  &LL
         LCLC  &RT
&RT      SETC  '&FLD'(1,4)
&NAME    LA    R1,&FLD.-&RT.CARD ^ SET R1 TO DISPLACEMENT OF FIELD
         LA    R1,1(,R1) ^         INCREMENT DIPLACEMENT TO POSN
         STC   R1,FLDP ^           PRESERVE POSN OF FIELD TO B E TESTED
&LL      SETA  L'&FLD
         LA    R1,&LL ^            SET R1 TO LENGTH OF FIELD
         STC   R1,FLDL ^           PRESERVE LENGTH OF FIELD
         LA    R3,FLDP ^           POINT R3 AT FIELD'S PL
         SR    R1,R1 ^             ZEROISE REGISTER 1
         IC    R1,SF&T ^           ESTABLISH TEST REQUIRED
         CBAL  R4,TESTSEL ^        PERFORM REQUIEED TEST
         MEND
         SPACE 5
         MACRO
&NAME    TSEL  &TEST,&CB
.*       SET UP LINKAGE FOR TESTSEL ROUTINE
         AIF   ('&CB' EQ '').A01
&NAME    L     R1,&CB 0            GET ADDRESS OF ASSOC C/B
         SLL   R1,8 0              ALTER '00AAAAAA' TO 'AAAAAA00'
         IC    R1,&TEST 0          ADD INTERNAL TEST ID TO R1
         AGO   .A02
.A01     ANOP
&NAME    IC    R1,&TEST 0          ADD INTERNAL TST ID TO R1
.A02     ANOP
         CBAL  R4,TESTSEL 0        PERFORM SELECTED TEST
         MEND
         TITLE 'BUDGIE SUITE BATCH BALANCING PROGRAM'
BUDGIE3  CSECT
         PRINT ON,GEN,NODATA
         SPACE 1
*        REGISTER EQUATES AND USAGE
         SPACE 1
R0       EQU   0
R1       EQU   1
R2       EQU   2                   SUB-ROUTINE CONTROL INFORMATION
R3       EQU   3                   PTR TO SUB-FIELD OFFSET AND LENGTH
R4       EQU   4                   CBALRETURN ADDRESS
R5       EQU   5                   POINTER TO SYSPRINT BUFFER
R6       EQU   6                   POINTER TO SYSIN / SYSUT1 BUFFER
R7       EQU   7                   POINTER TO PRINT BUFFER
R8       EQU   8                   MULTI-PURPOSE BUFFER POINTER
R9       EQU   9
R10      EQU   10                  WORK REG UNALTERED BY SUB RTNS
R11      EQU   11                  BASE REGISTER FOR SUB-CSECTS
R12      EQU   12                  BASE REGISTER 2
R13      EQU   13                  SAVE AREA POINTER / BASE REGISTER 1
R14      EQU   14
R15      EQU   15                  BALR ROUTINE ADDRESS / WORK REGISTER
         SPACE 5
*        PROGRAMMER      D.A.MOORCROFT
*        DATE WRITTEN    JULY, 1974
         SPACE 1
*        PURPOSE - THIS PROGRAM PERFORMS THE BATCH BALANCING
*         FUNCTIONS OF THE BUDGIE SUITE.  IT VERIFIES THAT
*         DATA IS NUMERIC, ACCUMULATES FIELDS AND COMPARES
*         THE TOTAL WITH A VALUE IN THE BATCH CARD, OPTIONALLY
*         CREATES A CONTROL RECORD FOR EACH BATCH, AND CAN
*         OPTIONALLY INVOICE A USER MODULE FOR FURTHER
*         PROCESSING.
         SPACE 1
*        FILES:-
*         SYSUT1   - INPUT BATCHES
*         SYSUT2   - ACCEPTED BATCHES
*         SYSLIN   - SOURCE OF BUDGIE LOGO
*         SUSPIN   - INPUT SUSPENSE FILE
*         SUSPOUT  - REJECTED BATCHES
*         WORK     - WORK FILE
*         PRINT    - BATCH BALANCING REPORT
*         SYSPRINT - UTILITY MESSAGE DATA SET
*         LOGI     - INPUT BATCH LOG
*         LOGOUT   - UPDATED BATCH LOG
*         LOGLIST  - LISTING OF BATCH LOG
*         SYSIN    - BUDGIE CONTROL CARDS
*         DELETED  - INDIVIDUALLY REJECTED RECORDS
*         DUPLICAT - BATCHES WITH DUPLICATE BATCH NUMBERS
         EJECT
*        LIMITATIONS -
*         1. MAXIMUM RECORD LENGTH 256 BYTES - **** RESTRICTION REMOVED
*         2. MAXIMUM LENGTH OF BATCH AND DETAIL CARD IDS IS 8 BYTES.
*         3. MAXIMUM LENGTH OF COMPOSITE BATCH NUMBER IS 16 BYTES.
*         4. MAXIMUM NUMBER OF COMPONENT FIELDS FOR THE BATCH NUMBER
*            IS 5.
*         5. ASSOCIATED DETAIL AND BATCH CARD FIELDS MIST HAVE THE SAME
*            DECIMAL ALIGNMENT, AND CAN HAVE NO MORE THAN 4 PLACES
*            OF DECIMALS.
*         7. RIGAM & ISAM KEYS MAY BE COMPOSED OF NO MORE THAN 8
*           LITERALS OF FIELDS FROM BATCH OR DETAIL RECORDS.
*         8. AN INTERNAL TABLE COBSTRUCTED FROM AN EXTERNAL TABLE CAN
*           COMPRISE N MORE THAN 7 SEPARETE FIELDS.
         EJECT
*        TECHNIQUES:-
*         1. CONTROL CARD INFORMATION OF THE FORM PPL - POSITION AND
*            LENGTH - IS CONVERTED TO TWO ADJACENT ONE-BYTE BINARY
*            FIELDS - PL.
*         2. AN AREA OF CORE IS DYNAMICALLY ECQUIRED, AND IS
*            SUB-ALLOCATED AS NECESSARY FOR THE BUDGIE CONTROL BLOCKS.
*            INTERNAL TABLES, BUFFER AREAS, LINKAGE AREAS ATC ARE ALSO
*            SUB-ALLOCATED FROM THIS BLOCK OF STORAGE
*         3. THE CONTROL CARDS ARE ASSUMES TO BE VALID, AND NO
*            CHECKING IS PERFORMED.  THEY SHOULD BE VALIDATED
*            BY BUDGIE0.
*         4. A NIMBER OF CONTROL CARDS CONTAIN 'BUCKETS' OF DATA.
*            IN ORDER TO MINIMISE CODING AND DSECT COMPLEXITY,
*            THE ONCE-OFF DATA IS EXTRACTED FROM THE CARD AND
*            THEN THE BUCKETS ARE PROCESSED IN A LOOP USING THE
*            FIRST SET OF SESCRIPTIONS AND INCREMENTING THE
*            DSECT BASE REGISTER TO MOVE THE MASK OVER THE
*            SUCCESSIVE BUCKETS.
*         5. ALL CODING ASSOCIATED WITH PROGRAM INITIALISATION AND WITH
*            MANY OF THE OPTIONS IS IN SUB-CSEC TS.  CSECTS THAT HAVE
*            BEEEN FINISHED WITH, OR ARE NOT REQUIEED FOR A PARTICULAR
*            APPLICATION, ARE USED AS STAOAGE POOLS.
*         6. INTER-ROUTINE EXCHANGE OF CONTROL IS ACCOMPLISHED BY
*            THE CBAL MACRO, WHICH IS A PART OF THE SOURCE DECK.
*            ANY SUB-ROUTINE MAY BE INVOKED FROM ANYWHERE BY ISSUING
*                                  CBAL  R4,ROUTINE
*            IF CONTROL IS TO BE PASSED TO A LABEL IN ANOTHER CSECT,
*            ( OTHER THAN BUDGIE3, WHICH IS ALWAYS ADRESSSABLE ),
*            THEN USE              CBAL  ,LABEL
*            NOTE THAT THE CBAL MACRO MUST BE UPDATED TO REFLECT THE
*            NAME OF EVERY CSECT, AND THE ROOT NAMES OF THE ROUTINES
*            AND LABELS WITHIN THEM, OR ADDRESSABULITY ERRORS MAY
*            OCCUR.  NOTE THAT MACROS SUBIN AND SUBOUT AUTOMATICALLY
*            PRESERVE AND RESTORE R11 IF R4 IS SAVED BY A SUB-ROUTINE
*            IN THE MAIN CSECT.  THIS ENSURES
*            ADDRESSABILITY IN THE CASE WHEN A SUB-CSECT INVOKES A
*            ROUTINE IN THE MAIN CSECT WHICH IN TURN INVOKES A ROUTINE
*            IN ANOTHER SUB-CSECT.
*            IN SUB-CSECTS WHICH FREQUENTLY PASS CONTROL TO A SUB-RTN
*            IN ANOTHER SUB-CSECT, CONTROL IS PASSED VIA A 'SUBSUBRTN'
*            WITHIN THE INITIATING SUB-CSECT, AND IT IS ONLY THIS
*            SUBSUBRTN THAT ESTABLISHES THE NECESSARY LINKAGE TO THE
*            TARGET ROUTINE.  THIS EFFECTS CONSIDERABLE CORE SAVINGS
*            WHILE INCREASING ONLY SLIGHTLY THE PROGRAM OVERHEAD.
*         7. SUB-ROUTINES PASS RESULTS BACK TO THE CALLER VIA THE
*            CONDITION CODE IN THE PSW.  UPON RETURN, THE USER CAN MAKE
*            THE APPROPRIATE CONDITIONAL BRANCHES.
         EJECT
*        TECHNIQUES:-
*         8. OCCASIONALLY USED ROUTINES SUCH AS USER MODULES, RIGAM,
*            AND CURRENCY CONVERSION ROUTINES ARE DYNAMICALLY INVOKED.
*            IN ORDER TO REDUCE SYSTEM OVERHEAD, AND TO CONFUSE THE
*            HELL OUT OF ANY-ONE TRYING TO DEBUG A USER ERROR, BUDGIE3
*            PRESERVES THE ADDRESS OF THE ENTRY POINT AFTER THE INITIAL
*            LOAD, AND THEREAFTER 'BALR S' TO IT.  CONSEQUENTLY, THE
*            RESPONSIBILITY COUNT CAN NEVER EXCEED 1.
*         9. IN ORDER TO CATER FOR THE EXTRAVAGANT DEMENDS ON THE
*             SYSTEM, AN ESSENTIALLY UNLIMITED NUMBER OF TESTS OF EVERY
*             TYPE MAY BE SPECIFIED.  THE MS13 CARD SPECIFIES THE ID (
*             LABEL ) OF THE APPROPRIATE MSXX CARD, AND THUS THE NUMBER
*             OF EACH SUCH TEST IS 256**2.
*        10. ALL READS ARE PERFORMED BY CBAL'S TO THE APPROPRIATE I/O
*            SUBROUTINE.  THESE ROUTINES ARE SO WRITTEN THAT THEY SET
*            THE CONDITION CODE TO REFLECT EOF, SO THAT THE CALLER CAN
*            MAKE THE FOLLOWING TESTS :-
*              BE  - RECORD RETURNED
*              BNE - END OF FIEE ENCOUNTERED
         EJECT
*        ABNORMAL TERMINATION -
*         BUDGIE3 CAN TERMINATE WITH THE FOLLOWING ABEND CODES:-
*               4 - USER REQUESTED DUMP DURING TERMINATION
*               8 - POTENTIALLY CRITICAL CONTROL CARD ERROR WITH
*                   POSSIBLY OVERWRITTEN CONTROL BLOCKS
*              12 - MANDATORY DD STAEMENT MISSING
*              16 - FIRST DATA CARD NOT A BATCH CARD
*              20 - SEQUENCE ERROR IN SYSUT1
*              24 - SEQUENCE ERROR IN LOGIN
*              28 - SEQUENCE ERROR IN SUSPIN
*              32 - UNSUPPORTED FUNCTION REQUESTED
*              36 - SEVERE ERROR(S) IN CONTROL CARDS
*              40 - INTERNAL RECORD SHORTER THAN OUTPUT
*              44 - ISAM ERROR OTHER THAN RECORD NOT FOUND
*              48 - CB21 SPECIFIES INCORRECT IS KEY LENGTH
*              52 - NO WORK DD STATEMENT & BATCH EXCEEDS AVAILABLE CORE
*              56 - EXCEEDED LIST SIZE WHILE BUILDING C4/C5 TYPE LIST
*              60 - USER REQUESTED ABEND WITH OPERATION CODE 'AB'
*              64 - NO CONTROL CARDS SUPPLIED
*              68 - INSUFFICIENT CORE FOR PROGRAM INITIALISATION/EXEC
*              72 - PROBABLE USER LOOP: NO READ FOR 5 SECONDS
*             100 - BUDGIE3 INTERNAL LOGIC ERROR
         SPACE 5
*        COMPLETION CODES -
*         BUDGIE3 CAN SET THE FOLLOWING COMPLETION CODES:-
*              0  - EXECUTION SUCCESSFUL
*              12 - AT LEAST ONE HARD ERROR IN INPUT
*              16 - NO BATCHES ACCEPTED
         EJECT
*        CSECTS:-
*         BUDGIE3 CONSISTS OF A NUMBER OF INTER-RELATED CSECTS IN
*         ONE ASSEMBLY.  ALL MAIN-LINE LOGIC, AANY SUB-ROUTINES AND ALL
*         CONSTANTS ARE IN THE 'ROOT' CSECT, AND THE SUB-CSECTS CONTAIN
*         INITIALISATION CODING AND THE CODING ASSOCIATED WITH THE MANY
*         OPTIONAL FUNCTIONS.
*         THE MAIN CSECT USES R13, AND R12 FOR BASE REGISTERS, WHILE
*         ALL SUB-CSECTS USE R11 FOR BASE.
*         ALL SUB-ROUTINES ARE INVOKED BY THE MACRO 'CBAL'. IF THE
*         ROUTINE IS IN THE MAIN CSECT ( WHICH IS ALWAYS ADDRESSABLE )
*         OR IS IN THE SAME SUB-CSECT AS THE CALLER, A SIMPLE 'BAL'
*         IS GENERATED.  OTHERWISE, ADDRESSABILITY TO THE OTHER CSECT
*         IS ESTABLISHED BEFORE ISSUING THE 'BAL', AND IS DIS-ENGAGED
*         UPON RETURN FROM THE SUB-ROUTINE.
*         I REALISE THAT THIS 'CBAL' TECHNIQUE IS NOT THE BEST
*         SOLUTION TO THE PROBLEM, BUT ( LIKE MOPSY ) BUDGIE3 JUST
*         GROWED AND GROWED, AND THIS WAS THE QUICKEST WAY TO RESOLVE
*         MY ADDRESSABILITY PROBLEMS WHEN I HAD A TIGHT DEADLINE.
*         UTILISING TECHNIQUES OF AMAZING SOPHISTOCATIOM, ALL CSECTS
*         NOT REQUIRED BY A PARTICULAR APPLICATION ARE USED AS STORAGE
*         POOLS BY THE 'WORKFILE' ROUTINES.
*         NOTE THAT THE FINAL CARD IN THE FINAL OCCURRENCE OF A CSECT
*         MUST BE OF THE FORM
*              LGTHX EQU *
*         WHERE X IS THE CSECT SUFFIX.  THIS IS USED BY THE WORKFILE
*         STORAGE POOL ALLOCATION ROUTINES TP DETERMINE THE LENGTH OF
*         THE CSECT.
*         THE CSECTS COMPRISING BUDGIE3 ARE -
*              BUDGIE3  - MAIN-LINE LOGIC, PRINCIPLE SUB-ROUTINES, AND
*                         CONSTANTS.
*              BUDGIE3A - STORAGE POOL AND WORKFILE MAIIPULATION
*              BUDGIE3B - FIELD TETS
*              BUDGIE3C - INITIALISATION, CONTROL CARD PROCESSING, AND
*                         CREATION OF CONTROL BLOCKS
*              BUDGIE3D - I/O SUB-ROUTINES
*              BUDGIE3E - CREATE THE B/B REPORT, WRITE TO ACCEPTED OR
*                         SUSPENSE, & INITIALISE FOR NEW BATCH
*              BUDGIE3F - PL CONVERSION AND USER ROUTINE PROCESSING
*              BUDGIE3G - PROGRAM TERMINATION, CARD TYPE DETERMINATION
*              BUDGIE3H - PARM FIELD PROCESSING & INTERCONNECTING C/B'S
*                         ALSO SOME C/B CREATION DUE TO BUDGIE3C OVFLOW
*              BUDGIE3I - TABLE OF VALID TEST CODES
*              BUDGIE3J - FIELD TESTS ( CONTINUED )
*              BUDGIE3K - CONTROL BLOCK BUILDING ( CONTINUED )
*              BUDGIE3L - DETAIL CARD PROCESSING
*              BUDGIE3M - INTERCONNECT CONTROL BLOCKS
*              BUDGIE3N - INITIALISATION: OPEN FILES & ACQUIRE CORE
*              BUDGIE3O - FIELD TESTS ( CONT'D )
         EJECT
*        PARM:-
*         THE PARM FIELD OF THE EXEC SAATEMENT IS SCANNED FOR
*         KEYWORD SUB-FIELDS.  THE FOLLOWING SUB-FIELDS ARE
*         VALID:
*            CB=NNNN    - SPECIFIES THE SIZE OF A CONTIGUOUS AREA
*                         OF CORE THAT IS ACQUIRED AND SUBDIVIDED
*                         FOR THE CONTROL BLOCKS AND INTERNAL
*                         TABLES. IF OMITTED, THE DEFAULT IS 5000.
*            MB=NNNN    - SPECIFIES THE MAXIMUM BLKSIZE TO BE USED
*                         FOR THE WORK FILE.  IF OMITTED, THE DEFAULT
*                         IS 1693 ( QUARTER TRACK BLOCKING - 2314 ).
*            UL=X       - SPECIFIES THE CHARACTER TO BE USED TO
*                         UNDERLINE FIELDS IN ERROR.  BY DEFAULT, '_'
*                         IS USED
*            NT=XX      - SPECIFIES THE TYPE OF TEST TO BE APPLIED TO
*                         NUMERIC FIELDS IN BATCH & DETAIL CARDS.
*                         BY DEFAULT, 'NZ' IS ASSUMED - ZEROISE ALL
*                         LEADING BLANKS.
*                         OPTIONS ARE NN, NS, NZ, NB, NM, UB, US, UZ.
*            NOBC       - SPECIFIES THAT THE INPUT CONSISTS OF A SINGLE
*                         'BATCH' WITH NO BATCH CARD PRECEDING IT.
*                         NOTE THAT A MS02 CARD IS STILL REQUIRED,
*                         BUT IT MAY NOT SPECIFY ANY CONTROL FIELDS
*                         OR BATCH NUMBER COMPONENTS.
*            SF=IN      - SPECIFIES THAT THE SUSPENSE FILE IS TO
*                         CONTAIN AN EXACT IMAGE OF THE INPUT.  IF NOT
*                         CODED, THEN THE SUSPENSE FILE CONATINS RECS
*                         MODIFIED BY CONTROL CARDS AND THE USER MODULE
*                         USING THIS PARM HALVES THE SIZE OF A BATCH
*                         THAT MAY BE PROCESSED WITHOUT RECOURSE TO
*                         THE WORK FILE.
*            FDUMP      - ABEND WITH USER CODE OF 4 DURING TERMINATION
*                         IN ORDER TO FACILITATE DEBUGGING
*            ADUMP      - BY DEFAULT, MOST USER DUMPS WILL ABNORMALLY
*                         TERMINATE THE PROGRAM WITHOUT PRODUCING A COR
*                         DUMP.  THIS PARM REQUESTS FULL DUMPS FOR ALL
*                         USSER ABEND CODES.
*            NOSEQ      - BASIC BUDGIE EXPECTS BATCHES TO BE IN
*                         ASCENDING BATCH NUMBER SEQUENCE, AND REJECTS
*                         DUPLICATE BATCH NUMBERS.  THIS PARM SUPPRESSS
*                         SEQUENCE CHECKING, AND ALLOWS DUPLICATES TO
*                         BE ACCEPTED.  THIS PARM SHOULD NOT BE USED
*                         IF THE SUSPENSE FILE AND/OR BATCH LOG ARE.
*            RCNT       - IF NO MS05 CARDS ARE PRESENT TO DEFINE BATCH
*                         BALANCING FIELDS, BUDGIE3 WILL, BY DEFAULT,
*                         SUPPRESS THE BATCH BALANCING TOTAL LINES.
*                         THIS PARM SPECIFIES THAT A RECORD COUNT BE
*                         MAINTAINED AND PRINTED IN THESE TOTAL LINES.
         EJECT
*        PARM ( CONT'D ) :-
*            ID=(PPP,XXX) SPECIFIED THAT THE LITERAL 'XXX' IS TO B
*                  PLACED IN POSITION PPP OF ALL OUTPUT RECORDS.
*                  THIS ALLOXS DATA FROM MULTOPLE LOCATIONS TO BE
*                  UNIQUELY DEFINED SO THAT, IF B/B AND MAIN EDIT
*                  FUNCTIONS ARE SEPATATED, UT461 CAN BE USED TO SEND
*                  MAIN EDIT REJECTS BACK TO THE CORRECT LOCATION.
*                  ( MAXIMUM LENGTH OF THES LITERAL IS 8 ).
*            BCID=(PPP,XXX) IS SIMILAR IN PURPOSE AND FUNCTION TO THE
*                  ID PARAMETER, BUT THE SUBMITTOR'S ID IS TO BE PLACED
*                  IN THE BATCH CARDS ONLY.
*            MS11=SOFT  - BY DEFAULT, A TEST SPECIFIED IN AN MS11 CARD
*                         IS A HARD ERROR.  THIS PARM MAY SPECIFY THAT
*                         ALL MS11 TESTS ARE TO BE SOFT.  NOTE THAT THI
*                         NOT APPLY TO THE NUMERIC TESTS ASSOCIATED
*                         WITH BALANCING VALUES, WHICH HAVE THE SEVERIT
*                         LEVEL OF THE MS05 CARD.
*            JUSTIFY    - SPECIFIES THAT ALL NUMERIC FIELDS ARE TO BE
*                         RIGHT JUSTIFIED BEFORE ANY OTHER PROCESSING
*                         IS PERFORMED UPON THEM. ( THIS PRESUMES THAT
*                         AN IMPLICIT OR EXPLICIT NUMERIC TEST IS THE
*                         FIRST ONE PERFORMED UPON THE FILE )
*            NOWEEK0    - BY DEFAULT, BUDGIE3 INVOKES UT458 IN SUCH A
*                         WAY THAT IT COMPLIES WITH THE STANDARD THAT
*                         WEEK 1 OF A YEAR IS THE 1ST WEEK TO CONTAIN
*                         3 OR MORE DAYS OF JANUARY, THUS ALLOWING WEEK
*                         09  THIS PARM SPECIFIES THAT THE 1ST WEEK OF
*                         THE YEAR IS ALWAYS WEEK 1.
*            BLSPACE    - BY DEFAULT, IF DOUBLE OR TRIPLE SPACING IS
*                         REQUESTED, THEN BUDGIE WILL SPACE ONLY IF
*                         THERE WERE INSUFFICIENT ERROR MESSAGES TO
*                         SPACE FORWARD THE REQUIRED AMOUNT. ( E.G.
*                         WITH TRIPL SPACING, A BLANK LINE WOULD ONLY
*                         BE WRITTEN IF THERE WERE LESS THAN 3 ERROR
*                         MESSAGES ).  THIS PARM SPECIFIES THAT THE
*                         SPACING REQUEST IS TO BE HONOURED WITH BLANK
*                         LINES REGARDLESS OF THE NUMBER OF ERRORS.
*            CC19=98    - CURRENCY CODE 19 (UK LSD) IS INVALID TO
*                         UT460, BUT SOME USERS HAVE NOT YET ADJUSTED
*                         TO DECIMILISATION AND ITS RAMIFICATIONS.  IF
*                         THIS PARM IS USED, CURRENCY CODE 19 WILL BE
*                         AUTOMATICALLY CONVERSTD TO CODE 98 (UK STER)
*                         PRIOR TO VALIDATION AND CURRENCY CONVERSION.
*            PUNCHSUSP  - SPECIFIES THAT 'SUSPENSE' IS TO BE TREATED
*                         AS 'REJECTED' IN THE BATCH LOG AND BATCH LOG
*                         LIST.  THIS IS REQUIRED IF SUSPOUT IS DIRECTE
*                         TO PUNCH, AND THE BATCHES ARE TO BE CORRECTED
*                         AND RESUBMITTED MANUALLY.  CONSEQUENTLY THEY
*                         SHOULD NOT BE IN THE BATCH LOG, OR THAY WILL
*                         WILL BE REJECTED THE SECOND TIME FOR DUPLICAT
*                         BATCH NUMBER.
         EJECT
*        PARM ( CONT'D ) :-
*            KEYBREAK   - SPECIFIES THAT BUDGIE IS TO RECOGNISE A NEW
*                         BATCH BY A CHANGE, IN ANY RECORD TYPE, OF THE
*                         BATCH NUMBER ( I.E. FILE KEY )9  THIS ALLOWS
*                         BUDGIE TO CREATE SUMMARY RECORDS.
*            MS11=PPPL  - ORDINARILY, MS11 FIELD DESCRIPTIONS ARE PPLL
*                         BUT THIS PARM ALTERS THEM TO PPPL.
*            NOISINDEX  - BY DEFAULT, MASTER INDICES ARE BUILT IN CORE
*                         FOR EVERY I.S. DCB OPENED.  THIS PARM SUPPRES
*                         THE INDICES ( AND INCREASES I/O & CPU 80%)
*            UPARM=(NNN,.....) - THE DATA ( 2ND SUB-FIELD ) IS MOVED
*                         TO POSITION 'NNN' IN THE CONCARENATED RECORD
*                         & WORK AREA DUTING INITIALISATION SO THAT
*                         USER HAS ACCESS TO OWN PARM FIELDS.
*            COM=*      - SPECIFIES THE CHARACTER AT THE START OF AN
*                         OPTIONAL ERROR MESSAGE THAT FLAGS IT AS AN
*                         INTERNAL COMMENT THAT IS NOT FOR PRINTING.
*                         SUCH COMMANTS WILL NOT BE USED AS ERROR MESSA
*                         BY DEFAULT X'FF' IS USED.
*            FREE       - FREEMAIN CORE OF ALL OVERLAYABLE CSECTS
*                         PRIOR TO THE OPEN OF ALL AVAILABLE D/S.
*            SC=NNN     - AMOUNT OF CORE THAT IS TO BE PRESERVED AND
*                         LEFT AVAILABLE TO OTHER FUNCTIONS WHEN
*                         BUDGIE3 DYNAMICALLY ACQUIRES ALL SPARE CORE
*                         IN THE PARTITION.  BY DEFAULT, SUFFICIENT IS
*                         LEFT FOR THE WORK FILE + 1000 FOR SAFETY.
*            MC=NNN     - MAXIMUM AMOUNT OF CORE THAT IS TO BE ACQUIRED
*                         DYNAMICALLY FOR WORK FILE PROCESSING. THE
*                         DEFAULT VALUE IS 50K.
*            NOLOAD     - BY DEFAULT, BUDGIE3 WILL LOAD AND INITIALISE
*                         ALL USER ROUTINES DURING INITIALISATION, AND
*                         PRIOR TO THE OPTIMISING ACQUISITION OF CORE.
*                         THIS PARM REQUESTS THAT THE ROUTINES ARE NOT
*                         PRE-LOADED, BUT ONLY LOADED IF REQUIRED.
*                         THIS PRE-SUPPOSES THAT 'SC=' HAS BEEN CODED *
*                         TO RESERVE CORE FOR THE ROUTINES.
*            LCNT=NN    - LINES / PAGE FOR EACH REPORT. THE DEFAULT
*                         VALUE IS 60.
*            UNLIKE     - UNLIKE DEVICES CONCATENATED FOR SYSUT1 INPUT
*            NOEOF      - DO NOT TERMINATE 'INTRDR' WITH /*EOF.  THIS
*                         ALLOWS 'WI' TO BE USED TO CREATE A DATA SET
*                         OTHER THAN A JOB STREAM DESTINED FOR INTRDR.
*            PPL+       - ALLOW '-' OR '&' OVERPUNCH ON THE FIRST DIGIT
*                         OF ANY PPL FIELD DEFINITION TO DENOTE A
*                         LEADING '1' OR '2' RESPECTIVELT.
*            KEEPINDS   - BY DEFAULT, BUDGIE3 RESETS ( TO BINARY ZERO )
*                         ALL DETAIL LEVEL INDICATORS WHEN A NEW CARD
*                         IS READ, AND ALL BATCH LEVEL INDICATORS WHEN
*                         A NEW BATCH CARD IS READ.  THIS PARM CAUSES D
*                        DETAIL INDS 56-99 NOT TO BE RESET UNTIL CHANGE
*                         OF BATCH, AND BATCH INDS 56-99 NEVER TO RESET
*            SEQALL     - ASSIGN AND PRINT SEQUENCE NUMBERS FOR ALL
*                         CONTROL CARDS.  BY DEFAULT, ONLY 'MSXX' CARDS
*                         HAVE SEQUENCE NUMBERS ASSIGNED AND PRINTED.
         EJECT
*        PARM ( CONT'D ) :-
*        BECAUSE OS ALLOWS ONLY 100 CJCRACTERS IN PARM FIELD, THE
*         FOLLOWING ABBREVIATIONS ARE RECOGNISED:-
*        NB    NOBC
*        FD    FDUMP
*        AD    ADUMP
*        NS    NOSEQ
*        RC    RCNT
*        J     JUSTIFY
*        N0    NOWEEK0
*        BL    BLSPACE
*        19    CC19=98
*        MP    MS11=PPPL
*        MS    MS11=SOFT
*        NL    NOLOAD
*        SF    SF=IN
*        UL    UNLIKE
*        PS    PUNCHSUSP
*        KB    KEYBREAK
*        NX    NOISINDEX
*        F     FREE
*        NE    NOEOF
*        P+    PPL+
*        KI    KEEPINDS
*        SA    SEQALL
        EJECT
*        TEST TYPES:-
*         THE FOLLOWING TEST REQUESTS ARE, OR WILL BE, SUPPORTED.
*         ( THE TABLE SHOWS THE REQUEST CODE, THE INTERNAL CODE
*         TO WHICH IT IS CONVERTED, AND THE REQUEST'S MEANING ).
*
*          L1  (  0) - ALPHABETIC: A - Z | BLANK
*          L2  (  1) - ALPHAMERIC: A - Z | BLANK | 0 - 9
*          L3  (  2) - ALPHAMERIC: A - Z | BLANK | 0 - 9 | SPECIAL CHS
*          L4  (  3) - NON-BLANK
*          L5  (  4) - BLANK
*          L6  (  5) - VALID CURRENCY CODE
*          L7  (  6) - LEFT JUSTIFY IF NON-BLANK
*          L8  (  7) - RIGHT JOSTIFY IF NON-BLANK
*          L9  (  8) - CURRENCY CONVERSION OR RATER EXTRACTION
*          LT  (  9) - LESS THAN LITERAL
*          LE  ( 10) - LESS THAN OR EQUAL TO LITERAL
*          EQ  ( 11) - EQUAL TO LITERAL
*          NE  ( 12) - NOT EQUAL TO LITERAL
*          GT  ( 13) - GREATER THAN LITERAL
*          GE  ( 14) - GREATER THAN OR EQUAL TO LITERAL
*          NN  ( 15) - COMPLETE UNSIGNED NUMERIC
*          NS  ( 16) - SIGNED/UNSIGNED NUMERIC + LEADING BL | ALL BL
*          NZ  ( 17) - AS NS: REPLACE LEADING BLANKS BY ZEROS
*          NB  ( 18) - AS NZ: EXCEPT ALL BLANK FIELDS NOT REPLACED
*          T.  ( 19) - TABLE LOOKUP
*          C1  ( 20) - VERIFY VALUE AGAINST SUPPLIED LIST
*          C2  ( 21) - TEST IF FIELD STARTS WITH ASTERISK
*          C3  ( 22) - MOVE/COMPARE FIELDS IN SAME RECORD
*          C4  ( 23) - BUILD C1-TYPE LIST FROM TOTAL INPUT
*          C5  ( 24) - REBUILD C1-TYPE LIST FOR EACH BATCH FROM INPUT
*          C6  ( 25) - CONVERT ALL BLANKS TO ZEROES
*          C7  ( 26) - PERFORM MATHEMATICAL OPERATION (IN MS36 CAD)
*          C8  ( 27) - ALIGN FLOATING DDCIMAL FIELD IN FIXED ALIGNMENT
*          R1 ( 28) - INCLUSIVE/EXCLUSIVE RANGE TEST
*          R2  ( 29) - TRANSFORM TRAILING SPACES TO ZEROES
*         R3  ( 30) - EXPAND BYTE OF SWITCHES
*         R4  ( 31) - COMPRESS 8 FLAGS INTO ONE BYTE
*          R5  ( 32) - CALL USER EXIT ( ITERATIVELY )
*          R6  ( 33) - CONDITIONALLY ACCUM B/C FLD: INPUT EBCDIC
*          R7  ( 34) - CONDITIONALLY ACCUM B/C FLD: INPUT PACKED
*          R8  ( 35) - CONDITIONALLY ACCUM C/R FLD: INPUT EBCDIC
*          R9  ( 36) - CONDITIONALLY ACCUM C/R FLD: INPUT PACKED
*          D1  ( 37) - DATE IN FORM MMDDYY
*          D2  ( 38) - DATE IN FORM DDMMYY
*          D3  ( 39) - DATE IN FORM YYMMDD
*          D4  ( 40) - DATE IN FORM DWWYY
*          D5  ( 41) - DATE IN FORM YYWWD
*          D6  ( 42) - DATE IN FORM YYDDD
*          D7  ( 43) - MONTH NUMBER EQUAL TO CURRENT
*          D8  ( 44) - DATE CONVERSION, EXTRACTION, MANIPULATION
*          D9  ( 45) - UNALLOCATED
         EJECT
*        TEST TYPES ( CONT'D ):-
         SPACE 1
*          I.  ( 46) - ISAM LOOKUP
*          J.  ( 47) - RIGAM LOOPUP
*         C9  ( 48) - TRANSFORM FIELDS ACCORDING TO MS38 CARD
*          E1  ( 49) - PARTIAL KEY MATCH AGAINST LITERAL IN MS33
*          E2  ( 50) - PROPAGTE MS13 LABEL THROUGH FIELD
*          E3  ( 51) - MOVE ERROR MESSAGE TO FIELD
*          E4  ( 52) - REMOVE EMBEDDED BLANKS & LEFT-JUSTIFY
*          E5  ( 53) - REMOVE EMBEDDED BLANKS & RIGHT JUSTIFY
*          E6  ( 54) - UNASSIGNED
*          E7  ( 55) - UNASSIGNED
*          E8  ( 56) - UNASSIGNED
*          E9  ( 57) - UNASSIGNED
*          F1  ( 58) - UNASSIGNED
*          F2  ( 59) - UNASSIGNED
*          F3  ( 60) - UNASSIGNED
*          F4  ( 61) - UNASSIGNED
*          F5  ( 62) - UNASSIGNED
*          F6  ( 63) - UNASSIGNED
*          M1  ( 64) - MODULUS 11 CHECK CHARACTER
*          M2  ( 65) - UNASSIGNED
*          M3  ( 66) - UNASSIGNED
*          M4  ( 67) - UNASSIGNED
*          M5  ( 68) - UNASSIGNED
*          M6  ( 69) - UNASSIGNED
*          M7  ( 70) - UNASSIGNED
*          M8  ( 71) - UNASSIGNED
*          M9  ( 72) - UNASSIGNED
*          US  ( 73) - UNSIGNED NUMERIC + LEADING BL | ALL BL
*          UZ  ( 74) - AS US: REPLACE LEADING BLANKS BY ZEROES
*          UB  ( 75) - AS UZ: EXCEPT ALL-BLANK FIELDS ARE NOY REPLACED
*          S   ( 76) - INVOKE 'SUBROUTINE'
*          DW  ( 76) - DO-WHILE: PERFROM WHILE CONDITIONS SATISFIED
*          NM  ( 77) - NUMERIC, LEADING BLANKS, LEADING MINUS SIGN
*          SX  ( 78) - USED INTERNALLY TO DELIMIT SUB-ROUTINE (CB13)
*          IT  ( 79) - USED INTERNALLY FOR INDICATOR TESTS
*          ON  ( 80) - SET INDICATOR ON
*          OF  ( 81) - SET INDICATOR OFF
*          WR  ( 82) - WRITE ADDITIONAL RECORD
*          DM  ( 83) - NO-OP TO FORCE END-OF-TEST PROCESSING
*          ER  ( 84) - NO-OP TO FORCE ERROR PROCESSING
*          NR  ( 85) - NUMERIC: ZEROISE IF NON-NUMERIC
*          UR  ( 86) - UNSIGNED NUMERIC: ZEROISE IF NON-NUMERIC
*          AB  ( 87) - ABEND WITH USER CODE 060
*         WI  ( 88) - WRITE TO INTERNAL READER
         TITLE 'DSECTS FOR CONTROL CARDS'
***********************************************************************
*        FORMAT OF MS00 CONTROL CARD                                  *
***********************************************************************
         SPACE 1
*        SPECIFIES THE REPORT HEADING FOR THE SUSPENSE FILE UPDATE REP
         SPACE 1
MS00CARD DSECT
MS00ID   DS    CL4                 CARD ID ('MS00')
MS00SPCE DS    CL1                 REPORT LINE SPACING
MS00TYPE DS    CL1                 REPORT HEADING TYPE
*                                   ' ' - SUSPENSE FILE UPDATE
*                                   'S' - SUSPENSE FILE UPDATE
*                                   'L' - BATCH LOG STATUS REPORT
MS00HEAD DS    CL74                REPORT HEADING
MS00LGTH EQU   *-MS00CARD          LENGTH OF DSECT
         EJECT
***********************************************************************
*        FORMAT OF MS01 CONTROL CARD                                  *
***********************************************************************
         SPACE 1
*        SPECIFIES THE REPORT HEADING FOR THE BATCH BALANCING REPRRT
         SPACE 1
MS01CARD DSECT
MS01ID   DS    CL4                 CARD ID ('MS01')
MS01SPCE DS    CL1                 REPORT LINE SPACING
MS01LIST DS    CL1                 DATA TO BE LISTED
*                                   ' ' - LIST ALL DATA
*                                   '1' - PRINT TOTALS & RECS IN ERROR
*                                   'N' - PRINT TOTALS & RECS IN ERROR
*                                   '2' - PRINT CONTROL TOTALS ONLY
MS01HEAD DS    CL74                REPORT HEADING
MS01LGTH EQU   *-MS01CARD
         EJECT
***********************************************************************
*        FORMAT OF MS02 CONTROL CARD                                  *
***********************************************************************
         SPACE 1
*        DEFINES THE FORMAT & CONTENT OF A BATCH CARD
         SPACE 1
MS02CARD DSECT
MS02ID   DS    CL4                 CARD ID ('MS02')
MS02PBCI DS    CL2                 POS'N OF BATCH CARD IDENTIFIER
MS02LBCI DS    CL1                 LENGTH OF BATCH CARD IDENTIFIER
MS02BCI  DS    CL8                 LITERAL BATCH CARD IDENTIFIER
MS02CBBI DS    CL8                 LITERAL ID FOR CORRECTION BATCHES
MS02DROP DS    CL1                 IF 'D' THEN DISCARD UNKNOWN CATD TYP
         DS    CL2                 UNUSED
MS02PCRN DS    CL2                 POS'N OF CORRECTION DATA RECORD NO
MS02LCRN DS    CL1                 LENGTH OF CORRECTION DATA RECORD NO
MS02ORL  DS    CL3                 OUTPUT RECORD LENGTH
MS02OCTL DS    CL1                 OUTPUT CONTROL SWITCH
*                                   ' ' - WRITE DATA ONLY
*                                   '1' - WRITE DATA + BATCH CARD
*                                   '2' - WRITE DATA + CONTROL RECORD
*                                   '3' - WRITE DATA, BATCH CARD, C.R.
MS02URTN DS    CL8                 NAME OF USER SUB-ROUTINE
MS02PBN1 DS    CL2                 POSN OF 1ST SEGMENT OF BATCH NO.
MS02LBN1 DS    CL1                 LGTH OF 1ST SEGMENT OF BATCH NO.
MS02PBN2 DS    CL2                 POSN OF 2ND SEGMENT OF BATCH NO.
MS02LBN2 DS    CL1                 LGTH OF 2ND SEGMENT OF BATCH NO.
MS02PBN3 DS    CL2                 POSN OF 3RD SEGMENT OF BATCH NO.
MS02LBN3 DS    CL1                 LGTH OF 3RD SEGMENT OF BATCH NO.
MS02PBN4 DS    CL2                 POSN OF 4TH SEGMENT OF BATCH NO.
MS02LBN4 DS    CL1                 LGTH OF 4TH SEGMENT OF BATCH NO.
MS02PBN5 DS    CL2                 POSN OF 5TH SEGMENT OF BATCH NO.
MS02LBN5 DS    CL1                 LGTH OF 5TH SEGMENT OF BATCH NO.
MS02IRL  DS    CL3                 LENGTH OF RECORD INTERNALLY.
*                                  IRL - ORL = WORK AREA
MS02PID1 DS    CL2                 POSN OF 1ST SEGMENT OF SUBMITTOR ID
MS02LID1 DS    CL1                 LGTH OF 1ST SEGMENT OF SUBMITTOR ID
MS02PID2 DS    CL2                 POSN OF 2ND SEGMENT OF SUBMITTOR ID
MS02LID2 DS    CL1                 LGTH OF 2ND SEGMENT OF SUBMITTOR ID
MS02PID3 DS    CL2                 POSN OF 3RD SEGMENT OF SUBMITTOR ID
MS02LID3 DS    CL1                 LGTH OF 3RD SEGMENT OF SUBMITTOR ID
MS02PSR1 DS    CL2                 POSN OF 1ST SEGMENT OF DETAIL SORT F
MS02LSR1 DS    CL1                 LGTH OF 1ST SEGMENT OF DETAIL SORT F
MS02PSR2 DS    CL2                 POSN OF 2ND SEGMENT OF DETAIL SORT F
MS02LSR2 DS    CL1                 LGTH OF 2ND SEGMENT OF DETAIL SORT F
MS02PSR3 DS    CL2                 POSN OF 3RD SEGMENT OF DETAIL SORT F
MS02LSR3 DS    CL1                 LGTH OF 3RD SEGMENT OF DETAIL SORT F
MS02DLTP DS    CL2                 POSN IN CORRECTION DATA OF DELETE FL
MS02DLTF DS    CL1                 CHAR IN CORRECTION DATA FOR DELETE
MS02LGTH EQU   *-MS02CARD          LENGTH OF DSECT
         EJECT
***********************************************************************
*        FORMAT OF MS03 CONTROL CARD                                  *
***********************************************************************
         SPACE 1
*        DESCRIBES THE KEY THAT IS TO BE PLACED IN THE CONTROL
*         RECORD THAT IS TO BE CONSTRUCTED FROM THE BATCH.
*         THE MERE PRECENCE OF THIS CARD REQUESTS THAT THE
*         CONTROL RECORD BE CREATED.
         SPACE 1
MS03CARD DSECT
MS03ID   DS    CL4                 CARD ID ('MS03')
MS03PCRK DS    CL3                 POSN OF CONTROL RECORD KEY
MS03LCRK DS    CL2                 LGTH OF CONTROL RECORD KEY
MS03CRK  DS    CL69                CONTROL RECORD KEY (LEFT-ADJUSTED)
MS03POSN DS    CL1                 POSITION OF CONTROL RECORD
*                                   ' ' - FOLLOWING BATCH
*                                   '1' - PRECEDING BATCH
MS03LIST DS    CL1                 OUTPUT CONTROL SWITCH :-
*                                   ' ' - WRITE ONLY
*                                   '1' - PRINT & WRITE
*                                   '2' - PRINT ONLY
MS03LGTH EQU   *-MS03CARD          LENGTH OF DSECT
         EJECT
***********************************************************************
*        FORMAT OF MS04 CONTROL CARD                                  *
***********************************************************************
         SPACE 1
*        DESRIBES A SINGLE FIELD WHICH IS TO BE CREATED
*         IN THE CONTROL RECORD THAT IS TO BE CONSTRUCTED
*         FROM THE BATCH.
         SPACE 1
MS04CARD DSECT
MS04ID   DS    CL4                 CARD ID ('MS04')
MS04FNO  DS    CL2                 CONTROL REC FIELD NO (B1 - B6/RC)
MS04PCRF DS    CL3                 POSN OF CONTROL RECORD FIELD
MS04LCRF DS    CL2                 LGTH OF CONTROL RECORD FIELD
MS04PIND DS    CL1                 PACK INDICATOR ('P' OR BLANK)
MS04NDEC DS    CL1                 NO. OF (IMPLIED) DECIMALS
MS04PSRC DS    0CL3                POSN OF SOURCE FIELD ( NORMALLY W/S)
MS04BNO  DS    CL3                 REQUEST FOR BATCH NUMBER ('BNO')
         DS    CL64                UNUSED
MS04LGTH EQU   *-MS04CARD          LENGTH OF DSECT
         EJECT
***********************************************************************
*        FORMAT OF MS05 CONTROL CARD                                  *
***********************************************************************
         SPACE 1
*        DESCRIBES A SINGLE FIELLD IN A BATCH CARD AGAINST
*         WHICH DETAIL RECORDS ARE TO BE BALANCED, OR WHICH
*         IS TO BE TESTED OR VALIDATED IN SONE WAY.
         SPACE 1
MS05CARD DSECT
MS05ID   DS    CL4                 CARD ID ('MS05')
MS05FNO  DS   0CL2                 BATCH CARD FIELD NO (A1-A6 / RC)
MS05TCDE DS    CL2                  OR NUMERIC TEST CODE
MS05PBCT DS    CL2                 POSN OF BATCH CARD TOTAL FIELD
MS05LBCT DS    CL2                 LGTH OF BATCH CARD TOTAL FIELD
MS05NDEC DS    CL1                 NO. OF (IMPLIED) DECIMALS
MS05LNE1 DS    CL16                1ST LINE OF NAME OF TOTAL
MS05LNE2 DS    CL16                2ND LINE OF NAME OF TOTAL
MS05ABID DS    CL1                 ' ' = BATCH TOTAL IS ALGEBRAIC
*                                  '1' = BATCH TOTAL IS BALANCING (-VE)
MS05ERID DS    CL1                 ' ' = HARD ERROR
*                                  '1' = SOFT ERROR
MS05NEGI DS    0CL9                DEFINITION OF -VE INDICATOR
MS05PNEG DS    CL2                 POSN OF -VE INDICATOR
MS05LNEG DS    CL1                 LGTH OF -VE INDICATOR
MS05IDNG DS    CL6                 LITERAL -VE INDICATOR
MS05VALU DS    CL9                 VALUE TO BE BALANCED AGAINST
MS05PIND DS    CL1                 PRINTIND INDICATOR
*                                   ' ' - ALWAYS PRINT TOTALS
*                                   '1' - ONLY PRINT IF DISCREPANCY
         DS    CL16                UNUSED
MS05LGTH EQU   *-MS05CARD          LENGTH OF DSECT
         EJECT
***********************************************************************
*        FORMAT OF MS11 CONTROL CARD                                  *
***********************************************************************
         SPACE 1
*        DESCRIBES FIELDS IN SPECIFIC TYPES OF DETAIN RECORDS
*         WHICH ARE EITHER TO BE BALANCED AGAINST THE BATCH CARD
*         OR TESTED OR VALIDATED IN SOME WAY.
         SPACE 1
MS11CARD DSECT
MS11ID   DS    CL4                 CARD ID ('MS11')
MS11PRTI DS    CL2                 POSN OF RECORD TYPE IDENTIFIER
MS11LRTI DS    CL1                 LGTH OF RECORD TYPE IDENTIFIER
MS11RTI  DS    CL8                 LITERAL RECORD TYPE IDENTIFIER
MS11IGN  DS    CL3                 BLANK OR 'IGN' - DO NOT PROCESS
         DS    CL2                 UNUSED
MS11FLD1 DS    0CL10               1ST DATA FIELD DESCRIPTION
MS11PDC1 DS    CL2                 POSN OF DATA CARD FIELD 1
MS11LDC1 DS    CL2                 LGTH OF DATA CARD FIELD 1
MS11DEC1 DS    CL1                 NDEC OF DATA CARD FIELD 1
MS11NDC1 DS    CL2                 BATCH CARD FIELD NO (A1 - A6)
*                                   OR NUMERIC TEST TYPE OR BLANK
MS11NCR1 DS    CL2                 ASSOC CTRL REC FLD NO (B1 -B6) OR BL
MS11AID1 DS    CL1                 'A' = ACCUMULATE ABSOLUTE VALUES
*                                  'P' - INPUT IS PACKED DECIMAL
MS11FLD2 DS    CL10                AS MS11PDC1 - MS11AID1
MS11FLD3 DS    CL10                AS MS11PDC1 - MS11AID1
MS11FLD4 DS    CL10                AS MS11PDC1 - MS11AID1
MS11FLD5 DS    CL10                AS MS11PDC1 - MS11AID1
MS11FLD6 DS    CL10                AS MS11PDC1 - MS11AID1
MS11LGTH EQU   *-MS11CARD          LENGTH OF DSECT
         EJECT
***********************************************************************
*        FORMAT OF MS12 CONTROL CARD                                  *
***********************************************************************
         SPACE 1
*        DESCRIBES NUMERIC FIELDS IN SPECIFIC TYPES OF DETAIL
*         RECORDS FOR WHICH A NEGATIVE VALUE IS NOT SHOWN BY A
*         '-' OVERPUNCH ON THE JUNIOR DIGIT, BUT BY THE CONTENTS
*         OF A SEPARATE FIELD.  IF THE MERE PRESENCE OF A FIELD
*         IMPLIES THAT IT IS NEGATIVE, THEN FIELD 'MS12IDNG'
*         SHOULD CONTAIN 'NONZERO'.
*        THIS CARD DESCRIPTION IS AN OVERLAY OF THE MS11 DSECT
*         BECAUSE THEY ARE PROCESSED BY COMMON INITIALISATION
*         CODING, AND ADDRESSABILITY OF BOTH CARDS AT ONCE
*         IS REQUIRED.
         SPACE 1
*        NOTE THAT THE MS12 CARD USED BY THE ORIGINAL PL/1 BUDGIE3
*         WAS OF A DIFFERENT FORMAT, AND CONSEQUENTLY THE TWO ARE NOT
*         100% COMPATIBLE.  ( THE DIFFERENCES ARE NECESSITATED BY THE
*         LOGIC OF THE CONTROL BLOCK CREATION ROUTINES ).
         SPACE 1
         ORG   MS11ID              DEFINE OVERLAYING DSECTS
MS12ID   DS    CL4                 CARD ID ('MS12')
MS12PRTI DS    CL2                 POSN OF RECORD TYPE IDENTIFIER
MS12LRTI DS    CL1                 LGTH OF RECORD TYPE IDENTIFIER
MS12RTI  DS    CL8                 LITERAL RECORD TYPE IDENTIFIER
MS12IGN  DS    CL3                 BLANK OR 2IGN' - DO NOT PROCESS
         DS    CL2                 UNUSED
MS12FLD1 DS    0CL20               1ST DATA FIELD DESCRIPTION
MS12PDC1 DS    CL2                 POSN OF DETAIL FIELD
MS12LDC1 DS    CL2                 LGTH OF DETAIL FIELD
MS12DEC1 DS    CL1                 NDEC OF DETAIL FIELD
MS12NDC1 DS    CL2                 BATCH CARD FIELD NO ( A1 - A6 ) OR
*                                   NUMERIC TEST TYPE OR BLANK
MS12NCR1 DS    CL2                 ASSOC CTRL REC FLD NO (B1-B6) OR BL
MS12AID1 DS    CL1                 PACK INDICATOR
*                                   'P' - INPUT IS PACKED DECIMAL
*                                   ' ' - INPUT IS DISPLAY NUMERIC
MS12PNEG DS    CL2                 POSN OF -VE INDICATOR ID
MS12LNEG DS    CL1                 LGTH OF -VE INDICATOR ID
MS12NGID DS    CL7                 LITERAL -VE INDICATOR ID
MS12FLD2 DS    CL20                AS MS12PDC1 - MS12IDNG
MS12FLD3 DS    CL20                AS MS12PDC1 - MS12IDNG
MS12LGTH EQU   *-MS11CARD          LENGTH OF DSECT
         EJECT
***********************************************************************
*        FORMAT OF MS13 CONTROL CARD                                  *
***********************************************************************
         SPACE 1
*        APPLIES TO THE RECORD TYPE SPECIFIED BY THE PRECEDING
*         MS11 OR MS12 CARD.  IT DESCRIBES A SINGLE FIELD THAT
*         IS TO BE TESTED IN SOME WAY.  OPTIONALLY, THE TEST
*         MAY BE RESTRICTED TO RECORDS WITH SPECIFIC VALUES
*         IN UP TO THREE SEPARATE FIELDS.
*        IF THERE IS NO PRECEDING MS11 OR MS12 CARD, THEN IT APPLIES
*         TO THE PRECEDING MS02 CONTROL CARD, AND DESCRIBES A FIELD
*         IN THE BATCH CARD THAT IS TO BE TESTED.
         SPACE 1
MS13CARD DSECT
MS13ID   DS    CL4                 CARD ID ('MS13')
MS13PRT1 DS    CL3                 POSN OF FIELD COMPARAND 1
MS13LRT1 DS    CL1                 LGTH OF FIELD COMPARAND 1
MS13PRT2 DS    CL3                 POSN OF FIELD COMPARAND 2
MS13LRT2 DS    CL1                 LGTH OF FIELD COMPARAND 2
MS13PRT3 DS    CL3                 POSN OF FIELD COMPARAND 3
MS13LRT3 DS    CL1                 LGTH OF FIELD COMPARAND 3
         ORG   MS13PRT1            REDEFINE OVER MULTI-UE FIELD
MS13IND0 DS    0CL4                IST INDICATOR DEFINITION
MS13IND  DS    CL2                 NUMBER OF INDICATOR TO BE TESTED
MS13ONOF DS    CL2                 DESIRED INDICATOR STATUS ( ON / OF )
MS13IND1 DS    CL4                 AS MS13IND - MS13ONOF
MS13IND2 DS    CL4                 AS MS13IND - MS13ONOF
MS13LTYP DS    CL2                 COMPARISON TYPE
*                                   '  ' - EQUAL
*                                   'EQ' - EQUAL
*                                   'NE' - NOT EQUAL
*                                   ETC
MS13LIT  DS    CL18                COMPOSITE LITERAL OF COMPARANDS
MS13PFLD DS    CL3                 POSN OF FIRLD TO BE TESTED
MS13LFLD DS    CL2                 LGTH OF FIELD TO BE TESTED
MS13TEST DS    0CL2                TEST TYPE
MS13TST1 DS    CL1                 1ST POSN OF TEST TYPE
MS13TST2 DS    CL1                 2ND POSN OF TEST TYPE
MS13ERRI DS    CL1                 RESULT INDICATOR - ' ' = HARD ARROR
*                                                     '1' = SOFT ARROR
*                                                     '2' = DELETE REC
*                                                     '3' - SET IND ONY
MS13CONT DS    CL1                 CONTINUATION INDICATOR
*                                   ' ' - CONTINUE PROCESSING THIS CARD
*                                   '1' - TERMINATE IF THIS TEST FAILS
*                                   '2' - TERMINATE IF TEEST SUCCEDDS
*                                   '3' - TERMINATE REGARDLESS
MS13MSXX DS    CL2                 ID OS ASSOC. MS2X/3X IF RELEVANT
MS13RIND DS    CL2                 RSSULT INDICATOR
MS13TMOD DS    CL1                 TEST MODIFIER ( BL, 'B', '*', 'T' )
MS13MESS DS    CL30                OPTIONAL ERROR MESSAGE
MS13LGTH EQU   *-MS13CARD          LENGTH OF DSECT
         EJECT
***********************************************************************
*        FORMAT OF MS14 CONTROL CARD                                  *
***********************************************************************
         SPACE 1
*        DESCRIBES A SERIES OF INDICATOR TESTS WHICH, IF NOT SATISFIED,
*         WILL CAUSE EITHER THE OVERALL BATCH OR AN INDIVIDUAL RECORD
*         TO BE FLAGGED WITH AN ERROR.
*        THE TESTS APPLY EITHER TO THE PRECEDING MS02 CARD ( WHEN IT
*         APPLIES TO THE WHHOLE BATCH ) OR TO THE PRECEDING MS11/12
*         CARD ( WHEN IT APPLIES TO A SINGLE RECORD ), WHICHEVER WAS
*         THE MOST RECENT.
*        NOTE THAT IF ALL THE RELATIONSHIPS SPECIFIED IN THIS CARD ARE
*         SATISFIED, THEN THE RECORD HAS FAILED THE COMPOSITE TEST, AND
*         IS IN ERROR.
         SPACE 1
MS14CARD DSECT
MS14ID   DS    CL4                 CARD ID ('MS14')
MS14ERRI DS    CL1                 RESULT INDICATOR
*                                   ' ' - HARD ERROR
*                                   '1' - SOFT ERROR
*                                   '2' - DELETE RECORD ('D' ONLY )
*                                   '3' - SET INDICATOR ONLY
MS14RIND DS    CL2                 RESULT INDICATOR
MS14TST0 DS    0CL4                DEFINE 1ST INDICATOR TEST
MS14IND  DS    CL2                 INDICATOR TO BE TESTED
MS14ONOF DS    CL2                 REQUIRED IND STATUS ( ON / OF )
MS14TST1 DS    CL4                 AS MS14IND - MS14ONOF
MS14TST2 DS    CL4                 AS MS14IND - MS14ONOF
MS14TST3 DS    CL4                 AS MS14IND - MS14ONOF
MS14TST4 DS    CL4                 AS MS14IND - MS14ONOF
MS14TST5 DS    CL4                 AS MS14IND - MS14ONOF
MS14TST6 DS    CL4                 AS MS14IND - MS14ONOF
MS14TST7 DS    CL4                 AS MS14IND - MS14ONOF
MS14TST8 DS    CL4                 AS MS14IND - MS14ONOF
MS14PFLD DS    CL2                 POSN OF FIELD TO BE UNDERLINED (OPT)
MS14LFLD DS    CL2                 LGTH OF FIELD TO BE UNDERLINED (OPT)
MS14BORD DS    CL1                 LEVEL INDICATOR:
*                                   'B' - APPLIES TO TOTAL BATCH
*                                   'D' - APPLIES TO SINGLE RECORD
*                                   ' ' - APPLIES TO SINGLE RECORD
*                                   'C' - BATCH LEVEL, BUT IN MS13 SEQ
         DS    CL2                 UNUSED
MS14MESS DS    CL30                OPTIONAL ERROR MESSAGE
MS14LGTH EQU   *-MS14CARD          LENGTH OF SDECT
BUDGIE3  CSECT
         EJECT
***********************************************************************
*        FORMAT OF MS15 CONTROL CARD                                  *
***********************************************************************
         SPACE 1
*        DESCRIBES A SINGLE FIELD IN A DETAIL RECORD AGAINST WHICH
*         OTHER FIELDS IN THE SAME RECORD ARE TO BE BALANCED.
         SPACE 1
MS15CARD DSECT
MS15ID   DS    CL4                 CARD ID ('MS15')
MS15FNO  DS    CL2                 FIELD NAME ( LABEL )
MS15POS  DS    CL3                 POSN OF FIELD IN INPUT
MS15LEN  DS    CL2                 LGTH OF FIELD IN INPUT
MS15NDEC DS    CL1                 NO OF IMPILED DECIMALS
MS15ABID DS    CL1                 TOTALLING TYPE :-
*                                   ' ' - ALGEBRAIC
*                                   '1' - BALANCING
MS15ERRI DS    CL1                 ERROR INDICATOR :-
*                                   ' ' - HARD ERROR
*                                   '1' - SOFT ERROR
*                                   '2' - DELETE RECORD IN ERROR
*                                   '3' - SET INDICATOR ONLY
MS15NEGI DS    0CL11               DEFINITION OF -VE INDICATOR
MS15PNEG DS    CL3                 POSN OF NEGATIVE INDICATOR
MS15LNEG DS    CL1                 LGTH OF NEGATIVE INDICATOR
MS15IDNG DS    CL7                 LITERAL NEGATIVE INDICATOR
MS15RIND DS    CL2                 RESULT INDICATOR
MS15PACK DS    CL1                 PACK FLAG
*                                   'P' - INPUT IS PACKED DECIMAL
*                                   ' ' - INPUT ISDISPLAY NUMERIC
MS15ABS  DS    CL1                 ABSOLUTE INDICATOR
*                                   'A' - MODULUS TOTAL
*                                   ' ' - ALGEBRAIC TOTAL
         DS    CL21                UNUSED
MS15MESS DS    CL30                OPTIONAL ERROR MESSAGE
MS15LGTH EQU   *-MS15CARD          LENGTH OF DSECT
BUDGIE3  CSECT
         EJECT
***********************************************************************
*        FORMAT OF MS16 CONTROL CARD                                  *
***********************************************************************
         SPACE 1
*        DESCRIBES FIELDS WHICH ARE TO BE BALANCED AGAINST ANOTHER
*         FIELD IN THE SAME CARD DEFINED BY AN MS15 CAONTROL CARD.
         SPACE 1
MS16CARD DSECT
MS16ID   DS    CL4                 CARD ID ('MS16')
MS16FNO  DS    CL2                 NAME OF ASSOC CONTROL FIELD (
MS16FLD0 DS    0CL17               DEFINITION OF 1ST FIELD
MS16POS  DS    CL3                 POSN OF FIELD IN INPUT
MS16LEN  DS    CL2                 LGTH OF FIELD IN INPUT
MS16NDEC DS    CL1                 NO OF ( IMPLIED ) DECIMALS
MS16PNEG DS    CL3                 POSN OF NEGATINE INDICATOR
MS16LNEG DS    CL1                 LGTH OF NEGATINE INDICATOR
MS16IDNG DS    CL7                 LITERAL NEGATINE INDICATOR
         ORG   *-2                 RESET COUNTER FOR REDEFINITION
MS16PACK DS    CL1                 PACK FLAG
*                                   'P' - INPUT IS PACKED DECIMAL
*                                   ' ' - INPUT IS DISPLAY NUMERIC
MS16ABS  DS    CL1                 ABSOLUTE INDICATOR
*                                   'A' - MODULUS TOTAL REQUIRED
*                                   ' ' - ALGEBRAIC TOTAL RESUIRED
MS16FLD1 DS    CL17                AS MS16POS - MS16IDNG
MS16FLD2 DS    CL17                AS MS16POS - MS16IDNG
MS16FLD3 DS    CL17                AS MS16POS - MS16IDNG
         DS    CL6                 UNUSED
MS16LGTH EQU   *-MS16CARD          LENGTH OF DESECT
BUDGIE3  CSECT
         EJECT
***********************************************************************
*        FORMAT OF MS20 CONTROL CARD                                  *
***********************************************************************
         SPACE 1
*        DESCRIBES THE CONSTRUCTION OF AN ISAM OR RIGAM KEY
*         OR THE KEY TO BE USED WITH AN INTERNAL TABLE
*         USED TO VALIDATE A FIELD AND OPTIONALLY TO EXTRACT
*         DATA FROM THE FILE.
         SPACE 1
MS20CARD DSECT
MS20ID   DS    CL4                 CARD ID ('MS20')
MS20TEST DS    0CL2                TEST IDENTIFIER
MS20TST1 DS    CL1                 1ST CHAR OF TEST IDENTIFIER
MS20TST2 DS    CL1                 2ND CHAR OF TEST IDENTIFIER
MS20DDN  DS    0CL8                DDNAME FOR ISAM FILE
MS20FNO  DS    CL2                 RIGAM FILE NUMBER
MS20FID  DS    CL3                 RIGAM FILE ID
MS20FLEN DS    CL3                 RIGAM RECORD LENGTH
         ORG   MS20FNO             REDEFINE MULTI-USE FIELD
         DS    CL1                 UNUSED FOR 'TANLE' SPECIFICATION
MS20ATNO DS    CL3                 'ALBATROS' TABLE NO/IDENTIFIER
MS20TID  DS    CL1                 TABLE INDICATOR ('T')
MS20TLEN DS    CL3                 LENGTH OF TABLE ELEMENT
         DS    CL2                 UNUSED
MS20FLD1 DS    0CL8                1ST KEY COMPONENT DESCRIPTION
MS20LITI DS    CL1                 IF 'L' THEN LEFT ALIGNED LITEREL
*                                  IF 'S' THEN DERIVE KEY COMPONENT
*                                   FROM CB13 AT EXECUTION TIME
MS20LITL DS    CL1                 LENGTH OF LITERAL ( MAX = 6 )
*                                   OR LENGTH OF KEY FROM CB13
MS20LIT  DS    CL6                 LEFT ALIGNED LITERAL
         ORG   MS20FLD1            REDEFINE OVER MULTI-USE FIELD
MS20POSN DS    CL3                 POSN OF KEY COMPONENT IN SOURCE
MS20LGT  DS    CL2                 LGTH OF KEY COMPONENT IN SOURCE
MS20DORB DS    CL1                 SOURCE: D=DETAIL, B=BATCH CARD
         DS    CL2                 UNUSED
MS20FLD2 DS    CL8                 AS MS20LITI - MS20DORB
MS20FLD3 DS    CL8                 AS MS20LITI - MS20DORB
MS20FLD4 DS    CL8                 AS MS20LITI - MS20DORB
MS20FLD5 DS    CL8                 AS MS20LITI - MS20DORB
MS20FLD6 DS    CL8                 AS MS20LITI - MS20DORB
MS20FLD7 DS    CL8                 AS MS20LITI - MS20DORB
MS20FLD8 DS    CL8                 AS MS20LITI - MS20DORB
MS20LGTH EQU   *-MS20CARD          LENGTH OF DSECT
BUDGIE3  CSECT
         EJECT
***********************************************************************
*        FORMAT OF MS21 CONTROL CARD                                  *
***********************************************************************
         SPACE 1
*        DESCRIBES THE FIELDS TO BE EXTRACTED FROM THE ISAM OR RIGAM
*         FILE DEFINED IN THE PRECEDING MS20 CARD, AND DESCRIBES WHERE
*         TO PLACE THEM IN THE RECORD.
*        IN THE ABSENCE OF AN MS21 CARD, THEN THE MS20 CARDD DEFAULTS
*         TO FIELD VALIDATION BY TABLE LOOKUP
         SPACE 1
MS21CARD DSECT
MS21ID   DS    CL4                 CARD ID ('MS21')
MS21FLD1 DS    0CL9                DSECRIPTION OF 1ST FIEED
MS21SPOS DS    CL3                 POSN OF FIELD IN SOURCE FILE
MS21SLEN DS    CL2                 LGTH OF FIELD IN SOURCE FILE
MS21DPOS DS    CL3                 POSN OF FIELD IN OUTPUT RECORD
MS21PIND DS    CL1                 PROCESSING INDICATOR:-
*                                      ' ' - DIRECT MOCE
*                                      'P' - IN UNPACKED, OUT PACKED
*                                      'U' - IN PACKED, OUT UNPACKED
MS21ERRI DS    CL1                 ACTION IF RECORD NOT FOUND
*                                   ' ' - DO NOTHING
*                                   '1' - PAD DERIVED FIELDS
*                                   '2' - PUT LITERAL IN DERIVED FLDS
MS21PADC DS    0CL1                PAS CHARACTER FOR 1 ABOVE
MS21LIT  DS    CL20                LITERAL TO USE IF NO KEY MATCH
MS21FLD2 DS    CL30                AS MS21SPOS - MS21LIT
         DS    CL16                UNUSED
MS21LGTH EQU   *-MS21CARD          LENGTH OF DSECT
BUDGIE3  CSECT
         EJECT
***********************************************************************
*        FORMAT OF MS30 CONTROL CARD                                  *
***********************************************************************
         SPACE 1
*        DESCRIBES THE RANGES FORR A TEST SPECIFIED IN AN MS13 CARD,
*         OR CONTAINS THE LITERAL AGAINST WHICH TO TEST
         SPACE 1
MS30CARD DSECT
MS30ID   DS    CL4                 CARD ID ('MS30')
MS30TID  DS    CL2                 TEST IDENTIFIER ( LABEL )
MS30RID  DS    CL1                 RANGE TYPE :-
*                                   ' ' - CHARACTER (LEFT-ADJUSTED)
*                                   'N' - NUMERIC (RIGHT-ADJUSTED)
MS30TYPE DS    CL1                 COMPARISON TYPE :-
*                                   ' ' - R1 <= FLD <= R2
*                                   'X' R1 < R2 & FLD < R1 | R2 < FLD
MS30RNG1 DS    CL16                RANGE 1 ( START )
MS30RNG2 DS    CL16                RANGE I ( END )
         DS    CL40                UNUSED
MS30LGTH EQU   *-MS30CARD          LENGTH OF DSECT
BUDGIE3  CSECT
         EJECT
***********************************************************************
*        FORMAT OF MS31 CONTROL CARD                                  *
***********************************************************************
         SPACE 1
*        DESCRIBES THE TYPE OF MODULUS CHECKING TO BE PERFORMED FOR A
*         TEST SPECIFIED IN AN MS13 CONTROL CARD
         SPACE 1
MS31CARD DSECT
MS31ID   DS    CL4                 CARD ID ('MS31')
MS31MID  DS    CL2                 MODULUS ID (SPECIFIED IN MS13 CARD)
MS31MTYP DS    CL2                 MODULUS CHECK TYPE ('11' OR '13' ETC
MS31POS1 DS    CL3                 POSN OF NUMERIC FLD FROM WHICH TO CA
MS31LEN1 DS    CL2                 LGTH OF NUMERIC FLD FROM WHICH TO CA
MS31POS2 DS    CL3                 POSN OF MODULUS CHAECK DIGIT
MS31LEN2 DS    CL2                 LGTH OF MODULUS CHAECK DIGIT
MS31LIST DS    CL62                LEFT-ADJUSTED TABLE OF CHECK DIGITS
MS31LGTH EQU   *-MS31CARD          LENGTH OF DSECT
BUDGIE3  CSECT
         EJECT
***********************************************************************
*        FORMAT OF MS32 CONTROL CARD                                  *
***********************************************************************
         SPACE 1
*        DESCRIBES THE DETAILS OF CURRENCY CONVERSION OR CURRENCY
*         RATE EXTRACTION FOR TESTS SPECIFIED IN MMS13 CONTROL CARDS
*         THE AMOUNT FIELD IS SPECIFIED BY THE MS13 CARD
         SPACE 1
MS32CARD DSECT
MS32ID   DS    CL4                 CARD ID ('MS32')
MS32TID  DS    CL2                 TEST ID ( LABEL )
MS32ICP  DS    0CL3                POSN OF INPUT CODE
MS32ICLF DS    CL1                 'L' - INPUT CODE IS FOLLOWING LITERL
*                                  'S' - TAKE INPUT CODE FROM MS13
MS32ICL  DS    CL2                 LITERAL INPUT CODE
MS32OCP  DS    0CL3                POSN OF OUTPUT CURRENCY CODE
MS32OCLF DS    CL1                 'L' - OUTPUT CODE IS FOLLOWING LITRL
*                                  'S' - TAKE OUTPUT CODE FROM MS13
MS32OCL  DS    CL2                 LITERAL OUTPUT CURRENCY CODE
MS32INP  DS    CL3                 POSN OF INPUT VALUE
*                                  'S  ' - TAKE INPUT VALUE FROM MS13
MS32INL  DS    CL2                 LGTH OF INPUT VALUE
MS32INT  DS    CL1                 INPUT FORMAT
*                                   ' ' - DISPLAY FORMAT
*                                   'P' - PACKED DECIMAL
MS32OUTP DS    CL3                 POSN OF OUTPUT FIELD IN RECORD
*                                   'S  ' - TAKE PPPLL FROM MS13
MS32OUTL DS    CL2                 LGTH OF OUTPUT FIELD IN RECORD
MS32OUTT DS    CL1                 OUTPUT FIELD TYPE
*                                   ' '- DISPLAY FIELD
*                                   'P' - PACKED DECIMAL
         DS    CL1                 UNUSED
MS32RTEP DS    CL3                 POSN OF RATE IN RECORD
MS32RTEL DS    CL2                 LGTH OF RATE IN RECORD
MS32RTET DS    CL1                 FORMAT OF OUTPUT CURR CONV RATE
*                                   ' ' - DISPLAY
*                                   'P' - PACKED DECIMAL
*                                  BASIC FIELD IS 9(5)V9(5).  IF LGTH
MS32NMIP DS    CL3                 POSN OF CURR NAME FOR INPUT CODE
MS32NMOP DS    CL3                 POSN OF CURR NAME FOR OUTPUT CODE
*                                  ( CURR CODE NAMES ARE 4 BYTES LONG )
MS32VNOP DS    CL3                 POSN OF CURR TABLE VERSION NUMBER
MS32ERRI DS    CL1                 ERROR INDICATOR
*                                   ' '- DO NOTHING
*                                   '1' - ZEROISE RECEIVING FIELD
MS32RNDN DS    CL1                 NO OF DIGITS TO ZEROISE IN ROUNDING
MS32RNDF DS    CL1                 ROUNDING TYPE
*                                   'A' - ALWAYS ROUND
*                                   'C' - PERFOORM COMMERCIAL ROUNDING
         DS    CL37                UNUSED
MS32LGTH EQU   *-MS32CARD          LENGTH OF DSECT
BUDGIE3  CSECT
         EJECT
***********************************************************************
*        FORMAT OF MS33 CONTROL CARD                                  *
***********************************************************************
         SPACE 1
*        ESCRIBES TWO FIELDS IN AN INPUT RECORD THAT ARE TO BE COMPARD
*         WITH EACH OTHER OR MOVED ONE TO THE OTHER.
         SPACE 1
MS33CARD DSECT
MS33ID   DS    CL4                 CARD ID ('MS33')
MS33TID  DS    CL2                 TEST ID ( LABEL ) SPECIIED IN MS13
MS33POS1 DS    CL3                 POSN OF FIRST ('FROM') FIELD
*                                   OR 'LIT' IN WHICH CASE THE 'FROM'
*                                   FIELD OR COMPARAND IS TAKEN FROM
*                                   THIS CONTROL CARD.
MS33LEN1 DS    CL2                 LGTH OF FIRST ('FROM') FIELD
MS33TYPE DS    CL2                 OPERATION TYPE ( COMPARISON OR MOVE)
*                                   'MV' - DIRECT MOVE
*                                   'MP' MOVE: IN UNPACKED, OUT PACKED
*                                   'MU' - MOVE: IN PACKED, OUTVUNPACKD
*                                   'EQ' - 1ST FLD EQUAL TO 2ND
*                                   'NE' - 1ST FLD NOT EQ TO 2ND
*                                   ETC
MS33POS2 DS    CL3                 POSN OF 2ND FIELD ( TO FIRLD
MS33LEN2 DS    CL2                 LGTH OF 2ND FIELD ( TO FIRLD
MS33CTYP DS    CL1                 COMPARE TYPE ( EQ, ETC. ONLY )
*                                   ' ' - CHARACTER COMPARE
*                                   'N' - NUMERIC COMPARE: FLDS ARE EBC
*                                   'P' - NUMERIC COMPARE: FLDS PACKED
MS33LIT  DS    CL61                LITERAL TO BE MOVED OR COMPARED WITH
MS33LGTH EQU   *-MS33CARD          LENGTH OF DSECT
BUDGIE3  CSECT
         EJECT
***********************************************************************
*        FORMAT OF MS34 CONTROL CARD                                  *
***********************************************************************
         SPACE 1
*        CONTAINS A LIST OF VALID VALUES FOR A FIELD DEFINED IN AN
*         MS13 CONTROL CAD.
         SPACE 1
MS34CARD DSECT
MS34ID   DS    CL4                 CARD ID ('MS34')
MS34TID  DS    CL2                 TEST ID ( LABEL ) SPECIFIED IN MS13
MS34NLST DS    CL3                 NUMBER OF ENTRIES IN THE LIST
MS34LLST DS    CL1                 LENGTH OF EACH ENTRY
MS34LIST DS    CL70                LEFT-ADJUSTED CONCATENATED LIST
MS34LGTH EQU   *-MS34CARD          LENGTH OF DSECT
BUDGIE3  CSECT
         EJECT
***********************************************************************
*        FORMAT OF MS35 CONTROL CARD                                  *
***********************************************************************
         SPACE 1
*        DEFINES DATE CONVERSION, EXTRACTION AND MANIPULATION
         SPACE 1
MS35CARD DSECT
MS35ID   DS    CL4                 CARD ID ('MS35')
MS35TID  DS    CL2                 TEST ID ( LABEL )
MS35POS1 DS    CL3                 POSN OF INPUT FIELD
MS35TYP1 DS    CL1                 TYPE OF INPUT FIELD ( 1-6 : UT458 )
MS35POS2 DS    CL3                 POSN O OUTPUT FIELD
MS35TYP2 DS    CL1                 TYPE OF OUTPUT FIELD ( 0-6 )
MS35IPL  DS    CL3                 POSN OF OPTIONAL IPL DATE
MS35IPLT DS    CL1                 FORMAT OF IPL DATE ( 0-6 )
*
*        NOTE THAT ALL THE FOLLOWING FIELDS HAVE A DEFAULT LENGTH
*         OF '9', EXCEPT MS35TIME WHICH IS '6'.
*
MS35REP  DS    CL4                 PPPL OF OPTIONAL REPORT-FORMAT DATE
MS35LMTH DS    CL4                 PPPL OF OPTIONAL NAME OF LAST MONTH
MS35TMTH DS    CL4                 PPPL OF OPTIOBAL NAME OF THIS MONTH
MS35NMTH DS    CL4                 PPPL OF OPTIONAL NAME OF NEXT MONTH
MS35DAYN DS    CL4                 PPPL OF OPTIONAL NAME OF DAY OF WEEK
MS35TIME DS    CL4                 PPPL OF OPTIONAL TIME (HHMMSS)
MS35LANG DS    CL1                 LANGUAGE REQUIRED
*                                   ' ' - ENGLISH
*                                   'E' - ENGLISH
*                                   'G' - GERMAN
*                                   'F' - FRENCH
*                                   'D' - FLEMISH
         DS    CL37                UNUSED
MS35LGTH EQU   *-MS35CARD          LENGTH OF DSECT
         EJECT
***********************************************************************
*        FORMAT OF MS36 CONTROL CARD                                  *
***********************************************************************
         SPACE 1
*        DEFINE A MATHEMATICAL OPERATION
         SPACE 1
MS36CARD DSECT
MS36ID   DS    CL4                 CARD ID ('MS36')
MS36TID  DS    CL2                 TEST ID ( LABEL )
MS36OPCD DS    CL1                 OPERATION (+ - / * )
MS36POS1 DS    CL3                 POSN OF 1ST FLD
MS36LEN1 DS    CL2                 LGTH OF 1ST FLD
MS36NDC1 DS    CL1                 NO OF DECIMAL PLACES IN 1ST OPERAND
MS36TYP1 DS    CL1                 TYPE OF 1ST FLD ( 'P' OR ' ' )
MS36POS2 DS    CL3                 POSN F SECOND FLD
*                                   OR 'LIT' IF MS36 CONTAINS LITERAL V
MS36LEN2 DS    CL2                 LGTH F SECOND FLD
MS36NDC2 DS    CL1                 NO OF DECIMAL PLACES IN 2ND OPERAND
MS36TYP2 DS    CL1                 TYPE F SECOND FLD ( 'P' OR ' ' )
MS36POS3 DS    CL3                 POSN OF RESULT FLD
MS36LEN3 DS    CL2                 LGTH OF RESULT FLD
MS36NDC3 DS    CL1                 NO OF DECIMAL PLACES IN RESULT FLD
MS36TYP3 DS    CL1                 TYPE OF RESULT FLD ( 'P' OR ' ' )
MS36RNDN DS    CL1                 NO OF DIGITD TO BE ROUNDED
*                                   OR 'N' - SUPPRESS ALL ROUNDING
MS36LIT  DS    CL16                RIGHT JUSTIFIED NUMERIC LITERAL (OP2
MS36POS4 DS    CL3                 POSN OF REMAINDER
MS36LEN4 DS    CL2                 LGTH OF REMAINDER
MS36NDC4 DS    CL1                 NO OF DECIMAL PLACES IN REMAINDER
MS36TYP4 DS    CL1                 TYPE OF REMAINDER ( 'P' OR ' ' )
         DS    CL28                UNUSED
MS36LGTH EQU   *-MS36CARD          LENGTH OF DSECT
         EJECT
***********************************************************************
*        FORMAT OF MS37 CONTROL CRD                                   *
***********************************************************************
         SPACE 1
*        DEFINE A MOVE FROM A FLOATING TO A FIXED DECIMAL FIELD
         SPACE 1
MS37CARD DSECT
MS37ID   DS    CL4                 CARD ID ('MS37')
MS37TID  DS    CL2                 TEST ID ( LABEL )
MS37POS1 DS    CL3                 POSN OF INPUT FIELD
MS37LEN1 DS    CL2                 LGTH OF INPUT FIELD
MS37DEC1 DS CL1                    DEFAULT DECIMAL ALIGNMENT (IF NO 9)
MS37POS2 DS    CL3                 POSN OF OUTPUT FIELD
MS37LEN2 DS    CL2                 LGTH OF OUTPUT FIELD
MS37DEC2 DS    CL1                 NO OF DECIMAL PLACES IN OUTPUT
MS37PACK DS    CL1                 OUTPUT PACK FLAG ('P' OR ' ')
         DS    CL61                UNUSED
MS37LGTH EQU   *-MS37CARD          LENGTH OF DSECT
BUDGIE3  CSECT
         EJECT
***********************************************************************
*        FORMAT OF MS38 CONTROL CARD                                  *
***********************************************************************
         SPACE 1
*        TRANSFORM ONE FIELD AGAINST ANOTHER
         SPACE 1
MS38CARD DSECT
MS38ID   DS    CL4                 CARD ID ('MS38')
MS38TID  DS    CL2                 TEST ID ( LABEL )
MS38POS1 DS    CL3                 POSN OF SOURCE FIELD
*                                   OR 'S  ' TO DERIVE FROM MS13 CARD
MS38LEN1 DS    CL2                 LGTH OF SOURCE FIELD
MS38POS2 DS    CL3                 POSN OF RECEIVINF FIELD
*                                   OR 'S  ' TO DERIVE FROM MS13
MS38TYPE DS    CL1                 TYPE OF TRANSFORMATION
*                                   'C' - COLUMN BY COLUMN
*                                   'F' - TOTAL FIELD IN ONE OPERATION
*                                   ' ' - TOTAL FIELD IN ONE OPERATION
         DS    CL65                UNUSED
MS38LGTH EQU   *-MS38CARD          LENGTH OF DSECT
         EJECT
***********************************************************************
*        FPRMAT OF MS40 CONTROL CARD                                  *
***********************************************************************
         SPACE 1
*        INDICATES THE START OF A SUB-ROUTINE COMPOSED OF MS11,12,13,14
*         CARDS THAT MAY BE INVOKED BY AN MS13 CARD.
*        THIS IS TO AVOID UNNECESSARY DUPLICATION OF CONTROL  CARDS
*         WHERE SOME TESTS AND FUNCTIONS ARE COMMON TO DIFFERENT
*         CARD TYPES.
         SPACE 1
MS40CARD DSECT
MS40ID   DS    CL4                 CARD ID ('MS40')
MS40RID  DS    CL2                 SUBROUTINE NAME ( LABEL )
         DS    CL74                UNUSED
MS40LGTH EQU   *-MS40CARD          LENGTH OF DSECT
BUDGIE3  CSECT
         EJECT
***********************************************************************
*        FORMAT OF MS41 CONTROL CARD                                  *
***********************************************************************
         SPACE 1
*        INDICATES THE END OF A 'SUB-ROUTINE'
         SPACE 1
MS41CARD DSECT
MS41ID   DS    CL4                 CARD ID ('MS41')
MS41RID  DS    CL2                 SUBROUTINE NAME ( LABEL )
         DS    CL74                UNUSED
MS41LGTH EQU   *-MS41CARD          LRNGTH OF DSECT
BUDGIE3  CSECT
         TITLE 'DSECTS FOR CONTROL BLOCKS'
***********************************************************************
*        FORMAT OF MS02 CONTROL BLOCK                                 *
***********************************************************************
         SPACE 1
CB02NTRY DSECT                     BATCH CARD CHAIN ELEMENT
CB02FLAG DS    0CL1                CONTROL BLOCK FLAG
CB02CB02 DS    F                   ADDRESS OF NEXT CB02 ENTRY
CB02CB11 DS    F                   ADDRESS OF 1ST ASSOC MS11 ENTRY
CB02CB03 DS    F                   ADDRESS OF ASSOC CB03 ENTRY
CB02CB05 DS    F                   ADDRESS OF FIRST CB05 ENTRY
CB02CB13 DS    F                   ADDRESS OF 1ST ASSOC CB13 ENTRY
CB02CB14 DS    F                   ADDRESS OF 1ST ASSOC CB14 ENTRY
CB02ARTN DS    F                   ADDRESS OF USER ROUTINE ENTRY POINT
CB02CCNO DS    PL2                 CONTROL CARD SEQUENCE NUMBBER
CB02BCI  DS    CL8                 LITERAL BATCH CARD IDENTIFIER
CB02URTN DS    CL8                 NAME OF USER SUBROUTINE
CB02CNT  DS    PL4                 COUNT OF RECORDS OF THIS TYPE
CB02HCNT DS    PL3                 COUNT OF HARD ERRORS IN BATCH
CB02SCNT DS    PL3                 COUNT OF SOFT ERRORS IN BATCH
CB02RCNT DS    PL3                 RECORD COUNT ( CURRENT BATCH )
CB02CNTR DS    PL3                 RECORD COUNT FROM BATCH CARD
CB02LCNT DS    PL4                 CARD NO WITHIN BATCH ( FOR SUSPENSE
CB02RETC DS    PL3                 NO OD CARDS RETAINED
CB02CNTP DS    CL1                 POSN OF RECORD COUNT IN BATCH CARD
CB02CNTL DS    CL1                 LGTH OF RECORD COUNT IN BATCH CARD
CB02PBCI DS    CL1                 POSN OF BATCH CARD IDENTIFIER
CB02LBCI DS    CL1                 LGTH OF BATCH CARD IDENTIFIER
CB02PBN1 DS    CL1                 POSN OF 1ST SEGMENT OF BATCH NO
CB02LBN1 DS    CL1                 LGTH OF 1ST SEGMENT OF BATCH NO
CB02PBN2 DS    CL1                 POSN OF 2ND SEGMENT OF BATCH NO
CB02LBN2 DS    CL1                 LGTH OF 2ND SEGMENT OF BATCH NO
CB02PBN3 DS    CL1                 POSN OF 3RD SEGMENT OF BATCH NO
CB02LBN3 DS    CL1                 LGTH OF 3RD SEGMENT OF BATCH NO
CB02PBN4 DS    CL1                 POSN OF 4TH SEGMENT OF BATCH NO
CB02LBN4 DS    CL1                 LGTH OF 4TH SEGMENT OF BATCH NO
CB02PBN5 DS    CL1                 POSN OF 5TH SEGMENT OF BATCH NO
CB02LBN5 DS    CL1                 LGTH OF 5TH SEGMENT OF BATCH NO
CB02PCRN DS    CL1                 POSN OF CORRECTION DATA REC NO.
CB02LCRN DS    CL1                 LGTH OF CORRECTION DATA REC NO.
CB02PID1 DS    CL1                 POSN OF 1ST SEGMENT OF SUBMITTOR ID
CB02LID1 DS    CL1                 LGTH OF 1ST SEGMENT OF SUBMITTOR ID
CB02PID2 DS    CL1                 POSN OF 2ND SEGMENT OF SUBMITTOR ID
CB02LID2 DS    CL1                 LGTH OF 2ND SEGMENT OF SUBMITTOR ID
CB02PID3 DS    CL1                 POSN OF 3RD SEGMENT OF SUBMITTOR ID
CB02LID3 DS    CL1                 LGTH OF 3RD SEGMENT OF SUBMITTOR ID
CB02SW   DS    CL1                 SWITCH BYTE
CB02SW2  DS    CL1                 2ND SWITCH BYTE
CB02INDB DS    CL13                104 INDICATORS AT BATCH LEVEL
CB02INDD DS    CL13                104 INDICATORS AT DETAIL LEVEL
CB02LGTH EQU   *-CB02NTRY          LENGTH OF CONTROL BLOCK
BUDGIE3  CSECT
         EJECT
***********************************************************************
*        FORMAT OF MS02 CONTROL BLOCK ( CONT'D )                      *
***********************************************************************
         SPACE 1
SW02WDC  EQU   1                   WRITE DETAIL CARDS
SW02WBC  EQU   2                   WRITE BATCH CARD
SW02WCR  EQU   4                   WRITE CONTROL RECORD
SW02URTN EQU   8                   CALL USER PROGRAM
SW02DROP EQU   16                  DROP UNKNOWN CARD TYPES
SW02IRTN EQU   32                  USER PGM HAS BEEN INITIALISED
SW02RCNT EQU   64                  BATCH CARD HES RECORD COUNT
SW02RCSF EQU   128                 RECORD COUNT IS SOFT ERROR
SW02PID  EQU   1                   PUT SUBMITTOR ID IN HEADING LINE
         EJECT
***********************************************************************
*        FORMAT OF MS03 CONTROL BLOCK                                 *
***********************************************************************
         SPACE 1
CB03NTRY DSECT                     CONTROL RECORD CHAIN ELEMENT
CB03FLAG DS    0CL1                CONTROL BLOCK FLAG
CB03CB04 DS    F                   ADDRESS OF 1ST ASSOC CB04 ENTRY
CB03CCNO DS    PL2                 CONTROL CARD SEQUENCE NUMBBER
CB03SW   DS    CL1                 SWITCH BYTE
CB03PCRK DS    CL1                 POSN OF CONTROL RECORD KEY
CB03LCRK DS    CL1                 LGTH OF CONTROL RECORD KEY
CB03CRK  DS    CL70                CONTROL RECORD KEY (VARIANLE LGTH)
CB03LGTH EQU   *-CB03NTRY          LENGTH OF CONTROL BLOCK
BUDGIE3  CSECT
         SPACE 5
***********************************************************************
*        FORMAT OF MS04 CONTROL BLOCK                                 *
***********************************************************************
         SPACE 1
CB04NTRY DSECT                     MS03 CONTROL BLOCK SUB-ELEMENT
CB04FLAG DS    0CL1                CONTROL BLOCK FLAG
CB04CB04 DS    F                   ADDRESS OF NEXT ASSOC CB04
CB04CCNO DS    PL2                 CONTROL CARD SEQUENCE NUMBBER
CB04PSRC DS    CL1                 POSN OF SOURCE FIELD
CB04PCRF DS    CL1                 POSN OF CONTROL RECORD FIELD
CB04LCRF DS    CL1                 LGTH OF CONTROL RECORD FIELD
CB04NDEC DS    PL1                 NO. OF DECIMALS
CB04FNO  DS    CL2                 FIELD NAME CODE
CB04BACC DS    PL8                 FIELD ACCUMULATOR FRO THIS BATCH
CB04SW   DS    CL1                 SWITCH BYTE
CB04LGTH EQU   *-CB04NTRY          LENGTH OF CONTROL BLOCK SUB-ELEMENT
BUDGIE3  CSECT
         SPACE 5
SW03LIST EQU   1                   CONRRLO RECORD TO BE WRITTEN
SW03POSN EQU   2                   ON  - CONTROL RECORD PRECEDES BATCH
*                                  OFF - CONTROL RECORD FOLLOWS BATCH
SW04PACK EQU   1                   CONTROL FIELD IS TO BE PACKED
SW04BNO  EQU   2                   INSERT BATCH NUMBER
SW04SRC  EQU   4                   FIELD IS TO BE RETRIEVD FROM W/S
         EJECT
***********************************************************************
*        FORMAT OF MS05 CONTROL BLOCK                                 *
***********************************************************************
         SPACE 1
CB05NTRY DSECT                     BATCH CARD FIELD CHAIN ELEMENT
CB05FLAG DS    0CL1                CONTROL BLOCK FLAG
CB05CB05 DS    F                   ADDRESS OF NEXT ASSOC CB05 ENTRY
CB05CCNO DS    PL2                 CONTROL CARD SEQUENCE NUMBBER
CB05FNO  DS    CL2                 FIELD NAME OR TEST ID
CB05TID  DS    CL1                 INTERNAL CODE FOR TEST ID
CB05PBCF DS    CL1                 POSN OF BATCH CARD TOTAL FIELD
CB05LBCF DS    CL1                 LGTH OF BATCH CARD TOTAL FIELD
CB05NDEC DS    PL1                 NO. OF (IMPLIED) DECIMALS
CB05SW   DS    CL1                 SWITCH BYTE
CB05BVAL DS    PL8                 FIELD VALUE FROM BATCH CARD
CB05BACC DS    PL8                 FIELD VALUE ACCUMULATED
CB05LVAL DS    PL8                 LITERAL VALUE AGAINST WHICH TO BALNC
CB05NA1  DS    0CL32               HEADING LINES FOR FIELD A1
CB05LNE1 DS    CL16                FIRST LINE OF NAME
CB05LNE2 DS    CL16                SECOND LINE OF NAME
CB05PNEG DS    CL1                 POSN OF -VE IDENTIFIER
CB05LNEG DS    CL1                 LGTH OF -VE IDENTIFIER
CB05IDNG DS    CL6                 LITERAL -VE IDENTIFIER
CB05LGTH EQU   *-CB05NTRY          LENGTH OF CONTROL BLOCK
BUDGIE3  CSECT
         SPACE 5
SW05BAL  EQU   1                   ON=BALANCING / OFF=ALGEBRAIC
SW05SOFT EQU   2                   ON=SOFT      / OFF=HARD
SW05VALU EQU   4                   MS05 CONTAINED BALANCING VALUE
SW05FLD  EQU   8                   FIELD ID
SW05TST  EQU   16                  TEST REQUEST
SW05NGID EQU   32                  SEPARATE NEGATIVE ID PRESENT
SW05NGNZ EQU   64                  NON-ZERO FIELD AUTOMATICCALLY -VE
SW05DPRT EQU   128                 ONLY PRINT TOTAL IF DISCREPANCY
         EJECT
***********************************************************************
*        FORMAT OF MS11 CONTROL BLOCK                                 *
***********************************************************************
         SPACE 1
CB11NTRY DSECT                     DETAIL CARD FIELD CHAIN ELEMENT
CB11FLAG DS    0CL1                CONTROL BLOCK FLAG
CB11CB11 DS    F                   ADDRESS OF NEXT CB11 ELEMENT
CB11SB11 DS    F                   ADDRESS OF 1ST ASSOC SUB-BLOCK
CB11CB13 DS    F                   ADDRESS OF 1ST ASSOC CB13 BLOCK
CB11CB14 DS    F                   ADDRESS OF 1ST ASSOC CB14 B/B
CB11CCNO DS    PL2                 CONTROL CARD SEQUENCE NUMBBER
CB11PRTI DS    CL1                 POSN OF RECORD TYPE IDENTIFIER
CB11LRTI DS    CL1                 LGTH OF RECORD TYPE IDENTIFIER
CB11RTI  DS    CL8                 LITERAL RECORD TYPE IDENTIFIER
CB11CNT  DS    PL4                 COUNT OF RECORDS OF THIS TYPE
CB11SW   DS    CL1                 SWITCH BYTE
CB11LGTH EQU   *-CB11NTRY          LENGTH OF CONTROL BLOCK
BUDGIE3  CSECT
         EJECT
***********************************************************************
*        FORMAT OF MS11 SUB-BLOCK                                     *
***********************************************************************
         SPACE 1
SB11NTRY DSECT                     SUB-BLOCK FOR CB11 DEFINING 1 FIELD
SB11FLAG DS    0CL1                CONTROL BLOCK FLAG
SB11SB11 DS    F                   ADDRESS OF NEXT ASSOC SB11
SB11CB05 DS    F                   ADDRESS OF ASSOC MS05 DETAIL FIELD
SB11CB04 DS    F                   ADDRESS OF ASSOC CB04 BATCH FIELD
SB11CCNO DS    PL2                 CONTROL CARD SEQUENCE NUMBBER
SB11FNO  DS    CL2                 FIELD NAME OR TEST TYPE
SB11CRFN DS    CL2                 FIELD NAME OF C/R FIELD
SB11TID  DS    CL1                 INTERNAL CODE FOR TEST ID
SB11PDC  DS    CL1                 POSN OF DETAIL FIELD
SB11LDC  DS    CL1                 LGTH OF DETAIL FIELD
SB11NDEC DS    PL1                 NO. OF (IMPLIED) DECIMALS
SB11SW   DS    CL1                 SWITCH BYTE
SB11SW2  DS    CL1                 SECOND SWITCH BYTE
SB11LGTH EQU   *-SB11NTRY          LENGTH OF MS11 CONTROL BLOCK
SB12PNEG DS    CL1                 POSN OF -VE INDICATOR IS
SB12LNEG DS    CL1                 LGTH OF -VE INDICATOR IS
SB12NGID DS    CL7                 LITERAL -VE INDICATOR IS
SB12LGTH EQU   *-SB11NTRY          LENGTH OF MS12 CONTROL BLOCK
BUDGIE3  CSECT
         SPACE 4
SW11IGN  EQU   1                   DO NOT PROCESS THIS RECORD TYPE
SW11DMOD EQU   1                   ACCUMULATE ABSOLUTE VALUES
SW11SOFT EQU   2                   ON = SOFT / OFF = HARD
SW11DBCN EQU   4                   B/C FIELD NO SUPPLIED
SW11DCRN EQU   8                   C/R FIELD NO SUPPLIED
SW11DTID EQU   16                  TEST IS REQUESTED
SW11INPD EQU   32                  INPUT FIELD IS PACKED DECIMAL
SW11NGID EQU   64                  -VE INDICATED BY A SEPARATE FIELD
SW11NGNZ EQU   128                 NONZERO FIELD AUTOMATICALLY NEGATIV
SW11COND EQU   1                   ACCUMULATOR CONDITIONAL ON R6-R9 OPC
         EJECT
***********************************************************************
*        FORMAT OF MS13 CONTROL BLOCK                                 *
***********************************************************************
         SPACE 1
CB13NTRY DSECT                     DETAIL CARD TEST SPECIFICATION
CB13FLAG DS    0CL1                CONTROL BLOCK FLAG
CB13CB13 DS    F                   ADDRESS OF NEXT CB13
CB13CBXX DS    F                   POINTER TO ASSOCIATED CB2X0CB3X IF R
CB13CCNO DS    PL2                 CONTROL CARD SEQUENCE NUMBBER
CB13PRT1 DS    CL1                 POSN OF 1ST SEGMENT OF COMPARAND
CB13LRT1 DS    CL1                 LGTH OF 1ST SEGMENT OF COMPARAND
CB13PRT2 DS    CL1                 POSN OF 2ND SEGMENT OF COMPARAND
CB13LRT2 DS    CL1                 LGTH OF 2ND SEGMENT OF COMPARAND
CB13PRT3 DS    CL1                 POSN OF 3RD SEGMENT OF COMPARAND
CB13LRT3 DS    CL1                 LGTH OF 3RD SEGMENT OF COMPARAND
CB13LTYP DS    CL1                 INTERNAL REPRESENTATION OF LIT TEST
CB13LIT  DS    CL18                LITERAL COMPARAND ( CONCATENATED )
CB13IND0 DS    0CL2                IST INDICATOT DEFINITION
CB13IND  DS    CL1                 INDICATOR NUMBER TO BE TESTED
CB13ONOF DS    CL1                 INTERNAL REP OF DESIRED INDICATOR ST
CB13IND1 DS    CL2                 AS CB13IND - CB13ONOF
CB13IND2 DS    CL2                 AS CB13IND - CB13ONOF
CB13PFLD DS    CL1                 POSN OF FIELD TO BE TESTED
CB13LFLD DS    CL1                 LGTH OF FIELD TO BE TESTED
CB13TEST DS    CL1                 TEST TYPE ( INTERNAL REPRESENTATION)
CB13TST0 DS    0CL2                TEST TYPE IN CHARACTER
CB13TST1 DS    CL1                 1ST CHAR OF TEST TYPE
CB13TST2 DS    CL1                 2ND CHAR OF TEST TYPE
CB13CBID DS    CL2                 ID OF ASSOC MS2X/3X IF RELEVANT
CB13TMOD DS    CL1                 MODIFIER FOR NUMERIC TESTS
CB13RIND DS    CL1                 RESULT ( ERROR ) INDICATOR NUMBER
CB13SW   DS    CL1                 SWITCH BYTE
CB13SW2  DS    CL1                 2ND SWITCH BYTE
CB13LGTH EQU   *-CB13NTRY          LENGTH OF BASIC CONTROL BLOCK
CB13MESS DS    CL30                OPTIONAL ERROR MESSAGE
BUDGIE3  CSECT
         SPACE 5
SW13MESS EQU   1                   OPTIONAL MESSAGE IS PRESENT
SW13LIT  EQU   2                   BLOCK CONTAINS COMPARAND
SW13SOFT EQU   4                   ON=SOFT       /OFF=HARD
SW13DLET EQU   8                   DELETE RECORD IF TEST NOT SATISFIED
SW13NTST EQU   16                  C/B NO-OPED - INVALID TEST REQUETS
SW13OIND EQU   32                  SET RESULT INDICATOR  ONLY
SW13RIND EQU   64                  SET INDICATOR IF TEST SATISFIED
SW13CBXX EQU   128                 ASSOC CBXX ADDRESS REQUIRED
SW13INDS EQU   1                   INDICATOR TESTS ARE TO BE MADE
SW132TMB EQU   2                   TERMINATE PROCESSING OF THIS TEST FA
SW132TMG EQU   4                   TERMINATE IF THE TEST SUCCEDDS
         EJECT
***********************************************************************
*        FORMAT OF MS14 CONTROL BLOCK                                 *
***********************************************************************
         SPACE 1
CB14NTRY DSECT
CB14FLAG DS    0CL1                CONTROL BLOCK FLAG
CB14CB14 DS    F                   ADDRESS OF NEXT CB14
CB14CCNO DS    PL2                 CONTROL CARD SEQUENCE NUMBBER
CB14SW   DS    CL1                 SWITCH BYTE
CB14TST0 DS    0CL2                DEFINITION OF 1ST INDICATOR TEST
CB14IND  DS    CL1                 INDICATOR NUMBER
CB14ONOF DS    CL1                 INTERNAL REPRESENTATION OF DESIRED S
CB14TST1 DS    CL2                 AS CB14IND - CB14ONOF
CB14TST2 DS    CL2                 AS CB14IND - CB14ONOF
CB14TST3 DS    CL2                 AS CB14IND - CB14ONOF
CB14TST4 DS    CL2                 AS CB14IND - CB14ONOF
CB14TST5 DS    CL2                 AS CB14IND - CB14ONOF
CB14TST6 DS    CL2                 AS CB14IND - CB14ONOF
CB14TST7 DS    CL2                 AS CB14IND - CB14ONOF
CB14TST8 DS    CL2                 AS CB14IND - CB14ONOF
CB14TST9 DS    CL2                 AS CB14IND - CB14ONOF
CB14LGTH EQU   *-CB14NTRY          LENGTH OF DSECT
BUDGIE3  CSECT
         SPACE 5
SW14BTCH EQU   1                   OFF=DETAIL LEVEL / ON=BATCH LEVEL
         EJECT
***********************************************************************
*        FORMAT OF MS20 CONTROL BLOCK                                 *
***********************************************************************
         SPACE 1
*        THIS C/B IS COMMON TO ISAM & RIGAM FILES, & INTERNAL TABLES
         SPACE 1
CB20NTRY DSECT                     ISAM FILL KEY CONSTRUCTION
CB20FLAG DS    0CL1                CONTROL BLOCK FLAG
CB20CB20 DS    F                   ADDRESS OF NEXT CB2X/CB3X
CB20TID  DS    CL2                 TEST ID ( LABEL )
CB20CCNO DS    PL2                 CONTROL CARD SEQUENCE NUMBBER
CB20CB21 DS    F                   ADDRES  OF 1ST CB21 C/B
CB20POOL DS    F                   ADDR OF LITERAL POOL OF KEY COMPONS
CB20TKEY DS    F                   ADDRESS OF CURRENT KEY
CB20LKEY DS    F                   ADDRESS OF PREVIOUS KEY
CB20DCBS DS    0CL24               I/O CONTROL BLOCK ( DCBSW )
CB20ISW  DS    0CL1                I/O CONTROL SWITCH
CB20IDCB DS    F                   ADDRESS OF DCB
CB20IDDN DS    0CL8                DDNAME ( FOR I/S ONLY )
CB20RFNO DS    CL2                 FILE NUMBER
CB20RFID DS    CL3                 RIGAM FILE ID
CB20RFLN DS    CL3                 RIGAM RECORD LENGTH
CB20IREC DS    F                   ADDRESS OF CURRENT RECORD IN BUFFER
CB20ICNT DS    PL4                 RECORD COUNT
CB20I4SA DS    F                   SAVE AREA FOR REG 4
CB20SW   DS    CL1                 SWITCH BYTE
CB20KLEN DS    CL1                 KEY LENGTH
CB20XORY DS    CL1                 REESULT OF I/S LOOK-UP
CB20FLD1 DS    0CL3                DESCRIPTION OF 1ST KEY COMPONENT
CB20POS  DS    CL1                 POSN OF COMPONENT IN SOURCE
CB20LEN  DS    CL1                 LGTH OF COMPONENT IN SOURCE
CB20TYP  DS    CL1                 NATURE OF SOURCE ( B/C, D/C, LITERL)
CB20FLD2 DS    CL3                 AS CB20POS - CB20TYP
CB20FLD3 DS    CL3                 AS CB20POS - CB20TYP
CB20FLD4 DS    CL3                 AS CB20POS - CB20TYP
CB20FLD5 DS    CL3                 AS CB20POS - CB20TYP
CB20FLD6 DS    CL3                 AS CB20POS - CB20TYP
CB20FLD7 DS    CL3                 AS CB20POS - CB20TYP
CB20FLD8 DS    CL3                 AS CB20POS - CB20TYP
CB20LGTH EQU   *-CB20NTRY          LENGTH OF BASIC DSECT
BUDGIE3  CSECT
         SPACE 5
SW20IS   EQU   1                   ON = ISAM / OFF = RIGAM
         EJECT
***********************************************************************
*        FORMAT OF MS21 CONTROL BLOCK                                 *
***********************************************************************
         SPACE 1
*        THIS C/B IS COMMON TO ISAM & RIGAM FILES, & INTERNAL TABLES
         SPACE 1
CB21NTRY DSECT                     DEFINITION OF DATA TO BE EXTRACTED
CB21FLAG DS    0CL1                CONTROL BLOCK FLAG
CB21CB21 DS    F                   ADDRESS OF NEXT CB21
CB21CCNO DS    PL2                 CONTROL CARD SEQUENCE NUMBBER
CB21SPOS DS    CL1                 POSN OF FIELD IN FILE
CB21SLEN DS    CL1                 LGTH OF FIELD IN FILE
CB21DPOS DS    CL1                 POSN OF FIELD IN OUTPUT RECORD
CB21SW   DS    CL1                 SWITCH BYTE
CB21LGTH EQU   *-CB21NTRY          LENGTH OF BASIC DSECT
CB21PADC DS    0CL1                PAD CHARACTER IF RELEVANT
CB21LIT  DS    CL20                DEFAULT LITERAL VALUE IF RELEVANT
BUDGIE3  CSECT
         SPACE 5
SW21PACK EQU   1                   PACK SOURCE BEFORE MOVE
SW21UNP  EQU   2                   UNPACK SOURCE BEFORE MOVE
SW21LIT  EQU   4                   USE DEFAULT LITERAL IF NO MATCH
SW21PAD  EQU   8                   PAD DERIVED FIELD IF NO MATCH
         EJECT
***********************************************************************
*        FORMAT OF MS30 CONTROL BLOCK                                 *
***********************************************************************
         SPACE 1
CB30NTRY DSECT
CB30FLAG DS    0CL1                CONTROL BLOCK FLLAG
CB30CB30 DS    F                   ADDRESS OF NEXT CBXX C/B
CB30TID  DS    CL2                 TEST ID ( LABEL )
CB30CCNO DS    PL2                 CONTROL CARD SEQUENCE NUMBBER
CB30SW   DS    CL1                 SWITCH BYTE
CB30RNG1 DS    CL16                RANGE 1 ( START OF RANGE OR LITERAL)
CB30RNG2 DS    CL16                RANGE 2 ( END OF RANGE )
CB30LGTH EQU   *-CB30NTRY          LENGTH OF DSECT
BUDGIE3  CSECT
         SPACE 5
SW30PAKD EQU   1                   ON  = PACKED DECIMAL COMPARE
*                                  OFF = CHARACTER COMPARE
SW30EXT  EQU   2                   ON  = R1 < R2 & FLD < R1 | R2 < FLD
*                                  OFF = R1 <= FLD <= R2
         EJECT
***********************************************************************
*        FORMAT OF MS32 CONTROL BLOCK                                 *
***********************************************************************
         SPACE 1
CB32NTRY DSECT
CB32FLAG DS    0CL1                CONTROL BLOCK FLAG
CB32CB32 DS    F                   ADDRESS OF NEXT CB2X/CB3X C/B
CB32TID  DS    CL2                 TEST ID ( LABEL )
CB32CCNO DS    PL2                 CONTROL CARD SEQUENCE NUMBBER
CB32SW1  DS    CL1                 SWITCH BYET
CB32SW2  DS    CL1                 ANOTHER SWITCH BYTE
CB32SW3  DS    CL1                 YET ANOTHER SWITCH BYTE
CB32ICP  DS    CL1                 POSN OF INPUT CURRENCY CODE
CB32OCP  DS    CL1                 POSN OF OUTPUT CURRENCY CODE
CB32INP  DS    CL1                 POSN OF INPUT VALUE
CB32INL  DS    CL1                 LGTH OF INPUT VALUE
CB32OUTP DS    CL1                 POSN OF OUTPUT VALUE
CB32OUTL DS    CL1                 LGTH OF OUTPUT VALUE
CB32RTEP DS    CL1                 POSN OF CONVERSION RATE
CB32RTEL DS    CL1                 LGTH OF CONVERSION RATE
CB32OUTA DS    CL1                 OUTPUT ALIGNMENT
CB32NMIP DS    CL1                 POSN OF NAME OF INPUT CURRENCY CODE
CB32NMOP DS    CL1                 POSN OF NAME OF OUTPUT CURRENCY CODD
CB32VNOP DS    CL1                 POSN OF VERSION NUMBER
CB32ICDE DS    CL2                 LITERAL INPUT CURRENCY CODE
CB32OCDE DS    CL2                 LITERAL OUTPUT CURRENCY CODE
CB32RNDN DS    PL1                 NO. OF DIGITS TO BE ZEROISED IN ROUN
CB32LGTH EQU   *-CB32NTRY          LENGTH OF DSECT
BUDGIE3  CSECT
         SPACE 5
SW321ICL EQU   1                   INPUT CUDRENCT CODE IS A LITERAL
SW321OCL EQU   2                   OUTPUT CURRENCY COE IS A LITERAL
SW321ICS EQU   4                   TAKE INPUT CURRENCY CODE FROM MS13
SW321OCS EQU   8                   TAKE OUTPUT CURRENCY CODE FROM MS13
SW321IVS EQU   16                  TAKE INPUT VALUE FROM MS13
SW321RTE EQU   32                  PERFORM CURRENCY CONVERSION RATE EXT
SW321NOC EQU   64                  NO CURRENCY CONVERSION REQUIRED
SW321ZRO EQU   128                 ZEROISE RECEIVING FIELD IF CONV ERRO
SW322IVP EQU   1                   INPUT VALUE IS PACKED
SW322OVP EQU   2                   OUTPUT VALUE IS PACKED
SW322RTP EQU   4                   CONVERSION RATE IS TP BE OUTPUT PACK
SW322VNO EQU   8                   CURRENCY TABLE VERSION NAUMBER IS RE
SW322INM EQU   16                  NAME OF INPUT  CODE IS REQUIRDD
SW322ONM EQU   32                  NAME OF OUTPUT CODE IS REQUIRDD
SW322OVS EQU   64                  TAKE OUTPUT FIELD PL FROM MS13
SW322RTS EQU   128                 POSN OF RATE TO BE EXTRACTED FROM MS
SW323RND EQU   1                   ROUNDING IS REQUIRED
SW323COM EQU   3                   'COMMERCIAL' ROUNDING ONLY
         EJECT
***********************************************************************
*        FORMAT OF MS33 CONTROL BLOCK                                 *
***********************************************************************
         SPACE 1
CB33NTRY DSECT
CB33FLAG DS    0CL1                CONTROL BLOCK FLAG
CB33CB33 DS    F                   ADDRESS OF NEXT CBXX C/B
CB33TID  DS    CL2                 TEST ID (LABEL )
CB33CCNO DS    PL2                 CONTROL CARD SEQUENCE NUMBBER
CB33POS1 DS    CL1                 POSN OF 'FROM'FIELD
CB33LEN1 DS    CL1                 LGTH OF 'FROM'FIELD
CB33POS2 DS    CL1                 POSN OF 'TO' FIELD
CB33LEN2 DS    CL1                 LGTH OF 'TO' FIELD
CB33TYPE DS    CL1                 TEST TYPE ( IF COMPARISON )
CB33SW   DS    CL1                 SWITCH BYTE
CB33LGTH EQU   *-CB33NTRY          LENGTH OF BASIC DSECT
CB33LIT  DS    CL1                 VARIABLE LENGTH OPTIONAL LITERAL
BUDGIE3  CSECT
         SPACE 5
SW33MOVE EQU   1                   OFF - FIELDS ARE TO BE COMPARED
*                                  ON  - FIELDS ARE TO BE MOVED
SW33LIT  EQU   2                   'FROM' FIELD IS LITERAL CONSTANAT
SW33MP   EQU   4                   IN UNPACKED, OUT PACKED
SW33MU   EQU   8                   IN PACKED, OUT UNPACKED
SW33CNUM EQU   16                  NUMERIC COMPARE: FLDS UNPACKED
SW33CPD  EQU   32                  NUMERIC COMPARE: FLDS PACKED
         EJECT
***********************************************************************
*        FORMAT OF MS34 CONTROL BLOCK                                 *
***********************************************************************
         SPACE 1
CB34NTRY DSECT
CB34FLAG DS    0CL1                CONTROL BLOCK FLAG
CB34CB34 DS    F                   ADDRESS OF NEXT CB2X/3X/4X
CB34TID  DS    CL2                 TEST ID ( LABEL )
CB34CCNO DS    PL2                 CONTROL CARD SEQUENCE NUMBBER
CB34LENO DS    F                   OUTSTANDING ( UNFILLED ) LENGTH
CB34NPOS DS    F                   ADDRESS OF NEXT AVAILABLE BYTE
CB34NLST DS    CL1                 NUMBER OF ENTRIES IN LIST
CB34LLST DS    CL1                 LENGTH OF EACH ENTRYY
CB34SW   DS    CL1                 SWITCH BYTE
CB34LGTH EQU   *-CB34NTRY          LENGTH OF BASIC C/B
CB34LIST DS    CL1                 VARIABLE LENGTH CONCATENATED LIST
BUDGIE3  CSECT
         SPACE 5
SW34BBLD EQU   1                   REBUILD LIST FOR EACH BATCH
         EJECT
***********************************************************************
*        FORMAT OF MS36 CONTROL BLOCK                                 *
***********************************************************************
         SPACE 1
CB36NTRY DSECT
CB36FLAG DS    0CL1                CONTROL BLOCK FLAG
CB36CB36 DS    F                   ADDRESS OF NEXT CB2X/3X
CB36TID  DS    CL2                 TEST ID ( LABEL )
CB36CCNO DS    PL2                 CONTROL CARD SEQUENCE NUMBBER
CB36SW   DS    CL1                 SWITCH BYTE
CB36OPCD DS    CL1                 INTERNAL REPRESANTATION OF OPERATION
CB36POS1 DS    CL1                 POSN F 1ST OPERAND
CB36LEN1 DS    CL1                 LGTH F 1ST OPERAND
CB36NDC1 DS    CL2 (HALFWORD ALIG) NO OF DECIMAL PLACES OF 1ST OPERAND
CB36POS2 DS    CL1                 POSN OF 2ND OPERAND
CB36LEN2 DS    CL1                 LGTH OF 2ND OPERAND
CB36NDC2 DS    CL2 (HALFWORD ALIGN) NO OF DECIMAL PLACES OF 2ND OPERAND
CB36POS3 DS    CL1                 POSN OF RESULT FIELD
CB36LEN3 DS    CL1                 LGTH OF RESULT FIELD
CB36NDC3 DS    CL2 (HALFWORD ALIGN) NO OF DECIMAL PLACES IN RESULT
CB36POS4 DS    CL1                 POSN OF REMAINDER
CB36LEN4 DS    CL1                 LGTH OF REMAINDER
CB36NDC4 DS    CL2 ( HALFWORD ALIGNNDEC OF REMAINDER
CB36RNDN DS    CL1                 NO OF PLACES TO BE ROUNDED
CB36LGTH EQU   *-CB36NTRY          LENGTH OF DSECT
CB36LIT  DS    PL8                 OPTIONAL LITERAL VALUE FOR OPERAND 2
BUDGIE3  CSECT
         SPACE 5
SW36PCK1 EQU   1                   1ST OPERAND IS PACKED
SW36PCK2 EQU   2                   2ND OPERAND IS PACKED
SW36PCK3 EQU   4                   RESULT IS TO BE PAC-ED
SW36RND  EQU   8                   ROUNDING IS REQUIRED
SW36LIT  EQU   16                  OPERAND 2 IS SUPPLIED LITERAL
SW36NRND EQU   32                  ALL ROUNDING TO BE SUPPRESSED
SW36REM  EQU   64                  REMAINDER IS REQUIRED
SW36REMP EQU   128                 REMAINDER IS TO BE PACKED
         EJECT
***********************************************************************
*        FORMAT OF MS37 CONTROL BLOCK                                 *
***********************************************************************
         SPACE 1
CB37NTRY DSECT
CB37FLAG DS    0CL1                CONTROL BLOCK FLAG
CB37CB37 DS    F                   ADDRESS OF NEXT CB2X/3X/4X
CB37TID  DS    CL2                 TEST ID ( LABEL )
CB37CCNO DS    PL2                 CONTROL CARD SEQUENCE NUMBBER
CB37POS1 DS    CL1                 POSN OF INPUT FIELD
CB37LEN1 DS    CL1                 LGTH OF INPUT FIELD
CB37POS2 DS    CL1                 POSN OF OUTPUT FIELD
CB37LEN2 DS    CL1                 LGTH OF OUTPUT FIELD
CB37DEC1 DS    CL1                 DEFAULT NO OF DECIMAL PLACES IN INPT
CB37DEC2 DS    CL1                 NO OF DECIMAL PLACES IN OUTPUT FIELD
CB37DECC DS    CL1                 COMPUTED NO OF DEC PLACES IN INPUT
CB37SW   DS    CL1                 SWITCH BYTE
CB37LGTH EQU   *-CB37NTRY          LENGTH OF CONTROL BLOCK
         SPACE 5
SW37PACK EQU   1                   OUTPUT IS TO BE PACKED
         EJECT
***********************************************************************
*        FORMAT OF MS40 CONTROL BLOCK                                 *
***********************************************************************
         SPACE 1
CB40NTRY DSECT                     DEFINE CB13 SUBROUTINE
CB40FLAG DS    0CL1                CONTROL BLOCK ID
CB40CB40 DS    F                   ADDRESS OF NEXT CBXX
CB40TID  DS    CL2                 SUBROUTINE NAME ( LABEL )
CB40CCNO DS    PL2                 CONTROL CARD SEQUENCE NUMBBER
CB40SW   DS    CL1                 SWITCH BYTE
         DS    CL1                 UNUSED
CB40FRST DS    F                   ADDRESS OF 1ST CB13 IN RUTINE
CB40LAST DS    F                   ADDRESS OF LAST CB13 IN ROUTINE
CB40LGTH EQU   *-CB40NTRY          LENGTH OF CONTROL BLOCK
         TITLE 'DSECT FOR USER ROUTINE LINKAGE AREA'
***********************************************************************
*        FORMAT OF USER ROUTINE PARAMETER AREA                        *
***********************************************************************
         SPACE 1
*        NOTE THAT THIS AREA IS IMMEDIATELY PRECEDED BY THE INPUT
*         RECORD IMAGE.
*
*        NOTE ALSO THAT THIS COMPOSITE AREA IS USED BY BASIC BUDGIE
*         REGARDLESS OF WHETHER OR NOT USER MODULES ARE SPECIFIED.
*         THE INPUT RECORD IMAGE IS LEFT UNMODIFIED, AND ALL EDITING
*         AND INSERTION TAKES PLACE IN THE 'OUTPUT' AREA. THUS WHEN THE
*         USER RECEIVES CONTROL, THE OUTPUT AREA ARREADY CONTAINS VALID
*         DATA.
         SPACE 1
URTNPARM DSECT                     LINKAGE AREA
URTNCSW  DS    CL1                 CALL SWITCH:  1 - INITIALISE
*                                                2 - BATCH CARD
*                                                3 - DETAIL CARD
*                                                4 - END
*                                                5 - CALLED BY R5 OPCDE
*                                                6 - END OF BATCH
URTNRSW1 DS    CL1                 RETURN CODE:  0 - RECORD OK
*                                                1 - REJECT BATCH
*                                                2 - DELETE RECORD ONLY
URTNRSW2 DS    CL1                 RETURN CODE:  0 - FINISHED WITH RECD
*                                               ^0 - PASS RECORD AGAIN
URTNMESS DS    CL30                ERROR MESSAGE
URTNPOS  DS    CL2                 POSITION OF FIELD IN ERROR
URTNLEN  DS    CL2                 LENGTH OF FIELD IN ERROR
URTNOUT  DS    CL1                 OUTPUT RECORD - UNLIMITED LENGTH
*                                  ... OPTIONALLY FOLLOWED BY WORK AREA
BUDGIE3  CSECT
         EJECT
***********************************************************************
*        FORMAT OF CURRENCY CONVERSION ROUTINE PARAMETER AREA         *
***********************************************************************
         SPACE 1
UT460LNK DSECT
UT460INV DS    PL8                 INPUT VALUE - S9(10)V9(5)
UT460INC DS    CL2                 INPUT CURRENCY CODE
UT460OTC DS    CL2                 OUTPUT CURRENCT CODE
UT460RTC DS    CL1                 RETRUN CODE
*                                   '1' - CONVERSION SUCCESSFUL
*                                   '2' - INPUT CODE INVALID
*                                   '3' - OUTPUT CODE INVALID
UT460OTV DS    PL8                 OUTPUT VALUE - S9(10)V9(5)
UT460DSI DS    CL4                 DESCRIPTION OF INPUT CURRENCY CODE
UT460DSO DS    CL4                 DESCRIPTION OF OUTPUT CURRENCY CODE
UT460RND DS    CL1                 ROUNDING FLAG
*                                   'C' - SUBJECT TO COMMERCIAL RNDING
UT460LGT EQU   *-UT460LNK          LENGTH OF DSECT
BUDGIE3  CSECT
         SPACE 5
***********************************************************************
*        FORMAT OF RIGAM PARAMETER AREA                               *
***********************************************************************
         SPACE 1
RIGAMLNK DSECT
RIGMNOT1 DS    H                   NO OF TYPE 1 FILES
RIGMNOT2 DS    H                   NO OF TYPE 2 FILES
RIGMRECN DS    F                   ABSOLUTE RECORD NUMBER
RIGMIND  DS    H                   RESULT INDICATOR
RIGMOPCD DS    CL3                 OPERATION CODE
RIGMFTYP DS    CL1                 FILE TYPE ( 1/2 )
RIGMFNO  DS    CL3                 FILE NUMBER
RIGMKEY  DS    CL35                RECORD KEY
RIGMMIO1 DS    CL1                 MUST BE 'N'
RIGMMIO2 DS    CL1                 MUST BE 'N'
RIGMLGTH EQU   *-RIGAMLNK          LENGTH OF DSECT
BUDGIE3  CSECT
         TITLE 'DSECTS FOR BATCH LOG RECORD AND REPORT'
***********************************************************************
*        FORMAT OF BATCH LOG RECORD                                   *
***********************************************************************
         SPACE 1
LOGCARD  DSECT                     BATCH LOG RECORD
LOGSW    DS    CL1                 'A' -ACCEPTED / 'S' - SUSPENSE
*                                  'P' - SUSPENSE BATCH PASSED BY UPDAT
LOGBNO   DS    CL16                BATCH NUMBER
LOGIDTE1 DS    CL5                 DATE BATCH ENTERED INTO SYSTEM YYDDD
LOGADTE1 DS    CL5                 DATE BATCH ACCEPTED BY  SYSTEM YYDDD
LOGIDTE2 DS    CL9                 DATE BATCH ENTERED - REPORT FORMAT
LOGADTE2 DS    CL9                 DATE BATCH ACCEPTED - REPORT FORMAT
LOGRCNT  DS    PL3                 NUMBER OF RECORDS ENTERED
LOGLCNT  DS    PL3                 NUMBER OF RECORDS RETRINED
LOGHCNT  DS    PL3                 COUNT OF HARD ERRORS IN BATCH
LOGSCNT  DS    PL3                 COUNT OF SOFT ERRORS IN BATCH
LOGBTYPE DS    CL8                 BATCH CARD ID
LOGSUBID DS    CL10                SUBMITTOR ID
         DS    CL5                 UNUSED
LOGLGTH  EQU   *-LOGCARD           LENGTH OF LOG RECORD
BUDGIE3  CSECT
         EJECT
***********************************************************************
*        FORMAT OF BATCH LOG STATUS REPORT DETAIL LINE                *
***********************************************************************
         SPACE 1
LLOGLINE DSECT
LLOGCC   DS    CL1                 CARRIAGE CONTROL CHARACTER
LLOGBNO  DS    CL16                BATCH NUMBER
         DS    CL3                 UNUSED
LLOGMACC DS    CL8                 'ACCEPTED' MESSAGE
         DS    CL2                 UNUSED
LLOGMSUS DS    CL8                 'SUSPENSE' MESSAGE
         DS    CL3                 UNUSED
LLOGEDTE DS    CL9                 DATE BATCH ENTERED - REPORT FORMAT
         DS    CL3                 UNUSED
LLOGADTE DS    CL9                 DATE BATCH ACCEPTED - RETORT FORMAT
         DS    CL3                 UNUSED
LLOGRCNT DS    CL6                 COUNT OF RECORDS ENTERED
         DS    CL5                 UNUSED
LLOGLCNT DS    CL6                 COUNT OF RECORDS RETRINED
         DS    CL3                 UNUSED
LLOGHCNT DS    CL6                 COUNT OF HARD ERRORS
         DS    CL3                 UNUSED
LLOGSCNT DS    CL6                 COUNT OF SOFT ERRORS
         DS    CL4                 UNUDED
LLOGTYPE DS    CL8                 BATCH CARD TYPE ( CARD IDENTIFIER )
         DS    CL3                 UNUSED
LLOGSUB  DS    CL10                SUBMITTOR ID
LLOHLGTH EQU   *-LLOGLINE          LENGTH OF DSECT
BUDGIE3  CSECT
         TITLE 'DSECT FOR B/B REPORT DETAIL LINE'
***********************************************************************
*        FORMAT OF DETAIL LINE OF B/B REPORT                          *
***********************************************************************
         SPACE 1
DETAILBB DSECT
DTBBCC   DS    CL1                 CARRIAGE CONTROL CHARACTER
         DS    CL2                 USED FOR CARD NO IF MORE THAN 4 DIGT
DTBBCNO  DS    CL4                 CARD NUMBER
         DS    CL5                 SPACES
DTBBCARD DS    CL80                CARD IMAGE
         DS    CL3                 SPACES
DTBBEMSS DS    CL30                ERROR MESSAGE
         DS    CL3                 SPACES
DTBBFLAG DS    CL4                 ERROR FLAG (****)
         DS    CL1                 SPACES
DTBBLGTH EQU   *-DETAILBB          LENGTH OF DSECT
         SPACE 5
***********************************************************************
*        FORMAT OF TOTAL LINE OF B/B REPOTT                           *
***********************************************************************
         SPACE 1
         ORG   DTBBCC              REDEFINE TO SATRT OF LINE
TTBBCC   DS    CL1                 CARRIAGE CONTROL CHARACTER
         DS    CL2                 UNUSED ( SPACES )
TTBBTEXT DS    CL11                DESCRIPTION OF LINE'S CONTENTS
TTBBCNT  DS    CL8                 RECORD COUNT VALUE / HEADING
TTBBFLD1 DS    0CL19               TOTAL LINE BUCKET
TTBBFLD  DS    CL16                1ST BUCKET VALUE / HEADING
         DS    CL3                 UNUSED ( SPACES )
TTBBFLD2 DS    CL19                2ND TOTAL LINE BUCKET
TTBBFLD3 DS    CL19                3RD TOTAL LINE BUCKET
TTBBFLD4 DS    CL19                4TH TOTAL LINE BUCKET
TTBBFLD5 DS    CL19                5TH TOTAL LINE BUCKET
TTBBFLD6 DS    CL16                6TH TOTAL LINE BUCKET
TTBBLGTH EQU   *-DETAILBB          LENGTH OF DSECT
BUDGIE3  CSECT
         EJECT
***********************************************************************
*        FORMAT OF SUB-BLOCK DEFINING 'WORKFILE' STORAGE POOLS        *
***********************************************************************
         SPACE 1
*        THIS CONTROL BLOCK IS USED TO DESCRIBE ACQUIRED STORAGE POOLS
*         OR UNUSED CSECTS WHICH ARE AVAILABLE TO THE GETAMIN AND
*         WORKFILE ROUTINES.
         SPACE 1
POOLDEFN DSECT                     SUB-BLOCK DEFINING STORAGE POOL
POOLSW   DS    0CL1                SWITCH BYTE
POOLADR  DS    F                   ADDRESS OF POOL
POOLSIZ  DS    F                   SIZE OF POOL
         ORG   POOLADR             REDEFINE OVER MULTI-USE FIELD
GETMNPOS DS    F                   START OF AREA AVAILABLE FOR GETMAINS
GETMNLEN DS    F                   LGTH  OF AREA AVAILABLE FOR GETMAINS
POOLCAP  DS    F                   CAPACITY OF POOL ( IN RECORDS )
POOLPTR  DS    F                   PTR TO NEXT AVAILABLE SLOT
POOLLGTH EQU   *-POOLDEFN          LENGTH OF SUB-BLOCK
BUDGIE3  CSECT
         SPACE 5
POOLUSE  EQU   1                   POOL AVAILABLE FOR USE
POOLGTM  EQU   2                   POOL AVAILABLE FOR GETMAINS
POOLWORK EQU   4                   POOL BEING USED BY WORK FILE
         SPACE 5
***********************************************************************
*        EQUATES FOR MATHEMATICAL OPERATIONS                          *
***********************************************************************
         SPACE 1
ADD      EQU   1                   INTERNAL REPRESENTATION OF ADD
SUBTRACT EQU   2                   INTERNAL REPRESENTATION OFSUBTRACT
MULTIPLY EQU   3                   INTERNAL REPRESENTATION OFMULTIPLY
DIVIDE   EQU   4                   INTERNAL REPRESENTATION OFDIVIDE
         TITLE 'PROCESS CONTROLLING FLAGS'
***********************************************************************
*        CONTROL BLOCK FLAGS                                          *
***********************************************************************
         SPACE 1
*        NOTE THAT THOSE CONTROL BLOCKS THAT ARE USED TO DEFINE TESTS
*         SPECIFIED IN MS13 CONTROL CARDS HAVE AN IDENTIFYING FLAG
*         IDENTICAL TO THE INTERNAL TEST REPRESENTATION TO WHICH THEY
*         REFER IN ORDER TO SIMPLIFY CHAINING.
         SPACE 1
FLAGCB02 EQU   1                   CONTROL BLOCK CB02
FLAGCB03 EQU   2                   CONTROL BLOCK CB03
FLAGCB05 EQU   4                   CONTROL BLOCK CB05
FLAGCB11 EQU   3                   CONTROL BLOCK CB11
FLAGCB04 EQU   16                  CONTROL BLOCK CB04
FLAGSB11 EQU   32                  CONTROL BLOCK SB11
FLAGCB13 EQU   64                  CONTROL BLOCK CB13
FLAGCB14 EQU   5                   CONTROL BLOCK CB14
FLAGCB15 EQU   6                   CONTROL BLOCK CB15
FLAGCB16 EQU   7                   CONTROL BLOCK CB16
FLAGCB20 EQU   X'2E'               CONTROL BLOCK CB20
FLAGCB2R EQU   X'2F'               CONTROL BLOCK CB20 FOR RIGAM
FLAGCB21 EQU   9                   CONTROL BLOCK CB21
FLAGCB22 EQU   10                  CONTROL BLOCK CB22
FLAGCB23 EQU   X'13'               CONTROL BLOCK CB23
FLAGCB24 EQU   11                  CONTROL BLOCK CB24
FLAGCB30 EQU   X'1C'               CONTROL BLOCK CB30
FLAGCB31 EQU   X'40'               CONTROL BLOCK CB31
FLAGCB32 EQU   X'08'               CONTROL BLOCK CB32
FLAGCB33 EQU   X'16'               CONTROL BLOCK CB33
FLAGCB34 EQU   X'14'               CONTROL BLOCK CB34
FLAGCB36 EQU   X'1A'               CONTROL BLOCK CB36
FLAGCB37 EQU   X'1B'               CONTROL BLOCK CB37
FLAGCB38 EQU   X'30'               CONTROL BLOCK CB38
FLAGCB40 EQU   X'4C'               CONTROL BLOCK CB40
FLAGCB41 EQU   12                  CONTROL BLOCK CB41
         SPACE 4
***********************************************************************
*        MASTER SWITCH FLAGS                                          *
***********************************************************************
         SPACE 1
SWMNLIST EQU   1                   DATA IS NOT TO BE LISTED
SWMHARD  EQU   2                   BATCH HAS HARD ERROR
SWMSOFT  EQU   4                   BATCH HAS SOFT ERROR
SWMBALNC EQU   8                   BATCH IS OUT OF BALANCE
SWMDUPIN EQU   16                  CURRENT BATCH NO SAME AS LAST
SWMDETL  EQU   32                  PROCESSING DETAIL RECORD (EOP RTN)
SWMPRINT EQU   64                  WRITE ERROR ON B/B REPORT
SWMDUPLG EQU   128                 BATCH NO DUPLICATED ON LOG
SWMBATCH EQU   SWMHARD+SWMSOFT+SWMBALNC+SWMDUPIN+SWMDUPLG
         EJECT
***********************************************************************
*        ERROR SWITCH FLAGS                                           *
***********************************************************************
         SPACE 1
SWEGETM  EQU   1                   STORAGE POOL TOO SWALL FOR CB'S
SWEURTN  EQU   2                   USER ROUTINE PASSED NIN-NUMERIC PPLL
SWEFLUSH EQU   4                   TERMINATE AFTER CONTROL CARD SCAN
SWEUNA   EQU   8                   UNALLOCATED TEST REQUESTED
SWEUNS   EQU   16                  UNSUPPORTED TEST REQUESTED
SWEDBCN  EQU   32                  MS11 SPECIFIES UNMATCHED B/C FLD NAM
SWEDCRN  EQU   64                  MS11 SPECIFIES UNMATCHED C/R FIELD N
SWENMSXX EQU   128                 MS13 REQUIRES AN MSXX CARD NOT THERE
SWEUNREC EQU   1                   MS13 SPECIFIED UNKNOWN TEST CODE
SWETMS11 EQU   2                   MS11 SPECIFIED TEST THAT REQUIRES CC
         SPACE 5
***********************************************************************
*        INITIALISATION SWITCH FLAGS                                  *
***********************************************************************
         SPACE 1
SWMS11   EQU   1                   MS11 CARD BEING PROCESSED
SWLDRIGM EQU   2                   RIGAM TO BE LOADED
SWLDDATE EQU   4                   UT457 TO BE LOADED
SWLD435  EQU   8                   UT435 TO BE LOADED
SWONMS11 EQU   16                  MS11 FOUND FOR THIS MS02
SWONURTN EQU   32                   USER ROUTINE(S) ARE TO BE INVOKED
SWMS11PL EQU   64                  MS11 HASP 'PPPL' & NOT 'PPLL'
SWCCPRNT EQU   128                 CURRENTLY PRINTING CONTROL CARDS
         SPACE 5
***********************************************************************
*        RECORD PROCESSING SWITCHES                                   *
***********************************************************************
         SPACE 1
PSWSOFT  EQU   1                   RECORD HAS SOFT ERROR
PSWHARD  EQU   2                   RECORD HAS HARD ERROR
PSWDLETE EQU   4                   RECORD IS TO BE DELETED
PSWIGN   EQU   8                   RECORD IS TO BE IGNOORED
PSWULINE EQU   16                  UNDERLINE CHAR NOT '_' OR ' '
*                                   DO NOT FORCE FORWARD SPACE IF NO ER
PSWNEG   EQU   32                  NEGATIVE IDENTIFIER SHOWS NEGATIVE
PSWKIGN  EQU   64                  KNOWN RECORD TYPE BEING IGNORED
PSWBCARD EQU   128                 PROCESSING BATCH CARD
PSWPRNT  EQU   PSWSOFT+PSWHARD+PSWDLETE+PSWIGN+PSWULINE
         EJECT
***********************************************************************
*        B/B REPORT PROCESSING SWITCHES                               *
***********************************************************************
         SPACE 1
SWBRRCNT EQU   1                   PUT RECORD COUNT IN THIS TOTAL LINE
SWBRDETL EQU   2                   PUT CARD IMAGE IN THIS LINE
SWBRNOBC EQU   4                   NO BATCH CARD SUPPLIED WITH RUN
SWBRKB   EQU   8                   RECOGNISE NEW BATCH NY CHANGE OF KEY
SWBRCRT  EQU   16                  CONTROL RECORD TRAILS BATCH
SWBRWRKP EQU   32                  WORK DD STAEMENT PRESENT
SWBRPCRD EQU   64                  CARD IMAGE BEING PLACED N LINE AGAIN
         SPACE 5
***********************************************************************
*        B/B REPORT PRINTER SPACING SWITCHES                          *
***********************************************************************
         SPACE 1
PRSWSPC2 EQU   1                   DOUBLE SPACING REQUESTED
PRSWSPC3 EQU   2                   TRIPLE SPACING REQUESTED
PRSWBLS2 EQU   4                   DOUBLE SPACE FOR BATCH LOG LIST
PRSWBLS3 EQU   8                   TRIPLE SPACE FOR BATCH LOG LIST
PRSWSPBL EQU   16                  DOUBLE/TRIPLE SPACE WITH BLANK LINES
PRSWNDTA EQU   32                  PRINT CONTROL TOTALS ONLY
         SPACE 5
***********************************************************************
*        ANOTHER PROCEDSING SWITCH                                    *
***********************************************************************
         SPACE 1
APSWSID  EQU   1                   SUBMITTOR'S ID TO BE PLACED IN RECDS
APSWSIDB EQU   3                   SUBMITTOR'S ID IN BATCH CARDS ONLY
APSWBCID EQU   2                   BCID PARM FOUND
APSWMS05 EQU   4                   MS05 CARDS PRESENT
APSWNSEQ EQU   8                   PERFORM NO SEQUENCE CHECKING
APSWMS1S EQU   16                  ALL MS11 TESTS ARE TO BE SOFT ERRORS
APSWSRTN EQU   32                  WITHIN AN MS40 SUBROUTINE
APSWJUST EQU   64                  RIGHT JUSTIFY BEFORE TESTING NUMERIC
APSWLOG  EQU   128                 BATCH LOG RECORD REQUIRED
         EJECT
***********************************************************************
*        YET ANOTHER PROCESSING SWITCJ                                *
***********************************************************************
         SPACE 1
YPSWCC19 EQU   1                   CONVERT CURR CODE 19 TO 98
YPSWNOIX EQU   2                   DO NOT BUILD I.S. INDEX IN CORE
YPSWFREE EQU   4                   FREEMAIN OVERLAYABLE CSCTS
YPSWNOLD EQU   8                   DO NOT PRELOAD USER ROUTINES
YPSWSFIN EQU   16                  SUSPENSE FILE = INPUT IMAGES
YPSWCLST EQU   32                  SWMNLIST + CARD IMAGE WRITTEN
YPSWNEOF EQU   64                  NO '/*EOF' TO BE WRITTEN TO INTDRR
YPSWPLOP EQU   128                 PPL MAY HAVE OVERPUNCH FOR LEADING D
         SPACE 5
***********************************************************************
*        A FURTHER PROCESSING SWITCH                                  *
***********************************************************************
         SPACE 1
AFSWKIND EQU   1                   PARM=KEEPINDS SPECIFIED
AFSWSEQA EQU   2                   SEQUENCE NUMVER ALL CONTROL CARDS
         TITLE 'BUDGIE INITIATION PROCESSING'
***********************************************************************
*        HOUSEKEEPING                                                 *
***********************************************************************
         SPACE 1
         PGMIN EQUATES=NO,USING=(R13,R12) ESTABLISH ADDRESSABILITY
POOLSTRT EQU   *                   START OF OVERLAID STORAGE POOL
         ST    R1,PARMPNTR         PRESERVE PARM POINTER
         SPACE 5
***********************************************************************
*        LINK TO INITIALISATION CODING                                *
***********************************************************************
         SPACE 1
         CBAL  R4,UT458O0          GET IPL DATE
         CBAL  R4,INITILIZ         GO PERFORM INITIALISATION
MAINLNE2 EQU   *                   RETURN FROM INITIALISATION
         OI    VBUDG3C,POOLUSE     FLAG INITIALISATION CSRCT AVAILABLE
*                                   FOR USE AS STARAGE POOL
         TM    SWINIT,SWONURTN     TEST IF USER ROUTINES REQUESTED
         BO    *+8                 BR IF YES
         OI    VBUDG3F,POOLUSE+POOLGTM IF NOT, CSECT MAY BE A POOL
         OI    VBUDG3I,POOLUSE     FLAG THAT CODE TABLE MAY BE OVERLAYE
         OI    VBUDG3K,POOLUSE     FLAG THAT C/B OVERLAY MAY BE OVERLYD
         OI    VBUDG3M,POOLUSE     FLAG TO OVERLAY INTERCONNECTION CSEC
         CBAL  ,INTIL02            LINK TO NEXT INITIALISATION CSECT
         TITLE 'BUDGIE3N - INITIALISATION PROCESSING'
        SCSECT N                   START CSECT BUDGIE3N
         SPACE 1
***********************************************************************
*        FREEMAIN REDUNDANT CSECTS IF REQUIRED                        *
***********************************************************************
         SPACE 1
         USING POOLDEFN,R9         ESTABLISG STORAGE POOL C/B ADDRESS'Y
INTIL02  EQU   *                   ENTRY POINT IN INITIALISATION CSECT
         TM    YPSWITCH,YPSWFREE   TEST IF FREEMAINS REQUESTED
         NOP   FREEMX              BYPASS IF NOT REQUIRED - SUPPR*SSED
         LH    R10,CSECTNO         SET NO OF CSECTS FOR LOOP
         LA    R9,VBUDG3A          POINT R9 AT 1ST CSECT DEFINITION
FREEM01  TM    POOLSW,POOLUSE      MAY CSECT BE OVERLAID
         BZ    FREEM02             BR IF NOT TO GET NEXT
         L     R0,POOLSIZ          SET SIZE OF CSECT IN R0
         L     R1,POOLADR          SET ADDREES OF CSECT IN R1
       FREEMAIN R,LV=(0),A=(1)     FREE CSECT
         NI    POOLSW,FF-POOLUSE   SET CSECT UNAVAILABLE TO WORK FILE
FREEM02  LA    R9,POOLLGTH(,R9)    POINT AT NEXT CSECT RCORD
         BCT   R10,FREEM01         LOOP BACK IF ANY CSECTS LEFT
FREEMX   EQU   *                   END OF FREEMAIN ROUTINE
         DROP  R9                  DROP CSECT FEFINITION ADDRESSABILITY
         SPACE 5
**********************************************************************
*        FREEMAIN ANY LARGE UNUSED OPERATION CODING                   *
**********************************************************************
         SPACE 1
         L     R10,FREETNO         SET NO OF POTENTIAL AREAS
         LA    R9,FREEE1           POINT R9 AT 1ST TEST DEFINITION
FREEM03  TM    0(R9),POOLUSE       IS TEST REQUIRED FOR THIS RUN
         BO    FREEM04             BR IF TEST REQUIRED
         L     R0,4(R9)            SET SIZE IN R0
         L     R1,0(R9)            SET ADDRESS OF CODIND IN R1
      FREEMAIN R,LV=(0),A=(1)      FREE CORE
FREEM04  LA    R9,8(,R9)           POINT R9 AT NEXT DEFINITION
         BCT   R10,FREEM03         LOOP BACK IF ANY LEFT
         EJECT
***********************************************************************
*        OPEN ALL AVAILABLE FILES                                     *
***********************************************************************
         SPACE 1
         TM    WORK+IOPSSW,IOSWPRES IS WORK DD STAEMENT PRESENT
         BZ    *+8                 BR IF NOT
         OI    BRSWITCH,SWBRWRKP   FLAG THAT WORK IS PRESENT
         NI    WORK+IOPSSW,FF-IOSWPRES SET OFF WORK PRESENT TO AVOID OP
         NI    SYSIN+IOPSSW,FF-IOSWPRES SET SYSIN NOT PRESENT TO AVOID
         IOM   OPEN,SYSUT1,LOOP=IOMMAXDD OPEN ALL AVAILABLE D/S
         TM    BRSWITCH,SWBRWRKP   IS WORK DD STAMENET PRESENT
         BZ    *+8                 BR IF NOT
         OI    WORK+IOPSSW,IOSWPRES RESET TO SHOW WORK DD STATMENT PRES
         OI    SYSIN+IOPSSW,IOSWPRES SET SYSIN PRESENT FOR AUDIT
         EJECT
***********************************************************************
*        ACQUIRE AREA FOR INPUT & REFORMATTED RECORDS                 *
***********************************************************************
         SPACE 1
         CLC   LRECLINT,LRECLUT1   IS INTERNAL LENGTH LESS THAN INPUT
         BH    *+10                BR IF YES
         MVC   LRECLINT,LRECLUT1   FORCE INTRENAL LGTH TO INPUT TO
*                                   PREVENT OVERWRITING C/BS WITH DAYA
         LH    R2,LRECLUT1         GET LENGTH OF SYSUT1 RECORD
         LA    R2,URTNOUT-URTNPARM(,R2) INCREMENT BY USER RTN INFO
         LR    R10,R2              PRESERVE OUTPUT RECORD DISPLACEMENT
         AH    R2,LRECLINT         INCREMENT BY INTERNAL RECORD LENGTH
         CBAL  R4,GETMAIN          GET CORE FOR WORK AREA
         ST    R1,PTRPARM          PRESERVE PTR FOR USER MODULE PROCESS
*                                   THIS IS ALSO THE PLACE IN WHICH
*                                   THE UNMODIFIED INPUT REC IS HELD
         AH    R1,LRECLUT1         POINT AT L/A CONTROL INFO POSN
         ST    R1,PTRPARMU         PRESERVE THIS POINTER AS WELL
         LA    R1,URTNOUT-URTNPARM(,R1) INCREMENT BY LGTH OF CONTROL
*                                   INFO TO POINT AT 'OUTPUT' REC RREA
         ST    R1,SYSUT1+IOPSRECA  TELL SYSUT1 WHERE TO GET-MOVE TO
         EJECT
***********************************************************************
*        ACQUIRE DUMMY BUFFER FOR MISSING DD STATE,MENTS              *
***********************************************************************
         SPACE 1
         USING IHADCB,R3           ESTABLISH DCB ADDRESSABILITY
         LA    R10,IOMMAXDD        SET NO OF DCBS FOR LOOP
         LA    R2,SYSUT1           POINT AT 1ST DCB SWITCH
         SR    R1,R1               ZEROISE WORK REGISTER
DBUFF01  L     R3,IOPSDCB(R2)      POINT R3 AT DCB ADDRESS
         CH    R1,DCBLRECL         IS THIS LRECL LAREGR THAN ANY PREVIO
         BNL   *+8                 BR IF NOT
         LH    R1,DCBLRECL         PRESERVE THIS LRECL AS GREATEST
         LA    R2,IOPSLGTH(,R2)    POINT AT NEXT CB SWITCH
         BCT   R10,DBUFF01         LOOP BACK IF ANY LEFT
         LR    R2,R1               SET LRECL IN R2
         BAL   R4,GETMAIN          ACQUIRE CORE FOR DUMMY BUFFER
         ST    R1,DBUFF            PRESERVE ADDRESS OF DUMMY BUFFER
         LA    R10,IOMMAXDD        RESET DCB COUNT FOR LOOP
         LA    R2,SYSUT1           POINT AT 1ST DCB SWITCH
DBUFF02  NC    IOPSRECA(4,R2),IOPSRECA(R2) DOES BUFFER ADDRESS EXIST
         BNZ   *+8                 AVOID OVERWRITING IF YES
         ST    R1,IOPSRECA(R2)     PRESERVE DUMMY BUFFER ADDRESS IN SWI
         LA    R2,IOPSLGTH(,R2)    POINT AT NEXT DCB SWITCH
         BCT   R10,DBUFF02         LOOP BACK IF ANY LEFT
         DROP  R3                  DROP DCB ADDRESSABILITY
         SPACE 5
***********************************************************************
*        ACQUIRE CORE FOR CONCATENATING SYSUT2 & SYSUY1 RECORDS       *
***********************************************************************
         SPACE 1
*        THIS AREA IS REQUIRED FOR WORK FILE PROCESSING, BUT ONLY IF
*         SF=IN HAS BEEN SPECIFIED.
         SPACE 1
         TM    YPSWITCH,YPSWSFIN   WAS SF=IN SPECIFIED
         BZ    GETSFWAX            BYPASS ROUTINE IF NOT
         LH    R2,LRECLUT2         RETRIEVE LENGTH OF SYSUT2 RECORD
         AH    R2,LRECLUT1         ADD LENGTH OF INPUT RECORD
         CBAL  R4,GETMAIN          ACQUIRE CORE FOR CONCATENATION AREA
         ST    R1,PTRPARM2         PRESERVE ADDRESS OF AREA
GETSFWAX EQU   *                   END OF ROUTINE
         EJECT
***********************************************************************
*        GET BUFFER ADDRESSES AND PRINT HEADINGS                      *
***********************************************************************
         SPACE 1
         CBAL  R4,PRINTLOG         RETRIEVE LOGLIST BUFFER ADDRESS
         CBAL  R4,HEADLOG          WRITE LOGLIST HEADINGS
         CBAL  R4,PRINTBBL         RETRIEVE PRINT BUFFER ADREESS
         EJECT
***********************************************************************
*        GET BUFFER ADDRESSES & PRINT HEADINGS ( CONT'D )             *
***********************************************************************
         SPACE 1
         L     R7,PRINTBB+IOPSRECA RETRIEVE RECORD ADDRESS FOR PRINT
         CBAL  R4,READLIN          RETRIEVE AND PRINT BUDGIE LOGO
         IOM   CLOSE,SYSLIN        CLOSE LOGO DATA SET IF PRESENT
         SPACE 5
***********************************************************************
*        MOVE USER PARM TO WORK AREA                                  *
***********************************************************************
         SPACE 1
         L     R1,SYSUT1+IOPSRECA  RETRIEVE ADDR OF REC AREA || W/A
         LH    R15,UPARMDES        RETRIEVE DISPLACEMENT OF DESTINATION
         AR    R15,R1              ADD ADDRESS OF RECORD || WORK AREA
         LH    R1,UPARMLEN         RETRIEVE EXECUTABLE LENGTH OF USER P
         L     R14,UPARMADR        RETRIEVE ADDRESS OF USER PARM
         LTR   R14,R14             TEST IF USER PARM SIPPLIED
         BZ    *+8                 BR IF NO USER PARM
         EX    R1,MVCKEY           MOVE PARM NTO WORK AREA
         EJECT
***********************************************************************
*        LOAD AND INITIALISE ALL USER ROUTINES                        *
***********************************************************************
         SPACE 1
         USING CB02NTRY,R7         ESTABLISH CB02 ADDRESSABILITY
         TM    YPSWITCH,YPSWNOLD   HAS PRELOADING BEEN SUPPRESSED
         BO    CCLOAD05            BR IF YES TOBYPASS LOADING
         L     R7,PTR1CB02         GET ADDREES OF 1ST CB02
         B     *+8                 BYPASS FORWARD CHAINING
CCLOAD04 L     R7,CB02CB02         GET ADDRESS OF NEXT CB02
         LTRR  R7,R7               TEST FOR END OF CHAIN
         BZ    CCLOAD05            BR IF END OF CHAIN
         TM    CB02SW,SW02URTN     IS THERE A USER ROUTINE
         BZ    CCLOAD04            IF NOT GO GET NEXT CB02
         TM    CB02SW,SW02IRTN     HAS RTN ALRERDY BEEN LOADED
         BO    CCLOAD04            IF YES GO GET NEXT CB02
         LR    R10,R7              POINT R10 AT CB02 (FOR SUBRTN)
         L     R9,PTRPARMU         POINT R9 AT LINKAGE AREA
         SPACE 1
*        SOME BRIGHT SPARKS GO INTO A LOOP IN USER EXIT INITIALISATION,
*         SO ESTABLISH USER ABEND U072 IF DO NOT RETURN WITHIN 5 SECS
         SPACE 1
         STIMER TASK,ABEND72,DINTVL=DINTVL ABEND IF DO NOT RENEW IN 5 S
         CBAL  R4,URTNLOAD         GO LOAD USER RTN & INITIALISE
         B     CCLOAD04            GO GET NEXT CB02
CCLOAD05 EQU   *                   END OF USER ROUTINE LOADING
         DROP  R7                  DROP CB02 ADDRESSABILITY
         L     R7,PRINTBB+IOPSRECA RESET 'PRINT' BUFFER ADDRESS
         EJECT
***********************************************************************
*        DYNAMICALLY ACQUIRE ANY SPARE CORE FOR WORK FILE PROCESSING  *
***********************************************************************
         SPACE 1
         USING POOLDEFN,R5         ESTABLISH CORE POOL DEFN ADDRESS'Y
         NC    GETMMC,GETMMC       IS AMOUNT TO ACQUIRE SET TO ZERO
         BZ    GETCOREX            EXIT IF YES
         TM    BRSWITCH,SWBRNOBC   IS PARM=NOBC SPECIFIED
         BO    GETCOREX            IF YES THEN NO WORK FILE SO EXIT
         LA    R5,GETMMCA          POINT AT 1ST AVAILABLE DEFN
         LA    R10,5               ESTABLISH LOOP OF UP TO 5 BUCKETS
         SR    R1,R1               ZEROISE WORK REGISTER
         NC    GETMSC,GETMSC       AS AMOUNT OF CORE TO SAVE SPECIFIED
         BNZ   GETCORE1            BR IF YES TO ACQUIRE IT
         TM    WORK+IOPSSW,IOSWPRES DOES WORK DD STAT EXIST
         BZ    GETCORE2            BR IF NO TO AVOID SAVING BUFFERS
         L     R1,WORKMBLK         GET MAX BLOCK SIZE FOR WORK FILE
         SLL   R1,1                DOUBLE IT FOR 2 BUFFERS
         LA    R1,1000(,R1)        ADD 1000 FOR VARIOUS AXTRAS
GETCORE2 LA    R1,1500(,R1)        ADD 1500 TO PLAY SAFE
         ST    R1,GETMSC           SET AS AMOUNT TO PRESERVE
         ST    R1,GETMSCA          SET SAME AMOUNT AS MINIMUM REQUIRED
GETCORE1 GETMAIN VC,LA=GETMSCA,A=GETMMCW2 CONDITIONALLY ACQUIRE CORE
         MVC   GETMSCA(8),GETMMCW2 PRESERVE ADDRESS & LENGTH OF CORE
         LTR   R15,R15             TEST IF CORE AVAILABLE
         BNZ   ABEND68             IF CORE NOT AVAILABLE THEN TERMINATE
GETCORE3 L     R1,GETMMC           GET AMOUNT OF CORE TO ACQUIRE
         S     R1,GETMMCG          SUBTRACT AMOUNT ALREADY ACQUORED
         BZ    GETCORE4            IF ALL ACQUIRED THEN GO FREE SAVED
         ST    R1,POOLSIZ          SET UPPER LIMIT FOR GETMAIN
         MVI   POOLADR+3,X'08'     SET LOWER LIMIT FOR GETMAIN
         MVC   GETMMCWA(8),POOLADR SET UPPER & LOWER LIMIT IN W/A
      GETMAIN  VC,LA=GETMMCWA,A=GETMMCW2 CONDITIONALLY ACQUIRE CORE
         EJECT
***********************************************************************
*        DYNAMICALLY ACQUIRE COR  ( CONT'D )                          *
***********************************************************************
         SPACE 1
         MVC   POOLADR(8),GETMMCW2 MOVE ADDRESS AND SIZE TO POOL DEFN
         LTR   R15,R15             TEST IF CORE AVAILABLE
         BNZ   GETCORE4            IF NOT AVAILABLE GO FREE SAVED CORE
         OI    POOLSW,POOLUSE      FLAG POOL AVAILABLE TO WORK FILE
         L     R1,GETMMCG          RETRIEVE AMOUNT ALREADY ACQUIRED
         A     R1,POOLSIZ          INCREMENT BY THIS AMOUNT
         ST    R1,GETMMCG          PRESERVE UPDATED AMOUNT
         LA    R5,POOLLGTH(,R5)    INCREMENT TO NEXT AVAILABLE POOL
         BCT   R10,GETCORE3        LOOP BACK IF NOT ACQUIRED 5 BUCKETS
         SPACE 5
***********************************************************************
*        FREE CORE PRESERVED FOR SAFETY                               *
***********************************************************************
         SPACE 1
GETCORE4 FREEMAIN V,A=GETMSCA      FREE PRESERVED CORE FOR SAFETY
GETCOREX EQU   *                   END OF DYNAMIC ACQUISITION
         DROP  R5                  DROP POOL DEFN ADDRESSABILITY
         EJECT
***********************************************************************
*        INITIALISE STORAGE POOLS AND WORK FILE                       *
***********************************************************************
         SPACE 1
         OI    VBUDG3N,POOLUSE     FLAG TO OVERLAY TTHIS CSECT
         LH    R1,LRECLUT2         RETRIEVE LENGTH OF SYSUT2 RECORD
         TM    YPSWITCH,YPSWSFIN   WAS SF=IN SPECIFIED
         BZ    *+8                 BR IF NOT SF=IN
         AH    R1,LRECLUT1         ADD LENGTH OF INPUT REORD
         STH   R1,POOLRECL         PRESERVE LRECL IN POOL CONTROL AREA
         CBAL  R4,WORKCAP          INITIALISE STORAGE POOLS & WORKFILE
         EJECT
***********************************************************************
*        ENSURE 1ST CARD IS BATCH CARD                                *
***********************************************************************
         SPACE 1
         CBAL  R4,READUT1          GET 1ST RECORD
         BNE   MAINLNEX            GO TO TERMINATION IF NO INPUT
         CBAL  R4,BCSCAN           DETERMINE IF IT IS A BATCH CARD
         BNE   MAINLNE5            TELL OF ERROR IF NOT BATCH CARD
         MVC   NMS02UT1,NEXTMS02   PRESERVE ADDRESS OF NEXT CB02 C/B
         MVC   NEXTUT1,NEXTSCAN    PRESERVE NEXT BATCH NUMBER
MAINLNE4 CBAL  R4,BATCH330         TRANSFER CONTROL TO B/C NIIT'N
         EJECT
***********************************************************************
*        TELL THAT 1ST CARD IS NOT A BATCH CARD                       *
***********************************************************************
         SPACE 1
MAINLNE5 EQU   *                   TELL THAT 1ST CARD NIT BATCH CARD
         MVC   NEXTMS02,PTR1CB02   POINT AT 1ST C/B LEST PARM=NOBC
         MVC   NMS02UT1,PTR1CB02   POINT AT 1ST C/B LEST PARM=NOBC
         MVI   CURRUT1,X'00'       ENSURE THAT B/C PROCESSING FINDS
*                                   PREV & CURRENT BATCH NUMBERS ARE
*                                   DIFFERENT IN CASE OF 'NOBC',
*                                   OTHERWISE INVALID 'DUP BATCH' MESSA
         TM    BRSWITCH,SWBRNOBC   WAS 'NO B/C' SPECIFIED
         BO    MAINLNE4            GO TO INIT'N IF YES
         LA    R5,10               ESTABLISH ERROR LINE LOOP
MAINLNE3 LINE  BBLINE12,20,(R7),P=Z PRINT ERROR MESSAGE
         BCT   R5,MAINLNE3         PRINT MESSAGE 10 TIMES
         B     ABEND16             GO TERMINATE ABNORMALLY
         SPACE 1
         CNOP  0,8                 ENSURE THAT CSECT LENGTH IS MULT OF8
LGTHN    EQU   *                   END OF CSECT BUDGIE3N
BUDGIE3  CSECT
         DROP  R11                 DROP ADDRESSABILITY FOR BUDGIE3N
         SPACE 1
MAINLNEX CBAL  ,PRINTERM           GO PRINT TERMINATION MESSAGES
         SPACE 1
         TITLE 'BUDGIE3L - MAIN LINE LOGIC: DETAIL CARD PROCESSING'
        SCSECT L                   START CSECT BUDGIE3L
         SPACE 1
***********************************************************************
*        PROCESS DETAIL RECORDS                                       *
***********************************************************************
         SPACE 1
         USING CB02NTRY,R10        ESTABLISH CB02 ADDRESSABILITY
         USING CB11NTRY,R9         ESTABLISH CB11 ADDRESSABILITY
         USING SB11NTRY,R8         ESTABLISH SB11 ADDRESSABILITY
         USING DETAILBB,R7         ESTABLISH REPORT ADDRESSABILITY
DETAIL   SUBIN ,                   PROCESS DETAIL RECORDS
         EJECT
***********************************************************************
*        READ FILE & SET UP DETAIL LINE                               *
***********************************************************************
         SPACE 1
         NI    PSWITCH,PSWULINE    RESET RECORD PROCESSING FLAGS
         NI    BRSWITCH,FF-SWBRDETL SET OFF 'ADD CARD TO LINE' FLAG
         NI    YPSWITCH,FF-YPSWCLST SET OFF 'CARD IMAGE PRINTED' FLAG
         CBAL  R4,READUT1          GET INPUT RECORD
         BE    DETAIL1             GO COBTINUE IF RECORD FOUND
         CBAL  ,BATCH              PASS CONTROL TO B/B REPORT CSECT
DETAIL1  TM    BRSWITCH,SWBRNOBC   IS IT PARM=NOBC
         BO    DETAIL0             BYAPSS B/C TEST IF SO
         CBAL  R4,BCSCAN           TEST IF RECORD IS BATCH CARD
         EJECT
***********************************************************************
*        READ FILE AND SET UP DETAIL LINE                             *
***********************************************************************
         SPACE 1
         BNE   DETAIL0             GO CONTINUE IF RECORD NOT BATCH CARD
         MVC   NMS02UT1,NEXTMS02   PRESERVE ADDRESS OF NE T CB02 C/B
         MVC   NEXTUT1,NEXTSCAN    PRESERVE NEXT BATCH NUMBER
         CBAL  ,BATCH              PASS CONTROL TO B/B REPORT CSECT
DETAIL0  EQU   *                   CONTINUE TO PROCESS DETAIL CARD
         XC    CB02INDD(7),CB02INDD SET OFF DETAIL INDS 00-55
         TM    AFSWITCH,AFSWKIND   ARE INDS 56-99 TO BE PRESERVED
         BO    *+10                BR IF YES
         XC    CB02INDD,CB02INDD   SET OFF ALL DETAIL LEVEL INDICATORS
         NI    PSWITCH,FF-PSWBCARD SHOW NOT PROCESSING B/C
         NI    MASTER,FF-SWMDETL   SET OFF DETAIL SW FOR HEADING
         CP    PRINTBB+IOPSRCNT(4),=P'59' TEST FOR IMMINENT EOP
         BL    DETAIL0B            BR IF NOT NEAR EOP
         CBAL  R4,HEADBB           PRINT B/B REPROT HEADINGS
DETAIL0B MVC   DTBBCARD,0(R6)      MOVE RECORD TO B/B RETORT
         OI    MASTER,SWMDETL      SHOW PROCESSING DETAIL RECORD
         AP    CB02RCNT,ONE        INCREMENT BATCH RECORD COUNT
         MVC   WORKAREA(8),EDITCNO EDIT MASK TO WARK AREA
         AP    CB02LCNT,ONE        INCREMENT CARD NUMBER
         ED    WORKAREA(8),CB02LCNT EDIT CARD NO FOR PRINTING
         AP    CB02RETC,ONE        INCREMEMNT RETAINED COUNT
         MVC   DTBBCNO-2(6),WORKAREA+2 CARD NO TO LINE
         LA    R2,DTBBCARD         POINT R2 AT CARD IMAGE IN THIS LINE
         SR    R1,R1               ZEROISE RU
         IC    R1,CB02PCRN         GET POSN OF CORRECTION REC NO
         LTR   R1,R1               TEST IF REC NO PL SUPPLIED
         BZ    DETAIL0A            BR IF NO REC NUM P
         BCTR  R1,0                DECREMENT TO ALTER LGTH TO DISPLACE
         AR    R2,R1               POINT R2 AT REC NO FLD
         IC    R1,CB02LCRN         GET LGTH OF RECO NO
         LTR   R1,R1               TEST IF LGTH SUPPLIED
         BZ    DETAIL0A            BR IF NO REC NUM PL
         BCTR  R1,0                DECREMENT LGTH FOR EXECUTE
         LA    R14,WORKAREA+7      POINT AT END OF EBCDIC CARD NO
         SR    R14,R1              POINT R14 AT 1ST CHAR REQUIRED
         EX    R1,MVCR14R2         MOVE REC NO TO CARD IMAGE
         EJECT
***********************************************************************
*        READ FILE AND SET UP DETAIL LINE                             *
***********************************************************************
         SPACE 1
DETAIL0A ZAP   BBLNECNT,ZERO       ZEROISE COUNT OD LINES THIS RECORD
         TM    MASTER,SWMNLIST     TEST IF DATA NOT TO BE LISTED
         BO    DETAIL00            BYPASS PRINTING LINE IF NOT
         MVC   DTBBCC,DTBBSPCE     ESTABLISH CARRIAGE CONTROL
         CBAL  R4,PRINTBBL         PRINT B/B LINE
         SP    PRINTBB+IOPSRCNT(4),ULINDECR CEDREMENT L/CNT IF NO SPCE
         SP    BBLNECNT,ULINDECR   REDUCE LINE CNT IF PRINT-NO-SPACE
         EJECT
***********************************************************************
*        DETERMINE CARD TYPE AND IGNORE IF NECESSARY                  *
***********************************************************************
         SPACE 1
DETAIL00 CBAL  R4,DCSCAN           TEST IF RECORD DETAIL TYPE
         BE    DETAIL03            BRANCH IF KNOWN RECORD TYPE
         TM    CB02SW,SW02DROP     DO WE DROP UNKNOWN RECORDS
         BNO   DETAIL01            BR IF NOT DROPPED TO IGNORE
        BBMESS 02                  MOVE DROPPED MESSAGE TO LINE
         MVC   DTBBFLAG-1(6),=C'DELETE' INDICATE REOORD DROPPED
         OI    PSWITCH,PSWDLETE    FLAG TO DELETE RECORD
         B     *+10                BYPASS MOVING 'IGNORED' MESSAGE
         SPACE 1
DETAIL01 EQU   *                   TELL CARD TO BE IGNORED
        BBMESS 01                  MOVE IGNORED MESSAGE TO LINE
         TM    PSWITCH,PSWKIGN     TEST IF RECORD TYPE KNOWN
         BZ    *+10                BR IF UNKNOWN RECORD TYPE
         MVC   DTBBEMSS(2),SPACES  BLANK OUT 'UN'
         OI    PSWITCH,PSWIGN      SET TO SHOW IGNORED
         CBAL  R4,PRINTBBL         PRINR ERROR MESSAGE
         EJECT
***********************************************************************
*        WRITE TO WORK FILE                                           *
***********************************************************************
         SPACE 1
DETAIL02 TM    PSWITCH,PSWDLETE    IS RECORD TO BE DELETED
         BO    DETAL021            BR IF RECORD TO BE DELETED
         LA    R4,DETAL022         SET TO FALL STRAIGHT THROUGH
         SPACE 1
DETAL02B SUBIN SAVE=R4             ENABLE OUTPUT ROUTINE TO BE PERFRMED
         TM    BRSWITCH,SWBRNOBC   IS IT PARM=NOBC
         BZ    DETAL02A            GO WRITE TO WORK IF NOT
         CBAL  R4,PUTUT2           WRITE DIRECT TO SYSUT2
         B     DETAL02C            BYPASS WRITING TO WORK
DETAL02A CBAL  R4,WORKPUT          WRITE RECORD TO WORK FILE
         EJECT
***********************************************************************
*        WRITE TO WORK FILE ( CONT'D )                                *
***********************************************************************
         SPACE 1
DETAL02C SUBOUT RESTORE=R4         GO TO DETAL022 OR RETURN TO TESTWR
DETAL021 CBAL  R4,PUTDLETE         WRITE RECORD TO 'DELETED'
         EJECT
***********************************************************************
*        WRITE TO WORF FILE ( CONT'D )                                *
***********************************************************************
         SPACE 1
         TM    SUSPOUT+IOPSSW,IOSWPRES DOES SUSPENSE FILE EXIST
         BZ    *+10                NO POINT IN DECRENENTING COUNT IF NO
         SP    CB02LCNT,ONE        DECREMENT CARD NO IN BATCH
         SP    CB02RETC,ONE        DECREMENT COUNT OF RETAINED RECORDS
DETAL022 TM    PSWITCH,PSWPRNT     TEST IF LINE WRITTEN YET
         BNZ   DETAL023            BYPASS WRITE IF LINE ALREADY WRITTEN
         TM    PSWITCH,PSWBCARD    IS THIS THE BATCH CARD
         BO    *+12                FORWARD SPACE IF YES
         TM    MASTER,SWMNLIST     IS DATA TO BE LISTED
         BO    DETAIL              DO NOT FORCE FORWARD SPACE IF NOT
         CBAL  R4,PRINTBBL         WRITE LINE TO FORCE FORWARD SPACE
         EJECT
***********************************************************************
*        ENSURE THAT REPORT SPACING IS AS REQUESTED                   *
***********************************************************************
         SPACE 1
DETAL023 TM    PRINTSW,PRSWSPC3    WAS TRIPL APACING REQUESTED
         BZ    DETAL024            BR IF NO TRIPLE REQUEST
         CP    BBLNECNT,=P'2'      HAVE AT LEAST 3 LINES BEEN WRITTEN
         TM    PRINTSW,PRSWSPBL    ARE BLANK SPACING LINES REQUIRED
         BO    *+18                THEN GO SPACE REGARDLESS
         BH    DETAL026            BR IF SPACING ACCOMPLISHED
         BE    *+14                2 LINES ALREADY SO 1 MORE SUFFICES
         MVI   DTBBCC,SPCE2AFT     ESTABLISH DOUBLE SPACE
         COUNT PRINTBB,1           ADJUST LINE COUNT FOR EOP PROCESSIN
         B     DETAL025            GO PRINT LINE
DETAL024 TM    PRINTSW,PRSWSPC2    WAS DOUBLE SPACING REQUESTED
         BZ    DETAL026            BYPASS PRINTING IF NOT
         TM    PRINTSW,PRSWSPBL    IS BLANK SPACING LINE RESUIRED
         BO    *+14                IF YES THEN GO SPACE REGARDLESS
         CP    BBLNECNT,=P'2'      WERE 2 LINES PRINTED ALREADY
         BNL   DETAL026            BR IF SPACING ACCOMPLISHED
DETAL025 CBAL  R4,PRINTBBL         PRINT NECESSARY SPACING LINES
DETAL026 B     DETAIL              GO GE NEXT RECORD
         SPACE 5
***********************************************************************
*        LOCATE CB11 FOR THIS RECORD  TYPE                            *
***********************************************************************
         SPACE 1
DETAIL03 EQU   *                   PROCESS KNOWN RECORD TYPE
         L     R9,CURRMS11         GET ADDRESS OF RELEVANT CB11
         TM    CB11SW,SW11IGN      IS RECORD TO BE IGNORED
         BZ    *+12                BR IF NOT TO BE IGNORED
         OI    PSWITCH,PSWKIGN     SET TO SHOW KNOWN BEING IGNORED
         B     DETAIL01            GO IGNORE RECORD
         L     R8,CB11SB11         GET ADDRESS OF 1ST SB11
         B     *+8                 BYPASS FORWARD CHAINING
         EJECT
***********************************************************************
*        PERFORM TESTS SPECIFIED IN SB11'S                            *
***********************************************************************
         SPACE 1
DETAIL04 EQU   *                   PROCESS SB11 ELEMENTS
         L     R8,SB11SB11         GET ADDRESS OF NEXT SB11
         LA    R8,0(,R8)           PURIFY HIGH-ORDER BYTE
         LTR   R8,R8               TEST FOR END OF CHAIN
         BZ    DETAIL09            BRANCH IF END OF CHAIN
         MVC   ULINEPL,SB11PDC     SET UP FIELD TO BE UNDERLINED
         TM    SB11SW,SW11DTID     TEST FOR A TEST REQUEST
         BNO   DETAIL05            BR IF NOT A ETST RESUEST
         LA    R3,SB11PDC          POINT R3 AT FIELD 'PL'
         TSEL  SB11TID             SELECT & PERFORM DESIRED TEST
         BNH   DETAIL04            IF TEST SATISFIED, GET NXT SB11
         TM    APSWITCH,APSWMS1S   ARE THESE ERRORS FORCED SOFT
         BO    DETAL04S            BR IF YES
         MVC   DTBBFLAG,=C'****'   INDICATE HARD ERROR IN MESSAGE
         OI    PSWITCH,PSWHARD     SET ON HARD ERROR SWITCHFOR CARD
         OI    MASTER,SWMHARD      SET ON HARD ERROR SWITCH FOR BATCH
         AP    CB02HCNT,ONE        INCREMENT COUNT OF HARD ERRORS/BATCH
         B     DETAL04P            GO PRINT ERROR MESSAGE
DETAL04S OI    PSWITCH,PSWSOFT     SET ON SOFT ERROR SWITCH FOR CARD
         OI    MASTER,SWMSOFT      SET ON SOFT ERROR SWITCH FOR BATCH
         AP    CB02SCNT,ONE        INCREMENT COUNT OF SOFT ERRORS/BATCH
DETAL04P CBAL  R4,PRINTBBL         PRINT ERROR MESSAGE
         B     DETAIL04            GET NEXT SB11
         EJECT
***********************************************************************
*        DETERMINE IF FIELD IS NEGATIVE                               *
***********************************************************************
         SPACE 1
DETAIL05 EQU   *                   PRICESS NUNERIC FIELD
         TM    SB11SW2,SW11COND    IS THIS A CONDITIONAL ACCUMULATOR
         BO    DETAIL04            IGNORE IF YES & GET NEXT SB11
         TM    SB11SW,SW11INPD     IS THE INPUT FIELD PACKED DECIMAL
         BO    DETAL05A            BR IF PACKED FIELD
         NI    PSWITCH,FF-PSWNEG   SET OFF NEGATINE FLAG
         MVC   SFTEST,SFDFAULT     ASSUME THAT SIGNED TEST IS REQUIEED
         TM    SB11SW,SW11NGID     TEST IF -VE INDICATED BY A FIELD
         BZ    DETAIL06            BR IF NO SEPARATE -VE INDICATOR
         MVC   SFTEST,SFUVALUE     ESTABLISH TEST FOR UNSIGNED FIELD
         OI    PSWITCH,PSWNEG      ASUME -VE UND IS ON
         TM    SB11SW,SW11NGNZ     TEST IF NON-ZERO FLD AUTO -VE
         BO    DETAIL06            BRANCH IF FDL AUTO -VE
         MVC   WORKAREA,SPACES     BLANK OUT WORK AREA
         LA    R2,WORKAREA         POINT R2 AT WORK AREA
         LA    R3,SB12PNEG         POINT R3 AT PL OF -VE ID
         CBAL  R4,EXTRACT          MOVE -VE ID TO WORK AREA
         CLC   SB12NGID,WORKAREA   SEE IF IDENTIFIER SHOWS -VE
         BE    DETAIL06            BR IF -VE ID ON
         NI    PSWITCH,FF-PSWNEG   SET OFF -VE FLAG
         B     DETAIL06            BR AROUND PACKED FIELD PROCESSING
         SPACE 5
DETAL05A SR    R14,R14             ZEROISE WORK REGISTER
         IC    R14,SB11PDC         RETRIEVE POSN OF INPUT FIELD
         BCTR  R14,0               DECREMENT POSN TO DISPLACEMENT
         AR    R14,R6              POMT AT INPUT FIELD
         SR    R1,R1               ZEROISE WORK REGISTER
         IC    R1,SB11LDC          RETRIEVE LENFTH OF INPUT FIELD
         BCTR  R1,0                DECREMENT FOR EXECUTE
         TM    SB11SW,SW11DBCN     IS THERE AN ASSOC BATCH CARD FIELD
         BZ    DETAL05B            BR IF NOT
         L     R15,SB11CB05        GET ADDRESS OF ASSOC C/B
         EX    R1,SB11AP05         ADD VALUE TO CB05 ACCUMULATOR
DETAL05B TM    SB11SW,SW11DCRN     IS THERE AN ASSOC CONTROL REC FIELD
         BZ    DETAL05C            BR IF NOT
         L     R15,SB11CB04        GET ADDRESS OF ASSOC CB04 C/B
         EX    R1,SB11AP04         ADD VALUE TO CB04 ACCUMULATOR
DETAL05C B     DETAIL04            GO GET NEXT SB11 ELEMENT
         EJECT
***********************************************************************
*        VERIFY FIELD NUMERIC AND ACCUMULATE AS NECESSARY             *
***********************************************************************
         SPACE 1
DETAIL06 LA    R3,SB11PDC          POINT R3 AT PL OF NUMERIC FIELD
         CBAL  R4,SFVERIFY         VERIFY NUMERIC & PACK INTO WORKPACK
         BNH   DETAIL07            BR IF FIELD BLANK OR NUMERIC
         TM    SB11SW,SW11SOFT     TEST IF THIS IS A SOFT ERROR
         BZ    *+16                BR IF HARD ERROR
         OI    PSWITCH,PSWSOFT     SET ON SOFT ERROR SWITCH FOR CARD
         OI    MASTER,SWMSOFT      SET ON SOFT ERROR SWITCH FOR BATCH
         B     *+18                BYPASS SETTING HARD SWITCH
         MVC   DTBBFLAG,=C'****'   INDICATE HARD ERROR IN MESSAGE
         OI    PSWITCH,PSWHARD     SET O HARD ERROR SWITCH FOR CARD
         OI    MASTER,SWMHARD      SET ON HARD ERROR SW FOR BATCH
         AP    CB02HCNT,ONE        INCREMENT COUNT OF HARD ERRORS/BATCH
         CBAL  R4,PRINTBBL         PRINT ERROR MESSAGE
         EJECT
***********************************************************************
*        VERIFY NUMERIC AND ACCUMULATE ( CONT'D )                     *
***********************************************************************
         SPACE 1
DETAIL07 TM    SB11SW,SW11DBCN     TEST IF ASSOC BATCH CARD FIELD EXIST
         BZ    DETAIL08            BR IF OO BATCH CARD FIELD
         L     R1,SB11CB05         RETRIEVE ADDRESS OF CB05
         USING CB05NTRY,R1         ESTABLISH CB05 ADDRESSABILITY
         TM    PSWITCH,PSWNEG      TEST IF FIELD IS -VE
         BO    *+14                BR IF FIELD IS -VE
         AP    CB05BACC,WORKPACK   ADD DETAIL VALUE TO ACCUMULATOR
         B     *+10                BYPASS SUBTRACTION
         SP    CB05BACC,WORKPACK   SUBTRACT DETAIL FROM ACCUMULATOR
         DROP  R1                  DROP CB05 ADDRESSABILITY
DETAIL08 TM    SB11SW,SW11DCRN     TEST IF ASSOC CONTROL RECORD FIELD
         BZ    DETAIL04            IF NO C/R FLD, GET  NEXT SB11
         L     R1,SB11CB04         GET ADDRESS OF ASSOC CB04
         USING CB04NTRY,R1         ESTABLISH CB04 ADDRESSABLIITY
         TM    PSWITCH,PSWNEG      TEST IF FIELD -VE
         BO    *+14                BR IF NEGATIBE
         AP    CB04BACC,WORKPACK   ADD DETAIL VALUE TO ACCUMULATOR
         B     *+10                BYAPSS SUBTRACTION
         SP    CB04BACC,WORKPACK   SUBTRACT DETAIL FROM ACCULULATOR
         DROP  R1                  DRIP CB04 ADDRESSALULITY
         B     DETAIL04            GO GET NEST SB11 ELEMENT
         EJECT
***********************************************************************
*        PERFORM TESTS SPECIFIED BY CB13'S                            *
***********************************************************************
         SPACE 1
DETAIL09 EQU   *                   GET START OF CB13 CHAIN
         L     R8,CB11CB13         GET ADDRESS OF 1ST CB13 ELEMENT
         DROP  R8                  DROP SB11 ADDRESSANILITY
         LA    R4,DETAIL16         SET R4 TO DROP THROUGH
DETAL09A SUBIN SAVE=R4             SAVE DROP THRU OR RETRUN ADDRESS
         USING CB13NTRY,R8         ESTABLISH CB13 ADDRESSABILITY
         B     *+8                 BYAPDS FORWARD CHAINING
         SPACE 1
DETAIL10 EQU   *                   PROCESS CB13 ELEMENTC
         L     R8,CB13CB13         GET NEXT CB13 ADDRESS
         LA    R8,0(,R8)           PURIFY ADDRESS
         LTR   R8,R8               TEST FOR END OF CB13 CHAIN
         BZ    DETAL15B            BR IF END OF CB13 CHAIN
         TM    CB13SW,SW13NTST     TEST IF C/B NO-OPED
         BO    DETAIL10            GO GET NEXT CB13
         ST    R8,CURRCB13         PRESERVE ADDRESS OF CURRENT CB13
         MVC   ULINEPL,CB13PFLD    SET UP FIELD TO BE UNDERLINED
         TM    CB13SW,SW13LIT      TEST IF CB13 CONTAINS COMPARAND
         BZ    DETAIL12            BR IF CB13 APPLIES TO ALL RECORDS
         LA    R5,3                ESTABLISH LOOP FOR 3 ELEMENTS
         LA    R2,WORKAREA         POINT R2 AT WORK AREA
         MVC   WORKAREA,SPACES     BLANK OUT WORK AREA
         LA    R3,CB13PRT1         POINT R3 AT PL OF 1ST COMPONENT
DETAIL11 CBAL  R4,EXTRACT          ADD COMPONENT TO WORK AREA
         LA    R3,2(,R3)           POINT AT NEXT COMPONENT PL
         BCT   R5,DETAIL11         LOOP BACK IF COMPONENTS LEFT
         SR    R1,R1               ZEROISE REGISTER 1
         IC    R1,CB13LTYP         INSERT COMPARISON TYPE INTO R1
         CLC   WORKAREA(L'CB13LIT),CB13LIT COMPARE EXTRACTED DATA & LIT
         CBAL  R4,COMPARE          PERFO RM REQUIRED RELATIOSHIP TEST
         BNE   DETAIL10            GO GET NEXT CB13 IF NOT SATISFIED
         EJECT
***********************************************************************
*        PERFORM TESTS SPECIFIED BY CB13'S ( CONT'D )                 *
***********************************************************************
         SPACE 1
DETAIL12 LA    R5,3                ESTABLISH LOOP OF 3 ELEMENETS
         TM    CB13SW2,SW13INDS    ARE THERE ANY IND TESTS TO BE MADE ?
         BZ    DETAL12D            BYPASS TESTS IF NOT
         LA    R3,CB13IND0         POINT AT 1ST IND TEST BUCKET
DETAL12C CBAL  R4,TESTINDD         TEST IF INDICATOR HAS RIGHT STATUS
         BNE   DETAIL10            GO GET NEXT CB13 IF NOT SATISFIED
         LA    R3,2(,R3)           INCREMENT TO NEXT BUDKET
         BCT   R5,DETAL12C         LOOP BACK IF BUCKETS LEFT
DETAL12D LA    R3,CB13PFLD         POINT R3 AT PL OF FIELD TO BE TESTED
         CLI   CB13TMOD,C'B'       IS A BLANK FIELD VALID
         BNE   DETAL12A            BR IF NOT TO AVOID TEST
         TSEL  SFBLANK             TEST IF FIELD BLANK
         BNH   DETAIL10            BR IF ETEST SATISFIED TO GET NEXT
         MVI   DTBBCARD,C' '       BLANK OUT CARD AREA IN LINE LEST ...
         MVC   DTBBCARD+1(L'DTBBCARD-1),DTBBCARD .. UNDERLINE LEFT.
         MVC   DTBBEMSS(L'DTBBEMSS+1),SPACES BLANK OUT MESSAGE
DETAL12A CLI   CB13TMOD,C'*'       IS 1ST CHAR=* VALID
         BNE   DETAL12B            BR FI NOT TO AVOID TEST
         EJECT
***********************************************************************
*        PERFORM TESTS SPECIFIED BY CB13'S ( CONT'D )                 *
***********************************************************************
         SPACE 1
         TSEL  SFASTRSK            TEST IF FIELD BEGINS WITH ASTERISK
         BNH   DETAIL10            BR IF TEST SATISFIED TO GET NEXT
         MVI   DTBBCARD,C' '       BLANK OUT CARD AREA IN LINE LEST ...
         MVC   DTBBCARD+1(L'DTBBCARD-1),DTBBCARD .. UNDERLINE LEFT.
         MVC   DTBBEMSS(L'DTBBEMSS+1),SPACES BLANK OUT MESSAGE
DETAL12B TSEL  CB13TEST,CB13CBXX   SELECT & PERFORM REQUESTED TEST
         BH    DETAL12E            BR IF TEST FAILED
         TM    APSWITCH,APSWSRTN   ARE WE WITHIN MS40 SUB-ROUTINE
         BO    DETAIL10            GO GET NEXT TEST IF YES
         TM    CB13SW2,SW132TMG    SHOULD WE TERMINATE PROCESSING
         BO    DETAL15B            SIMULATE END-OF-CB13-CHAIN IF YES
         B     DETAIL10            GO GET NEXT CB13
DETAL12E TM    CB13SW,SW13OIND     IS IND SETTING ONLY REQUIRED
         BO    DETAL15A            BR IF SET IND ONLY
         TM    CB13SW,SW13MESS     TEST IF ERROR MESSAGE SUPPLIED
         BZ    *+16                BR IF NO USER MESSAGE
         MVC   DTBBEMSS(L'DTBBEMSS+1),SPACES BLANK OUT DEFAULT MESSAGE
         MVC   DTBBEMSS,CB13MESS   MOVE ERROR MESSAGE TO LINE
         TM    CB13SW,SW13DLET     TEST IF RECORD TO BE DELETED
         BZ    DETAIL13            BR IF RECORD NOT TO BE DELETED
         OI    PSWITCH,PSWDLETE    SHOW RECORD TO BE DELETED
         MVC   DTBBFLAG-1(6),=C'DELETE' SHOW DELETED IN ERROR MESSAGE
         B     DETAIL15            GO WRITE ERROR MESSAGE
         EJECT
***********************************************************************
*        PERFORM TESTSS SPECIFIED BY CB13'S ( CONT'D )                *
***********************************************************************
         SPACE 1
DETAIL13 TM    CB13SW,SW13SOFT     TEST IF ERROR IS SOFT
         BZ    DETAIL14            BR IF ERROR IS HARD
         OI    PSWITCH,PSWSOFT     SET ON SOFT ERROR FLAG  FOR CARD
         OI    MASTER,SWMSOFT      SET ON SOFT ERROR FLAG FRO BATCH
         AP    CB02SCNT,ONE        INCREMENT COUNT OF SOFT ERRORS
         B     DETAIL15            GO WRITE ERROR MESSAGE
DETAIL14 OI    PSWITCH,PSWHARD     SET ON HARD ERRROR FLAG FOR CARD
         OI    MASTER,SWMHARD      SET ON HARD EEROR FLAG FOR BATCH
         AP    CB02HCNT,ONE        INCREMENT COUNT OF HARD ERRORS
         MVC   DTBBFLAG,=C'****'   SHOW HARD ERROR IN MESSAGE
DETAIL15 TM    MASTER,SWMNLIST     ARE ONLY ERRORS BEING LISTED
         BZ    DETAL15D            BR IF NOT COS CAR IMAGE ALREDAY PRT
         TM    YPSWITCH,YPSWCLST   HAS CARD IMAGE ALREADY BEEN PRINTED
         BO    DETAL15D            BR IF YES TO AVOID PRINTING AGAIN
         L     R1,DBUFF            RETRIEVE ADDRESS OF DUMY BUFFER
         MVC   0(133,R1),0(R7)     PRESERVE THIS PRINT LINE
         MVC   0(1,R7),DTBBSPCE    ESTABLISH CARRIAGE CONTROL
         MVC   DTBBEMSS(38),SPACES BLANK OUT BEYOND CARD IMAGE IN LINE
         L     R1,PTRPARM          POINT AT PRESERVED INPUT RECORD IMAG
         MVC   DTBBCARD,0(R1)      MOVE CARD IMAGE TO LINE
         CBAL  R4,PRINTBBL         PRINT LINE WITH INPUT IMAGE
         OI    YPSWITCH,YPSWCLST   FLAG THAT CARD IMAGE PRINTED
         SP    PRINTBB+IOPSRCNT(4),ULINDECR DECREMENT L/CNT IF NO SPACE
         SP    BBLNECNT,ULINDECR   REDUCE LINE COUNT IF PRINT-NO SPCE
         L     R1,DBUFF            RETRIEVE ADRESS OF DUMMY BUFFER
         MVC   0(133,R7),0(R1)     MOVE ORIGINAL LINE BACK TO BUFFER
DETAL15D TM    PRINTSW,PRSWNDTA    IS NO DATA TO BE PRINTED
         BO    DETAL15A            BR IF NO DATA TO BE PRINTED
         CBAL  R4,PRINTBBL         PRINT LINE WITH ERROR MESSAGE
         EJECT
***********************************************************************
*        PERFORM TESTS SPECIFIED BY CB13'S ( CONT'D )                 *
***********************************************************************
         SPACE 1
DETAL15A CBAL  R4,SETINDS          SET ERROR INDICATORS
         MVC   DTBBEMSS(L'DTBBEMSS+1),SPACES BLANK OUT MESSAGE
         MVI   DTBBCARD,C' '       BLANK OUT CARD AREA IN LINE LEST ...
         MVC   DTBBCARD+1(L'DTBBCARD-1),DTBBCARD ... UNDERLINE LEFT IN
         TM    APSWITCH,APSWSRTN   ARE WE WITHIN SUBROUTINE
         BO    DETAL15C            IGNORE TERMINATION REQUEST IF YES
         TM    CB13SW2,SW132TMB    SHOULD WE TERMINATE POCESSING
         BO    DETAL15B            SIMULATE END OF CB13 CHAIN IF YES
DETAL15C B     DETAIL10            GO GET NEXT CB13
DETAL15B SUBOUT RESTORE=R4         DROP THRU OR RETURN TO BATCH AS NEC
         EJECT
***********************************************************************
*        PERFORM USER ORUTINE IF NECESSARY                            *
***********************************************************************
         SPACE 1
DETAIL16 EQU   *                   INVOKE USER RTN IF REQUIRED
         LA    R4,DETAIL17         SET TO DROP THROUGH ROUTINE
DETAL16A SUBIN SAVE=R4             PRESERVE RETURN ADDRESS
         TM    CB02SW,SW02URTN     TEST IF USER RTN REQUIRED
         BZ    DETAL16B            BR IF USER RTN NOT REQUIRED
         CBAL  R4,URTNCALL         INVOKE USER RTN
DETAL16B SUBOUT RESTORE=R4         RETURN OR DROP THRU AS APPROPRIATE
         SPACE 1
DETAIL17 B     DETAIL02            WRITE FIOE TO WORK & GET NEXT RECORD
         DROP  R10,R9,R8           DROP CONTROL BLOCK ADDRESSABILITY
         DROP  R7                  DROP B/B REPORT ADDRESSABILITY
         SPACE 1
         CNOP  0,8                 ENSURE CSECT LENGTH IS MULTIPLE OF 8
LGTHL    EQU   *                   END OF SCECT BUDGIE3L
         DROP  R11                 DROP BUDGIE3L ADDRESSABILITY
         TITLE 'BUDGIE3E - BATCH CARD PROCESSING'
        SCSECT E
***********************************************************************
*        PROCESS BATCH CARDS                                          *
***********************************************************************
         SPACE 1
         USING CB02NTRY,R10        ESTABLISH CB02 ADDRESSABILITY
         USING CB05NTRY,R9         ESTABLISH CB05 ADDRESSABILITY
         USING DETAILBB,R7         ESTABLISH B/B REPORT ADDRESSABILITY
BATCH    SUBIN ,                   PROCES BATCH CARDS
         NI    MASTER,FF-SWMDETL   SET OFF 'DETAIL' SWITCH
         SPACE 4
***********************************************************************
*        PERFORM ANY BATCH LEVEL TESTS                                *
***********************************************************************
         SPACE 1
         L     R8,CB02CB14         GET ADDRESS OF 1ST BATCH LEVEL TEST
*        NOTE THAT THIS POINTER REALLY POINTS AT A CB13.  THE CB13
*         POINTS AT THE RELEVANT CB14.
         BLANK (R7),,SPCE1AFT      BLANK OUT PRINT LINE BUFFER
*                                  THIS IS NECESSARY BECAUSE THE BUFFER
*                                   WILL NOT BE BLANK IF :-
*                                   A) ERRORS ONLY ARE BEING PRINTED  &
*                                   B) LAST RECORD IN INPUT CONTAINED
*                                      NO ERRORS
         CBAL  R4,BATCHBBL         PRINT BLANK LINE
         CBAL  R4,DETAL09A         PERFORM BATCH LEVEL TESTS
         EJECT
***********************************************************************
*        PREPARE TO PRINT CONTROL TOTALS                              *
***********************************************************************
         SPACE 1
         TM    APSWITCH,APSWMS05   IS THERE ANY BALANCING TO REPORT ON
         BZ    BATCH12             BYPASS UNNECESSARY PROCESSING IF NO
         OI    BRSWITCH,SWBRRCNT   SHOW CARD COUNT FOR THIS TOTAL LINE
         MVC   CURRCB05,CB02CB05   PRESERVE ADDRESS OF 1ST CB05
BATCH0   COUNT PRINTBB,14          FORCE LINE COUNT TO INCLUDE BATCH
*                                   TOTAL LINE REQUIREMENTS.  IF TOO
*                                   CLOSE TO EOP, THEN THE FOLLOWING
*                                   CBAL WILL FORCE A PAGE SKIP SO THAT
*                                   THE TOTALS ARE NOT SPLIT ACROSS PGE
         CBAL  R4,BATCHBBL         PR BL LINE & TEXT IF SPCE LEFT
         COUNT PRINTBB,-14         DECREMENT LINE COUNT TO TRUE VALUE
         CBAL  R4,BATCHBBL         PRINT 2ND BLANK LINE
         EJECT
***********************************************************************
*        ESTABLISH CONTROL TOTAL HEADINGS                             *
***********************************************************************
         SPACE 1
BATCH00  LA    R5,6                ESTABLISH LOOP OF 6 CB05 ELEMENTS
         TM    BRSWITCH,SWBRRCNT   TEST IF RECORD COUNT FOR THIS LINE
         BZ    *+10                BYPASS HEADING IF NOT
         MVC   TTBBCNT,BBLINE14    MOVE RECORD COUNT HEADING TO LINE
         L     R9,CURRCB05         GET 1ST CB05 FOR THIS TOTLA LINE
         LA    R8,TTBBFLD1         POINT R8 AT 1ST REPORT BUCKET
         B     *+8                 BYPASS FORWARD CHAINING
BATCH01  L     R9,CB05CB05         GET ADDRESS OF NEXT CB05 ELENENT
         LTRR  R9,R9               PURIFY & TEST FOR END OF CHAIN
         BZ    BATCH02             BR IF END OF CHAIN TO PRINT LINE
         TM    CB05SW,SW05TST      IS THIS A TEST REQUEST
         BO    BATCH01             IF YES, GET NEXT CB05 ELEMENT
         TM    CB05SW,SW05DPRT     DO WE ONLY PRINT IF DISCREPANCY
         BZ    *+14                BR IF NOT TO ALWAYS PRINT
         CP    CB05BVAL,CB05BACC   ARE BATCH CARD AND DETAIL VALUES SAM
         BE    BATCH01             NO DISCREPANCY SO IGNORE
         MVC   0(16,R8),CB05LNE1   ADD HEADING LINE TO REPORT
         LA    R8,19(,R8)          INCREMENT TO NEXT REPORT BUCKET
         BCT   R5,BATCH01          GO GET NEXT CB05 IF LOOP LEFT
BATCH02  CBAL  R4,BATCHBBL         PRINT TOTAL LINE
         MVI   DTBBCC,SPCE2AFT     ESTABLISH DOUBLE SPACE
         TM    BRSWITCH,SWBRRCNT   TEST IF RECORD COUNT FOR THIS LINE
         BZ    *+10                BYPASS HEADING IF NOT
         MVC   TTBBCNT,BBLINE15    ADD ' COUNT' TO TOTAL LINE
         LA    R5,6                ESTABLISH LOOP OF 6 CB05 ELEMENTS
         LA    R8,TTBBFLD1         POINT R8 AT 1ST REPORT BUCKET
         L     R9,CURRCB05         POINT R9 AT 1ST CB05 FOR FHIS SET
         B     *+8                 BYPASS FORWARD CHAINING
BATCH03  L     R9,CB05CB05         GET NEXT CB05 IN CHAIN
         LTRR  R9,R9               PURIFY & TEST FOR END ON CHAIN
         BZ    BATCH04             BR IF END OF CHAIN TO PRINT LINE
         TM    CB05SW,SW05TST      IS THIS A TEST REQUEST
         BO    BATCH03             GO GET NEXT CB05 IF TEST REQ
         TM    CB05SW,SW05DPRT     DO WE ONLY PRINT IF DISCREPANCY
         BZ    *+14                BR IF NOT TO ALWAYS PRINT
         CP    CB05BVAL,CB05BACC   ARE BATCH CARD AND DETAIL VALUES SAM
         BE    BATCH03             NO DISCREPANCY SO IGNORE
         MVC   0(16,R8),CB05LNE2   SECOND HEADING LINE TO LINE
         LA    R8,19(,R8)          INCREMENT TO NEXT LINE BUCKET
         BCT   R5,BATCH03          LOOP BACK IF BUCKETS LEFT
         EJECT
***********************************************************************
*        PRINT BATCH CARD VALUES                                      *
***********************************************************************
         SPACE 1
BATCH04  CBAL  R4,BATCHBBL         PRINT LINE + FOLLOWING SPACE
         MVI   DTBBCC,SPCE2AFT     ESTABLISH NEXT DOUBLE SPACE
         LA    R5,6                ESTABLISH LOOP OF 6 BUCKETS
         LA    R8,TTBBFLD1-1       POINT R8 AT 1ST REPORT BUCKET
         L     R9,CURRCB05         GET ADDRESS OF 1ST CB05 FOR THIS SET
         MVC   TTBBTEXT,BBLINE16   MOVE 'BATCH CARD' TO LINE
         TM    BRSWITCH,SWBRRCNT   TEST IF CARD COUNT IN THIS SET
         BZ    BATCH05+4           BR IF CARD COUNT NOT REQUIRED
         TM    CB02SW,SW02RCNT     DOES BATCH CARD HVE RECORC COUNT
         BZ    BATCH05+4           BR IF NO BATCH CARD RECORD COUNT
         MVC   TTBBCNT,EDITPL3     EDIT MASK TO LINE
         ED    TTBBCNT,CB02CNTR    EDIT RECORD COUNT FROM BATCH CARD
         B     *+8                 BYPASS FORWARD CHAINING
BATCH05  L     R9,CB05CB05         GET ADDRESS OF NEXT CB05
         LTRR  R9,R9               PURIFY & TEST FOR END OF CHAIN
         BZ    BATCH06             BR IF END OF CHAIN
         TM    CB05SW,SW05TST      IS THIS A TEST REQUEST CB05
         BO    BATCH05             BR IF YES TO GET NEXT CB05 IN CHAIN
         TM    CB05SW,SW05DPRT     DO WE ONLY PRINT IF DISCREPANCY
         BZ    *+14                BR IF NOT TO ALWAYS PRINT
         CP    CB05BVAL,CB05BACC   ARE BATCH CARD AND DETAIL VALUES SAM
         BE    BATCH05             NO DISCREPANCY SO IGNORE
         LA    R1,CB05BVAL         POINT AT VALUE TO BE EDITED
         CBAL  R4,FLDEDIT          EDIT VALUE FILED
         LA    R8,19(,R8)          NNCREMENT TO NEXT BUCKET
         BCT   R5,BATCH05          LOOP BACK IF BUCKETS LEFT
         EJECT
***********************************************************************
*        PRINT ACCUMULATED VALUES                                     *
***********************************************************************
         SPACE 1
BATCH06  CBAL  R4,BATCHBBL         WRITE PRINT LINE
         MVI   DTBBCC,SPCE2AFT     ESTAVLISH DOUBLE SPACE
         LA    R5,6                ESTABLISH LOOP OF 6 BUCKETS
         LA    R8,TTBBFLD1-1       POINT R8 AT 1ST REPORT BUCKET
         L     R9,CURRCB05         GET ADDR OF 1ST CB05 FOR THIS SET
         MVC   TTBBTEXT,BBLINE17   ADD MESSAGE TO START O FLINE
         TM    BRSWITCH,SWBRRCNT   ARE WE PRODUCINR REC CNT FOR THIS SE
         BZ    BATCH07+4           BR IF N REC CNT FOR THIS SET
         MVC   TTBBCNT,EDITPL3     EDIT MASK TO LINE
         ED    TTBBCNT,CB02RCNT    EDIT CALCULATED REC CNT
         B     *+8                 BYPASS FORWARD CHAINING
BATCH07  L     R9,CB05CB05         GET NEXT CB05 IN CHAIN
         LTRR  R9,R9               PURIFY & TEST FOR END OF CHAIN
         BZ    BATCH08             BR IF END OF CHAIN
         TM    CB05SW,SW05TST      IS THIS A TEST REQUEST CB05
         BO    BATCH07             BR IF YES TO GET NEXT CB05 IN CHAIN
         TM    CB05SW,SW05DPRT     DO WE ONLY PRINT IF DISCREPANCY
         BZ    *+14                BR IF NOT TO ALWAYS PRINT
         CP    CB05BVAL,CB05BACC   ARE BATCH CARD AND DETAIL VALUES SAM
         BE    BATCH07             NO DISCREPANCY SO IGNORE
         LA    R1,CB05BACC         POINT AT VALUE TO BE EDITED
         CBAL  R4,FLDEDIT          EDIT VALUE FILED
         LA    R8,19(,R8)          INCREMENT TO NEXT BICKET
         BCT   R5,BATCH07          LOOP BACK IF BUCKETS LEFT
         EJECT
***********************************************************************
*        PRINT DIFFERENCES IF ANY
***********************************************************************
         SPACE 1
BATCH08  CBAL  R4,BATCHBBL         PRINT REPORT LINE
         LA    R5,6                ESTABLISH LOOP OF 6 BUCKETS
         LA    R8,TTBBFLD1-1       POINT R8 AT 1ST REPORT BUCKET
         L     R9,CURRCB05         GET ADDRESS OF 1ST CB05 FOR THIS SET
         MVC   TTBBTEXT,BBLINE18   ADD MESSAGE TO START OF LINE
         TM    BRSWITCH,SWBRRCNT   ARE WE PODUCING REC CNT FIR THIS SET
         BZ    BATCH09+4           BR IF NO REC CNT REQUIRED
         TM    CB02SW,SW02RCNT     DOES B/C RECORD COUNT EXIST
         BZ    BATCH09+4           BR IF B/C REC CNT DOES NOT EXIST
         SP    CB02CNTR,CB02RCNT   DETERMINE DIFFERENCE IF ANY
         BZ    BATCH09+4           BR IF DIFERENCE ZERO
         MVC   TTBBCNT,EDITPL3     EDIT MASK TO INE
         ED    TTBBCNT,CB02CNTR    EDIT DIFFERENCE INTO LINE
         BNL   *+8                 BR IF DIEFERENECE NOT -BE
         MVI   TTBBCNT+L'TTBBCNT-1,C'-' MOVE MINUS SIGN BEHIND DIFF
         OI    MASTER,SWMBALNC     SET TO SHOW OUT OF BALANCE
         TM    CB02SW,SW02RCSF     TEST IF ERROR IS SOFT
         BZ    *+12                BR IF ERROR IS HARD
         OI    MASTER,SWMSOFT      SET ON SOFT ERROR SWITCH
         B     *+8                 BYPASS SETTING HARD SW
         OI    MASTER,SWMHARD      SET ON HARD ERROR SW
         B     *+8                 BYPASS FORWARD CHAINING
BATCH09  L     R9,CB05CB05         GET NEXT CB05 IN LINE
         LTRR  R9,R9               PURIFY & TEST FOR END OF CHAIN
         BZ    BATCH11             BR IF END OF CHAIN
         TM    CB05SW,SW05TST      IS THIS A TEST EQUEST CB05
         BO    BATCH09             GET NEXT CB05 IF THIS IS TEST
         TM    CB05SW,SW05DPRT     DO WE ONLY PRINT IF DISCREPANCY
         BZ    *+14                BR IF NOT TO ALWAYS PRINT
         CP    CB05BVAL,CB05BACC   ARE BATCH CARD AND DETAIL VALUES SAM
         BE    BATCH09             NO DISCREPANCY SO IGNORE
         ZAP   WORKPACK,CB05BVAL   PUT B/C VALUE IN WORK AREA
         TM    CB05SW,SW05BAL      IS BATCH VALUE BALABCING
         BZ    *+14                BRANCH FI B/C ALGEBRAIC
         AP    WORKPACK,CB05BACC   DETERMINE BALANCING DIFFERENCES
         B     *+10                BYPASS ALGEBRAIC SUBTRACTION
         SP    WORKPACK,CB05BACC   DETERMINE DIFFERENCE IF ANY
         BZ    BATCH10             BR IF NO DIFFERENCE
         LA    R1,WORKPACK         POINT AT VALUE TO BE EDITED
         CBAL  R4,FLDEDIT          EDIT VALUE FILED
         OI    MASTER,SWMBALNC     SET ON OUT OF BALANCE SW
         TM    CB05SW,SW05SOFT     TEST IF ERROR OS SOFT
         BZ    *+12                BR IF ERROR IS HARD
         OI    MASTER,SWMSOFT      SET ON SOFT ERROR SW
         B     *+8                 BYPASS SETTINT HARD ERROR SW
         OI    MASTER,SWMHARD      SET ON HARD ERROR SW
         EJECT
***********************************************************************
*        PRINT DIFFERENCES IF ANY ( CONT'D )                          *
***********************************************************************
         SPACE 1
BATCH10  LA    R8,19(,R8)          INCREMENT TO NEXT REPORT BUCKET
         BCT   R5,BATCH09          LOOP BACK IF BUCKETS LEFT
BATCH11  CBAL  R4,BATCHBBL         PRINT REPORT LINE
         COUNT PRINTBB,4           INCREMENT LINE COUNT FOR DOUBLE SPAC
         NI    BRSWITCH,FF-SWBRRCNT SHOW REC CNT NOT REQUIRED FOR NEXT
         LTRR  R9,R9               TEST IF LAST TOTAL GOT END OF CHAIN
         BZ    BATCH12             BR IF END OF CHAIN REACHED
         L     R9,CB05CB05         GET ADDRESS OF NEXT CB05
         LTRR  R9,R9               TEST IF THIS IS END OF CHAIN
         BZ    BATCH12             BR IF END OF CHAIN REACHED
         ST    R9,CURRCB05         PRESERVE START OF THIS CB05 SET
         B     BATCH0              GO CREATE NEXT TOTAL LINE SET
         EJECT
***********************************************************************
*        TELL WHETHER BATCH BALANCED, ACCEPTED, ETC                   *
***********************************************************************
         SPACE 1
BATCH12  MVI   DTBBCC,SPCE2AFT     ESTABLISH DOUBLE SPACE
         CBAL  R4,BATCHBBL         PRINT 2 BL LINES
         COUNT PRINTBB,1           INCREMENT LINE COUNT
         MVI   95(R7),C'*'         MOVE * TO START OF MESSAGE AREA ....
         MVC   96(37,R7),95(R7)     ... AND PROPAGTE ACROSS THE LINE
         AP    CNTREJ,ONE          ASSUME REJECTED & INCREMENT COUNT
         LINE  BBLINE19,3,(R7),P=N ASSUNE DUP INPUT BATCH NO
         MVC   3+L'BBLINE19(L'BBLINE08,R7),BBLINE08 'FROM SYSTEM'
         TM    DUPLICAT+IOPSSW,IOSWPRES IS DUPLICAT FILE PRESENT
         BZ    *+10                BR IF NOT
         MVC   3+L'BBLINE19(L'BBLINE20,R7),BBLINE20 'TO DUPLICATE'
         TM    MASTER,SWMDUPIN     IS THIS BATCH NO = LAST
BRUT1DUP BO    BATCH13             GO PRINT LINE IF YES
         MVI   3(R7),C' '          BLANK OUT ....
         MVC   4(80,R7),3(R7)       .... MESSAGE AREA
         LINE  BBLINE05,3,(R7),P=N ASSUME BATCH NO ALREADY IN LOG
         MVC   3+L'BBLINE05(L'BBLINE08,R7),BBLINE08 'FROM SYSTEM'
         TM    DUPLICAT+IOPSSW,IOSWPRES IS 'DUPLICAT' PRESENT
         BZ    *+10                BR IF NOT
         MVC   3+L'BBLINE05(L'BBLINE20,R7),BBLINE20 ' TO DUPLICATE'
         TM    MASTER,SWMDUPLG     TEST IF BATCH NO IS DUPLICATED
         BO    BATCH13             GO PRINT LINE IF YES
         MVI   3(R7),C' '          BLANK OUT ....
         MVC   4(80,R7),3(R7)       .... MESSAGE AREA
         LINE  BBLINE03,3,(R7),P=N   ASSUME OUT OF BALANCE & REJECTED
         MVC   3+L'BBLINE03(L'BBLINE08,R7),BBLINE08 MESSAGE TO LINE
         TM    SUSPOUT+IOPSSW,IOSWPRES IS SUSPENSE FILE PRESENT
         BZ    *+10                BR IF NO SUSPENSE
         MVC   3+L'BBLINE03(L'BBLINE07,R7),BBLINE07 MESSAGE TO LINE
         TM    MASTER,SWMBALNC+SWMHARD TEST IF OUT OF BALANCE & REJECTE
         BO    BATCH13             GO PRINT LINE IF YES
         BLANK (R7),90             BLANK OUT MESSAGE
         EJECT
***********************************************************************
*        TELL WHETHER BATCH BALANCED, ACCEPTED, ETC ( CONT'D )        *
***********************************************************************
         SPACE 1
         LINE  BBLINE04,3,(R7),P=N   ASSUME IN BALANCE - REJECTED
         MVC   3+L'BBLINE04(L'BBLINE08,R7),BBLINE08 MESSAGE TO LINE
         TM    SUSPOUT+IOPSSW,IOSWPRES TEST IF SUSPENSE FILE EWISTS
         BZ    *+10                BR IF NO SUSPENSE
         MVC   3+L'BBLINE04(L'BBLINE07,R7),BBLINE07 MESSAGE TO LINE
         TM    MASTER,SWMHARD      TEST IF REJECTED
         BO    BATCH13             GO PRINT LINE IF YES
         BLANK (R7),133            BLANJ OUT MESSAGES & ****
         SP    CNTREJ,ONE          BATCH NOT REJECTED SO DECREMENT COUN
         AP    CNTACC,ONE          INCREMENT COUNT OF ACCEPTED BATCHES
         LINE  BBLINE02,3,(R7),P=N   ASSUME OUT OF BALANCE BUT ACCEPTED
         TM    MASTER,SWMBALNC     TETS IF OUT OF BALANCE
         BO    BATCH13             GO PRINT LINE IF OUT OF BALANCE
         BLANK (R7),90             BLANK OUT MESSAGE
         LINE  BBLINE01,3,(R7),P=N   SHOW BALANCED AND ACCEPTED
BATCH13  MVI   DTBBCC,SPCE3AFT     ESTABLISH TRIPLE SPACE LEST C/R PRT
         CBAL  R4,BATCHBBL         PRINT BATCH ACTION MESSAGE
         TM    MASTER,SWMHARD      WAS THERE A HARD ERROR
         BZ    *+20                BR IF NO HARD ERROR IF BATCH
         CLC   COMPCODE,COND12     IS COND CODD GREATER THAM 12
         BH    *+10                BR IF COND CODE GREATER THAN 12
         MVC   COMPCODE,COND12     SET COND CODE TO 12
         EJECT
***********************************************************************
*        CONSTRUCT CONTROL RECORD IF NESESSARY                        *
***********************************************************************
         SPACE 1
         DROP  R9                  DROP CB05 ADDRESSABILITY
         USING CB03NTRY,R9         ESTABLISH CB03 ADDRSSSABILITY
         USING CB04NTRY,R8         ESTABLISH CB04 ADDRESSABILITY
         TM    MASTER,SWMHARD+SWMDUPIN+SWMDUPLG IS BATCH TO BE REJECTED
         BNZ   BATCH30             IGNORE C/R PROCESSING IF YES
         L     R9,CB02CB03         GET ADDRESS OF C/R C/B
         LTRR  R9,R9               PURIFY & TEST IF PRESENR
         BZ    BATCH30             BRANCH IF NO CONTROL RECORD
         L     R6,DBUFF            POINT R6 AT DUMMY BUFFER AREA
         MVI   0(R6),C' '          MOBE BL TO STRAT OF BUFFER
         LH    R1,LRECLUT2         GET LENGHT OF OUTPUT RECORD
         BCTR  R1,0                DECREMENT FOR EXECUTE
         BCTR  R1,0                DECREMENT TO ALOW FOR *+1 START OF
         EX    R1,BTCHMVC1         EXECUTE TO PROPAGATE BLANKS
         SR    R14,R14             ZEROISE WORK REGISTER
         SR    R15,R15             ZEROISE WORK REGISTER
         IC    R14,CB03PCRK        GET POSN OF CONTROL RECORD KEY
         BCTR  R14,0               DECREMENT ( POSN - 1 = DISPLACEMENT)
         AR    R14,R6              PONT R14 AT START OF C/R KEY
         IC R15,CB03LCRK           GET LENFTH OF C/R KEY
         BCTR  R15,0               DECREMENT FOR EXECUTE
         EX    R15,BTCHMVC2        MOVE KET TO CONTROL RECORD
         L     R8,CB03CB04         GET ADDRESS OF 1ST CB04 C/B
         B     *+8                 BYPASS FORWARD CHAINING
BATCH14  L     R8,CB04CB04         GET ADDRESS OF NEXT CB04
         LTRR  R8,R8               PURIFY AND TEST FOR END OF CHAIN
         BZ    BATCH25             BR IF EOC TO PRFORM I/O
         CLC   CB04FNO,=C'RC'      IS THIS A REQUEST FOR THE RECORD COU
         BNE   *+10                BR IF NOT REC CNT
         ZAP   CB04BACC,CB02RCNT   RETRIEVE COMPUTED REC CNT
         SR    R15,R15             ZEROISE WORK REGISTER
         IC    R15,CB04LCRF        GET EXECUTABLE LENGTH OF OUTPUT FIEL
         SR    R14,R14             ZEROISE WORK REGISTER
         IC    R14,CB04PCRF        GET POSN OF OUTPUT FIELD
         BCTR  R14,0               DECREMENT POSN TO DISPLACEMENT
         AR    R14,R6              PINT AT OUTPUT FIELD IN C/R
         TM    CB04SW,SW04BNO      IS THE BATCH NUMBER REQUIRED
         BO    BATCH17             BR IF BNO REQUIRED
         TM    CB04SW,SW04SRC      IS F LD TO BE RETRIEVED FROM W/R
         BO    BATCH18             BR IF YES TO RETRIEVE FIELD
         EJECT
***********************************************************************
*        CONSTRUCT CONTROL RECORD ( CONT4D )                          *
***********************************************************************
         SPACE 1
         TM    CB04BACC+7,X'03'    IS THE SIGN A 'C'
         BNZ   *+8                 BR IF NOT
         OI    CB04BACC+7,X'03'    CHANGE TO 'F' FOR EBCDIC CLARITY
         TM    CB04SW,SW04PACK     IS OUTPUT FIELD TO BE PACKED
         BZ    BATCH15             BR IF NOT
         EX    R15,BTCHMVC3        ZAP ACCUMULATED TOTAL INTO C/R
         B     BATCH14             GO GET NEXT CB04
BATCH15  EX    R15,BTCHMVC4        UNPACJ TOTAL INTO C/R
BATCH16  B     BATCH14             GO GET NEXT CB04
BATCH17  EX    R15,BTCHMVC5        MOVE CURREBT BNO TO C/R
         B     BATCH14             GO GET NEXT CB04
BATCH18  SR    R1,R1               ZEROISE WORJ REGISTER
         IC    R1,CB04PSRC         GET POSN OF SOURE FILED
         BCTR  R1,0                RECREMENT POSN TO DISPLACEMENT
         A     R1,SYSUT1+IOPSRECA  POINT AT FIELD WITHIN REC OR W/S
         EX    R15,BTCHMVC6        RETRIEVE FLD FROM W/S
         B     BATCH14             GO GET NEWT CB04
         EJECT
***********************************************************************
*        WRITE CONTROL RECORD TO 'WORK' AND 'PRINT' AS NECESSARY      *
***********************************************************************
         SPACE 1
BATCH25  EQU   *                   PERFORM NECESSARY I/O
         DROP  R9                  DROP CB05 ADDRESSABILITY
         USING CB03NTRY,R9         ESTABLISH CB03 ADDRESSABILITY
         L     R9,CB02CB03         GET ADDRESS OF CB03 C/B
         TM    CB03SW,SW03LIST     IS C/R TO BE WRITTEN TO PRINT
         BZ    BATCH26             BYPASS PRINTING IF NOT
         MVC   DTBBCARD,0(R6)      MOVE C/R TO PRINT LINE
         MVC   DTBBEMSS(L'BBMESS14),BBMESS14 IDENTIFY AS C/R
         CBAL  R4,BATCHBBL         GO PRINT LINE
BATCH26  TM    CB02SW,SW02WCR      IS CONTRO RECORD TO BE WRITTEN UT2
         BZ    BATCH30             BYPASS FURTHER PROCESSING IF NOT
         TM    CB03SW,SW03POSN     DOES C/R FOLLOW BATCH
         BO    BATCH27             BR IF C/R PRECEDES BATCH
         CBAL  R4,WORKPUT          ADD C/R TO END OF BATCH IN WORK FILE
         B     BATCH30             GO READ BATCH FROM WORKFILE
BATCH27  CBAL  R4,PUTUT2           WRITE C/R DIRECT TO SYSUT2 SO THAT
*                                   IT PRCEDES THE BATCH - IT IS KNOWN
*                                   THAT THE BATCH IS ACCEPETD.
         B     BATCH30             GO READ BATCH FROM WORKFILE
         EJECT
***********************************************************************
*        READ BATCH FROM WORK FILE                                    *
***********************************************************************
         SPACE 1
BATCH30  TM    MASTER,SWMDUPIN+SWMDUPLG IS THIS A DUPLICATE BATCH NO
         BZ    *+12                GO PROCEED IF NOT DUP BATCH NO
         TM    DUPLICAT+IOPSSW,IOSWPRES IS 'DUPLICAT' PREEENR
         BZ    BATCH33             GO REJECT BATCH IF NO
         TM    BRSWITCH,SWBRNOBC   WAS PARM=NOBC SPECIFIED
         BO    BATCH33             RECORD ALREADY WRITTEN TO SYSUT2 IF
         CBAL  R4,WORKOPI          CLOSE WORK AS OUTPUT AND OPEN INPUT
         TM    MASTER,SWMDUPIN+SWMDUPLG IS THIS A DUPLIACTE B/NO
         BNZ   BATCH31             BR IF YES TO READ BATCH
         TM    CB02SW,SW02WBC      IS B/C TO BE WTITTEN TO SYSUT2
         BO    BATCH31             BR IF YES
         TM    BRSWITCH,SWBRNOBC   HAS PARM=NOBC BEEN SPECIFIED
         BO    BATCH31             IS YES THEN 1ST CARD NOT B/C SO INCL
         TM    BRSWITCH,SWBRKB+SWBRCRT ?PARM=KEYBREAK + TRAINING C/R
         BO    BATCH31             GO RETRIEVE C/R (1ST RECORD) IF YES
*                                  THIS ASSUMES THAT ALL DETAIL RECORDS
*                                   HAVE BEEN DELETED AND THAT THE
*                                   WORKFILE CONTAINS OMLY THE TRAINING
*                                   CONTROL RECORD.
         TM    MASTER,SWMHARD      IS BATCH TO BE WRITTEN TO SYSUT2
         BO    BATCH31             BR IF NO
         CBAL  R4,WORKGET          RETRIEVE & IGNORE BATCH CARD
         EJECT
***********************************************************************
*        READ BATCH FROM WORK FILE ( CONT'D )                         *
***********************************************************************
         SPACE 1
BATCH31  CBAL  R4,WORKGET          GET RECORD FROM WORK FILE
         EJECT
***********************************************************************
*        READ BATCH FROM WORK FILE ( CONT'D )                         *
***********************************************************************
         SPACE 1
         BNE   BATCH33             BRANCH IF EOND OF FILE
         TM    MASTER,SWMDUPIN+SWMDUPLG IS THIS A DUPLICATE BATCH
         BNZ   BATCH32A            GO WRITE TO 'DUPLICAT' IF YES
         TM    MASTER,SWMHARD      IS BTTCH TO BE ACCEPTED
         BO    BATCH32             BR IF BATCH REJECTED
         CBAL  R4,PUTUT2           WRITE RECORD TO SYSUT2
         B     BATCH31             GO GET NEWT RECORD
BATCH32  TM    SUSPOUT+IOPSSW,IOSWPRES TEST IF SUSPENSE FILE EXISTS
         BZ    BATCH33             BR IF NOT TO AVOID UNNCEC I/O
         TM    YPSWITCH,YPSWSFIN   WAS SF=IN SPECIFIED
         BZ    *+16                BYPASS SF=IN CODING IF NOT
         AH    R6,LRECLUT2         POINT PAST OUTPUT RECORD AT INPUT RE
         CLI   0(R6),X'00'         HAS RECORD ALREADY BEEM WRITTEN
         BE    BATCH31             GO GET NEXT IF ALREADY WRITTEN
*                                   NOTE THAT IF 'WR' IS USED TO CRATE
*                                   EXTRA RECORDS, MORE RECORDS WILL BE
*                                   ON THE WORKFILE THAN WERE ORIGINALL
*                                   READ.  THIS CODING ENSURES THAT THE
*                                   SUSPENSE FILE CONTAINS ONLY 1 COPY
*                                   OF EACH INPUT RECORD
         CBAL  R4,PUTSUSP          WRITE BATCH TO SUSPENSE
         EJECT
***********************************************************************
*        READ BATCH FROM WORK FILE ( CONT'D )                         *
***********************************************************************
         SPACE 1
         B     BATCH31             GO GET NEXT RECORD
BATCH32A CBAL  R4,PUTDUP           GO WRITE TO 'DUPLICAT'
         B     BATCH31             GO GET NEXT RECORD
         EJECT
***********************************************************************
*        PRODUCE BATCH LOG RECORD                                     *
***********************************************************************
         SPACE 1
BATCH33  TM    APSWITCH,APSWLOG    IS BATCH LOG RECORD REQUIRED
         BZ    BATCH33C            BR IF NO LOG WANTED
         TM    MASTER,SWMDUPIN+SWMDUPLG IS THIS A DUPLICATE BATCH NO.
         BNZ   BATCH33C            BYPASS LOG PROCESSING IF YES
         DROP  R9                  DROP CB05 ADDRESSABILTTY
         USING LOGCARD,R9          ESTABLISH LOG ENTRY ADDRESSABILITY
         L     R9,LOGOUT+IOPSRECA  GET ADDRESS OF OUTPUT BUFFER
         MVC   LOGSW,LOGSUSP       ASSUME SUSPENSE / REJECTED
         TM    MASTER,SWMHARD      TEST IF TO BE REJECTED
         BO    BATCH33A            BR IF REJECT
         MVI   LOGSW,C'A'          SHOW BATCH ACCEPTED
         MVC   LOGADTE1,DTEYYDDD   ADD ACCEPTED DATE IN JULIAN FORMAT
         MVC   LOGADTE2,DTEREPRT   ADD ACCEPTED DATE IN REPORT FORMAT
BATCH33A ZAP   LOGLCNT,CB02RETC    RECORDS RETAINED IN BATCH
         CLC   LOGRCNT,SPACES      LEST B/L UPDATED BY CARDS
         BE    *+14                BR IF 'CARDS ENTERED' BLANK
         CP    LOGRCNT,ZERO        DOES 'RECORDS ENTERED' EXIST ALREADY
         BNE   *+10                BR IF IT EXISTS
         ZAP   LOGRCNT,CB02RCNT    COUNT OF RECORDS ENTERED
         MVC   LOGSUBID,SUBID      SUBMITTOR ID
         MVC   SUBID,SPACES        BLANK OUT SUBMITTOR ID
         ZAP   LOGHCNT,CB02HCNT    COUNT OF HARD ERRORS
         ZAP   LOGSCNT,CB02SCNT    COUNT OF SOFT ERRORS
         MVC   LOGBTYPE,CB02BCI    BATCH CARD TYPE
BATCH33B LR    R1,R9               POINT R1 AT WORK AREA
         CBAL  R4,PUTLOG           GO WRITE TO LOGOUT
         DROP  R9                  DROP LOG ENTRY ADDRESSABILITY
         USING CB05NTRY,R9         RE-ESTABLISH CB05 ADDRESSABILITY
BATCH33C EQU   *                   END OF BATCH OG PROCESSING
         EJECT
***********************************************************************
*        INITIALISE FOR NEW BATCH CARD                                *
***********************************************************************
         SPACE 1
BATCH330 CBAL  R4,WORKOPO          PREPARE WORK FILE AS OUTPUT
         TM    SYSUT1+IOPSSW,IOSWEOF TEST IF EOD ON SYSUT1
         BO    MAINLNEX            GO TERMINAT EPGM IF EOD
*
*                                  C/R PROCESSING MAY HAVE OVERWRITTEN
*                                   THE NEW BATCH CARD, SO IT MUST BE
*                                   RESTORED FROM THE SAVE AREA.
         LH    R2,LRECLUT1         GET SYSUT1 RECORD LENGTH
         L     R1,PTRPARM          POINT R1 AT THE RECORD S/A
         L     R3,SYSUT1+IOPSRECA  POINT R3 AT RECORD W/A
         CBAL  R4,VARMOVE          MOVE RECORD TO WORK AREA
         MVC   PREVUT1,CURRUT1     MOVE CURRENT BATCH NO TO LAST
         MVC   CURRSCAN,NEXTUT1    GET NEW BATCH NO
         MVC   CURRUT1,NEXTUT1     PRESERVE NEX AS CURRENT
         CLC   PREVUT1,CURRUT1     IS THIS BATCH NO LESS THAN LAST
BRDUMP20 BH    ABEND20             TELL OF SYSUT1 SEQUENCE ERROR
         MVC   CURRMS02,NMS02UT1   GET NEW CB02 C/B ADDRESS
         L     R10,CURRMS02        ESTABLISH ADDRESS'Y FOR CURR CB02
         AP    CB02CNT,ONE         INCREMENT COUNT OF BATCHES OF THIS T
         XC    CB02INDB(7),CB02INDB SET OFF BATCH INDS 00-55
         TM    AFSWITCH,AFSWKIND   ARE INDS 56-99 TO BE PRESERVED
         BO    *+10                BR IF YES
         XC    CB02INDB,CB02INDB   SET OFF ALL BATCH LEVEL INDICATORS
         XC    CB02INDD,CB02INDD   SET OFF DETAIL LEVEL INDICATORS
         L     R6,SYSUT1+IOPSRECA  RETRIEVE ADDRESS OF CURRENT BUFFER
         ADDR  BB02BNO,D,R2        POINT R2 AT B/NO IN HEADING
         MVC   0(L'BB02BNO,R2),SPACES BLANK OUT OLD B/NO
         LA    R9,5                ESTABLISH LOOP OF 5 COMPONENTS
         LA    R3,CB02PBN1         POINT AT 1ST BATCH NO COMPONENT PL
         EJECT
***********************************************************************
*        INITIALISE FOR NEEW BATCH CARD ( CONT'D )                    *
***********************************************************************
         SPACE 1
BATCH331 CBAL  R4,EXTRACT          ADD BTCH NO COMPONENT TO HEADING
         BCTR  R2,0                DECREMENT TO POINT AT LAST CHAR
         CLI   0(R2),C'-'          WAS LAST CHAR A HYPHEN
         BE    *+12                BYPASS INSERTING HYPHEN
         LA    R2,1(,R2)           INCREMENT TO POINT PAST LAST CHAR
         MVI   0(R2),C'-'          INSERT HYPHEN BETWEEN COMPONENTS
         LA    R2,1(,R2)           INCREMENT POINTER PAST HYPHEN
         LA    R3,2(,R3)           INCREMENT TO NEXT COMPONENT PL
         BCT   R9,BATCH331         LOOP IF COMPONENTS LEDT
         BCTR  R2,0                DECREMENT TO POINT AT LAST HYPHEN
         MVI   0(R2),C' '          BLANK OIT LAST HYPHEN
         ADDR  BB02SUB,D           POINT AT 'SUBMITTOR:' IN HEADING
         MVC   0(L'BB02SUB,R1),SPACES BLANK OUT 'SUBMITTOR'
         ADDR  BB02SID,D,R2        POINT R2 AT SUBMITTOR ID IN HEADING
         MVC   0(L'BB02SID,R2),SPACES BLANK OUT SUBMITTOR ID
         TM    CB02SW2,SW02PID     IS SUBMITTOR ID TO BE PRINTED
         BZ    BATCH333            BR IF NOT
         MVC   0(L'BB02SUB,R1),=C'SUBMITTOR: ' ADD LITERAL TO HEADING
         LA    R9,3                ESTABLISH LOOP OF 3 COMPONENTS
         LA    R3,CB02PID1         POINT AT 1ST COMPONENT PL
BATCH33D CBAL  R4,EXTRACT          ADD SUBMITTOR ID COMPONENT TO HEADIN
         BCTR  R2,0                DECREMENT TO POINT AT LAST CHARACTER
         CLI   0(R2),C'-'          WAS LAST CHAR A HYPHEN
         BE    *+12                BYPASS INSERTING HYPHEN IF YES
         LA    R2,1(,R2)           INCREMENET PAST LAST CHARACTER
         MVI   0(R2),C'-'          INSERT HYPHEN BETWEEN COMPONENTS
         LA    R2,1(,R2)           INCREMENT PPAST HYPFEN
         LA    R3,2(,R3)           INCREMENT TO NEXT COMPONENT
         BCT   R9,BATCH33D         LOOP BACK IF COMPONENTS LEFT
         BCTR  R2,0                DECREMENT TO POINTT AT LAST HYUPHEN
         MVI   0(R2),C' '          BLANK OUT LAST HYPHEN
         LA    R9,3                SET TO LOOP 3 TIMES
         LA    R3,CB02PID1         POINT AT 1ST COMPONENT PL
         MVC   SUBID,SPACES        BLANK OUT SAVE AREA
         LA    R2,SUBID            POINT AT SAVE AREA
         CBAL  R4,EXTRACT          ADD COMPONENT TO STORE
         LA    R3,2(,R3)           INCREMENT TO NEXT COMPONENT
         BCT   R9,*-8              LOOP BACK IF COMPONENTS LEFT
         EJECT
***********************************************************************
*        INITIALISE FOR NEW BATCH CARD ( CONT'D )                     *
***********************************************************************
         SPACE 1
BATCH333 CBAL  R4,HEADBB           PRINT HEADINGS FOR NEW BATCH
         TM    BRSWITCH,SWBRNOBC   IS THERE NO B/C THIS RUN
         BO    BATCH334            AVOID SETTING UP PRINT LINE IF NOBC
         MVC   DTBBCARD,0(R6)      MOVE RECORD TO LINE
         MVC   DTBBCC,DTBBSPCE     ESTABLISH CARRIAGE CONTROL
         ZAP   BBLNECNT,ZERO       ZEROISE COUNT OF LINES THIS RCEORD
         CBAL  R4,BATCHBBL         PERFORM WRITE OF LINE
         SP    PRINTBB+IOPSRCNT(4),ULINDECR DECREMENT LINE COUNT IF
*                                   NO SPACE ON PREVIOUS WRITE
         SP    BBLNECNT,ULINDECR   ZEROISE LINE CNT IF PRINT-NO-SPACE
BATCH334 NI    PSWITCH,PSWULINE    SET OFF PRINT SW'S FOR RECORD
         NI    MASTER,FF-SWMBATCH-SWMDETL SET OFF BATCH-ORIENTED SW'S
         OI    PSWITCH,PSWBCARD    SHOW PROCESSING BATCH CARD
         CLC   PREVUT1,CURRUT1     IS CURRENT BATCH NO = LAST
         BNE   *+16                BR IF NO
         TM    APSWITCH,APSWNSEQ   IS SEQUENCE CHECKING SUPPRESSED
         BO    *+8                 BYPASS SETTING INDICATOR IF YES
         OI    MASTER,SWMDUPIN     SET ON SW TO SWOW DUP INPUT B NO
         ZAP   CB02HCNT,ZERO       ZEROISE BATCH-ORIENTED ACCULULATOR
         ZAP   CB02SCNT,ZERO       ZEROISE BATCH-ORIENTED ACCULULATOR
         ZAP   CB02RCNT,ZERO       ZEROISE BATCH-ORIENTED ACCULULATOR
         ZAP   CB02LCNT,ZERO       ZEROISE CARD NO WITHIN BATCH
         ZAP   CB02RETC,ZERO       ZEROISE COUNT OF RETAINED RCORDS
         EJECT
***********************************************************************
*        SET UP BATCH LOG RCEORD                                      *
***********************************************************************
         SPACE 1
         TM    APSWITCH,APSWLOG    IS BATCH OG RECORD REQUIRED
         BZ    BATCH332            BR IF NOT
         L     R9,LOGOUT+IOPSRECA  GET ADDRESS OF LOG WORK AREA
         DROP  R9                  DROP CB05 ADDRESSABILITY
         USING LOGCARD,R9          ESTABLISH BUFFER ADDRESSABILITY
         MVC   LOGBNO,CURRUT1      MOVE BETCH NO TO RECORD
         MVC   LOGIDTE1,DTEYYDDD   ADD JULIAD ENTRY DATE
         MVC   LOGIDTE2,DTEREPRT   ADD ENTRY DATE IN REPORT FORMAT
         MVC   LOGADTE1,SPACES     BLANK OUT ACCEPTED DATE ( JULIAN )
         MVC   LOGADTE2,SPACES     BLANK OUT ACCEPTED DATE ( REPORT )
         ZAP   LOGRCNT,ZERO        SET 'CARDS ENTERED TO ZERO
         MVC   LOGSUBID,SPACES     BLANK OUT SUBMITTOR ID
         CBAL  R4,GETLOG           GET LOGIN/LOGOUT IN PHASE AND TEST
*                                   FOR DUPLICATE BATCH NO IN LOGIN
         DROP  R9                  DROP BUFFER ADDRESSABILITY
         USING CB05NTRY,R9         RE-ESTABLISG CB05 ADRESSABILITY
BATCH332 EQU   *                   END OF BATCH LOG INITIALISATION
         SPACE 5
***********************************************************************
*        MERGE SUSPIN WITH SUSPOUT                                    *
***********************************************************************
         SPACE 1
         CBAL  R4,GETSUSP          WRITE SUSPIN TO SUSPOUT IF LESS
*                                   THAN CURRENT SYSUT1 BATCH NUMBER
         EJECT
***********************************************************************
*        RETRIEVE CARD COUNT FROM BATCH CARD                          *
***********************************************************************
         SPACE 1
         L     R9,CB02CB05         GET ADDRESS OF 1ST CB05
         TM    CB02SW,SW02RCNT     DOES BATCH CARD CONTIAN RECORD COUNT
         BZ    BATCH35+4           BR IF NO REC CNT TO BE EXTRACTED
         MVC   SFTEST,SFUVALUE     ESTABLISH UNSIGNED TEST
         LA    R3,CB02CNTP         POINT R3 AT RECORD COUNT PL
         CBAL  R4,SFVERIFY         VERIFY NMMERIN & PACK INTO WORKPACK
         BNH   BATCH34             BR IF FLD BL OR NUMERIC
         TM    CB02SW,SW02RCSF     IS RECORD COUNT A SOFT ERROR
         BZ    *+22                BR IF NOT SOFT ERROR
         AP    CB02SCNT,ONE        INCREMENT SOFT ERRROR COUNT FOR BATC
         OI    MASTER,SWMSOFT      SET ON SOFT EEROR SW FOR BATCH
         OI    PSWITCH,PSWSOFT     SET ON SOFT EEROR SW FOR CARD
         B     *+24                BYPASS SETTING HARD SWITCHES
         OI    MASTER,SWMHARD      SET ON HARD ERROR SW FOR BATCH
         OI    PSWITCH,PSWHARD     SET ON HARD ERROR SW FOR CARD
         AP    CB02HCNT,ONE        INCREMENT HARD ERROR COUNT FOR BATCH
         MVC   DTBBFLAG,=C'****'   SOW ERROR IS HARD IN MESSAGE
         CBAL  R4,BATCHBBL         PRINT ERROR MESSAGE
BATCH34  ZAP   CB02CNTR,WORKPACK   PRESERVE B/C RECORD COUNT
         B     *+8                 BYPASS FORWARD CHAINING
         EJECT
***********************************************************************
*        INITIALISE CB05 FIELDS                                       *
***********************************************************************
         SPACE 1
BATCH35  L     R9,CB05CB05         GET ADDRESS OF NEXT CB05
         LTRR  R9,R9               PURIFY & TEST FOR END OF CHAIN
         BZ    BATCH38             BR IF END OF CHAIN
         ZAP   CB05BACC,ZERO       ZEROISE ACCUMULATOR FOR BATCH
         ZAP   CB05BVAL,CB05LVAL   ZEROISE BATCH CARD VALUE OR REFRESH
*                                   LITERAL BALANCING VALUE AS APPROPRI
         TM    CB05SW,SW05VALU     IS VALUE A CONSTANT FROM MS05 CARD
         BO    BATCH35             BR IF YES TO GET NEXT CB05
         TM    CB05SW,SW05TST      IS THIS A ETS REQUEST
         BO    BATCH35             IF TEST, NO INIT SO GET NEXT CB05
         MVC   SFTEST,SFDFAULT     ASSUME SIGNED TEST IS REQUIRED
         NI    PSWITCH,FF-PSWNEG   ASSUME NO -VE ID
         TM    CB05SW,SW05NGID+SW05NGNZ TEST IF -VE ID EXISTS
         BZ    BATCH36             BR IF NO SEPARATE -VE ID
         MVC   SFTEST,SFUVALUE     ESTABLISH TEST FOR UNSIGNED FIELD
         OI    PSWITCH,PSWNEG      ASSUME -VE ID IS ON
         TM    CB05SW,SW05NGNZ     TEST IF NON-ZERO AOTU -VE
         BO    BATCH36             BR IF NON-ZERO AUTO -VE
         MVC   SFTEST,SFUVALUE     ESTABLISH UNSIGNED TEST
         MVC   WORKAREA,SPACES     BLANK OUT WORK AREA
         LA    R2,WORKAREA         POINT R2 AT RECEIVING FIELD
         LA    R3,CB05PNEG         POINT R3 AT PL OF -VE FLD
         CBAL  R4,EXTRACT          MOVE -VE ID TO WORJ AEEA
         CLC   CB05IDNG,WORKAREA   SEE IF IDENTIFEER SHOWS -VE
         BE    BATCH36             BR IF FIELD IS -VE
         NI    PSWITCH,FF-PSWNEG   SET OFF -VE FLAG
BATCH36  LA    R3,CB05PBCF         POINT R3 AT PL OF FIELD IN B/C
         MVC   ULINEPL,CB05PBCF    SET TO UNDERLINE B/C FLD IR ERROR
         CBAL  R4,SFVERIFY         VERIFY NUMERIC & PACCK IN TO WORKARE
         EJECT
***********************************************************************
*        INITIALISE CB05 FIELDS ( CONT'D )                            *
***********************************************************************
         SPACE 1
         BNH   BATCH37             BT IF BL OR NUMERIC
         TM    CB05SW,SW05SOFT     TEST IF THIS IS SOFT ERROR
         BZ    *+16                BR IF HARD
         OI    PSWITCH,PSWSOFT     SET ON SOFT ERROR FLAG FOR CARD
         OI    MASTER,SWMSOFT      SET ON SOFT ERROR FLAG FOR BATCH
         B     *+18                BYPASS SETTING HARD SWITCHES
         MVC   DTBBFLAG,=C'****'   SHOW HARD ERROR IN MESSAGE
         OI    MASTER,SWMHARD      SET ON HARD ERROR SW FOR BATCH
         OI    PSWITCH,PSWHARD     EET IN HARD ERROR SW FOR CARD
         CBAL  R4,BATCHBBL         PRINT ERROR MESSAGE
BATCH37  TM    PSWITCH,PSWNEG      TEST IF FIELD -VE
         BO    *+14                B R TO SUBTRACT IF -VE
         AP    CB05BVAL,WORKPACK   ADD B/C VALUE TO STORE
         B     *+10                BYPASS SUBTRACTION
         SP    CB05BVAL,WORKPACK   PRESERVE B/C VALUE
         B     BATCH35             GO GET NEXT CB05
         EJECT
***********************************************************************
*        INITIALISE CONTROL RECORD CONTROL BLOCKS                     *
***********************************************************************
         SPACE 1
BATCH38  L     R9,CB02CB03         GETT ADDRESS OF ASSOC CB03
         LTRR  R9,R9               PURIFY & TEST IF CB03 EXISTS
         BZ    BATCH40             BT IF NO C/R TO BE PRODUCED
         DROP  R9                  DROP CB05 ADDRESSABILITY
         USING CB04NTRY,R9         ESTABLISH CB04 ADDRESSABILITY
         L     R9,CB03CB04-CB03NTRY(,R9) GET ADDRESS OF 1ST CB04
         B     *+8                 BYPASS FORWARD CHAINING
BATCH39  L     R9,CB04CB04         GET ADDRES OF NEXT CB04
         LTRR  R9,R9               TEST FOR END OF CHAIN
         BZ    BATCH40             BR IF END OF CHAIN
         ZAP   CB04BACC,ZERO       ZEROISE BATCH ACCUMULATOT
         B     BATCH39             GO GET NEXT CB04
         DROP  R9                  DROP CB04 ADDRESSABLLITY
         SPACE 5
***********************************************************************
*        MAKE ANY TESTS REQUESTED                                     *
***********************************************************************
         SPACE 1
BATCH40  L     R8,CB02CB13         GET ADDRESS OF 1ST B/C CB13
         CBAL  R4,DETAL09A         PERFORM ANY CB13 TESTS FOR BATCH CAD
         TM    BRSWITCH,SWBRNOBC   IS THERE NO B/C THIS RUN
         BO    BATCH41             BR IF NO B/C TO PROCESS AS DETAIL
         EJECT
***********************************************************************
*        TRANSFER CONTROL TO APPROPRIATE SECTION OF BUDGIE3L          *
***********************************************************************
         SPACE 1
         CBAL  R4,DETAL16A         PERFROM USER ROUTINE IF ANY
         SPACE 1
         TM    BRSWITCH,SWBRKB     ARE WE RECOGNISING KEYBREAKS
         BO    BATCH41             BR IF YES TO PROCESS AS DETAIL REC
         CBAL  ,DETAIL17           GO TO RELEVANT CODING
         SPACE 1
BATCH41  CBAL  ,DETAIL0            GO PROCESS AS DETAIL REOCRD
         EJECT
***********************************************************************
*        INVOKE ROUTINE PRINTBBL FROM CSECT BUDGIE3E                  *
***********************************************************************
         SPACE 1
*        SUB-CSECT BUDGIE3E ISSUES MANY CALLS TO THE SUB-ROUTINE
*         'PRINTBBL', WHICH IS IN ANOTHER CSECT.  IN ORDER TO REDUCE
*         THE AMOUNT OF GENERATED CODE, PRINTBBL IS INVOKED BY
*         THIS SUB-ROUTINE, WHICH IS THE ONLT ONE TO ESTABLISH
*         THE NECESSARY LINKAGE.
         SPACE 1
BATCHBBL SUBIN SAVE=R4             PRESERVE REGISTER 4
         CBAL  R4,PRINTBBL         PERFORM SUB-ROUTINE
        SUBOUT RESTORE=R4          RETURN TO CALLER
         SPACE 5
BTCHMVC1 MVC   1(0,R6),0(R6)       PROPAGATE BL FOR LGTH OF SYSUT2 RECD
BTCHMVC2 MVC 0(0,R14),CB03CRK-CB03NTRY(R9) MOVE C/R KEY TO BUFFER
BTCHMVC3 ZAP   0(0,R14),CB04BACC   MOVE TOTAL INTO C/R
BTCHMVC4 UNPK  0(0,R14),CB04BACC   UNPACK TOTAL INTO C/R
BTCHMVC5 MVC   0(0,R14),CURRUT1    RETRIEVE CURRENT BATCH NUMBER
BTCHMVC6 MVC   0(0,R14),0(R1)      RETRIEVE FIELD FORM W/S
         SPACE 1
         DROP  R7,R10              DROP C/B ADDRESSABILITY
         CNOP  0,8                 ENSURE CSECT LENGTH IS MULTIPLE OF 8
LGTHE    EQU   *                   END OF CSECT BIDGIE3E
         DROP  R11                 DROP CSECT ADDRESSABILITY
BUDGIE3  CSECT
         TITLE 'BUDGIE3H - INITIALISATION AND PARM PROCESSING'
        SCSECT H
***********************************************************************
*        INITIALISATION CODING ( CSECT BUDGIE3C )                     *
***********************************************************************
         SPACE 1
INITILIZ EQU   *                   START OF INITIALISATION CODING
         SPACE 5
***********************************************************************
*        DETERMINE WHICH DD STATEMENTS ARE PRESENT                    *
***********************************************************************
         SPACE 1
         IOM   TIOTSCAN,SYSUT1,LOOP=IOMMAXDD
         EJECT
***********************************************************************
*        OPEN SYSPRINT
***********************************************************************
         SPACE 1
         IOM   OPEN,SYSPRINT       OPEN SYSPRINT NOW TO MINIMISE FRAG'N
         LA    R1,LINE01           POINT R1 AT MESSAGE POOL
         TM    SYSPRINT+IOPSSW,IOSWPRES IS SYSPRINT PRESENT
         BO    *+8                 BR IF YES
         ST    R1,SYSPRINT+IOPSRECA USE MESSAGE AREA AS DUMMY BUFFER
         CBAL  R4,PRINT3H          ISSUE 1ST PUT TO RETRIEVE BUFFER ADD
         L     R5,SYSPRINT+IOPSRECA RETRIRVE CURRENT BUFFER ADDRESS
         LINE  S=P                 SKIP TO HEAD OF PAGE
         LINE  LINE01,50,S=2       PRINT SYSPRINT HEADING
               SPACE               5
**********************************************************************
*        OPEN SYSUT1                                                  *
**********************************************************************
         SPACE 1
         IOM   OPEN,SYSUT1         OPEN SYSUT1 ( TO GET LRECL )
         EJECT
***********************************************************************
*        REPORT ON DD STATEMENTS PRESENT                              *
***********************************************************************
         SPACE 1
         IOM   AUDIT,SYSUT1,(R5),ABEND12,RTN=PRINT3H,LOOP=IOMMAXDD
         CBAL  R4,PRINT3H          PRINT BLANK LINE
         EJECT
***********************************************************************
*        PROCESS PARM                                                 *
***********************************************************************
         SPACE 1
PARM01   CBAL  R4,PARMGET          RETRIEVE SUBFIELD
         BNE   EOPARM              BRANCH IF PARM EXHAUESTED
         CH    R3,=H'3'            TEST IF SUB-FIELD AT LEAST 4 LONG
         BL    PARMABRV            GO TEST FOR ABBREVIATIONS IF NOT =>3
         BE    PARM02              NO PARM HAS LEN 3 SO INVALID
         CLC   0(3,R2),=C'CB='     TEST FOR CB POOL SPECIFICATION
         BE    PARMCB              BRANCH IF YES TO PROCESS
         CLC   0(3,R2),=C'MB='     TEST FOR MAX BLKSIZE SPECIFICATION
         BE    PARMMB              BRANCH IF YES TO PROCESS
         CLC   0(3,R2),=C'UL='     TEST FOR UNDERLINE SPECIFICATION
         BE    PARMUL              BRANCH IF YESY TP PROCESS
         CLC   0(3,R2),=C'NT='     IS IT TEST TYPE SPECIFICATION
         BE    PARMNT              GO PROCESS IF YES
         CLC   0(4,R2),=C'NOBC'    IS IT 'NO BATCH CARD4
         BE    PARMNOBC            GO PROCESS IF YES
         CLC   0(4,R2),=C'ID=('    IS IT SUBMITTOT ID
         BE    PARMID              GO PROCESS IF YES
         CLC   0(6,R2),=C'BCID=('  IS IT SUBMITTOR ID IN B/C ONLY
         BE    PARMIDB             GO PROCESS IF YES
         CLC   0(5,R2),=C'FDUMP'   IS IT REQUEST FOR TERMINATION DUMP
         BE    PARMFDMP            GO PROCESS IF YES
         CLC   0(5,R2),=C'ADUMP'   IS IT REQUEST FOR FULL DUMP
         BE    PARMADMP            GO PROCESS IF YES
         CLC   0(5,R2),=C'NOSEQ'   IS IT REQUEST TO SUPPRESS SEQ CHECKI
         BE    PARMNSEQ            GO PROCESS IF YES
         CLC   0(4,R2),=C'RCNT'    IS IT REQUEST FOR RECORD COUNT
         BE    PARMRCNT            GO PROCESS IF YES
         CLC   0(6,R2),=C'MS11=S'  IS IT MS11 ERROR SEVERITY LEVEL
         BE    PARMMS11            GO PROCESS IF YES
         CLC   0(7,R2),=C'JUSTIFY' TEST IF RIGHT JUSTIFY REQUEST
         BE    PARMJUST            GO PROCESS IF YES
         CLC   0(7,R2),=C'NOWEEK0' TEST FOR WEEK 0 SUPPRESSION
         BE    PARMWK0             GO PROCESS IF YES
         CLC   0(7,R2),=C'BLSPACE' IS IT REQUEST FOR BLANK SPACING
         BE    PARMBLSP            GO PROCESS IF YES
         CLC   0(7,R2),=C'CC19=98' IS IT CURR CODE 19 CONV REQUEST
         BE    PARMCC19            GO PROCESS IF YES
         CLC   0(9,R2),=C'PUNCHSUSP' IS IT REQUET TO IGNORE SUSP IN LOG
         BE    PARMPUNS            GO PROCESS IF YES
         CLC   0(8,R2),=C'KEYBREAK' IS IT REQUEST TO CHANGE BNO ON KEYB
         BE    PARMKB              BR IF YES
         EJECT
***********************************************************************
*        PROCESS PARM ( CONT'D )                                      *
***********************************************************************
         SPACE 1
         CLC   0(9,R2),=C'MS11=PPPL' IS THIS PPPL REQUEST FOR MS11
         BE    PARMPPPL            BR IF YES TO PROCESS
         CLC   0(9,R2),=C'NOISINDEX' IS IT NO MASTER INDEX REQUEST
         BE    PARMNOIX            BR IF YES TO PROCESS
         CLC   0(7,R2),=C'UPARM=(' IS IT USER PARM
         BE    PARMUPRM            GO PROCESS IF YES
         CLC   0(4,R2),=C'COM='    IS THIS A COMMENT IDENTIFIER
         BE    PARMCOM             BR IF YES TO PROCESS
         CLC   0(4,R2),=C'FREE'    IS THIS REQUEST TO FREEMAIN CSECTS
         BE    PARMFREE            BR IF YES TO PROCESS
         CLC   0(3,R2),=C'MC='     IS THIS AMOUNT OF CORE TO ACQUIRE
         BE    PARMMC              BR IF YES TO PROCESS
         CLC   0(3,R2),=C'SC='     IS THIS AMOUNT OF CORE TO PRESERVE
         BE    PARMSC              BR IFYES TO PROCESS
         CLC   0(6,R2),=C'NOLOAD'  IS THIS REQUEST NOT TO PRELOAD
         BE    PARMNL              BR IF YES TO PROCESS
         CLC   0(5,R2),=C'LCNT='   IS IT LINES/PAGE
         BE    PARMLCNT            BR IF YES TO PROCES
         CLC   0(5,R2),=C'SF=IN'   IS IT SUSP FILE=INPUT REQUEST
         BE    PARMSFIN            GO PROCESS IF YES
         CLC   0(5,R2),=C'NOEOF'   IS I SUPPRESS /*EOF REQUEST
         BE    PARMNEOF            GO PROCESS IF YES
         CLC   0(4,R2),=C'PPL+'    IS IT PPL OVERPUNCH AUTHORISATION
         BE    PARMPLOP            GO PROCESS IF YES
         CLC   0(8,R2),=C'KEEPINDS' ARE INDS 56-99 TO BE PRESERVED
         BE    PARMKIND            BR IF YES TO PROCESS
         CLC   0(6,R2),=C'SEQALL'  IS IT REQUEST FOR SEQ NOS IN ALL C/C
         BE    PARMSEQA            BR IF YES TO PROCESS
PARM02   MVC   5(L'LINE25,R5),LINE25 UNRECOGNISABLE MESSAGE TO LINE
         MVC   5+L'LINE25(40,R5),TESTAREA ADD PARM TO MESSAGE
         CBAL  R4,PRINT3H          PRINT MESSAGE
         B     PARM01              GO GET NEXT SUBFIELD
         EJECT
***********************************************************************
*        PROCESS PARM ( CONT'D ) - RECOGNISE ABBREVIATIONS            *
***********************************************************************
         SPACE 1
PARMABRV EQU   *                   RECOGNISE ABBREVIATED KEYWORDS
         CLC   0(2,R2),=C'NB'      NO BATCH CARD
         BE    PARMNOBC            GO PROCESS IF YES
         CLC   0(2,R2),=C'FD'      REQUEST FOR TERMINATION DUMP
         BE    PARMFDMP            GO PROCESS IF YES
         CLC   0(2,R2),=C'AD'      REQUEST FOR FULL DUMPS
         BE    PARMADMP            GO PROCESS IF YES
         CLC   0(2,R2),=C'NS'      SUPPRESS SEQUEBCE CHECK
         BE    PARMNSEQ            GO PROCESS IF YES
         CLC   0(1,R2),=C'F'       IS THIS REQUEST TO FREEMAIN CSECTS
         BE    PARMFREE            BR IF YES TO PROCESS
         CLC   0(2,R2),=C'RC'      REQUEST FOR RECORD COUNT
         BE    PARMRCNT            GO PROCESS IF YES
         CLC   0(1,R2),=C'J'       RIGHT JUSTIFY REQUEST
         BE    PARMJUST            GO PROCESS IF YES
         CLC   0(2,R2),=C'N0'      SUPPRESS WEEK 0 IN UT458
         BE    PARMWK0             GO PROCESS IF YES
         CLC   0(2,R2),=C'BL'      BLANK SPACING REQUEST
         BE    PARMBLSP            GO PROCESS IF YES
         CLC   0(2,R2),=C'19'      CURR CODE 19 CONVERSION
         BE    PARMCC19            GO PROCESS IF YES
         CLC   0(2,R2),=C'PS'      IGNORE SUSPENSE IN BATCH           O
         BE    PARMPUNS            GO PROCESS IF YES
         CLC   0(2,R2),=C'KB'      CHANGE BNO ON KEY BREAK
         BE    PARMKB              GO PROCESS IF YES
         CLC   0(2,R2),=C'NX'      SUPPRESS MASTER ISAM INDICES
         BE    PARMNOIX            GO PROCESS IF YES
         CLC   0(2,R2),=C'NL'      DO NOT PRELOAD USER EXEIT
         BE    PARMNL              BR IF YES TO PROCESS
         CLC   0(2,R2),=C'MP'      S IT MS11=PPPL
         BE    PARMPPPL            BR IF YES TPPROCESS
         CLC   0(2,R2),=C'MS'      IS IT MS11=SOFT
         BE    PARMMS11            BR IF YES TO PROCESS
         CLC   0(2,R2),=C'SF'      IS IT SUSP FILE=INPUT REQUEST
         BE    PARMSFIN            GO PROCESS IF YES
         CLC   0(2,R2),=C'NE'      IS IT SUPPRESS /*EOF RESUEST
         BE    PARMNEOF            GO PROCESS IF YES
         CLC   0(2,R2),=C'P+'      IS IT PPL OVERPUNCH AUTHORISATION
         BE    PARMPLOP            GO PROCESS IF YES
         CLC   0(2,R2),=C'KI'      ARE INDS 56-99 TO B PRESERVED
         BE    PARMKIND            BR IF YES TO PROCESS
         CLC   0(2,R6),=C'SA'      IS IT REQUEST FOR SEQ NOS IN ALL C/C
         BE    PARMSEQA            BR IF YES TO PROCESS
         B     PARM02              UNKNOWN PARM SO TELL
         EJECT
***********************************************************************
*        PROCESS PARM ( CONT'D ) - CONTROL BLOCK STORAGE POOL         *
***********************************************************************
         SPACE 1
PARMCB   LA    R1,3(,R2)           POINT R1 PAST 'CB='
         LR    R15,R3              SET R15 TO LENGTH OF SUBFIELD
         SH    R15,=H'3'           REDUCE LENGTH TO ALLOW FOR 'CB=
         CBAL  R4,NUMERICH         TEST IF PARM SUBFIELD NUMERIC
         BE    PARM11              BRABCH IF YES
PARMCB01 MVC   5(L'LINE11,R5),LINE11 NON-NUMERIC MESSAGE TO LINE
         MVC   5+L'LINE11(40,R5),TESTAREA ADD PARM TO MESSAGE
         CBAL  R4,PRINT3H          PRINT ERROR MESSAGE
         B     PARM01              GO GET NEXT SUBFIELD
PARM11   EX    R15,SFPACK          PACK SUB-FIELD ( POOL LENGTH )
         CVB   R1,WORKPACK         CONVER LENGTH TO BINARY
         LA    R1,7(,R1)           ROUND SIZE UP TO ....
         N     R1,GETMMASK         ... NEAREST FULLWORD
         ST    R1,GETMLEN          STORE STORAGE POOL LENGTH
EOPARM1  B     PARM01              GO GET NEXT SUBFIELD
         SPACE 5
***********************************************************************
*        PROCESS PARM ( CONT'D ) - MS11 SEVERITY LEVEL                *
***********************************************************************
         SPACE 1
PARMMS11 CLC   5(4,R2),=C'SOFT'    IS 'SOFT' SPECIFIED
         BNE   PARM02              TELL UNKNOWN IF NOT
         OI    APSWITCH,APSWMS1S   SET FLAG TO SHOW SOFT ERRORS
         B     PARM01              GO GET NEXT SUBFIELD
         SPACE 5
***********************************************************************
*        PROCESS PARM ( CONT'D ) - RIGHT JUSTIFY NUMERIC FIELDS       *
***********************************************************************
         SPACE 1
PARMJUST OI    APSWITCH,APSWJUST   SET TO RIGHT JUSTIFY NUMERIC FIELDS
         B     PARM01              GO GET NEXT SUBFIELD
         EJECT
***********************************************************************
*        PROCESS PARM ( CONT'D ) - MAX BLKSIZE FOR WORKFILE           *
***********************************************************************
         SPACE 1
PARMMB   LA    R1,3(,R2)           POINT PAST 'MB='
         LR    R15,R3              SET R15 TO LENGTH OF SUB-FIELD
         SH    R15,=H'3'           REDUCE LENGTH TO ALLOW FOR 'MB='
         CBAL  R4,NUMERICH         TEST IF PARM VALUE NUMERIC
         BNE   PARMCB01            GO TELL OF ERROR IF NOT
         EX    R15,SFPACK          PACK SUB-FIELD ( MAX BLKSIZE )
         CVB   R1,WORKPACK         CONVERT BLKSIZE TO BINARY
         ST    R1,WORKMBLK         PRESERVE MAX BLKSIZE FOR WORK FILE
         B     PARM01
         SPACE 5
***********************************************************************
*        PROCESS PARM ( CONT'D ) - NO BATCH CARD THIS RUN             *
***********************************************************************
         SPACE 1
PARMNOBC OI    BRSWITCH,SWBRNOBC   SET 'NO BATCH CARD'
         B     PARMNSEQ            GO FORCE 'NSEQ' BECAUSE IMPLIED
         SPACE 5
***********************************************************************
*        PROCESS PARM ( CONT'D ) - PRINT RECORD COUNT                 *
***********************************************************************
         SPACE 1
PARMRCNT OI    APSWITCH,APSWMS05   FORCE BALANCING TOTAL LINES
         B     PARM01              GO GET NEXT SUB-FIELD
         SPACE 5
***********************************************************************
*        PROCESS PARM ( CONT'D ) - BLANK SPACING LINES                *
***********************************************************************
         SPACE 1
PARMBLSP OI    PRINTSW,PRSWSPBL    FLAG TO FORCE BLANK SPAXING
         B     PARM01              GO GET NEXT SUBFIELD
         EJECT
***********************************************************************
*        PROCESS PARM ( CONT'D ) - UNDERLINE CHARACTER                *
***********************************************************************
         SPACE 1
         SPACE 1
PARMUL   CH    R3,=H'4'            TEST IF FIELD LENGTH 4
         BNE   PARM02              TELL OF ERROR IF NOT
         MVC   UNDRLINE,3(R2)      MOVE CHAR TO UNDERLINE STORE
         CLI   3(R2),C' '          TEST IF UNSERLINE CHAR A BLANK
         BE    PARMULX             BR IF UNDERLINE NULLIFIED
         CLI   3(R2),C'_'          TEST IF UNDER-SCORE SPECIFIED
         BE    PARMULX             BR IF UNDELINE IS UNDERSCORE
         OI    PSWITCH,PSWULINE    SHOW FORWARD SPACE NEED NOT BE FORCE
         MVI   DTBBSPCE,X'09'      IF UNDERLINE CHAR NOT '_' OR ' '
*                                   THEN MUST SPACE 1 BEFORE MESSGES
         ZAP   ULINDECR,ZERO       ZEROISE DECREMENT OF AUTO LINE COUNT
*                                   FOR CURRENT RECORD, SINCE WE ARE NO
*                                   LONGER PRINTING-NO-SPACE.
PARMULX  B     PARM01              GO GET NEXT SUBFIELD
         SPACE 5
***********************************************************************
*        PROCESS PARM ( CONT'D ) - CURR CODE 19 CONVERSION            *
***********************************************************************
         SPACE 1
PARMCC19 OI    YPSWITCH,YPSWCC19   FLAG TO CONVERT CODE 19
         B     PARM01              GO GET NEXT SUBFIELD
         SPACE 5
***********************************************************************
*        PROCESS APRM ( CONT'D ) - NO /*EOF TO INTRDR                 *
***********************************************************************
         SPACE 1
PARMNEOF OI    YPSWITCH,YPSWNEOF   FLAG TO SUPPRESS /*EOF CARD
         B     PARM01              GO GET NEXT SUBFIELD
         EJECT
***********************************************************************
*        PROCESS PARM ( CONT'D ) - NUMERIC TEST TYPE                  *
***********************************************************************
         SPACE 1
PARMNT   MVC   SFDFAULT,SFNS       ASSUME NS TEST REQUESTED
         MVC   SFUVALUE,SFUS       ESTABLISH US FOR UNSIGNED FIELDS
         CLC   3(2,R2),=C'NS'      TEST IF NS REQUESTED
         BE    PARM01              GO GET NEXT SUBFIELD IF YES
         MVC   SFDFAULT,SFNN       ASSUME NN TEST REQUESTED
         MVC   SFUVALUE,SFNN       ESTABLISH NN FOR UNSIGNED FIELDS
         CLC   3(2,R2),=C'NN'      TEST IF NN REQUESTED
         BE    PARM01              GO GET NEXT SUBFIELD IF YES
         MVC   SFDFAULT,SFNB       ASSUME NB TEST REQUESTED
         MVC   SFUVALUE,SFUB       ESTABLISH UB FOR UNSIGNED FIELDS
         CLC   3(2,R2),=C'NB'      TEST IF NB REQUESTED
         BE    PARM01              GO GET NEXT SUBFIELD IF YES
         MVC   SFDFAULT,SFNM       ASSUME NM TEST REQUIRED
         MVC   SFUVALUE,SFNM       ASSUME NM TEST REQUIRED
         CLC   3(2,R2),=C'NM'      TEST IF NM SPECIFIED
         BE    PARM01              GO GET NEXT SUBFIELD IF YES
         MVC   SFDFAULT,SFUS       ASSUME US REQUESTED
         MVC   SFUVALUE,SFUS       ESTABLISH US FOR UNSIGNED FIELDS
         CLC   3(2,R2),=C'US'      TEST IF US SPECIFIED
         BE    PARM01              GO GET NEXT SUB-FIELD IF YES
         MVC   SFDFAULT,SFUZ       ASSUME UZ REQUESTED
         MVC   SFUVALUE,SFUZ       ESTABLISH UZ FOR UNSIGNED FIELDS
         CLC   3(2,R2),=C'UZ'      TEST IF UZ SPECIFIED
         BE    PARM01              GO GET NEXT SUB-FIELD IF YES
         MVC   SFDFAULT,SFUB       ASSUME UB REQUESTED
         MVC   SFUVALUE,SFUB       ESTABLISH UB FOR UNSIGNED FIELDS
         CLC   3(2,R2),=C'UB'      TEST IF UB SPECIFIED
         BE    PARM01              GO GET NEXT SUB-FIELD IF YES
         MVC   SFDFAULT,SFNZ       ASSUME NZ TEST REQUESTED
         MVC   SFUVALUE,SFUZ       ESTABLISH UZ FOR UNSIGNED FIELDS
         CLC   3(2,R2),=C'NZ'      TEST IF NZ REQUESTED
         BE    PARM01              GO GET NEXT SUBFIELD IF YES
         B     PARM02              TELL OF UNRECOGNISABLE PARM
         SPACE 5
***********************************************************************
*        PROCESS PARM ( CONT4D ) - IGNORE SUSPENSE IN LOG             *
***********************************************************************
         SPACE 1
PARMPUNS MVI   LOGSUSP,C'R'        ALTER FLAG FROM 'S' TO 'R'
         ADDR  LOGMESS2,D          GET ADDRESS OF MESSAGE
         MVC   0(8,R1),8(R1)       ALTER 'SUSPENSE' TO 'REJECTED'
         B     PARM01              GO GET NEXT SUBFIELD
         EJECT
***********************************************************************
*        PROCESS PARM ( CONT'D ) - SUBMITTOR ID                       *
***********************************************************************
         SPACE 1
PARMID   LR    R4,R3               PRESERVE PRM LENGTH
         LA    R1,4(,R2)           POINT PAST 'ID=('
         LR    R2,R3               MOVE LENGTH TO R2
         SH    R3,=H'4'            ALLOW FOR 'ID=('
         CH    R3,=H'4'            ENSURE NOT LESS THAN 3 BYTES LEFT
         BL    PARM02              FORMAT WRONG - TELL UNRECOGNISABLE
         LA    R15,0(,R1)          POINT R15 AT FIRST CHAR OF POSN
PARMID00 CLI   0(R15),C','         HAVE WE REACHED DELIMITER
         BE    PARMID01            BR IF YS
         CLI   0(R15),C')'         HAVE WE RUN OUT OF PARM
         BE    PARM02              FORMAT ERRO IF YES
         LA    R15,1(,R15)         INCREMENT R15 TO NEXT POSN
         B     PARMID00            LOOP BACK
PARMID01 SR    R15,R1              DETERMINE LENGTH OF NUMERIC SUBPARM
         CBAL  R4,NUMERICH         ENSURE SUBPARM IS NUMERIC
         BNE   PARMCB01            IF NOT - TELL PARM NONNUMERIC
         CVB   R14,WORKPACK        CONVERT POSN TO BINARY
         STC   R14,PARMIDP         PRESERVE DESTINATION OF ID
         AR    R1,R15              INCREMENT R1 TOPOINT AT ...
         LA    R1,1(,R1)           ... ',' DELIMITING POSN
         LA    R1,1(,R1)           INCR START OF LITERAL ID
         MVC   PARMIDC,0(R1)       PRESERVE SUBMITTORS ID
         LA    R15,7(,R15)         INCR LGTH OF POSN FOR DECR & 'ID=(,)
         SR    R2,R15              DETERMINE LENGTH OF LITERAL ID
         STC   R2,PARMIDL          PRESERVE LENGTH OF LITERAL ID
         LTR   R3,R3               ENSURE LGTH GREATER THAN ZERO
         BH    *+8                 PROCEED IF LNGTH GOOD
         B     PARM02              TELL OF FORMAT ERROR
         OI    APSWITCH,APSWSID    INDICATE SUBMITTOR ID WANTED
         B     PARM01              GO GET NEXT PARM FIELD
         SPACE 5
***********************************************************************
*        PROCESS PARM ( CONT'D ) - SUPPRESS WEEK 0                    *
***********************************************************************
         SPACE 1
PARMWK0  MVC   WEEK0,0(R2)         REPLACE 'WEEK0' BY 'NOWEEK'
         B     PARM01              GO GET NEWT PARM FIELD
         EJECT
***********************************************************************
*        PROCESS PARM ( CONT'D ) - SUBMITTOR ID IN B/C ONLY           *
***********************************************************************
         SPACE 1
PARMIDB  LA    R2,2(,R2)           INCREMENT PAST 'BC'
         SH    R3,=H'2'            DECREMENT LENGTH TO ALLOW FOR 'BC'
         OI    APSWITCH,APSWBCID   INDICATE BATCH CARD ID FOUND
         B     PARMID              GO VALIDATE PARM & EXTRACT VALUES
         SPACE 5
***********************************************************************
*        PROCESS PARM ( CONT'D ) - DUMP IN TERMINATION                *
***********************************************************************
         SPACE 1
PARMFDMP OI    JOBEND+1,X'F0'      SET ON BR IN TERMINATION
         B     PARM01              GO GET NEXT PARM FIELD
         SPACE 5
***********************************************************************
*        PROCESS PARM( CONT'D ) - ALLOW FULL DUMPS                    *
***********************************************************************
         SPACE 1
PARMADMP LA    R1,DUMPLIST         POINT AT 1ST DUMP PARAM LIST
         CLI   0(R1),X'FF'         TEST FOR END OF LIST OF LISTS
         BE    PARM01              EXIT IF END OF LIST
         OI    0(R1),X'80'         SET ON 'DUMP' REQUEST
         LA    R1,4(,R1)           INCREMENT TO NEXT PARAM LIST
         B     *-16                LOOP BACK TO PROCESS
         SPACE 5
***********************************************************************
*        PROCESS PARM ( CINT'D ) - SUPPRESS SYSUT1 SEQUENCE CHECK     *
***********************************************************************
         SPACE 1
PARMNSEQ L     R1,VBUDG3E          POINT AT RELEVANT CSECT
         NI    BRDUMP20-BUDGIE3E+1(R1),X'0F' SET OFF BR FOR SEQ ERROR
         NI    BRUT1DUP-BUDGIE3E+1(R1),X'0F' SET OFF BR FOR REJECT DUP
         OI    APSWITCH,APSWNSEQ   SET TO SHOW NSEQ SPECIFIED
         B     PARM01              GO GET NEXT PARM FIELD
         EJECT
***********************************************************************
*        PROCESS PARM ( CONT'D ) - KEY BREAK PARM                     *
***********************************************************************
         SPACE 1
PARMKB   OI    BRSWITCH,SWBRKB     SET ON 'KEYBREAK' FLAG
         B     PARM01              GO GET NEXT SUBFIELD
         SPACE 5
***********************************************************************
*        PROCESS PARM (CONT'D ) - PPPL PROCESSING FOR MS11            *
***********************************************************************
         SPACE 1
PARMPPPL OI    SWINIT,SWMS11PL     FLAG TO PROCESS AS PPPL NOT PPLL
         B     PARM01              GO GET NEXT PARM FIELD
         SPACE 5
***********************************************************************
*        PROCESS PARM ( CONT'D ) - NO IS MASTER INDEX                 *
***********************************************************************
         SPACE 1
PARMNOIX OI    YPSWITCH,YPSWNOIX   FLAG TO SUPPRESS MASTER INDEXES
         B     PARM01              GO GET NEXT PARM FIELD
         SPACE 5
***********************************************************************
*        PROCESS ARM ( CONT'D ) - IDENTIFY MS13 COMMENT               *
***********************************************************************
         SPACE 1
PARMCOM  MVC   MS13COMM,4(R2)      MOVE CHARACTER TO STORE
         B     PARM01              GO GET NEXT SUBFIELD
         SPACE 5
***********************************************************************
*        PROCESS PARM ( CONT'D ) - FREEMAIN REDUNDANT CSECTS          *
***********************************************************************
         SPACE 1
PARMFREE OI    YPSWITCH,YPSWFREE   FLAG TO PERFROM FREEMAIN
         B     PARM01              GO GET NEXT PARM SUBFIELD
         EJECT
***********************************************************************
*        PROCESS PARM ( CONT'D ) - USER PARM                          *
***********************************************************************
         SPACE 1
PARMUPRM CH    R3,=H'11'           ENSURE LENGTH > 11 (UPARM=(,))
         BNH   PARM02              GO TELL OF ERROR IF NOT
         LA    R1,7(,R2)           POINT PAST 'UPARM=('
         LR    R2,R3               PRESERVE LENGTH IN R2
         SH    R3,=H'7'            ALLOW FOR 'UPRM=('
         LR    R15,R1              POINT R15 AT 1ST DIGIT OF POSN
PARMUP00 CLI   0(R15),C','         HAVE WE REACHED DELIMITER
         BE    PARMUP01            BR IF YES
         CLI   0(R15),C')'         HAVE WE RUN OUT OF PARM
         BE    PARM02              FORMAT ERROR IF YES
         LA    R15,1(,R15)         INCREMENT RU5 TO NEXT POSM
         B     PARMUP00            LOOP BACK TO TEST FOR END
PARMUP01 SR    R15,R1              DETEREMINE LNGH OF NUMERIC PARM
         CBAL  R4,NUMERICH         ENSURE POSN IS NUMERIC
         BNE   PARMCB01            IF NOT NUMERIC TELL OF ERROR
         CVB   R14,WORKPACK        CONVERT POSN TO BUNARY
         BCTR  R14,0               DECREMENT POSN TO DISPLACEMENT
         STH   R14,UPARMDES        PRESERVE DESTINATION DISPLACEMENT
         AR    R1,R15              INCREMENT R1 TO POINT AT ...
         LA    R1,2(,R1)            ... COLUMN FOLLOWING DELIMITER
         ST    R1,UPARMADR         PRESERVE ADDRESS OF USER PARM
         LA    R15,9(,R15)         INCREMENT LENGTH OF 'NNN' BY UPARM=
         SR    R2,R15              DETERMINE LENGHT OF REMAINDER
         BCTR  R2,0                DECREMENT LENGTH FOR EXECUTE
         STH   R2,UPARMLEN         PRESERVE EXECUTABLE LENGT
         B     PARM01              GO GET NEXT PARM FIELD
         SPACE 1
         SPACE 5
***********************************************************************
*        PROCESS PARM ( CONT'D ) - DO NOT PRELOAD USER EXITS          *
***********************************************************************
         SPACE 1
PARMNL   OI    YPSWITCH,YPSWNOLD   FLAG NOT TO PRELOAD
         B     PARM01              GO GET NEXT SUBFIELD
         EJECT
***********************************************************************
*        PROCESS APRM ( CONT'D ) - CORE TO DYNAMICALLY ACQUIRE        *
***********************************************************************
         SPACE 1
PARMMC   LA    R1,3(,R2)           POINT PAST 'MC='
         LR    R15,R3              SET R15 TO LENFTH OF SUB-FIELD
         SH    R15,=H'3'           ALLOW FOR PARM ID
         CBAL  R4,NUMERICH         TEST IF PARM VALUE NUMERIC
         BNE   PARMCB01            GO TELL OF ERROR IF NOT
         EX    R15,SFPACK          PACK SUB-FIELD DATA
         CVB   R1,WORKPACK         CONVERT AMOUNT INTO BINARY
         ST    R1,GETMMC           PRESERVE AMOUNT OF CORE TO ACQUIRE
         B     PARM01              GO GET NEXT SUB-FIELD
         SPACE 5
***********************************************************************
*        PROCESS PARM ( CONT'D ) - CORE TO BE PRESERVED               *
***********************************************************************
         SPACE 1
PARMSC   LA    R1,3(,R2)           POINT PAST 'SC='
         LR    R15,R3              SET R15 TO LENFTH OF SUB-FIELD
         SH    R15,=H'3'           ALLOW FOR PARM ID
         CBAL  R4,NUMERICH         TEST IF PARM VALUE NUMERIC
         BNE   PARMCB01            GO TELL OF ERROR IF NOT
         EX    R15,SFPACK          PACK SUB-FIELD DATA
         CVB   R1,WORKPACK         CONVERT AMOUNT INTO BINARY
         ST    R1,GETMSC           PRESERVE AMOUNT TO BE PRESERVED
         B     PARM01              GO GET NEXT SUB-FIELD
         SPACE 5
***********************************************************************
*        PROCESS PARM ( CONT'D ) - PPL MAY HAVE OVERPUNCH             *
***********************************************************************
         SPACE 1
PARMPLOP OI    YPSWITCH,YPSWPLOP   FLAG THAT OVERPUNCH VALID
         B     PARM01              GO GET NEXT PARM SUBFIELD
         EJECT
***********************************************************************
*        PROCESS PARM ( CONT'D ) - LINES / PAGE                       *
***********************************************************************
         SPACE 1
PARMLCNT LA    R1,5(,R2)           POINT PAST 'LCNT='
         LR    R15,R3              SET R15 TO LENGTH OFPARM FIELD
         SH    R15,=H'5'           ALLOW FOR 'LCNT='
         CBAL  R4,NUMERICH         TEST IF PARM VALUE NUMERIC
         BNE   PARMCB01            GO TELL OF ERROR IF NOT
         EX    R15,SFPACK          PACK SUB-FIELD DATA
         ZAP   IOPSLCNT,WORKPACK   SET LINES/PAGE IN IO-SWITCH FIELD
         CP    IOPSLCNT,=P'10'     ENSURE THAT LINE/PAGE IS AT LEAST 10
*                                   OR A HEADING LOOP WILL RESULT
         BH    *+10                BR IF NOT LESS THAN 10
         ZAP   IOPSLCNT,=P'60'     FOFCE VALUE BACK TO DEFAULT
         B     PARM01              GO GET NEXT PARM SUBFIELD
         SPACE 5
***********************************************************************
*        PROCESS PARM ( CONT'D ) - SUSPENSE FILE = INPUT              *
***********************************************************************
         SPACE 1
PARMSFIN OI    YPSWITCH,YPSWSFIN   SET FLAG FOR SF=IN
         B     PARM01              GO GET NEXTPARM SUB-FIOD
         SPACE 5
***********************************************************************
*        PROCESS PARM ( CONT'D ) - PRESERVE INDICATORS 56-99          *
***********************************************************************
         SPACE 1
PARMKIND OI    AFSWITCH,AFSWKIND   FLAG TO PRESERVE INDICATORS
         B     PARM01              GO GET NEXT PARM SUB-FIELD
         SPACE 5
***********************************************************************
*        PROCESS PARM ( CONT'D ) - SEQUENCE NUMBER ALL CONTROL CARDS  *
***********************************************************************
         SPACE 1
PARMSEQA OI    AFSWITCH,AFSWSEQA   FLAG TO SEQ NO ALL CONTROL CARDS
         B     PARM01              GO GET NEXT PARM SUBFIELD
         SPACE 1
EOPARM   EQU   *                   END OF PARM PROCESSING
         EJECT
***********************************************************************
*        ACQUIRE CORE FOR STORAGE POOLS                               *
***********************************************************************
         SPACE 1
GETM02   L     R0,GETMLEN          RETRIEVE LENGTH OF C/B POOL
         L     R1,GETMLEN          GET LENGTH OF C/B POOL
         LTRR  R1,R1               PURIFY & TEST FOR ZERO
         BZ    GETM03              BR IF ZERO SIZE
       GETMAIN R,LV=(0)            ACQUIRE POOL
         ST    R1,GETMSTRT         STORE ADDRESS OF POOL
         OI    GETMSTRT,POOLUSE+POOLGTM FLAG AS AVAILABLE FOR USE AS
*                                   GETMAIN/WORKFILE STORAGE POOL
GETM03   EQU   *                   CONTINUE PROCESSING
         EJECT
***********************************************************************
*        PREPARE TO READ CONTROL CARDS                                *
***********************************************************************
         SPACE 1
         OI    SWINIT,SWCCPRNT     INDICATE PRINTING C/C - FOR EOP RTN
         AP    SYSPRINT+IOPSRCNT(4),IOPSLCNT FORCE LCNT TO PAGE LIMIT
         LINE  P=Y                 SPACE BLANK LINE TO FORCE HEADING
         IOM   OPEN,SYSIN          OPEN CONTROL CARD DATA SET
         LA    R1,PTR1CB02         TREAT POINTER TO 1ST CB02 ...
         ST    R1,PTRCB02           ... AS 1ST CB02 FOR CHAINING
         LA    R1,PTR1CB20         TREAT POINTER TO 1ST CB20 ...
         ST    R1,PTRCB20           .. AS 1ST CB20 FOR CHAINING
         CBAL  ,CCREAD             GO PROCESS CONTROL CARDS
         EJECT
***********************************************************************
*        INVOKE SUB-ROUTINE 'PRINT' FROM BUDGIE3H                     *
***********************************************************************
         SPACE 1
PRINT3H  SUBIN SAVE=R4             PRESERVE RETURN ADDRESS
         CBAL  R4,PRINT            INVOKE ROUTINE 'PRINT'
        SUBOUT RESTORE=R4          RESTORE & RETURN TO CALLER
         EJECT
***********************************************************************
*        INVOKE SUB-ROUTINE 'NUMERIC' FROM BUDGIE3H                   *
***********************************************************************
         SPACE 1
NUMERICH SUBIN SAVE=R4             PRESERVE RETURN ADDRESSS
         ZAP   WORKPACK,ZERO       ZEROISE RESULT LEST NONNUMERIC
         CBAL  R4,NUMERIC          TEST IF FIELD IS NUMERIC
         BNE   *+10                BR IF NOT NUMERIC
         BCTR  R15,0               DECREMENT FOR EXECUTE
         EX    R15,SFPACK          PACK LENGTH INTO 'WORKPACK'
         BNH   NUMERCHX            BR IF FIELD NUMERIC
         LINE  LINE09              SET UP EROR MESSAGE
         MVC   COMPCODE,COND16     SET COMPLETION CODE
         OI    SWERROR,SWEFLUSH    SET TO TERMINATE ATTER C/C SCAN
NUMERCHX SUBOUT RESTORE=R4         RESTORE & RETURN TO CALLER
BUDGIE3  CSECT
         DROP  R11                 DROP BUDGIE3H ADDRESSABILITY
         EJECT
***********************************************************************
*        INVOKE ROUTINE 'NUMERICS' FROM CSECT BUDGIE3H                *
***********************************************************************
         SPACE 1
NUMERCSH SUBIN SAVE=R4             PRESERVE RETURN ADDRESS
         ZAP   WORKPACK,ZERO       ZEROISE RESULT LEST NONNUMERIC
         CBAL  R4,NUMERICS         TEST FIELD FOR NUMERIC
         BNE   *+10                BR IF NOT NUMERIC
         BCTR  R15,0               DECRENENT FOR EXECUTE
         EX    R15,SFPACK          PACK FIELD INTO 'WORKPACK'
         BNH   NUMRCSHX            BR IF FILED NUMERIC
         LINE  LINE09              SET UP ERROR MESSAGE
         MVC   COMPCODE,COND16     SET COMPLETAON CODE
         OI    SWERROR,SWEFLUSH    SET TO TERMINATE AFTR C/C SCAN
NUMRCSHX SUBOUT RESTORE=R4         RESTORE & RETURN TO CALLER
         TITLE 'BUDGIE3C - BUILD CONTROL BLOCKS'
        SCSECT C
***********************************************************************
*        READ CONTROL CARDS                                           *
***********************************************************************
         SPACE 1
CCREAD   CBAL  R4,READIN           GET CONTROL CARD AND PRINT IT
         BNE   EODSYSIN            EXIT IF EOD ON SYSIN
         CCTST MS00                PROCESS MS00 CARD
         CCTST MS01                PROCESS MS01 CARD
         CCTST MS02                PROCESS MS02 CARD
         CCTST MS03                PROCESS MS03 CARD
         CCTST MS04                PROCESS MS04 CARD
         CCTST MS05                PROCESS MS05 CARD
         CCTST MS11                PROCESS MS11 CARD
         CCTST MS12                PROCESS 'MS12' CONTROL CARDS
         CCTST MS13                PROCESS MS13 CARD
         CCTST MS14                GO PROCESS MS14 CONTROL CARDS
         EJECT
***********************************************************************
*        READ CONTROL CARDS ( CONT'D )                                *
***********************************************************************
         SPACE 1
         CCTST MS20                GO PROCESS MS20 CONTROL CARDS
         CCTST MS21                GO PROCESS MS21 CONTROL CARDS
         CCTST MS30                GO PROCESS MS30 CONTROL CARDS
         CCTST MS32                GO PROCESS MS32 CONTROL CARDS
         CCTST MS33                GO PROCESS MS33 CONTROL CARDS
         CCTST MS34                GO PROCESS MS34 CONTROL CARDS
         EJECT
***********************************************************************
*        READ CONTROL CARDS ( CONT'D )                                *
***********************************************************************
         SPACE 1
         CCTST MS36                PROCESS MS36 CONTROL CARDS
         CCTST MS37                PROCESS MS37 CONTROL CARDS
         CCTST MS40                GO PROCESS MS40 CONTROL CADS
         CCTST MS41                GO PROCESS MS41 CONTROL CADS
         CLI   0(R6),C'*'          IS THIS A COMMENTS CARD
         BE    CCREADX             BR IF YES
         CLC   0(5,R6),=C'TITLE'   IS THIS A TITLE CARD
         BE    CCREADX             BR IF YES
         CLC   0(5,R6),=C'EJECT'   IS THIS AN EJECT CARD
         BE    CCREADX             BR IF YES
         CLC   0(4,R6),=C'SKIP'    IS THIS A SKIP CARD
         BE    CCREADX             BR IF YES
         LINE  LINE15,P=Y          TELL OF UNKNOWN CARD TYPE
CCREADX  B     CCREAD              GO GET NEXT CONTROL CARD
         EJECT
***********************************************************************
*        PROCESS MS00 CONTROL CARD                                    *
***********************************************************************
         SPACE 1
         USING MS00CARD,R6         ESTABLISH CONTROL CARD ADDRESSAB'Y
CCMS00   EQU   *
         CLI   MS00TYPE,C'L'       IS IT BATCH LOG HEADING
         BNE   CCMS0001            BR IF NOT
         CLI   MS00SPCE,C'2'       IS DOUBLE SPACING REQUESTED
         BNE   *+8                 BR IF NOT
         OI    PRINTSW,PRSWBLS2    FLAG TO DOUBLE SPACE
         CLI   MS00SPCE,C'3'       IS TRIPLE SPACE REQUESTED
         BNE   *+8                 BR IF NOT
         OI    PRINTSW,PRSWBLS3    FLAG TO TRIPLE SPACE
         ADDR  LOGHEAD1,D          GET ADDRESS OF HEADING LINE
         CLC   MS00HEAD,SPACES     IS HEADING SUPPLIED
         BE    *+10                BR IF NOT
         MVC   0(L'MS00HEAD,R1),MS00HEAD MOVE HEADING TO LINE
CCMS0001 B     CCREAD              GO GET NEXT CONTROL CARD
        EJECT
***********************************************************************
*        PROCESS MS01 CARD                                            *
***********************************************************************
         SPACE 1
         USING MS01CARD,R6         ESTABLISH CONTROL CARD ADDRESSAB'Y
CCMS01   ADDR  BB01MS01,D          GET ADDRESS OF USER HADING STORE
         CLC   MS01HEAD,SPACES     IS HEADING SUPPLIED
         BE    *+10                BR IF NOT
         MVC   0(L'BB01MS01,R1),MS01HEAD STORE USER HEADING IN LINE ARA
         CLI   MS01LIST,C'N'       TEST IF DATA TO BE LISTED
         BNE   *+8                 BRANCH IF YES
         OI    MASTER,SWMNLIST     INDICTAE B/C & DATA IN ERROR ONLY
         CLI   MS01LIST,C'1'       IS ONLY DATA IN ERROR REQUIRED
         BNE   *+8                 BR IF NOT
         OI    MASTER,SWMNLIST     SET FLAG TO LIST ERROR ONLY
         CLI   MS01LIST,C'2'       ARE ONLY CONTROL TOTALS RZQUIRED
         BNE   *+12                BR IF NOT
         OI    MASTER,SWMNLIST     FLAG THAT GOOD DATA NOT REQUIRED
         OI    PRINTSW,PRSWNDTA    FLAG NOT TO PRINT ERRORS
         CLI   MS01SPCE,C' '       TEST FOR SPACE RESUEST
         BE    CCREAD              BRAVCH IF NO
         CLI   MS01SPCE,C'1'       TEST FOR SINGLE SPACING REQUEST
         BE    CCREAD              DEFAULT VALUE SO BRANCH
         CLI   MS01SPCE,C'2'       TEST FRR DOUBLE SPACING REQUEST
         BNE   CCMS0101            BR IF NOT DOUBLE SPACE REQUEST
         OI    PRINTSW,PRSWSPC2    SET TI SHOW DOUBLE SPACE REQUEST
         ADDR  BBSPCE,D            GET ADDRESS OF CARRIAGE CONTROL CHAR
         MVI   0(R1),SPCE2AFT      SET DEFAULT TO DOUBLE SPACE
         B     CCREAD              GET NEXT CONTROL CARD
CCMS0101 CLI   MS01SPCE,C'3'       TEST FOR TRIPLE SPACE REQUEST
         BNE   CCREAD              IF NOT, ALLOW DEFAULT SINGLE SPACE
         MVI   0(R1),SPCE3AFT      ESTABLISH DEFAULT TRIPLE SPACE
         OI    PRINTSW,PRSWSPC3    SET TO SHOW TRIPLE SPACE REQUESY
         B     CCREAD              GET NEXT CONTROL CARD
         DROP  R6                  DROP ADDRESSABILITY
         EJECT
***********************************************************************
*        PROCESS MS02 CARD                                            *
***********************************************************************
         SPACE 1
         USING MS02CARD,R6         ESTABLISH CONTROL CARD ADDRESSAB'Y
         USING CB02NTRY,R8         ESTABLISH CONTROL BLOCK ADDRESSAB'Y
CCMS02   EQU   *                   CONSTRUBT CB02 CONTROL BLOCK
         LA    R2,CB02LGTH         SET R2 TO LENGTH OF CONTROL BLOCK
         CBAL  R4,GETMAIN          GET CORE & INITIALISE TO LOW-VALUES
         L     R8,PTRCB02          GET ADDRESS OF PREVIOS CB02
         ST    R1,CB02CB02         POINT PREVIOS ELEMENT AT THIS ONE
         OI    CB02FLAG,FLAGCB02   INDICATE PREVIOS IS CB02
         LR    R8,R1               POINT R8 AT NEW CB02
         OI    CB02FLAG,FLAGCB02   INDICATE NEW IS CB02
         ST    R8,PTRCB02          PRESERVE CURRENT CB02 ADDRESS
         XC    PTRCB03,PTRCB03     ZEROISE POINTER TO NEXT CONTROL BLOC
         XC    PTRCB04,PTRCB04     ZEROISE POINTER TO NEXT CONTROL BLOC
         XC    PTRSB11,PTRSB11     ZEROISE POINTER TO NEXT CONTROL BLOC
         XC    PTRCB11,PTRCB11     ZEROISE POINTER TO CURRENT CONTROL B
         LA    R1,CB02CB05         TREAT CB02CB05 AS A ''DUMMY'' CURREN
         ST    R1,PTRCB05           CB05 TO FACILITATE CHAINING
         LA    R1,CB02CB11         TREAT CB02CB11 AS ''DUMMY'' CURRENT
         ST    R1,PTRCB11           CB11 TO FACILITATE CHAINING
         LA    R1,CB02CB13         TREAT CB02CB13 AS A ''DUMMY'' CURREN
         ST    R1,PTRCB13           CB13 TO FACILITATE CHAINING
         LA    R1,CB02CB14         TEST CB02CB14 AS A 'DUMMY' CURRENT
         ST    R1,PTRCB14           CB14 TO FACILITATE CHAINING
         NI    SWINIT,FF-SWONMS11  INDICATE NO MEUU YET FOUND
         ZAP   CB02CCNO,SYSIN+IOPSRCNT(4) MOVE C/C SEQ NO TO C/B
         MVC   CB02BCI,MS02BCI     SET BATCH CARD ID
         ZAP   CB02CNT,ZERO        ZEROISE RECORD COUNTER
         ZAP   CB02HCNT,ZERO       ZEROISE COUNT OF HARD ERRORS
         ZAP   CB02SCNT,ZERO       ZEROISE COUNT OF SOFT ERRORS
         ZAP   CB02CNTR,ZERO       ZEROISE BATCH CARD CARD COUNT
         ZAP   CB02RCNT,ZERO       ZEROISE ACCUMULATED CARD COUNT
         ZAP   CB02LCNT,ZERO       ZEROISE CARD NUMBER WITH IN BATCH
         ZAP   CB02RETC,ZERO       ZEROISE COUNT OF RETAINED RECORDS
         MVC   CB02URTN,MS02URTN   SET USER EXIT NAME (IF ANY)
         CLC   CB02URTN,SPACES     TEST IF USER ROUTINE REQUIRED
         BE    *+12                BR IF MO
         OI    SWINIT,SWONURTN     SHOW USER RTN ESQUESTED
         OI    CB02SW,SW02URTN     SET USER RTN SWITCH ON
         CLI   MS02DROP,C'D'       TEST IF DROP UNKNOWN CARDS
         BNE   *+8                 BRANCH IF NO
         OI    CB02SW,SW02DROP     SET DROP SWITCH ON
         LA    R2,MS02PBCI         POINT AT CC BATCH CARD PPP
         LA    R3,CB02PBCI         POINT AT CC BATCH CARD PL
         CBAL  R4,PPLPLC            CONVERT EBCDIC TO BINARY PL
         LA    R10,5               ESTABLISH LOOP
         LA    R2,MS02PBN1         POINT AT CC 1ST BATCH NO COMPONENT
         LA    R3,CB02PBN1         POINT AT CB 1ST BATCH NO COMPONENT
         EJECT
***********************************************************************
*        PROCESS MS02 CARD ( CONT'D )                                 *
***********************************************************************
         SPACE 1
CCMS0201 CBAL  R4,PPLPLC            CONVERT EBCDIC PPL TO BINARY PL
         LA    R2,3(,R2)           POINT AT NEXT COMPONENT PPL
         LA    R3,2(,R3)           POINT AT NEXT COMPOMENT PL
         BCT   R10,CCMS0201        LOOP BACK IF COMPONENTS LEFT
         OI    CB02SW,SW02WDC      SET TO  WRITE DETAIL CARDS
         CLI   MS02OCTL,C'1'       TEST IF BATCH CARD TO BE WRITTEN
         BNE   *+8                 BRANCH IF NOT
         OI    CB02SW,SW02WBC      TELL TO WRITE BATCH CARDS
         CLI   MS02OCTL,C'2'       TEST IF CONTROL RECORD TO BE WRITTEN
         BNE   *+8                 BRANCH IF NOT
         OI    CB02SW,SW02WCR      TELL TO WRITE CONTROL RECORD
         CLI   MS02OCTL,C'3'       IS IT C/R & B/C
         BNE   *+8                 BRANCH IF NOT
         OI    CB02SW,SW02WCR+SW02WBC SHOW TO WRITE B/C & C/R
         TM    BRSWITCH,SWBRKB     IS 'KEYBREAK' SPECIFIED
         BZ    *+8                 BR IF NO
         OI    CB02SW,SW02WBC      FLAG TO WRITE 1ST CARD ( B/C ) ALLWY
         PL    PPL,MS02PCRN,CB02PCRN CONVERT REC NO FLD PL TO BINARY
         CLC   MS02ORL,SPACES      TEST IF OUTPUT RECORD LENGTH SUPPLIE
         BE    *+18                IF NO, DEFAULT TO 80
         PACK  WORKPACK,MS02ORL    PACK OUTPUT RECORD LENGTH ..
         CVB   R1,WORKPACK          ... & CONVERT IT TO BINARY
         STH   R1,LRECLUT2         PRESERVE OUTPUT RECORD LENGTH
         OC    LRECLINT,LRECLINT   HAS INTERNAL LGTH BEEN SUPPLIED
         BNZ   *+10                BR IF YES TO AVOID ONERWRITING
         MVC   LRECLINT,LRECLUT2   ASSUME INTERNAL LENGTH = OUTPUT
         CLC   MS02IRL,SPACES      TEST IF INTERNAL LGTH SUPPLIED
         BE    *+26                BR IF NOT SUPPLIED
         PACK  WORKPACK,MS02IRL    PACK INTERNAL RECORD LENGTH
         CVB   R1,WORKPACK         ... AND CONVERT IT TO BINARY
         CH    R1,LRECLINT         IS THIS LARGEST VALUE YET SUPPLIED
         BNH   *+8                 BR IF NOT LARGETS TO RETAIN OLD VALU
         STH   R1,LRECLINT         PRECERVE INTERNAL LENHTH
         CLC   LRECLUT2,LRECLINT   VERIFY PSEUDO ^< OUTPUT LENGTH
         BH    ABEND40             GO TERMINATE IF NOT
         CLC   MS02PID1(9),SPACES  IS SUBMITTOR ID DEFINED
         BE    CCMS0203            BR IF NOT
         OI    CB02SW2,SW02PID     SET SW TO PRINT ID IN HEADINGS
         LA    R10,3               ESTABLISG LOOP OF 3 COMPONETS
         LA    R2,MS02PID1         POINT AT 1ST C/C COMPONENT
         LA    R3,CB02PID1         POINT AT 1ST C/C COMPONENT
CCMS0202 CBAL  R4,PPLPLC           CONVERT PPL TO BINARY PL
         LA    R2,3(,R2)           POINT AT NEXT C/C PPL
         LA    R3,2(,R3)           POINT AT NEXT C/B PL
         BCT   R10,CCMS0202        LOOP BACK IF BUCKTES LEDT
CCMS0203 B     CCREAD              GO GET NEXT CONTROL CARD
         DROP  R6,R8               DROP ADDRESSABILITY
         EJECT
***********************************************************************
*        PROCESS MS03 CARD                                            *
***********************************************************************
         SPACE 1
         USING MS03CARD,R6         ESTABLISH CONTROL CARD ADDRESSAB'Y
         USING CB03NTRY,R8         ESTABLISH CONTROL BLOCK ADDRESSAB'Y
CCMS03   EQU   *                   CONSTRUCT CB03 CONTROL BLOCK
         PACK  WORKPACK,MS03LCRK   PACK LENGTH OF KEY ...
         CVB   R2,WORKPACK          ... & CONVERT IT TO BINARY
         LA    R2,CB03CRK-CB03NTRY(,R2) ADD CONSTANT CB LENGTH
         CBAL  R4,GETMAIN          ACQUIRE CORE FOR CONTROL BLOCK
         LR    R8,R1               POINT R8 AT GOTTEN CORE
         ST    R8,PTRCB03          PRESERVE CB03 POINTER AS CURRENT
         ST    R8,PTRCB04          TRAET CB03CB04 AS 1ST CB03 TO ...
*                                   ... FACILITATE CH AINING
         L     R1,PTRCB02          RETRIEVE CURRENT CB02 POINTER
         ST    R8,CB02CB03-CB02NTRY(R1) POINT CB02 AT CB03
         OI    CB03FLAG,FLAGCB03   SHOW IT IS A CB03
         ZAP   CB03CCNO,SYSIN+IOPSRCNT(4) MOVE C/C SEQ NO TO C/B
         LA    R2,MS03PCRK         POINT AT CC PPPLL
         LA    R3,CB03PCRK         POINT AT CB PL
         CBAL  R4,PPPLLPLC         CONVERT EBCDIC PPPLL TO BINARY PL
         SR    R1,R1               ZEROISE WORK REGISTER
         IC    R1,CB03LCRK         GET LENGTH OF KEY
         LTR   R1,R1               TEST FOR ZERO LENGTH
         BZ    *+10                BYPASS BCT & EXECUTE IF ZERO LENGTH
         BCTR  R1,0                DECREMENT FOR EXECUTE
         EX    R1,CCMS03MV         MOVE KEY TO CONTROL BLOCK
         L     R1,PTRCB02          POINT R1 AT CURRENT CB02
         USING CB02NTRY,R1         ESTABLISH CB02 ADDRESSABILITY
         OI    BRSWITCH,SWBRCRT    ASSUME TRAILING C/R
         CLI   MS03POSN,C'1'       DOES CONTROL RECORD PRECEDE BATCH
         BNE   *+12                BR IF NO (TRAILING C/R)
         NI    BRSWITCH,FF-SWBRCRT SET FOR LEADING C/R
         OI    CB03SW,SW03POSN     SET TO SHOW LEADING C/R
         CLI   MS03LIST,C'2'       TEST IF PRINT ONLY
         BNE   *+12                BR IN NOT PRINT ONLY
         OI    CB03SW,SW03LIST     SET TO PRINT ONLY
         B     CCMS0301            GO CONTINUE PROCESSING
         CLI   MS03LIST,C'1'       TEST IF PRINT & WRITE
         BNE   *+16                BR IF NOT PRINT & WRITE
         OI    CB03SW,SW03LIST     SET TO PRINT
         OI    CB02SW,SW02WCR      SET TO WRITE TO SYSUT2
         B     CCMS0301            BR TO CONTINUE PROCESSING
*                                  ASSUME ' ' - WRITE ONLY
         OI    CB02SW,SW02WCR      SET TO WRITE TO SYSUT2
CCMS0301 EQU   *                   CONTINUE PROCESSING
         B     CCREAD              GET NEXT CONTROL BLOCK
         SPACE 1
CCMS03MV MVC   CB03CRK(0),MS03CRK  EXECUTED MOVE INSTRUCTION
         DROP  R1,R6,R8            DROP ADDRESSABILITY
         EJECT
***********************************************************************
*        PROCESS MS04 CARD                                            *
***********************************************************************
         SPACE 1
         USING CB04NTRY,R8         ESTABLISH CONTROL BLOCK ADDRESSAB'Y
         USING MS04CARD,R6         ESTABLISH CONTROL CARD ADDRESSAB'Y
CCMS04   EQU   *                   CONSTRUCT CB04 CONTROL BLOCK
         LA    R2,CB04LGTH         GET LENGTH OF CONTROL BLOCK
         CBAL  R4,GETMAIN          ACQUIRE CORE FOR CONTROL BLOCK
         LR    R8,R1               POINT R8 AT GOTTEN CORE
         OI    CB04FLAG,FLAGCB04   SHOW CURRENT IS CB04
         L     R1,PTRCB04          RETRIEVE CURRENT CB04 POINTER
         ST    R8,CB04CB04-CB04NTRY(,R1) POINT CURRENT AT NEW
         OI    CB04FLAG-CB04NTRY(R1),FLAGCB04 SHOW PREVIOUS IS CB04
         ST    R8,PTRCB04          ESTABLISH NEW AS CURRENT
         ZAP   CB04CCNO,SYSIN+IOPSRCNT(4) MOVE C/C SEQ NO TO C/B
         LA    R2,MS04PCRF         POINT AT EBCDIC PPPLL
         LA    R3,CB04PCRF         POINT AT BINARY PL
         CBAL  R4,PPPLLPLC         CONVERT EBCDIC PPPLL TO BINARY PL
         CLI   MS04PIND,C'P'       IS OUTPUT C/R FIELD TO BE PACKED
         BNE   *+8                 BRANCH IF NOT
         OI    CB04SW,SW04PACK     SET ON PACK SWITCK
         SR    R1,R1               ZEROISE WORJ REGISTER
         IC    R1,CB04LCRF         GET LENGTH OF OUTPUT FIELD
         BCTR  R1,0                DECREMENT FOR SUBSEQUENT EXECUTES
         CLC   MS04BNO,SPACES      IS THIS BNO OR FLD EXTRACT REQUEST
         BNE   *+8                 BR IF YES COS NOT PACKED DEC OPERATI
         SLA   R1,4                SHIFT LENGTH FOR PD EXECUTE
         STC   R1,CB04LCRF         RESTORE ADJUSTED FIELD
         MVC   CB04FNO,MS04FNO     MOVE FRIELD NAME TO CONTROL BLOCK
         CLI   MS04NDEC,C' '       TEST IF NO OF DECIMALS BLANK
         BNE   *+8                 BRANCH IF NOT
         MVI   MS04NDEC,C'0'       SET TO DEFAULT OF ZERO
         PACK  CB04NDEC,MS04NDEC   ADD NO OF DECAMALS TO CONTROL BLOCK
         ZAP   CB04BACC,ZERO       ZEROISE FIELD ACCUMULATOR
         CLC   MS04BNO,=C'BNO'     IS THIS A RESUEST FOR THE BATCH NUMB
         BNE   *+12                BR IF NOT
         OI    CB04SW,SW04BNO      FLAG FOR BATCH NUMBER
         B     CCMS0401            GO AROUNG NUMERIC TEST
         CLC   MS04PSRC,SPACES     TEST IF POSN IS SUPPLIED
         BE    CCMS0401            BR IF NOT
         OI    CB04SW,SW04SRC      FLAG THAT FLD IS TO BE EXTERCED
       NUMERIC MS04PSRC            TEST IF SOURCE PARM IS NUMERIC
         CVB   R1,WORKPACK         CONVERT POSN TO BUNARY
         STC   R1,CB04PSRC         PREVERVE POSN OF SURCE FIELD
         CH    R1,LRECLUT1         DETERMINE IF SOURCE FLD IN INPUT REC
         BNL   CCMS0401            BR IF NOT WITHIN INPUT RREA
         LINE  LINE14,P=Y          PRINT WARNING MESSAGE
CCMS0401 B     CCREAD              GET NEXT CONTROL CARD
         DROP  R6,R8               DROP ADDRESSABILITY
         EJECT
***********************************************************************
*        PROCESS MS05 CARD                                            *
***********************************************************************
         SPACE 1
         USING CB05NTRY,R8         ESTABLISH CONTROL BLOCK ADDRESSAN'Y
         USING MS05CARD,R6         ESTABLISH CONTROL CARD ADDRESSAB'Y
         USING CB02NTRY,R7         ESTABLISH CONTROL BLOCK ADDRESSABILI
CCMS05   EQU   *                   CONSTRUCT CB05 CONTROL BLOCK
         OI    APSWITCH,APSWMS05   FLAG THAT MS05'S EXIST
         L     R7,PTRCB02          GET CURRENT CB02 ADDRESS
         CLC   MS05FNO,=C'RC'      TEST FOR RECORD COUNT REQUEDT
         BNE   CCMS0500            BR IF NOT REC CNT REQUEST
         LA    R2,MS05PBCT         POINT AT EBCDIC PPLL
         LA    R3,CB02CNTP         POINT AT BIBARY PL IN CB02 CARD
         CBAL  R4,PPLLPLC           CONVERT EBCDIC TO BINARY
         OI    CB02SW,SW02RCNT     INDICAE BATCH ACRD COUNT EXISTS
         CLI   MS05ERID,C'1'       ETST IF ERROR IS SOFT
         BNE   *+8                 BYPASS SETTING SW IF NOT SOFT
         OI    CB02SW,SW02RCSF     INDICATE REC CNT ERROR IS SOFT
         B     CCREAD              GO GET NEXT CONTROL CARD
CCMS0500 LA    R2,CB05LGTH         DETERMINE LENGTH OF C/B
         GETCB CB05                ACQUIRE AND CHAIN C/B
         MVC   CB05FNO,MS05FNO     RETRIEV E FIELD OR TEST NAME
         LA    R2,MS05FNO          POINT AT FIELD NAME
         CBAL  R4,TESTINTL         DETERMINE IF NAME IS TEST REQUEST
         BNE   *+18                BRANCH IF NOT TEST REQUEST
         MVC   CB05TID,3(R1)       ADD INTERNAL CODE FOR TEST REQUIEST
         OI    CB05SW,SW05TST      INDICATE IS TEST REQUEST BLOCK
         B     CCMS0501            CONTINUE
         OI    CB05SW,SW05FLD      MUST BE FIELD REQUEST SO INDICATE
         EJECT
***********************************************************************
*        PROCESS MS05 CARD ( CONT'D )                                 *
***********************************************************************
         SPACE 1
CCMS0501 LA    R2,MS05PBCT         POINT AT EBCDIC PPLL
         LA    R3,CB05PBCF         POINT AT BIBARY PL
         CBAL  R4,PPLLPLC           CONVERT EBCDIC PPLL TO BINARY PL
         CLI   MS05NDEC,C' '       TEST IF NO OF DECIMALS BLANK
         BNE   *+8                 BRANCH IF NOT
         MVI   MS05NDEC,C'0'       SET TO DEFAULT OF SERO
         PACK  CB05NDEC,MS05NDEC   ADD NO OF DECIMALS TO CB05
         ZAP   CB05BVAL,ZERO       ZEROISE STORE FOR BATCH CARD VALUE
         ZAP   CB05BACC,ZERO       ZEROISE DETAIL CARD ACCUMULATOR
         ZAP   CB05LVAL,ZERO       ZEROISE LITERAL VALUE STORE
         MVC   CB05LNE1,MS05LNE1   SAVE 1ST & ...
         MVC   CB05LNE2,MS05LNE2    ... 2ND TITLE LINES
         CLI   MS05ABID,C'1'       TEST IF B/C TOTAL IS BALANCING
         BNE   *+8                 BRANCJ IF NOT
         OI    CB05SW,SW05BAL      INDICATE VALUE IS BALANCING
         CLI   MS05ERID,C'1'       TEST IF ERROR IS SORT
         BNE   *+8                 BRANCH IF NOT
         OI    CB05SW,SW05SOFT     INDICATE ERROR IS SOFT
         CLC   MS05NEGI,SPACES     TEST IF NEG IND SPECIFIED
         BE    CCMS0502            BR IF NO -VE INDICATOR
         OI    CB05SW,SW05NGID     INDICATE -VE FLD PRESENT
         OI    CB05SW,SW05NGNZ     ASSUME OON-ZERO AUTO -VE
         CLC   MS05IDNG,=C'NONZERO' TEST IF NON-ZERO AUTO -VE
         BE    CCMS0502            BR IF NON-ZERO AUTO -BE
         NI    CB05SW,FF-SW05NGNZ  SET OFF AUTO -VE FLAG
         PL    PPL,MS05PNEG,CB05PNEG CONVERT EBCDIC TO BINARY
         MVC   CB05IDNG,MS05IDNG   STORE -VE ID LITERAL
CCMS0502 CLC   MS05VALU,SPACES     HAS CONSTANT BALANCING VALUE BEEN SU
         BE    CCMS0503            BR IF NO BALANCING VALUE
         OI    CB05SW,SW05VALU     FLA THAT VALUE IS SUPPLIED
       NUMERIC MS05VALU,,SIGNED    VERIFY THAT FIELD IS NUMERIC
         ZAP   CB05BVAL,WORKPACK   PRESETVE BALANCING VALUE
         ZAP   CB05LVAL,WORKPACK   PRESERVE BALANCING VALUE IN STORE
CCMS0503 CLC   MS05PBCT(4),SPACES  WAS FIELD PPLL SUPPLIED
         BNE   CCMS0504            BR IF YES
         CLC   MS05VALU,SPACES     WAS LITERAL VALUE SUPPLIED
         BNE   CCMS0504            BE IF YES
         LINE  LINE40              ERROR: ONE OR OTHER IS REQUIRED
CCMS0504 CLI   MS05PIND,C'1'       ARE WE ONLY TO PRINT DISCREPANCIES
         BNE   *+8                 BR IF NOT
         OI    CB05SW,SW05DPRT     FLAG TO PRINT ONLY ERRORS
         B     CCREAD              GO GET NEXT CONTROL CARDS
         DROP  R6,R8               DROP ADDRESSABILITY
         DROP  R7                  DROP CONTROL BLOCK ADDRESS'T
         EJECT
***********************************************************************
*        PROCESS MS11 & MS12 CONTROL CARDS                            *
***********************************************************************
*        NOTE - THIS CODING IS SHAREDE BY MS11 AND MS12
*                INITIALISATION AND CONTROL CARD PROCESSING
         USING CB11NTRY,R8         ESTABLISH CONTROL BLOCK ADDRESSAB'Y
         USING MS11CARD,R6         ESTABLISH CONTROL CARD ADDRESSABILY
CCMS11   EQU   *                   CONSTRUCT CB11/SB11 CONTROL BLOCKS
CCMS12   EQU   *                   CONSTRUCT CB11/SB12 CONTROL BLOCKS
         OI    SWINIT,SWONMS11     INDICATE MS11/12 FOUND (FOR MS13)
         CLC   MS11ID,=C'MS11'     TEST FRR MS11 CARD
         BNE   *+8                 BR IF NOT - MUST BE MS12
         OI    SWINIT,SWMS11       SHOW MS11 CARD BEING PROCESSED
         LA    R2,MS11PRTI         POINT AT EBCDIC PPL
         LA    R3,XB11PRTI         POINTA AT BINARY PL TEMPOR ARU STORE
         CBAL  R4,PPLPLC            CONVERT PPL TO BINARY PL
         MVC   XB11RTI,MS11RTI     MOVE LITERAL ID TO TEMPORARY STORE
*                                  THE PURPOSE OF THIS CODING IS TO
*                                   DETERMINE IF THIS MS11 CARD DEFINES
*                                   AN IDENTICAL CARD TYPE TO A PREVIOI
*                                   CONTROL CARD.
         L     R8,PTRCB11          RETRIEVE 1ST CB11 ADDRESS
CCMS1101 LTRR  R8,R8               TEST FOR END OF CJAIN
         BZ    CCMS1102            YES: THEN BLD CB11 FOR NEW REC TYPE
         CLC   CB11PRTI(10),XB11PRTI MATCH WITH PREV REC TYPE DEFIN'N
         BE    CCMS1125            MATCH: REC TYPE EXISTS ALREADY
         L     R8,CB11CB11         GET NEXT CB11 ADDRESS
         B     CCMS1101            LOOP BACK TO TEST FOR MATCH
CCMS1102 EQU   *                   BUILD CB11 CONTROL BLOCK
         LA    R2,CB11LGTH         GTE LENGTH OF CONTROL BLOCK
         GETCB CB11                ACQUIRE AND CHAIN C/B
         LA    R1,CB11SB11         TREAT CB11 SB11 POINTER ...
         ST    R1,PTRSB11           ... AS 1ST SB11 IN CHAIN
         LA    R1,CB11CB13         TREAT CB11CB13 AS A ''DUMMY'' CURREN
         ST    R1,PTRCB13           CB13 TO FACILITATE CHAINING
         MVC   CB11PRTI(10),XB11PRTI ADD RECORD TYPE PL & LITERAL
         ZAP   CB11CNT,ZERO        ZEROISE RECORD COUNTER
         CLC   MS11IGN,=C'IGN'     TEST FI RECORD TYPE TO BE IGNORED
         BNE   *+12                BRANCH IF NOT
         OI    CB11SW,SW11IGN      INDICATE RECORD TO BE IGNORED
         B     CCREAD              GET NEXT CONTROL CARD
         DROP  R8                  DROP CB11 ADDRESSABILITY
         EJECT
***********************************************************************
*        PROCESS MS11 CARD ( CONT'D )                                 *
***********************************************************************
         SPACE 1
         USING SB11NTRY,R8         ESATBLSH CONTROL BLOCK ADDRESSAB'Y
CCMS1125 EQU   *                   CONSTRUCT SB11 CONTROL BLOCK
         LA    R10,6               ESTABLISH LOOP
         TM    SWINIT,SWMS11       TEST IF MS12 CARD
         BO    *+8                 BRANCH IF NOT MS12
         LA    R10,3               ESTABLISH LOOP OF 3 MS12 BUCKETS
CCMS1103 CLC   MS11FLD1,SPACES     TEST IF FIELD DESCRIPTION PRESENT
         BNE   CCMS1135            CONTINUE PROCESSING IF PRESENT
         TM    SWINIT,SWMS11       TEST IF MS11 CARD
         BO    CCMS1107+4          GO INCREMENT TO NEXT MS11 BUCKET
         B     CCMS1107            GO INCREMENT TO NEXT MS12 BUCKET
CCMS1135 LA    R2,SB11LGTH         GET LENGTH OF CONTROL BLOCK
         TM    SWINIT,SWMS11       TEST IF MS11 CARD
         BO    CCMS1108            BRANCH IF MS11 CARD
         CLC   MS12NGID,=C'NONZERO' TEST FOR 'MS12' WITH 'NONZERO'
         BE    CCMS1108            BRANCH IF 'NONZERO' SPECIFIED
         LA    R2,SB12LGTH         SET LENGTH OF CONTROL BLOCK
CCMS1108 GETCB SB11                ACQUIRE AND CHAIN C/B
         MVC   SB11FNO,MS11NDC1    MOVE B/C FIELD NAME OE TEST TYPE
         MVC   SB11CRFN,MS11NCR1   MOVE C/R FIELD NAME ( IF ANY )
         LA    R2,MS11NDC1         POINT AT POSSIBLE TEST REQUEST
         CBAL  R4,TESTINTL         DEETERMINE IF FIELD IS TEST REQUEST
         BNE   CCMS1104            BRANCH IF NOT
         MVC   SB11TID,3(R1)       SAVE INTERNAL CODE FOR TEST
         OI    SB11SW,SW11DTID     INDICATE TEST REQUEST
         CLI   2(R1),C'X'          IS ASSOCIATED C/C REQUIRED
         BNE   CCMS1109            BR IF NOT
         MVI   SB11TID,X'53'       ESTABLISH DUMMY OPERATION AS NO-OP
         MVC   LINE33TT,MS11NDC1   MOVE TEST ID TO ERROR MESSAGE
         LINE  LINE33              PRINT ERROR MESSAGE
CCMS1109 EQU   *                   CONTINUE PROCESSING
         B     CCMS1105            AVOID INDICATING B/C FLD NAME
         EJECT
***********************************************************************
*        PROCESS MS11 CARD ( CONT'D )                                 *
***********************************************************************
         SPACE 1
CCMS1104 CLC   MS11NDC1,SPACES     TEST IF FIELD BLANK
         BE    *+8                 BRANCH IF YES
         OI    SB11SW,SW11DBCN     INDICATE B/C FLD NAME SUPPLIED
CCMS1105 CLC   MS11NCR1,SPACES     TEST IF C/R FLD NAME SUPPLIED
         BE    *+8                 BRANCJ IF NO
         OI    SB11SW,SW11DCRN     INDICATE C/R FLD NAME SUPPLIED
         CLI   MS11AID1,C'A'       TEST IF ACCUMULATE ABSOLUTE VALUES
         BNE   *+8                 BRANCH IF NO
         OI    SB11SW,SW11DMOD     INDICATE MODULOS TOTAL
         CLI   MS11AID1,C'P'       IS INPUT FIELD PACKED
         BNE   *+8                 BR IF NOT
         OI    SB11SW,SW11INPD     INDICATE INPUT FIELD IS PACKED
         LA    R2,MS11PDC1         POINT AT EBCDIC PPLL
         LA    R3,SB11PDC          POINT AT BINARY PL
         TM    SWINIT,SWMS11PL     IS IT MS11=PPPL
         BZ    *+12                BR IF NOT TO TREAT AS PPLL
         CBAL  R4,PPPLPLC          CONVERT PPPL TO BINARY PL
         B     *+8                 BR OVER PPLL CONVERSION
         CBAL  R4,PPLLPLC           CONVERT EBCDIC PPLL TO BINARY PL
         CLI   MS11DEC1,C' '       TEST IF NO OF DECIMALS BLANK
         BNE   *+8                 BRANCH IF NOT
         MVI   MS11DEC1,C'0'       SET TO DEFAULT OF ZERO
       NUMERIC MS11DEC1            ENSURE NO OF DECIMALS IS NUMERIC
         PACK  SB11NDEC,MS11DEC1   ADD NO OF DECIMALS TO CB
CCMS1106 TM    SWINIT,SWMS11       TEST IF MS12 CARD
         BO    CCMS1107+4          BRANCH IF NOT
         OI    SB11SW,SW11NGNZ     ASSUME 'NONZERO' SPECIFIED
         CLC   MS12NGID,=C'NONZERO' TEST IF 'NONZERO' SPECIFIED
         BE    CCMS1107            BRANCH IF YES
         NI    SB11SW,FF-SW11NGNZ  SET OFF 'NONZERO' SWITCH
         OI    SB11SW,SW11NGID     SHOW SEPARATE -VE FLD LITERAL
         PL    PPL,MS12PNEG,SB12PNEG CONVERT POSN & LGTH TO BINARY
         MVC   SB12NGID,MS12NGID   STORE LITERAL -VE IND
CCMS1107 LA    R6,10(,R6)          INCREMANT BY EXTRA 10 FOR MS12 ONLY
         LA    R6,10(,R6)          INCREMENT TO NEXT FIELD DESCRIPTION
         BCT   R10,CCMS1103        LOOP BACK TO PROCESS DESCRIPTION
         NI    SWINIT,FF-SWMS11    SET OFF MS11 INIICATOR
         B     CCREAD              GET NEXT CONRROL CARD
         DROP  R6,R8               DROP ADDRESSABLLITY
         EJECT
***********************************************************************
*        PROCESS MS13 CONTROL CARD                                    *
***********************************************************************
         SPACE 1
         USING MS13CARD,R6         ESTABLISH CONTRO CARD ADDRESS'Y
         USING CB13NTRY,R8         ESTABLISH CONTROL BLOCK ADDRESS'Y
CCMS13   EQU   *                   CONTRACT MS13 CONTROL BLOCKS
         CLI   MS13ERRI,C'3'       IS IT SET IND ONLY
         BE    CCMS1300            SUPPRESS MESSAGE IF ANY IF YES
         CLC   MS13COMM,MS13MESS   IS THIS A COMMENT
         BE    CCMS1300            BLANK OUT COMMENT IF YES
         B     CCMS1300+6          BYPASS BLANKING OUT MESSAGE
CCMS1300 MVC   MS13MESS,SPACES     BLANK OUT MESSAGE (WILL NEVER PRINT)
         LA    R2,CB13LGTH         GET BASIC CONTROL BLOCK LENGTH
         CLC   MS13MESS,SPACES     TEST IF OPTIONAL MESSAGE SPECIFIED
         BE    *+8                 BRANCH IF NOT
         LA    R2,30(,R2)          ALLOW FOR MESSAGE IN CONTROL BLOCK
CCMS1311 CBAL  R4,GETMAIN          ACQUIRE CORE FOR CONTROL BLOCK
         LR    R8,R1               PRESERVE ADDRESS OF NEW BLOCK
         L     R1,PTRCB13          RETRIEVE CURRENT CB13 POINTER
         CLC   MS13TEST,=C'SB'     IS THIS A BATCH LEVEL SUBROUTINE
         BNE   *+16                BR IF NOT
         L     R1,PTRCB14          RETRIEVE BATCH LEVEL C/B POINTER
         ST    R8,PTRCB14          SET NEW BATCH LEVEL C/B POINTER
         B     *+8                 BR OVER OTHER SETTING
         ST    R8,PTRCB13          ESTAVLISH NEW AS CURRENT
         ST    R8,CB13CB13-CB13NTRY(R1) POINT CURRENT AT NEW
         OI    CB13FLAG-CB13NTRY(R1),FLAGCB13 HSOW LAST IS CB13
         OI    CB13FLAG,FLAGCB13   SHOW CURRENT IS CB13
         ZAP   CB13CCNO,SYSIN+IOPSRCNT(4) MOVE C/C SEQ NO TO C/B
         LA    R2,MS13PRT1         POINT AT 1ST CC COMPARAND SEGMENT
         LA    R3,CB13PRT1         POINT AT 1ST CB COMPARAND SEGMENT
         LA    R10,3               ESTABLISH LOOP
CCMS1302 CLI   2(R2),C'O'          IS THIS AN INDICATOR SPECIFICATION
         BNE   CCMS1308            BR IF NOT TO TEST NUMERIC
         OI    CB13SW2,SW13INDS    SET FLAG TO SHOW INDICATORS PRESENT
         B     CCMS1304            BR TO GET NEXT BUCKET
CCMS1308 CBAL  R4,PPPLPLC          CONVERT EBCDIC PPPL TO BINARY PL
CCMS1304 LA    R2,4(,R2)           POINT AT NEXT COMPONENT PPPL
         LA    R3,2(,R3)           POINT AT NEXT COMPONENT PL
         BCT   R10,CCMS1302        LOOP BACK IF COMPONENTS LEFT
         MVC   CB13LIT,MS13LIT     STORE COMPARAND IN CONTROL BLOCK
         CLC   MS13LTYP,SPACES     SEE IF COMPARISON SPECIFIED
         BE    *+8                 BRANCH IF NO
         OI    CB13SW,SW13LIT      INDICATE COMPARAND IS PRESENT
         MVI   CB13IND0,FF         NULLIFY 1ST INDICATOR TEST
         MVI   CB13IND1,FF         NULLIFY 2ND INDICATOR TEST
         MVI   CB13IND2,FF         NULLIFY 3RD INDICATOR TEST
         TM    CB13SW2,SW13INDS    ARE THERE ANY INDICATORS PRESENT
         BZ    CCMS1307            BR IF NO INDS
         EJECT
***********************************************************************
*        PROCESS MS13 CONTROL CARD ( CONT'D )                         *
***********************************************************************
         SPACE 1
         LA    R2,MS13IND0         POINT AT 1ST C/C BUCKET
         LA    R3,CB13IND0         POINT AT 1ST C/B BUCKET
         LA    R10,3               ESTABLISH 3 BUCKET LOOP
CCMS1305 CLI   2(R2),C'O'          IS THIS AN INDICATOR SPECIFICATION
         BNE   CCMS1306            BR IF NOR AN IND
         PACK  WORKPACK,0(2,R2)    PACK INDICATOR NUMBER
         CVB   R1,WORKPACK         CONVERT IND NUMBER TO BUNARY
         STC   R1,0(R3)            PRESERVE NUMBER IN C/B
         MVI   1(R3),OF            ASSUME DESIDED STATUS IS OFF
         CLC   2(2,R2),=C'OF'      TEST IF OFF SPECIFIED
         BE    *+8                 BR IF YES
         MVI   1(R3),ON            DESIRED STAUS MUST BE ON
CCMS1306 LA    R3,2(,R3)           INCREMENT TO NEXT C/B BUCKET
         LA    R2,4(,R2)           INCREMENT TO NEXT C/C BUCKET
         BCT   R10,CCMS1305        LOOP BACK IF ANY LEFT
CCMS1307 CLI   MS13ERRI,C'1'       TEST FOR SOFT ERROR
          BNE  *+8                 BR IF NOT SOFT ERROR
          OI   CB13SW,SW13SOFT     INDICTAE SOFT ERROR
         CLI   MS13ERRI,C'2'       TEST FOR DELETE REQUEST
         BNE   *+8                 BR IF NOT DELETE REQUEST
         OI    CB13SW,SW13DLET     INDICATE DELETE RECORD
         CLI   MS13ERRI,C'3'       TEST FOR INDICATOR SETTING REQUEST
         BNE   *+8                 BR IF NOT INDICATOR REQUEST
         OI    CB13SW,SW13OIND     INDICATE INDICATOR ONLY REQUIRED
         MVI   CB13RIND,X'FF'      ASSUME NO ERROR IND SUPPLIED
         CLI   MS13RIND,C' '       TET IF ERROR IND NUMBER SUPPLIED
         BE    CCMS1310            BR IF NOT SUPPLIED
         PACK  WORKPACK,MS13RIND   PACK IND NUMBER
       NUMERIC MS13RIND            VERIFY INDICATOR NUMBER ISNUMERIC
         CVB   R1,WORKPACK         CONVERT NO TO BINARY
         STC   R1,CB13RIND         PRESERVE ERROR IND NUMBER
CCMS1310 MVC   CB13CBID,MS13MSXX   MOVE ID OF ASSOC C/B
         MVC   CB13TMOD,MS13TMOD   PRESERVE TEST MODIFIER, IF ANY
         CLI   MS13CONT,C'1'       DO WE TERMINATE IF TESTS FAILS
         BNE   *+8                 BR IF NOT
         OI    CB13SW2,SW132TMB    FLAG TO TERMIANET
         CLI   MS13CONT,C'2'       DO WE TERMINATE IF TEST SUCCEDDS
         BNE   *+8                 BR IF NOT
         OI    CB13SW2,SW132TMG    FLAG TO TERMINTE
         CLI   MS13CONT,C'3'       DO WE TERMINATE REGARDLESS
         BNE   *+8                 BR IF NOT
         OI    CB13SW2,SW132TMB+SW132TMG FLAG TO TERMINATE
         EJECT
***********************************************************************
*        PROCESS MS13 CARD ( CONT'D )                                 *
***********************************************************************
         SPACE 1
         PL    PPPLL,MS13PFLD,CB13PFLD CONVERT PPPLL TO BINARY PL
         CLC   MS13MESS,SPACES     TEST IF MESSAGE SPECIFED
         BE    *+14                BRANCH IF NO MESSAGE
         MVC   CB13MESS,MS13MESS   MOVE MESSAGE TO CB
         OI    CB13SW,SW13MESS     INDICATE MESSAGE IS PRESENT
         LA    R2,MS13TEST         POINTA AT TEST REQUEST
         CBAL  R4,TESTINTL         GET INTERNAL REPRESENTATION OF TEST
         BE    CCMS1312            BR IF TEST VALID
         OI    CB13SW,SW13NTST     FLAG C/B AS NO-OP
         LINE  LINE32              PRINT ERROR MESSAGE
CCMS1312 EQU   *                   CONTINUE PROCESSING
         MVC   CB13TEST,3(R1)      MOVE INTERNAL CODE TO CB
         MVC   CB13TST0,MS13TEST   PRESERVE CHARACTER TEST ID
         CLI   2(R1),C'X'          DOES THIS TEST REQUIRE AN ASSOC MSXX
         BNE   *+8                 BR IF NOT
         OI    CB13SW,SW13CBXX     FLAG TO SWOW A(CBXX) IS REQUIRED
         MVI   CB13LTYP,NE         ASSUME 'NE' LITERAL TEST
         CLC   MS13LTYP,=C'NE'     TEST IF 'NE'
         BE    CCMS1303            BR IF YES
         MVI   CB13LTYP,GT         ASSUME 'GT' LITERAL TEST
         CLC   MS13LTYP,=C'GT'     TEST IF 'GT'
         BE    CCMS1303            BR IF YES
         MVI   CB13LTYP,GE         ASSUME 'GE' LITERAL TEST
         CLC   MS13LTYP,=C'GE'     TEST IF 'GE'
         BE    CCMS1303            BR IF YES
         MVI   CB13LTYP,LT         ASSUME 'LT' LITERAL TEST
         CLC   MS13LTYP,=C'LT'     TEST IF 'LT'
         BE    CCMS1303            BR IF YES
         MVI   CB13LTYP,LE         ASSUME 'LE' LITERAL TEST
         CLC   MS13LTYP,=C'LE'     TEST IF 'LE'
         BE    CCMS1303            BR IF YES
         MVI   CB13LTYP,EQ         ALLOW 'EQ' AS DEFAULT
         EJECT
***********************************************************************
*        PROCESS MS13 CARD ( CONT'D )                                 *
***********************************************************************
         SPACE 1
CCMS1303 EQU   *                   CONTINUE PROCESSING
         SPACE 1
*        OPERATION CODES R6-R9 REPRESENT CONDITIONAL B/C (MS05) AND C/R
*         (MS04) ACCUMULATING, AND REQUIRE AN SB11 TO BE CREATED AND
*         CHAINED TO THE CURRENT CB11.
         SPACE 1
         CLI   MS13TEST,C'R'       IS IT AN 'RX' OPERATION
         BNE   CCMS1309            BYPASS ROUTINE IF NOT
         CLI   MS13TEST+1,C'6'     IS IT IN RANGE R6-R9
         BL    CCMS1309            BR IF LOW
         CLI   MS13TEST+1,C'9'     TEST IF IN RANGE R6-R9
         BH    CCMS1309            BYPASS ROUTINE IF HIGH
         LA    R2,SB11LGTH         SET LENGTH OF SB11
         CBAL  R4,GETMAIN          ACQUIRE CORE FOR SB11
         ST    R1,CB13CBXX         PRESERVE SB11 ADDR IN CB13
         USING SB11NTRY,R1         ESTABLISH TEMPORARY SB11 ADDRESS'Y
         ZAP   SB11CCNO,SYSIN+IOPSRCNT(4) ADD C/C SEQ NO TO C/B
         MVC   SB11FNO,MS13MSXX    ASSUME B/C ACCUM AND SAVE NAME
         MVC   SB11CRFN,MS13MSXX   ASSUME C/R ACCUM AND SAVE NAME
         MVC   SB11PDC(2),CB13PFLD PRESERVE PPPLL IN SB11
         OI    SB11SW2,SW11COND    FLAG AS CONDITIONAL ACCUMULATOR
         CLI   MS13TEST+1,C'6'     TEST IF TEST TYPE 'R6'
         BNE   *+8                 BR IF NOT
         OI    SB11SW,SW11DBCN     FLAG AS B/C ACCUM
         CLI   MS13TEST+1,C'7'     TEST IF TEST TYPE 'R7'
         BNE   *+8                 BR IF NOT
         OI    SB11SW,SW11DBCN+SW11INPD FLAG AS B/C ACCUM WITH PACKED
         CLI   MS13TEST+1,C'8'     TEST IF TEST TYPE 'R8'
         BNE   *+8                 BR IF NOT
         OI    SB11SW,SW11DCRN     FLAG AS C/R ACCUM
         CLI   MS13TEST+1,C'9'     TEST IF TEST TYPE 'R9'
         BNE   *+8                 BR IF NOT
         OI    SB11SW,SW11DCRN+SW11INPD FLAG AS C/R ACCUM WITH PACKED
         DROP  R1                  DROP TEMAPRARY SB11 ADDRESS'Y
         LR    R2,R1               POINT R2 AT THIS SB11
         L     R1,PTRSB11          POINT R1 AT PREVIOUS SB11
         ST    R2,SB11SB11-SB11NTRY(,R1) POINT PREVIOUS AT THIS
         ST    R2,PTRSB11          ESTABLISH THIS SB11 AS PREVIOUS
         OI    SB11FLAG-SB11NTRY(R1),FLAGSB11 INDICATE OLD IS SB11
         OI    SB11FLAG-SB11NTRY(R2),FLAGSB11 INDICATE NEW IS SB11
         EJECT
**********************************************************************
*        PROCESS MS13 CARD ( CONT'D )                                 *
**********************************************************************
         SPACE 1
CCMS1309 EQU   *                   CONTINUE PROCEESSING
         CLC   MS13TEST,=C'E1'     IS THIS TEST TYPE 'E1'
         BNE   *+8                 B- IF NOT
         OI    FREEE1,POOLUSE      FLAG THAT CODING REQUIRED
         CLC   MS13TEST,=C'C7'     IS THIS OPERATON 'E7'
         BNE   *+8                 BR IF NOT
         OI    FREEC7,POOLUSE      FLAG THAT CODING REQUIRED
         B     CCREAD              GO GET NEXT CONTROL CARD
         DROP  R6,R8               DROP ADDRESSABILITY
         EJECT
***********************************************************************
*        PROCESS MS14 CONTROL CARD                                    *
***********************************************************************
         SPACE 1
*        NOTE THAT AN MS14 CARD CREATES BOTH A CB13 - TO FACILITATE
*         CHAINING - AND A CB14 WHICH IS POINTED TO BY THE CB13.
         SPACE 1
         USING CB13NTRY,R8         ESTABLISH C/B ADDRESSABILITY
         USING MS14CARD,R6         ESTABLISH C/C ADDRESSABILITY
CCMS14   EQU   *                   CONSTRUCT CB13 & CB14 CONTROL BLOCKS
         CLC   MS13COMM,MS14MESS   IS THIS MESSAGE A COMMENT
         BNE   *+10                BR I NOT
         MVC   MS14MESS,SPACES     BLANK OUT MESSAGE IF COMMENT
         LA    R2,CB13LGTH         GET BASIC CONTROL BLOCK LENGTH
         CLC   MS14MESS,SPACES     IS THERE A MESSAGE SUPPLIED
         BE    *+8                 BR IF NO MESSAGE
         LA    R2,30(,R2)          INCREMENT LENGTH TO ALLOW FOR MESSAG
         CBAL  R4,GETMAIN          ACQUIRE CORE FOR COMTROL BLOCK
         LR    R8,R1               PRESERVE ADDRESS OF NEW BLOCK
         MVI   CB13FLAG,FLAGCB13   IDENTIFY NEW BLOCK AS CB13
         L     R1,PTRCB13          RETRIEVE CURRENT CB13 POINTER
         CLI   MS14BORD,C'B'       DOES TEST APPLY AT BATCH LEVEL
         BNE   *+16                BR IF APPLIES AT CARD LEVEL
         L     R1,PTRCB14          RETRIEVE BATCH LEVEL C/B POINTER
         ST    R8,PTRCB14          SET NEW BATCH LEVEL C/B PINTER
         B     *+8                 BR OVER OTHER SETTING
         ST    R8,PTRCB13          STORE NEW DETAIL LEVEE C/B POINTER
         ST    R8,CB13CB13-CB13NTRY(R1) POINT LAST AT NEW
         MVI   CB13FLAG-CB13NTRY(R1),FLAGCB13 RE-ESTABLISH LAST AS CB13
         CLC   MS14MESS,SPACES     WAS MESSAGE SUPPLIED
         BE    *+14                BR IF NO MESSAGE
         MVC   CB13MESS,MS14MESS   ADD MESSAG ETO C/B
         OI    CB13SW,SW13MESS     SET SW TO SHOW MESSAGE PRESENT
         ZAP   CB13CCNO,SYSIN+IOPSRCNT(4) ADD C/C SEQ NO TO C/B
         MVI   CB13RIND,FF         NULLIFY RESULT INDICATOR NUMBER
         CLC   MS14RIND,SPACES     TEST IF RESURT IND SUPPLIED
         BE    *+18                BR IF NOT SUPPLIED
         PACK  WORKPACK,MS14RIND   PACK RESULT IND NUMBER
         CVB   R1,WORKPACK         CONVERT TO BNARY
         STC   R1,CB13RIND         PRESERVE IND NUMBER IN C/B
         ADDR  TESTITCD,I          GET ADDRESS OF IND CODE INTERNAL REP
         MVC   CB13TEST,3(R1)      ESTABLISH AS INDICATOR TEST
         MVC   CB13TST0,0(R1)      ADD 'IT' FOR IDENTIFICATION
         PL    PPLL,MS14PFLD,CB13PFLD CONVERT PPLL TO BINARY PL
         EJECT
***********************************************************************
*        PROCESS MS14 CONTROL CARD ( CONT'D )                         *
***********************************************************************
         SPACE 1
         CLI   MS14ERRI,C'1'       TEST FOR SOFT ERRPR
         BNE   *+8                 BR IF NOT SOFT ERROR
         OI    CB13SW,SW13SOFT     INDICATE SOFT ERROR
         CLI   MS14ERRI,C'2'       TEST FOR DELETE REQUEST
         BNE   *+8                 BR IF NOT DELETE
         OI    CB13SW,SW13DLET     INDICATE DELETE REQUEST
         CLI   MS14ERRI,C'3'       TEST FOR INS SETTING REQUEST
         BNE   *+8                 BR IF NOT IND REQUEST
         OI    CB13SW,SW13OIND     INDICATE INDICATOR ONLY REQUIREDD
         LA    R2,CB14LGTH         SET LENBTH OF CB14
         CBAL  R4,GETMAIN          ACQUIRE CORE FOR CB14
         ST    R1,CB13CBXX         POINT CB13 AT CB14
         DROP  R8                  DROP CB13 ADDRESSABILITY
         USING CB14NTRY,R8         ESTABLISH CB14 ADDRESSABILITY
         LR    R8,R1               POINT R8 AT CB14
         MVI   CB14FLAG,FLAGCB14   ESTABLISH AS CB14
         ZAP   CB14CCNO,SYSIN+IOPSRCNT(4) ADD C/C SEQ NO TO C/B
         CLI   MS14BORD,C'B'       IS THIS A BATCH LEVEL TEST
         BNE   *+8                 BR IF NOT
         OI    CB14SW,SW14BTCH     FLAG AS BATCH LEVEL TEST
         CLI   MS14BORD,C'C'       IS THIS A SEQ BATCH LEVEL TEST
         BNE   *+8                 BR IF NOT
         OI    CB14SW,SW14BTCH     FLAG AS BATCH LEVEL TEST
         LA    R10,9               ESTABLISH LOOP OF 9 BUCKETS
         LA    R3,MS14TST0         POINT AT 1ST C/C BUCKET
         LA    R2,CB14TST0         POINT AT 1ST C/B BUCKET
CCMS1401 MVI   0(R2),FF            NULLIFY INDICATOR TEST
         CLC   0(2,R3),SPACES      IS INDICATOR SPECIFIED
         BE    CCMS1402            BR IF NO INDICATOR
         PACK  WORKPACK,0(2,R3)    PACK IND NUMBER
         CVB   R1,WORKPACK         CONVERT TO BINARY
         STC   R1,0(R2)            PESERVE INDICATOR NUMBER
         MVI   1(R2),OF            ASSUME DESIRED STATE IS 'OFF'
         CLC   2(2,R3),=C'OF'      TEST IF OFF SPECOFED
         BE    *+8                 BR IF YES
         MVI   1(R2),ON            DESIRES STATE MUST BE ON
CCMS1402 LA    R3,4(,R3)           INCREMENT TO NEXT C/C BUCKET
         LA    R2,2(,R2)           INCREMENT TO NEXT C/B BUCKET
         BCT   R10,CCMS1401        LOOP BACK IF BUCKETS LEFT
         B     CCREAD              GO GET NEXT CONTROL CARD
         DROP  R6,R8               DROP ADDRESSABILITY
         DROP  R11                 DROP SUB-CSECT ADDRESSABILITY
         TITLE 'BUDGIE3H - BUILD CONTROL BLOCKS'
        SCSECT H                   RESTART CSECT BUDGIE3H
***********************************************************************
*        PROCESS MS20 CARD                                            *
***********************************************************************
         SPACE 1
         USING MS20CARD,R6         ASTABBLISH C/C ADDRESSABILITY
         USING CB20NTRY,R8         ESTABLISH C/B ADDRESSABILITY
CCMS20   EQU   *                   CONSTRUCT MS20 CONTROL BLOCK
         LA    R2,CB20LGTH         SET CONTROL BLOCK LENGTH
         GETCB CB20,SAVE1ST        ACQUIRE NEW CONTROL BLOCK
         XC    SAVELITL(12),SAVELITL ZEROISE WORK AREAS
         MVC   CB20IDDN,MS20DDN    MOVE ISAM/RIGAM INFO TO C/B
         CLI   MS20FNO,C'0'        TEST IF DDNAME ( IE ISAM )
         BH    *+8                 BR IF RIGAM
         OI    CB20SW,SW20IS       FLAG AS ISAM
         MVC   CB20TID,MS20TEST    ADD TEST NAME (LABELE TO C/B
         TM    CB20SW,SW20IS       TEST IF RIGAM
         BO    *+8                 BR IF ISAM
         MVI   CB20FLAG,FLAGCB2R   ALTER C/B FLAG TO SHOW RIGAM
         ZAP   CB20ICNT,ZERO       ZEROISE RECORD COUNT
         LA    R1,1                SET R1 TI 1
         ST    R1,SAVELITP         SET POSN WITHIN LITERAL POOL TO 1
         LA    R10,8               ESTABLISH LOOP OF 8 KEY COMPONETS
CCMS2001 CLI   MS20LITI,C'L'       TEST FOR LITERAL
         BE    *+12                BR IF LITERAL SPECIFICATION
         CLI   MS20LITI,C'S'       TEST IF DERIVED FROM CB13 AT EXEC
         BNE   CCMS2002            BR IF NOT
         MVC   CB20TYP,MS20LITI    STORE IDENTIFYING INFO
         PACK  WORKPACK,MS20LITL   PACK LITERAL LENGTH
         CVB   R1,WORKPACK         CONVERT LENGTH TO BINARY
         STC   R1,CB20LEN          PRESERVE LENGTH OF LITERAL
         L     R2,SAVELITP         RETRIEVE POSN OF LITERAL
         STC   R2,CB20POS          PRESERVE POSN OF LIERAL
         AR    R2,R1               INCREMENT FOR LENGTH OF NEXT LITERAL
         ST    R2,SAVELITP         STORE POSN OF NEXT LITERAL
         L     R2,SAVELITL         GET LENGTH OF LITERAL POOL
         AR    R2,R1               INCREMENT FOR NEW LITERAL
         ST    R2,SAVELITL         PRESERVE UPDATED POOL LENTH
         IC    R2,CB20LEN          GET LENGTH OF KEY ELEMENT
         A     R2,SAVEKEYL         ADD PREVIOUS KEY LENGTH
         ST    R2,SAVEKEYL         STORE UPDATED KEY LENGTH
         B     CCMS2003            GO INCREMENT TO NEXT BUCET
         EJECT
***********************************************************************
*        PROCESS MS20 CONTROL CARD ( CONT'D )                         *
***********************************************************************
         SPACE 1
CCMS2002 CLC   MS20FLD1,SPACES     TEST IF COMPONENT UNUSED
         BE    CCMS2003            BR TO NEXT BUCKET IF UNUSED
         MVC   CB20TYP,MS20DORB    PRESERVE SOURCE OF COMPOMENT
         CLI   CB20TYP,C' '        IS THE SOURCE LEFT BLANK
         BNE   *+8                 BR IF NOT BLANK
         MVI   CB20TYP,C'D'        FORCE DEFAULT VALUE OF 'D' (DETAIL)
         PL    PPPLL,MS20POSN,CB20POS CONVERT PPPLL TO PL
         SR    R2,R2               ZEROISE WORK REGISTER
         IC    R2,CB20LEN          GET LENGTH OF KEY ELEMENT
         A     R2,SAVEKEYL         ADD PREVIOUS KEY LENGTH
         ST    R2,SAVEKEYL         STORE UPDATED KEY LENGTH
CCMS2003 LA    R6,8(,R6)           INCREMENT TO NEXT CONTROL CARD BUCKT
         LA    R8,3(,R8)           INCREMENT TO NEXT C/B BUCKET
         BCT   R10,CCMS2001        GO PROCESS NEXT BUCKET, IF ANY
         L     R8,PTRCB20          ADJUST R8 TO START OF C/B
         L     R6,SYSIN+IOPSRECA   ADJUST R6 TO STAT OF CONTROL CARD
         L     R2,SAVELITL         GET LENGTH OF LITERAL POOL
         LA    R1,CB20CB21         TREAT CB20 CB21 POINTER ...
         ST    R1,PTRCB21          ... AS 1ST CB21 IN CHAIN
         LTRR  R2,R2               TEST IF LITERAL POOL REQUIRED
         BZ    CCMS2006            BR IF NO LITERAL POOL
         CBAL  R4,GETMAIN          ACQUIRE CORE FOR LITERAL POOL
         ST    R1,CB20POOL         SAVE ADDRES  OF LITERAL POOL
         LR    R3,R1               PRESERVE ADDRESS OF LITERAL POOL
         LA    R10,8               ESTABLISH LOOP OF 8 BUCKETS
CCMS2004 CLI   CB20TYP,C'L'        TEST IF LITERAL COMPONENT
         BNE   CCMS2005            BR IF NOT LITERAL
         SR    R1,R1               ZEROISE ....
         SR    R2,R2                ... WORK REGISTERS
         IC    R1,CB20LEN          GET LENGTH OT LITERAL
         BCTR  R1,0                DECREMENT FOR EXECUTE
         IC    R2,CB20POS          GET POSN OF LITERAL IN POOL
         BCTR  R2,0                ALTER POSN TO DISPLACEMENT
         AR    R2,R3               ADD ADDR OF POOL TO DISPLACEMENT
         EX    R1,CB20MOVL         ADD LITERAL TO POOL
         EJECT
***********************************************************************
*        PROCESS MS20 CONTROL CARD ( CONT'D )                         *
***********************************************************************
         SPACE 1
CCMS2005 LA    R8,3(,R8)           POINT AT NEXT C/B BUCKET
         LA    R6,8(,R6)           INCREMENT TO NEXT CONTROL CARD BUCKE
         BCT   R10,CCMS2004        GO PROCESS NEXT BUCKET IF ANY
CCMS2006 L     R8,PTRCB20          ADJUST R8 TO START OF C/B
         L     R6,SYSUT1+IOPSRECA  ADJUST R6 TO START OF CONTROL CARD
         L     R2,SAVEKEYL         RETRIEVE KEY LENGTH
         STC   R2,CB20KLEN         PRESERVE KEY LENGTH IN C/B
         SLA   R2,1                MULTIPLY LENGTH BY 2
         CBAL  R4,GETMAIN          GET CORE TO SAVE 2 KEYS
         ST    R1,CB20TKEY         SAVE ADDRESS OF 1ST KEY
         A     R1,SAVEKEYL         INCREMENT TO 2ND KEY ADDRESS
         ST    R1,CB20LKEY         SAVE ADDRESS OF LAST KEY
         TM    CB20SW,SW20IS       TEST IF ISAM FILE
         BZ    CCMS2007            BR IF NOT ISAM
         OI    CB20ISW,IOSWINPT    FLAG ISAM FILE AS INPUT
         IOM   TIOTSCAN,CB20DCBS   VERIFY IF DD STATEMENT PRESENT
CCMS2007 CBAL  ,CCREAD             GO GET NEXT CONTROL CAD
         DROP  R6,R8               DROP ADDRESSABILITY
         EJECT
***********************************************************************
*        PROCESS MS21 CARD                                            *
***********************************************************************
         SPACE 1
         USING MS21CARD,R6         ASTABLISH C/C ADDRESSABILITY
         USING CB21NTRY,R8         ESTABLISH C/B ADDRESSABILITY
CCMS21   EQU   *                   CONSTRUBT MS21 COONTRIL BLOCK
         LA    R10,2               ESTABLISH LOOP OF 2 BUCKETS
CCMS2101 CLC   MS21FLD1,SPACES     TEST IF BUCKET IN USE
         BE    CCMS2102            BR IF NOT IN USE
         LA    R2,CB21LGTH         SET BASIC C//B LENGTH
         CLI   MS21ERRI,C'1'       IS PD CHARACTER DESIRED
         BNE   *+8                 BR IF NOT
         LA    R2,1(,R2)           INCREMENT LGTH FOR PAD CGARACTER
         CLI   MS21ERRI,C'2'       IS DEFEULT LITERAL DESIRED
         BNE   *+8                 BR IF NOT LITERAL
         LA    R2,20(,R2)          INCREMENT LGTH FOR LITERAL
         GETCB CB21                ACQUIRE & CHAIN C/B
         PL    PPPLL,MS21SPOS,CB21SPOS CONVERT PPPLL TO PL
         PACK  WORKPACK,MS21DPOS   PACK OUTPUT POSN
         CVB   R1,WORKPACK         CONVERT POSN TO BINARY
         STC   R1,CB21DPOS         PRESERVE OUTPUT POSN
         CLI   MS21PIND,C'U'       TEST IF UNPACKING REQUIRED
         BNE   *+8                 BR IF NO UNPACKING
         OI    CB21SW,SW21UNP      FLAG TO SHOW UNPACK
         CLI   MS21PIND,C'P'       TEST IF PACKING REQUIRED
         BNE   *+8                 BR IF NO PACKING
         OI    CB21SW,SW21PACK     FLAG TO SHOW PACK
         CLI   MS21ERRI,C'1'       TEST IF PADDING REQUIRED
         BNE   *+14                BR IF NO PADDING
         EJECT
***********************************************************************
*        PROCESS MS21 CARD ( CONT'D )                                 *
***********************************************************************
         SPACE 1
         MVC   CB21PADC,MS21PADC   PRESERVE PAD CGARACTER IN C/B
         OI    CB21SW,SW21PAD      FLAG TO  SHOW PADDING REQIURED
         CLI   MS21ERRI,C'2'       TEST IF DEFAULY LITERAL SUPPLIED
         BNE   *+14                BR IF NO ITERAL
         MVC   CB21LIT,MS21LIT     PRESERVE DEFAULT LITERAL
         OI    CB21SW,SW21LIT      FLAG TO SHOW LITERAL
         SR    R3,R3               ZEROISE WORK REGISTER
         IC    R3,CB21SLEN         GET LENGTH OF SOURCE FIELD
         TM    CB21SW,SW21PACK     IS RETRIVED FIELD TO BE PACKED
         BZ    CCMS2103            BR IF NOT TO BE PACKED
*
*                                  ALGORITHM IS L2 = (L1 + 1) / 2
*
         SR    R2,R2               ZEROISE WORK REGISTER
         LA    R3,1(,R3)           INCREMENT LENGTH BY 1
         LA    R1,2                SET R1 TO VALUE OF 2
         DR    R2,R1               DIVIDE INCREMENTED LENGTH BY 2
         BCTR  R3,0                DECREMENT FOR SUBSEQUENT EXECUTES
         STC   R3,WORKPL           PRESERVE QUOTIENT
         MVO   CB21SLEN,WORKPL(1)  ESTABLISH L2||L1 FOR EXECUTES
CCMS2103 TM    CB21SW,SW21UNP      IS RETRIEVED FIELD TO BE UNPACKED
         BZ    CCMS2102            BR IF NOT TO BE UNPACKED
*
*                                  ALGORITHM IS L2 = (2 * L1) - 1
*
         AR    R3,R3               MULTIPLY LENGTH BY 2
         BCTR  R3,0                SUBTRACT 1 FROM DOUBLED LENGTH
         BCTR  R3,0                DECREMENT FOR SUBSEQUENT EXECUTES
         STC   R3,WORKPL           PRESERVE MODIFIED LENGTH
         MVO   CB21SLEN,WORKPL(1)  ESTABLISH L2||L1 FOR EXECUTES
CCMS2102 LA    R6,30(,R6)          INCREMENT TO NEXT BUCKET
         BCT   R10,CCMS2101        BR TO PROCESS BUCKET, IF ANY
         CBAL  ,CCREAD             GO GET NEXT CONTROL CARD
         DROP  R6,R8               DROP ADDRESSABILITY
         EJECT
***********************************************************************
*        PROCESS MS30 CONTROL CARD                                    *
***********************************************************************
         SPACE 1
         USING MS30CARD,R6         ESTABLISH C/ ADDRESSABILITY
         USING CB30NTRY,R8         ESTABLISH C/B ADDRESSABILITY
CCMS30   EQU   *                   CONSTRUCT MS30 CONTROL BLOCK
         LA    R2,CB30LGTH         SET C/B LENGTH
         GETCB CB30                ACQUIRE & CHAIN NEW CONTROL BLOCK
         MVC   CB30TID,MS30TID     SET TEST I D ( LABEL )
         CLI   MS30RID,C'N'        IS THIS A NUMERIC RANGE/LITERAL
         BNE   *+8                 BR IF NOT NUMERIC
         OI    CB30SW,SW30PAKD     FLAG AS NUMERIC
         CLI   MS30TYPE,C'X'       IS THIS AN AXTERNAL RANGE
         BNE   *+8                 BR IF NOT
         OI    CB30SW,SW30EXT      FLAG AS 'EXTERNAL' RANGE TEST
         MVC   CB30RNG1,MS30RNG1   ADD START OF RANGE TO C/B
         MVC   CB30RNG2,MS30RNG2   ADD END OF RANGE TO C/B
         TM    CB30SW,SW30PAKD     IS THIS A NUMERIC RANGE
         BZ    CCMS3001            BR IF NIT NUMERIC RANGE
       NUMERIC MS30RNG1,,SIGNED    TEST IF FIELD NUMERIC
         ZAP   CB30RNG1,WORKPACK   STORE PACKED VALUE IN C/B
       NUMERIC MS30RNG2,,SIGNED    TEST IF FIELD NUMERIC
         ZAP   CB30RNG2,WORKPACK   STORE PACKED VALUE
CCMS3001 CBAL  ,CCREAD             GO GET NEXT CONTROL CARD
         DROP  R6,R8               DROP ADDRESSABILITY
         EJECT
***********************************************************************
*        PROCESS MS32 CONTROL CARD                                    *
***********************************************************************
         SPACE 1
         USING MS32CARD,R6         ESTABLISH C/C ADDRESSABILITY
         USING CB32NTRY,R8         ESTABLISH C/B ADDRESSABILITY
CCMS32   EQU   *                   CONSTRUCT MS32 CONTROL BLOCK
         LA    R2,CB32LGTH         SET C/B LENGTH
         GETCB CB32                ACQUIRE & CHAIN NEW CONTROL BLOCK
         MVC   CB32TID,MS32TID     SET TEST ID ( LABEL )
         MVC   CB32ICDE,MS32ICL    ASSUME LITERAL INPUT CODE & STORE
         OI    CB32SW1,SW321ICL    ASSUME INPUT CODE LITERAL & FFLAG
         CLI   MS32ICLF,C'L'       TEST IF INPUT CODE IS              I
         BE    CCMS3201            BR IF INPUT CODE IS A LITERAL
         NI    CB32SW1,FF-SW321ICL SET OFF 'LITERAL' FLAG
         OI    CB32SW1,SW321ICS    FLAG TO DERIVE INPUT CODE FROM MS13
         CLI   MS32ICLF,C'S'       TEST IF INPUT CODE IS TO BE DERIVED
         BE    CCMS3201            BR IF INPUT CODE IS TO BE DERIVED
         NI    CB32SW1,FF-SW321ICS SET OFF 'DERIVE' FLAG
       NUMERIC MS32ICP             ENSURE POSN I NUMERIC
         CVB   R1,WORKPACK         CONVERT POSN TO BINARY
         STC   R1,CB32ICP          PRESERVE POSN OF INPUT CURR CODE
CCMS3201 MVC   CB32OCDE,MS32OCL    ASSUME LITERAL OUTPUT CODE & STORE
         OI    CB32SW1,SW321OCL    ASSUME OUTPUT CODE IS LITERAL & FLAG
         CLI   MS32OCLF,C'L'       TEST IF OUTPUT CODE IS LITERAL
         BE    CCMS3202            BR IF OUTPUT CODDE ID A LITERAL
         NI    CB32SW1,FF-SW321OCL SET OFF 'LITERAL' FLAG
         OI    CB32SW1,SW321OCS    ASSUME OUTPUT CODE TO BE DERIVED
         CLI   MS32OCLF,C'S'       TEST IF CODE TO BE ERIVED FROM MS13
         BE    CCMS3202            BR IF CODE TO BE DERIVED
         NI    CB32SW1,FF-SW321OCS SET OFF 'DERIVE' FLLAG
       NUMERIC MS32OCP             ENSURE POSN OF CODE IS NUMERIC
         CVB   R1,WORKPACK         CONVERT POSN TO BINARY
         STC   R1,CB32OCP          PRESERVE POSN OF OUTPUT CURR CODE
         EJECT
***********************************************************************
*        PROCESS MS32 CONTROL CARD ( CONT'D )                         *
***********************************************************************
         SPACE 1
CCMS3202 OI    CB32SW1,SW321IVS    ASSUMEM INPUT FIELD TO BE TAKEN MS13
         CLI   MS32INP,C'S'        TEST IF OUTPUT FIELD TO BE DERIVED
         BE    CCMS3203            BR IF INPUT FIELD TO BE DERIVED
         NI    CB32SW1,FF-SW321IVS SET OFF 'DERIVE' FLAG
         PL    PPPLL,MS32INP,CB32INP CONVERT 'PPPLL' TO BINARY
CCMS3203 CLI   MS32INT,C'P'        TEST IF INPUT VALUE IS PACKED
         BNE   *+8                 BR IF NOT
         OI    CB32SW2,SW322IVP    FLAG THAT INPUT IS PACKED
CCMS3204 OI    CB32SW1,SW321NOC    ASSUME NO CURRENCY CONV REQUIRED
         CLC   MS32OUTP(5),SPACES  TEST IF ANY OUTPUT FIELD
         BE    CCMS3205            BR IF NO OUTPUT FIELD
         NI    CB32SW1,FF-SW321NOC SET OFF 'NO COONV' FLAG
         OI    CB32SW2,SW322OVS    ASSUME OUTPUT FIELD TO BE DERIVED
         CLI   MS32OUTP,C'S'       EST IF OUTPUT FIELD TO BE DERIVED
         BE    CCMS3205            BR IF OUTPUT POSN TO BE DERIVED
         NI    CB32SW2,FF-SW322OVS SET OFF 'DERIVE' FLAG
         PL    PPPLL,MS32OUTP,CB32OUTP CONVERT OUTPUT PPPLL TO BINARY
CCMS3205 CLI   MS32OUTT,C'P'       TEST IF OUTPUT REQUIRED PACKED
         BNE   *+8                 BR IF NOT
         OI    CB32SW2,SW322OVP    FLAG OUTPUT AS PACKED
         EJECT
***********************************************************************
*        PROCESS MS32 CONTROL CARD ( CONT'D )                         *
***********************************************************************
         SPACE 1
CCMS3206 EQU   *                   CONTINUE PROCESSING
CCMS3207 CLC   MS32RTEP(5),SPACES  TEST IF CONVERSION RATE REQUIRER
         BE    CCMS3208            BR IF NO CONV  RATE REQUIRED
         OI    CB32SW1,SW321RTE    SET TO EXTRACT CONV RATE
         OI    CB32SW2,SW322RTS    ASSUME RATE PL TO BE DERIVED
         CLI   MS32RTEP,C'S'       TEST IF RATE PL TO BE DERIVED
         BE    CCMS3208            BR IF RATE POSN TO BE DERIVED
         NI    CB32SW2,FF-SW322RTS SET OFF 'DERIVE' FLAG
         PL    PPPLL,MS32RTEP,CB32RTEP CONVERT PPPLL TO BINATY
CCMS3208 CLI   MS32RTET,C'P'       IS CONV RATE REQUIRED PACKED
         BNE   *+8                 BR IF NOT
         OI    CB32SW2,SW322RTP    FLAG TO OUTPUT RATE AS PACKED
CCMS3209 CLC   MS32NMIP,SPACES     TEST IF NAME OF INPUT CODE REQUIRED
         BE    CCMS3210            BR IF NOT
         OI    CB32SW2,SW322INM    FLAG THAT NAME IS REQUIRED
       NUMERIC MS32NMIP            ENSURE POSN IS NUMERIC
         CVB   R1,WORKPACK         CONVERT POSN TO BINARY
         STC   R1,CB32NMIP         PRESERVE POSN OF INPUT NAME
CCMS3210 CLC   MS32NMOP,SPACES     TEST IF NAME OF OUTPUT CODE REQUIRED
         BE    CCMS3211            BR IF NOT
         OI    CB32SW2,SW322ONM    FLAG THAT PUTPUT NAME IS REQUIRED
       NUMERIC MS32NMOP            ENSURE THAT POSN IS NUMERIC
         CVB   R1,WORKPACK         CONVERT POSN TO BINARY
         STC   R1,CB32NMOP         PRESERVE POSN OF OUTPUT NAME
               EJECT
***********************************************************************
*        PROCESS MS32 CONTROL CARD ( CONT'D )                         *
***********************************************************************
         SPACE 1
CCMS3211 CLC   MS32VNOP,SPACES     TEST IF VERSION NUMBER REQUIRED
         BE    CCMS3212            BR IF NO
         OI    CB32SW2,SW322VNO    FLAG THAT VESRION NUMBER REQUIRED
       NUMERIC MS32VNOP            ENSURE POSN IS NUMERIC
         CVB   R1,WORKPACK         CONVERT NUMBER TO BINARY
         STC   R1,CB32VNOP         PRESERVE POSN OF VERSION NUMBER
CCMS3212 CLI   MS32ERRI,C'1'       ARE WE TO ZEROISE IF ERROR
         BNE   *+8                 BE IF NOT
         OI    CB32SW1,SW321ZRO    FLAG TO ZEROISE IF ERROR
CCMS3213 PACK  WORKPACK,MS32RNDN   ASSUME ROUNDING & PACK NO OF DIGITS
         CLI   MS32RNDN,C' '       IS THERE ANY ROUNDING
         BE    CCMS3214            BR IF NO ROUNDING
         CVB   R1,WORKPACK         CONVERT NO OF DIGITS TO BINARY
         STC   R1,CB32RNDN         PRESERVE NO OF DIGITS
         CLI   MS32RNDF,C'A'       IS EVERYTHING TO BE ROUNDED
         BNE   *+8                 BR IF NOT
         OI    CB32SW3,SW323RND    FLAG TO PERFORM ROUNDING
         CLI   MS32RNDF,C'C'       IS CONMERCIAL ROUNDING RQUIRED
         BNE   *+8                 BR IF NOT
         OI    CB32SW3,SW323COM    FLAG TO PERFORM COMMERCIAL ROUNDING
CCMS3214 EQU   *
         CBAL  ,CCREAD             GO GET NEXT CONTROL CARD
         DROP  R11                 DROP SUB-CSECT ADDRESSABILITY
         TITLE 'BUDGIE3K - BUILD CONTROL BLOCKS'
        SCSECT K                   START CSECT BUDGIE3K
***********************************************************************
*        PROCESS MS33 CONTROL CARD                                    *
***********************************************************************
         SPACE 1
         USING MS33CARD,R6         ESTABLISH C/C ADDRESSABILITY
         USING CB33NTRY,R8         ESTABLISH C/B ADDRESSABILITY
CCMS33   EQU   *                   CONSTRUCT MS33 CONTROL BLOCK
       NUMERIC MS33LEN1            ENSURE LENGTH IS NUMERIC
         LA    R2,CB33LGTH         SET BASIC C/B LENGTH
         CLC   MS33POS1,=C'LIT'    TEST IF LITERAL SUPPLIED
         BNE   CCMS3301            BR IF NO LITERAL
         CLC   MS33LEN1,SPACES     WAS LENGTH OMITTED
         BNE   CCMS3306            BR I FLENGHT SUPPLIED
         OI    SWERROR,SWEFLUSH    SET TO TERMINATE AFTER C/C SCAN
         MVC   COMPCODE,COND16     SET COMPLETION CODE
         LINE  LINE30              TELL OF ERROR
         B     CCMS33X             TERMINATE PROCESSING THIS CARD
CCMS3306 CVB   R2,WORKPACK         CONVERT LITERAL LENGTH TO BINARY
         LA    R2,CB33LGTH(,R2)    INCREMANT BY BASIC DSECT LENGTH
CCMS3301 GETCB CB33                ACQUIRE & CHAIN CONTROL BLOCK
         CVB   R1,WORKPACK         CONVERT LITERAL LENGTH TO BINARY
         STC   R1,CB33LEN1         PRESERVE LENGTH IN C/B
         MVC   CB33TID,MS33TID     PRESERVE TEST ID  ( LABEL )
         CLC   MS33POS1,=C'LIT'    IS A LITERAL SUPPLIED
         BNE   *+8                 BR IF NO LITERAL
         OI    CB33SW,SW33LIT      INDICATE LITERAL IS PRESENT
         CLI   MS33TYPE,C'M'       IS THIS A MOVE OPERATION
         BNE   CCMS3302            BR IF NOT A MOVE
         OI    CB33SW,SW33MOVE     FLAG AS A MOVE OPERATION
         CLI   MS33TYPE+1,C'U'     TEST FOR 'MU' OPERATION
         BNE   *+8                 BR IF NOT 'MU'
         OI    CB33SW,SW33MU       FLAG AS 'MU' OPERATION
         CLI   MS33TYPE+1,C'P'     TEST FOR 'MP' OPERATION
         BNE   *+8                 BR IF NOT 'MP'
         OI    CB33SW,SW33MP       FLAG AS 'MP' OPERATION
         B     CCMS3303            BR TO NEXT COMMON CODING
         EJECT
***********************************************************************
*        PROCESS MS33 CONTROL CARD ( CONT'D )                         *
***********************************************************************
         SPACE 1
CCMS3302 MVI   CB33TYPE,NE         ASSUME 'NE' OPERATION
         CLC   MS33TYPE,=C'NE'     TEST IF ASSUMPTION CORRECT
         BE    CCMS3303            BR IF ASSUMPTION CORRECT
         MVI   CB33TYPE,GT         ASSUME 'GT' OPERATION
         CLC   MS33TYPE,=C'GT'     TEST IF ASSUMPTION CORRECT
         BE    CCMS3303            BR IF ASSUMPTION CORRECT
         MVI   CB33TYPE,GE         ASSUME 'GE' OPERATION
         CLC   MS33TYPE,=C'GE'     TEST IF ASSUMPTION CORRECT
         BE    CCMS3303            BR IF ASSUMPTION CORRECT
         MVI   CB33TYPE,LE         ASSUME 'LE' OPERATION
         CLC   MS33TYPE,=C'LE'     TEST IF ASSUMPTION CORRECT
         BE    CCMS3303            BR IF ASSUMPTION CORRECT
         MVI   CB33TYPE,LT         ASSUME 'LT' OPERATION
         CLC   MS33TYPE,=C'LT'     TEST IF ASSUMPTION CORRECT
         BE    CCMS3303            BR IF ASSUMPTION CORRECT
         MVI   CB33TYPE,EQ         ASSUME 'EQ' OPERATION
CCMS3303 CLI   MS33CTYP,C'P'       IS IT COMPARE OF PACKED FIELDS
         BNE   *+8                 BR IF NOT
         OI    CB33SW,SW33CPD      FLAG AS PACKED DECIMAL COMPARE
         CLI   MS33CTYP,C'N'       IS IT COMPARE OF EBCDIC NUMERIC FLDS
         BNE   *+8                 BR IF NOT
         OI    CB33SW,SW33CNUM     FLAG AS COMPARE OF EBCDIC NUMERIC
         CLC   MS33LEN2,SPACES     TEST IF RECEIVING LENGTH SPECIFIED
         BNE   *+10                BR IF NOT
         MVC   MS33LEN2,MS33LEN1   SET TO SAME AS 'FROM' LENGTH
         PL    PPPLL,MS33POS2,CB33POS2 CONVERT 'PPPLL' OF 'TO' FIELD
         EJECT
***********************************************************************
*        PROCESS MS33 CONTROL CARD ( CONT'D )                         *
***********************************************************************
         SPACE 1
         IC    R1,CB33LEN2         RETRIEVE 'TO' LENGTH
         BCTR  R1,0                DECREMENT FOR FUTURE EXECUTES
         STC   R1,CB33LEN2         PRESERVE MODIFIED LENGTH
         TM    CB33SW,SW33LIT      IS THERE A LITERAL
         BZ    CCMS3304            BR IF NO LITERAL
         SR    R1,R1               ZEROISE WORK REGISTER
         IC    R1,CB33LEN1         RETRIEVE LENGTH OF LITERAL
         BCTR  R1,0                DECREMENT LENGTH FOR EXECUTE
         EX    R1,CCMS33MV         MOVE LITERAL TO C/B
         B     CCMS3305            BR TO NEXT COMMON CODE
CCMS3304 PL    PPPLL,MS33POS1,CB33POS1 CONVERT 'FROM' PPPLL TO BINARY
CCMS3305 TM    CB33SW,SW33MU+SW33MP IS THERE A PACK/UNPACK TO PERFORM
         BZ    *+10                BR IF NOT
         MVO   CB33LEN1,CB33LEN2   ESTABLISH L1||L2 FOR SUBSEQUENT EXEC
CCMS33X  CBAL  ,CCREAD             GO GET NEXT CONTROL CRD
         SPACE 1
CCMS33MV MVC   CB33LIT(0),MS33LIT  ADD LITERAL TO C/B
         DROP  R6,R8               DROP ADDRESSABILITY
         EJECT
***********************************************************************
*        PROCESS MS34 CONTROL CARD                                    *
***********************************************************************
         SPACE 1
         USING MS34CARD,R6         ESTABLISH C/C ADDRESSABILITY
         USING CB34NTRY,R8         ESTABLISH CB34 ADDRESSABILITY
CCMS34   EQU   *                   CONSTRUCT MS34 CONTROL BLOCK
         L     R8,PTRCB34          GET ADDRESS OF PREVIOUS C/B
         CLI   CB34FLAG,FLAGCB34   WAS IT A CB34
         BNE   CCMS3401            BR IF NOT TO BUILD ONE
         CLC   CB34TID,MS34TID     WAS IT FOR THE SAME LABEL
         BE    CCMS3402            BR IF YES TO ADD DATA TO LIST
CCMS3401 PL    PPPL,MS34NLST,FLDP  VERIFY NO OF ENTRIES & LENGTH ARE
         SR    R1,R1               SEROISE WORK REGISTER
         SR    R3,R3               SEROISE WORK REGISTER
         IC    R1,FLDP             ADD NO OF ENTRIES TO R1
         IC    R3,FLDL             LENGTH OF EACH ENTRY INTO R3
         MR    R2,R1               CALCULATE LENGTH OF LIST
         LR    R10,R3              PRESERVE LENGTH OF LIST AREA
         LA    R2,CB34LGTH(,R3)    ADD ON BASIB C/B LENGTH
         GETCB CB34                ACQUIRE AND CHAIN C/B
         MVC   CB34TID,MS34TID     ADD LABEL TO C/B
         MVC   CB34NLST(2),FLDP    ADD NO OF ENTRIES & LENGTH
         ST    R10,CB34LENO        SHOW ENTIRE LIST IS OUTSTANDING
         LA    R10,CB34LIST        POINT AT 1ST BYTE OF LIST
         ST    R10,CB34NPOS        PRESERVE AS ADRESS OF NEXT BYTE
         EJECT
***********************************************************************
*        PROCESS MS34 CONTROL CARD ( CONT'D )                         *
***********************************************************************
         SPACE 1
CCMS3402 L     R1,CB34NPOS         GET ADDRESS OF 1ST AVAILABLE BYTE
         L     R2,CB34LENO         GET LENGTH OF LIST UNUSED
         CH    R2,=H'70'           IS IT LESS THAN 1 CARD
         BH    CCMS3403            BR IF MORE THZN 1 CARD
         BCTR  R2,0                DECREMENT FOR EXECURE
         EX    R2,CCMS34MV         ADD DATA TO LIST
         XC    CB34LENO(8),CB34LENO ZEROISE OUTSTABDING LENGTH & ADDRES
         B     CCMS3404            BR TO NEXT COMMON CODE
CCMS3403 MVC   0(70,R1),MS34LIST   ADD CARD'S DATA TO LIST
         LA    R1,70(,R1)          INCREMENT TO NEXT AVAILABLE BYTE
         ST    R1,CB34NPOS          ... AND PRESERVE IT
         SH    R2,=H'70'           CALCULATE OUTSTANDING LENGTH
         BL    ABEND08             IF -VE THEN C/C ERROR HAS OVERWRITEN
         ST    R2,CB34LENO         PRESERVE OUTSTANDING LENGTH
CCMS3404 CBAL  ,CCREAD             GO GET NEXT CONTROL CARD
CCMS34MV MVC   0(0,R1),MS34LIST    EXECUTED MOVE INSTRUCTION
         DROP  R6,R8               DROP ADDRESSABILITY
         EJECT
***********************************************************************
*        PROCESS MS36 CONTROL CARDS                                   *
***********************************************************************
         SPACE 1
         USING MS36CARD,R6         ESTABLISH C/C ADDRESSABILITY
         USING CB36NTRY,R8         ESTABLISH C/B ADDRESSABILITY
CCMS36   EQU   *
         LA    R2,CB36LGTH         SET LENGTH OF C/B
         CLC   MS36POS2,=C'LIT'    IS OPERAND 2 A LITERAL
         BNE   *+8                 BR IF NOT
         LA    R2,8(,R2)           INCRESE C/B SIZE TO ALLOW FOR LITERL
         GETCB CB36                ACQUIRE & CHAIN NEW C/B
         MVC   CB36TID,MS36TID     SET TEST ID ( LABEL )
         PL    PPPLL,MS36POS1,CB36POS1 CONVERT PPPLL OF OPERAND 1 TO BI
         CLC   MS36POS2,=C'LIT'    IS OPERAND 2 A LITERAL
         BNE   CCMS3603            BR IF NOT LITERAL
         OI    CB36SW,SW36LIT      FLAG THAT OPERAND 2 IS A LITERAL
       NUMERIC MS36LIT,,SIGNED     ENSURE THAT LITERAL IS NUMERIC
         EJECT
***********************************************************************
*        PROCESS MS36 CONTROL CARD ( CONT'D )                         *
***********************************************************************
         SPACE 1
         PACK  CB36LIT,MS36LIT     PACK LITERAL VALUE INTO C/B
         B     CCMS3604            GO PROCESS DEFINITION OF RESULT FIEL
CCMS3603 PL    PPPLL,MS36POS2,CB36POS2 CONVERT PPPLL OF OPERAND 2 TO BI
CCMS3604 PL    PPPLL,MS36POS3,CB36POS3 CONVERT PPPLL OF RESULT TO BINRY
         CLI   MS36TYP1,C'P'       TEST IF 1ST OPERAND PACKED
         BNE   *+8                 BR IF NOT PACJED
         OI    CB36SW,SW36PCK1     FLAG THAT OPERAND 1 IS PACKED
         CLI   MS36TYP2,C'P'       TEST IF OPERAND 2 IS PACKED
         BNE   *+8                 BR IF NOT PACKED
         OI    CB36SW,SW36PCK2     FLAG THAT OPERAND 2 IS PACKED
         CLI   MS36TYP3,C'P'       TEST IF RESULT IS TO BE PACKED
         BNE   *+8                 BR IF NOT TO BE PACKED
         OI    CB36SW,SW36PCK3     FLAG THAT RESULT IS TO BE PACKED
         PACK  WORKPACK,MS36RNDN   PACK NO OF DIGITS TO BE ROUNDED
         CLI   MS36RNDN,C' '       TEST IF ROUNDING RQUIRED
         BE    CCMS3601            BR IF NO ROUNDING
         OI    CB36SW,SW36NRND     ASSUMA ALL ROUNDING SUPPRESSED
         CLI   MS36RNDN,C'N'       TEST IF ROUNDING SUPPRESSED
         BE    CCMS3601            BR IF ROUNDING SPPRESSEC
         NI    CB36SW,FF-SW36NRND  SET OFF SUPPRESS ROUNDING FALD
         CVB   R1,WORKPACK         CONVERT NO OF DIGITS TO BINARY
         STC   R1,CB36RNDN         PRESERVE RUNDING REQUIREMENTS
         OI    CB36SW,SW36RND      FLAG THAT ROUNDING IS REQUIRED
         EJECT
***********************************************************************
*        PROCESS MS36 CONTROL CARD ( CONT'D )                         *
***********************************************************************
         SPACE 1
CCMS3601 MVI   CB36OPCD,DIVIDE     ASSUME OPERATTION ID DIVIDE
         CLI   MS36OPCD,C'/'       TEST IF DIVIDE
         BE    CCMS3602            BR IF YES
         MVI   CB36OPCD,MULTIPLY   ASSUME OPERATION IS MULTIPLY
         CLI   MS36OPCD,C'*'       TEST IF MULTIPLY
         BE    CCMS3602            BR IF YES
         MVI   CB36OPCD,SUBTRACT   ASSUME OPERATION IS SUBTRACT
         CLI   MS36OPCD,C'-'       TEST IF SUBTRACT
         BE    CCMS3602            BR IF SUBTRAVT
         MVI   CB36OPCD,ADD        OPERATION MUST BE ADD
CCMS3602 CLI   MS36NDC1,C' '       IS NDEC FIELD BLANK
         BNE   *+8                 BR I NOT BLANK
         MVI   MS36NDC1,C'0'       INSERT DEFAULT ZERO IF BLANK
       NUMERIC MS36NDC1            ENSURE NDEC FIELD IS NUMERIC
         PACK  WORKPACK,MS36NDC1   PACK NDEC INTO WORK AREA
         CVB   R1,WORKPACK         CONVERT NDEC INTO BINARY
         STH   R1,CB36NDC1         PRESERVE NDEC FOR 1ST OPERAND
         CLI   MS36NDC2,C' '       IS NDEC FIELD BLANK
         BNE   *+8                 BR I NOT BLANK
         MVI   MS36NDC2,C'0'       INSERT DEFAULT ZERO IF BLANK
       NUMERIC MS36NDC2            ENSURE NDEC FIELD IS NUMERIC
         EJECT
***********************************************************************
*        PROCESS MS36 CONTROL CARD ( CONT'D )                         *
***********************************************************************
         SPACE 1
         PACK  WORKPACK,MS36NDC2   PACK NDEC INTO WORK AREA
         CVB   R1,WORKPACK         CONVERT NDEC INTO BINARY
         STH   R1,CB36NDC2         PRESERVE NDEC OF 2ND OPERAND
         CLI   MS36NDC3,C' '       IS NDEC FIELD BLANK
         BNE   *+8                 BR I NOT BLANK
         MVI   MS36NDC3,C'0'       INSERT DEFAULT ZERO IF BLANK
       NUMERIC MS36NDC3            ENSURE NDEC FIELD IS NUMERIC
         PACK  WORKPACK,MS36NDC3   PACK NDEC INTO WORK AREA
         CVB   R1,WORKPACK         CONVERT NDEC INTO BINARY
         STH   R1,CB36NDC3         PRESERVE NDEC OF RESULT FIELD
         CLI   MS36NDC4,C' '       IS NDEC BLANK
         BNE   *+8                 BR IF NOT BLANK
         MVI   MS36NDC4,C'0'       INSERT DEFAULT ZERO IF BLANK
      NUMERIC  MS36NDC4            ENSURE NDEC IS NU,ERIC
         PACK  WORKPACK,MS36NDC4   PACK NDEC INTO WORK AREA
         CVB   R1,WORKPACK         CONVERT NDEC INTO BINARY
         STH   R1,CB36NDC4         PRESERVE NDEC OF RESULT FIELD
         EJECT
***********************************************************************
*        PROCESS MS36 CONTROL CARD ( CONT'D )                         *
***********************************************************************
         SPACE 1
         PL    PPPLL,MS36POS4,CB36POS4 CONVERT PPLL OF REMAINDER
         CLC   MS36POS4(5),SPACES  IS REMAINDER REQUIRED
         BE    *+8                 BR IF NOT REQUIRED
         OI    CB36SW,SW36REM      FLAG THAT REMAINDER REQUIRED
         CLI   MS36TYP4,C'P'       TEST IF REMAINDER TO BE PACKED
         BNE   *+8                 BR IF NOT TO BE PACKED
         OI    CB36SW,SW36REMP     FALG TO PACK REMAINDER
         CBAL  ,CCREAD             GO GET NEXT CONTROL CARD
         DROP  R6,R8               DROP ADDRESSABILITY
         EJECT
***********************************************************************
*        PROCESS MS37 CONTROL CA DS                                   *
***********************************************************************
         SPACE 1
         USING MS37CARD,R6         ASTABLISH C/C ADDRESSABILITY
         USING CB37NTRY,R8         ESTABLISH C/B ADDRESSABILITY
CCMS37   EQU   *
         CBAL  ,CCREAD             GO GET NEXT CONTROL CARD
         DROP  R6,R8               DROP ADDRESSABILITY
         SPACE 1
         CNOP  0,8                 ENSURE CSECT LENGTH IS MULTIPLE OF 8
LGTHK    EQU   *                   LENGTH OF CSECT BUDGIE3K
BUDGIE3  CSECT
         DROP  R11                 DROP SUB-CSECT ADDRESSABULITY
         TITLE 'BUDGIE3H - BUILD CONTROL BLOCKS'
        SCSECT H                   RESTART CSECT BUDGIE3H
***********************************************************************
*        PROCESS MS40 CONTROL CARD                                    *
***********************************************************************
         SPACE 1
         USING MS40CARD,R6         ESTABLISH C/C ADDRESSABILITY
         USING CB40NTRY,R8         ESTABLISH C/B ADDRESSABILITY
CCMS40   EQU   *                   CONSTRUCT MS40 CONTROL BLOCK
         LH    R2,MS40CNT          GET COUNT OF MS40 CARDS
         LA    R2,1(,R2)           INCREMENT COUNT
         STH   R2,MS40CNT          S3ORE UPDATED MS40 COUNT
         LA    R2,CB40LGTH         GET LENGTH OF C/B
         GETCB CB40                ACQUIRE NEW CONTROL BLOCK
         MVC   CB40TID,MS40RID     PRESERVE SUBROUTINE NAME
         LA    R1,CB40FRST         TREAT CB40 FIELD AS A CB13 ...
         ST    R1,PTRCB13          .. TO CHAIN FOLLOWING CB13'S TO IT
         ST    R8,CURRCB40         PRESERVE CBADDRESS FOR MS41 PROCESSI
         CBAL  ,CCREAD             GO GET NEXT CONTROL CARD
         DROP  R6,R8               DROP ADDRESSABILTIY
         EJECT
***********************************************************************
*        PROCESS MS41 CONTROL CARD                                    *
***********************************************************************
         SPACE 1
*        NOTE THAT AN MS41 CONTROL CARD CREATES AN 'INTERNAL' CB13
*         WHICH IN TURN TRIGGERS THE APPROPRIATE PROCESSING.  THIS
*         APPROACH GREATLY SIMPLIFIES THE CHAINING OF THE C/B'S.
         SPACE 1
         USING CB40NTRY,R8         ESTABLISH C/B ADDRESSABILIYT
         USING MS41CARD,R6         ESTABLISH C/C ADDRESSABILITY
CCMS41   EQU   *                   COMPLETE MS40 C/B & BUILD DUMMY CB13
         LH    R2,MS41CNT          GET MS41 COUNT
         LA    R2,1(,R2)           INCREMENT COUNT OF MS41 CARDS
         STH   R2,MS41CNT          PRSERVE UPDATED MS41 COUNT
         L     R8,CURRCB40         RETRIEVE CB40 ADDRESS
         CLI   CB40FLAG,FLAGCB40   VERIFY THAT THIS IS A CB40
         BNE   CCMS4101            BR IF NOT TO TELL OF ERROR
         CLC   CB40TID,MS41RID     ENSURE IT IS FOR THE SAME ROUTINE
         BE    CCMS4102            BR IF I IS TO CONTINUE
         SPACE 1
CCMS4101 LINE  LINE31,P=Y          PRINT ERROR MESSAGE
         OI    SWERROR,SWEFLUSH    SET ERROR SWITCH
         MVC   COMPCODE,COND16     SET COMPLETION CODE
         B     CCMS41X             GO GET NEXT CONTROL CARD
         SPACE 1
         DROP  R8                  DROP CB40 ADDRESSABILITY
         USING CB13NTRY,R8         ESTABLISH CB13 ADDTESSABILITY
CCMS4102 LA    R2,CB13LGTH         SET LENGTH OF BASIC CB13
         GETCB CB13                ACQUIRE & CHAIN DUMMY CB13
         ADDR  TESTSXCD,I          GET ADDRESS OF 'SX' INTERNAL REP
         MVC   CB13TEST,3(R1)      ESTABLISH AS SUB-ROUTINE EXIT C/B
         MVC   CB13TST0,0(R1)      ADD 'SX' FOR  IDENTIFICATUON
         L     R1,CURRCB40         RETRIEVE CB40 ADDRESS
         ST    R8,CB40LAST-CB40NTRY(R1) ESTABLISH THIS CB13 AS RTN EXIT
         MVC   CB13CBID,MS41RID    STORE RTN NAME FOR IDENTIFICATION
         MVI   CB13RIND,X'FF'      NULLIFY ERROR INDICATOR NUMBER
CCMS41X  CBAL  ,CCREAD             GO GET NEXT CINTROL CARD
         DROP  R6,R8               DROP ADDRESSABILITY
         DROP  R11                 DROP BUDGIE3H ADDRESSABILITY
         TITLE 'BUDGIE3C - BUILD CONTROL BLOCKS'
        SCSECT C                   RESTART BUDGIE3C CSECT
***********************************************************************
*        TERMINATE CONTROL CARD PROCESSING                            *
***********************************************************************
         SPACE 1
EODSYSIN EQU   *                   EOD ON SYSIN
         CP    SYSIN+IOPSRCNT(4),ZERO WERE ANY CONTROL CARDS FOUND
         BE    ABEND64             GO ABEND IF NO CONTROL CARDS
         NI    SWINIT,FF-SWCCPRNT  SHOW NO LONGER PRINTING C/C
         IOM   EOF,SYSIN           FLAG SYSIN EOD
         IOM   CLOSE,SYSIN         CLOSE SYSIN DATA SET
         CBAL  R4,PRINT3C          PRINT BLANK LINE TO SPACE
         LINE  LINE08,10,S=2       TELL OF END OF C/C LIST
         LH    R1,MS40CNT          RETRIEVE MS4/ COUNT
         CH    R1,MS41CNT          CMPARE WITH MS41 COUNT
         BE    EODIN2              BR IF EQUAL
         OI    SWERROR,SWEFLUSH    FLAG THAT SEVERE ERROR FOUND
         LINE  LINE17,P=Y          PRINT ERROR MESSAGE
EODIN2   EQU   *                   CONTINUE PROCESING
         TM    SWERROR,SWEFLUSH    TEST IF CONTROL CARD ERROR DETECTED
         BZ    EODIN1              BRANCH IF NOT
         LINE  LINE16,S=2          TELL OR EROR AND TERMINATIOM
         MVC   COMPCODE,COND16     SET COMPLETION CODE TO 16
         B     ABEND36             GO ABNORMALLY TERMINATE
EODIN1   L     R4,VBUDG3F          GET CSECT ADDRESS
         OI    PLERROR+1-BUDGIE3F(R4),X'F0' ESTABLISH USER RTN PL ERROR
*                                   DURING USER RTN PPLL CONVERSION
         EJECT
***********************************************************************
*        OBTAIN BUFFER AND WORK RAEAS                                 *
***********************************************************************
         SPACE 1
         TM    LOGOUT+IOPSSW,IOSWPRES TEST IF BATCH LOG REQUIRED
         BO    *+12                GO ACQUIRE CODE IF YES
         TM    LOGLIST+IOPSSW,IOSWPRES TEST IF BATCH LOG LIST REQUIRED
         BZ    GETWA01             BYPASS GETMAIN IF NOT
         OI    APSWITCH,APSWLOG    SET FLAG TO PRODUCE BATCH LOG RECORD
         TM    SUSPOUT+IOPSSW,IOSWPRES DOES SUSPENSE FILE EXIST
         BO    GETLG01             BR IF YES
         MVI   LOGSUSP,C'R'        ALTER FLAG FROM 'S' TO 'R'
         ADDR  LOGMESS2,D          ET ADDRESS OF MESSAGE
         MVC   0(8,R1),8(R1)       ALTER SUSPENSE TO REJCTED
GETLG01  LA    R2,80               SET SIZE OF BATCH LOG RECORD
         CBAL  R4,GETMAIN          OBTAIN CORE FOR LOG WORK RAEA
         ST    R1,LOGOUT+IOPSRECA  PRESERVE ADDRESS OF WORK AREA
GETWA01  EQU   *                   CONTINUS PROCESSING
         SPACE 5
***********************************************************************
*        MAKE UNUSED CORE AVAILABLE FOR WORKPOOL                      *
***********************************************************************
         SPACE 1
         OI    GETMSTRT,POOLUSE    FLAG RESIDUAL CB POOL FOR USE
*                                   BY WORKPOOL PROCESSING
         OI    VBUDG3C,POOLUSE+POOLGTM FLAG BUDGIE3C CSECT AVAILABLE
*                                   AS GETMAIN POOL AND/OR WORKFILE POL
         SPACE 5
***********************************************************************
*        GO INTERCONNECT CONTROL BLOCKS                               *
***********************************************************************
         SPACE 1
         CBAL  ,CCLINK00           GO INTERCONNECT CONTROL BLOCKS
BUDGIE3  CSECT
         DROP  R11                 DROP BUDGIE3C ADDRESSABILITY
         TITLE 'BUDGIE3M - INTERCONNECT CONTROL BLOCKS'
        SCSECT M                   START CECT BUDGIE_3M
***********************************************************************
*        INTERCONNECT CONTROL BLOCKS                                  *
***********************************************************************
         SPACE 1
         USING CB02NTRY,R6         ESTABLISH CB02 ADDRESSABILITY
         USING CB04NTRY,R7         ESTABLISH CB04 ADDRESSABILITY
         USING CB05NTRY,R8         ESTABLISH CB05 ADDRESSABILITY
         USING CB11NTRY,R9         ESTABLISG CB11 ADDRESSABILITY
         USING SB11NTRY,R10        ESTABLISH SB11 ADDRESSABILITY
CCLINK00 L     R6,PTR1CB02         GET ADDRESS OF 1ST CB02
         SPACE 1
*                                  TEST FOR END OF CB02 CHAIN
CCLINK   LA    R6,0(,R6)           PURIFY HIGH ORFER BYTE
         LTR   R6,R6               TEST FOR END OF CHAIN
         BZ    CCLINKX             EXIT IF END
         L     R9,CB02CB11         GET ADDR OF 1ST CB11 FOR THIS CB02
         SPACE 1
*                                  TEST FOR END CB11'S FOR THIS CB02
CCLINK01 LA    R9,0(,R9)           PURIFY HIGH ORDER BYTE
         L     R10,CB11SB11        GET ADDR OF 1ST SB11 FOR CB11
         LTR   R9,R9               TEST FOR END OF CB11 CHAIN
         BNZ   CCLINK02            BRANCH IF NOT
         L     R6,CB02CB02         GET ADDR OF NEXT CB02
         B     CCLINK              LOOP BACK TO PROCESS
         SPACE 1
*                                  TEST FOR END OF SB11'S FOR THIS CB11
CCLINK02 LA    R10,0(,R10)         PURIFY HIGH ORDER BYTE
         LTR   R10,R10             TEST FOR END OF SB11 CHAIN
         BNZ   CCLINK03            BRANCH IF NOT
         L     R9,CB11CB11         GET ADDR OF NEXT CB11 FOR THIS CB02
         B     CCLINK01            LOOP BACK TO PROCESS
         SPACE 1
*                                  ESTABLISH CONTROL BLOCK POINTERS
CCLINK03 L     R1,CB02CB03         GET ADDRESS OF CB03
         L     R7,CB03CB04-CB03NTRY(R1) GET ADDR OF 1ST CB04 FOR TH CB2
         L     R8,CB02CB05         GET ADDR OF 1ST CB05
         TM    SB11SW,SW11DBCN     DOES SB11 CONTAIN B/C FLD NAME
         BZ    CCLINK06            BRANCH IF NOT
         EJECT
***********************************************************************
*        INTERCONNECT CONTROL BLOCKS ( CONF'D )                       *
***********************************************************************
         SPACE 1
*                                  POINT SB11 AT ASSOC CB05
CCLINK04 LA    R8,0(,R8)           PURIFY HIGH ORDER BYTE
         ST    R8,SB11CB05         ASSUME MATCH: POINT SB11 AT CB05
         LTR   R8,R8               TEST IF END OF CB05 CHAIN
         BNZ   CCLINK05            BRANCH IF NOT
         NI    SB11SW,FF-SW11DBCN  SET OFF B/C FLD NAME INDICATOR
         MVC   LINE26ID,SB11FNO    MOVE C/B LABEL TO MESSAGE
         CCNO  LINE26N1,SB11       MOBE C/C SEQ NO TO MESSAGE
         LINE  LINE26,P=Y          PRINT ERROR MESSAGE
         B     CCLINK06            PROCESS C/R FLD NAME
CCLINK05 CLC   SB11FNO,CB05FNO     TEST FOR FLD NAME MATCH
         BE    CCLINK06            MATCH: CB'S LINKED SO BRANCH
         L     R8,CB05CB05         GET ADDR OF NEXT CB05 FOR THIS CB02
         B     CCLINK04            LOOP BACK TO PROCESS
         SPACE 1
*                                  POINT SB11 AT ASSOC CB04
CCLINK06 TM    CB05SW,SW05SOFT     IS THIS A SOFT ERROR
         BZ    *+8                 BR IF NOT
         OI    SB11SW,SW11SOFT     FLAG SB11 AS SOFT AS WELL
         TM    SB11SW,SW11DCRN     DOES IT CONTAIN C/R FLD NAME
         BZ    CCLINK09            BRANC IF NOT
CCLINK07 LA    R7,0(,R7)           PURIFY HIGH ORDER BYTE
         ST    R7,SB11CB04         ASSUME MATCH : POINT SB11 AT CB04
         LTR   R7,R7               TEST IF END OF CB04 CHAIN
         BNZ   CCLINK08            BRANCH IF NOT
         NI    SB11SW,FF-SW11DCRN  SET OFF C/R FLD NAME INDICATOR
         MVC   LINE27ID,SB11CRFN   MOVE C/B LABEL TO MESSAGE
         CCNO  LINE27N1,SB11       ADD C/C SEQ NO TO MESSAGE
         LINE  LINE27,P=Y          PRINT ERROR MESSAGE
         B     CCLINK09            GO GET NEXT SB11 FOR THIS CB11
CCLINK08 CLC   SB11CRFN,CB04FNO    TEST FOR FIELD NAME MATCH
         BE    CCLINK09            MATCH: CB'S LINKED SO BRANCH
         L     R7,CB04CB04         GET EDDR OF NEXT CB04 FOR THIS CB02
         B     CCLINK07            LOOP BACK TO PROCESS
         SPACE 1
*                                  GET NEXT SB11
CCLINK09 L     R10,SB11SB11        GET NEXT SB11 FOR THIS CB11
         B     CCLINK02            LOOP BACK TO PROCESS
CCLINKX  EQU   *                   END OF CB LINKAGE CODING
         SPACE 1
         DROP  R6,R7,R8,R9,R10     DROP CB ADDRESSABILITY
         USING DETAILBB,R7         ESTABLISH ADDRESSABILITY OF BUFFER
         EJECT
***********************************************************************
*        INTERCONNECT CONTROL BLOCKS ( CONT'D )                       *
***********************************************************************
         SPACE 1
*        POINT CB13 C/BS AT THE ASSOCIATED CB2X/3X/4X, IF ANY
*         ( ALL CB2X/3X/4X C/BS START WITH A CHAINING FIELD FOLLOWED BY
*         THE TEST ID - LABEL - SO ALL SUCH BLOCKS MAY BE TREATED AS
*         CB20'S FOR THE PURPOSES OF THIS CODING ).
         SPACE 1
         USING CB02NTRY,R6         ESTABLISH CB02 ADDRESSABILITY
         USING CB11NTRY,R8         ESTABLISH CB11 ADDRESSABILITY
         USING CB13NTRY,R9         ESTABLISH CB13 ADDRESSABILITY
         USING CB20NTRY,R10        ESTABLISH CB20 ADDRESSABILITY
         L     R6,PTR1CB02         GET ADDESS OF 1ST CB02
*                                  TEST FOR END OF CB02 CHAIN
CCLINK10 LTRR  R6,R6               TEST FOR END OF CHAIN
         BZ    CCLINK15            EXIT IF END
         L     R8,CB02CB11         GET ADDRESS OF 1ST CB11 FOR THIS C02
         L     R9,CB02CB14         GET ADDR OF 1ST BATCH LEVEL CB13
*                                  TEST FOR LAST BATCH LEVEL CB13
CCLINK20 LTRR  R9,R9               TEST FOR END OF CHAIN
         BZ    CCLINK21            BR IF END OFCHAAIN
         CBAL  R4,CCLCB13          GET ADDRESS OF ASSOC CB40 C/B
         L     R9,CB13CB13         GET ADDRESS OF NEXT CB13 (BATCH LEVE
         B     CCLINK20            LOOP BACK TO PROCESS
CCLINK21 L     R9,CB02CB13         GET ADDR OF 1ST B/C CB13 FOR CB02
*                                  TEST FOR LAST CB13 FOR THIS CB02
CCLINK11 LTRR  R9,R9               TEST FOR END OF CHAIN
         BZ    CCLINK12            BR IF END OF CHAIN
         CBAL  R4,CCLCB13          GET ADDR OF AASSOC CB2X/3X/4X C/B
         L     R9,CB13CB13         GET ADDRESS OF NEXT CB13
         B     CCLINK11            LOOP BACK TO PROCESS
*                                  TEST FOR LST CB11 FOR THIS CB02
CCLINK12 L     R9,CB11CB13         GET ADDR OF 1ST CB13 FOR THIS CB11
         LTRR  R8,R8               TEST FOR END OF CB11 CHAIN
         BNZ   CCLINK13            BR IF NOT END OF CHAIN
         L     R6,CB02CB02         GET ADDR OF NEXT CB02
         B     CCLINK10            LOOP BACK TO PROCESS
         EJECT
***********************************************************************
*        INTERCONNECT CONTROL BLOCKS ( CONT'D )                       *
***********************************************************************
         SPACE 1
*                                  TES FOR LAST CB13 FOR THIS CB11
CCLINK13 LTRR  R9,R9               TEST FOR END OF CB13 CHAIN
         BNZ   CCLINK14            BR IF NOT END OF CHAIN
         L     R8,CB11CB11         GET ADDR OF NEXT CB11
         B     CCLINK12            LOOP BACK TO PROCESS
         SPACE 1
*                                  CONNECT UP CB13
CCLINK14 CBAL  R4,CCLCB13          GET ADDR OF ASSOX CB2X/3X/4X
         L     R9,CB13CB13         GET ADDR OF NEXT CB13
         B     CCLINK13            LOOP BACK TO PROCESS
         SPACE 1
*        NOW MAKE ANY NECESSARY CONNECTIONS FOR CB13'S WITHIN CB40'S
         SPACE 1
         DROP  R6                  DROP CB02 ADDRESSABILITY
         USING CB40NTRY,R6         ESTABLISH CB40 ADDRESSABILITY
CCLINK15 L     R6,PTR1CB40         GET ADDRESS OF 1ST CB40
*                                  TEST FOR END OF CB40 CHAIN
CCLINK16 LTRR  R6,R6               TEST FOR END OF CHAIN
         BZ    CCLINKX1            EXIT IF END OF CHAIN
         CLI   CB40FLAG,FLAGCB40   VERIFY THAT THIS IS A CB40
         BE    CCLINK18            BR IF YES
CCLINK17 L     R6,CB40CB40         GET ADDRESS OF NEXT CB40
         B     CCLINK16            LOOP BACK TO PROCESS
CCLINK18 L     R9,CB40FRST         GET ADDR OF 1ST CB13 FOR THIS CB40
*                                  TEST FOR END OF CB13 CHAIN
CCLINK19 LTRR  R9,R9               TEST FOR END OF CHAIN
         BZ    CCLINK17            GO GET NEXT CB40 IF END OF CHAIN
         CBAL  R4,CCLCB13          GET ADDR OF ASSOC CB2X/3X/4X IF ANY
         L     R9,CB13CB13         GET ADDRESS OF NEXT CB13
         B     CCLINK19            LOOP BACK TO PROCESS
         EJECT
***********************************************************************
*        INTERCOONNECT CONTROL BLOCKS ( CONT'D )                      *
***********************************************************************
         SPACE 1
CCLCB13  SUBIN SAVE=R4             PRESERVE RETURN ADDRESS
         L     R10,PTR1CB20        GET ADDRESS OF 1ST CB2X/3X/4X
         TM    CB13SW,SW13CBXX     IS ASSOC CBXX ADDRESS REQUIRED
         BZ    CCLCB13X            BYPASS ROUTINE IF NOT
         SPACE 1
CCLCB131 LTRR  R10,R10             TEST FOR END OF CHAIN
         BZ    CCLCB13E            EXIT IF END OF CHAIN TO FLAG CB13
         CLC   CB20FLAG,CB13TEST   IS THIS REQUIRED TYPE OF C/B
         BE    CCLCB133            BR TO NEXT TEST I YES
         CLI   CB20FLAG,FLAGCB33   IS THIS A CB33
*                                   (CB33'S ARE CHAINED TO BY MORE THAN
*                                   1 TYPE OF TEST CODE )
         BNE   CCLCB134            GO SEE IF CB30 IF NOT
         CLI   CB13TEST,X'31'      IS THIS AN E1 - PARTIAL KEY MATCH
         BE    CCLCB133            GO SEE IF IDS MATCH IF YES
CCLCB134 EQU   *                   CONTINUE PROCESSING
         CLI   CB20FLAG,FLAGCB30   IS THIS A CB30
*                                  ( CB30 C/B'S ARE CHAINED TO BY A
*                                   NUMBER OF DIFFERENT TEST CODES )
         BNE   CCLCB132            GO GET NEXT CBXX IF NOT
         CLI   CB13TEST,X'09'      IS TEST IN RANGE LT-GE
         BL    CCLCB132            BR IF BELOW TEST RANGE
         CLI   CB13TEST,X'0E'      IS TEST IN RANGE LT-GE
         BH    CCLCB132            BR IF ABOVE RANGE
CCLCB133 CLC   CB20TID,CB13CBID    IS THIS THE REQUIRED LABEL
         BNE   CCLCB132            GO GET NEXT CBXX IF NOT
         ST    R10,CB13CBXX        CHAIN CB13
         SPACE 1
*        ASSUME, PESSIMISTICALLY, THAT THERE ARE DUPLICATE LABELS FOR
*         THIS TYPE OF CONTROL BLOCK, AND TEST FOR THEM
         SPACE 1
         MVC   LINE39ID,CB20FLAG   PRESERVE TYPE OF C/B FOR TESTING
         CCNO  LINE39N2            MOVE C/C SEQ NO OF CURRENT C/B TO LN
CCLCB135 L     R10,CB20CB20        GET ADDRESS OF NEXT CB2X/3X/4X
         LTRR  R10,R10             TEST FOR END OF CHAIN
         BZ    CCLCB13X            EXIT FROM SUBRTN IF END OF CHAIN
         CLC   CB20FLAG,LINE39ID   IS THIS SAME TYPE OF C/B
         BNE   CCLCB135            BR IF NOT SAME TO TEST NEXT
         CLC   CB20TID,CB13CBID    IS IT THE SAME LABEL
         BNE   CCLCB135            BR IF NOT SAME LABEL TO TEST NEXT
         CCNO  LINE39N1            SET C/C SEQ NO OF THIS C/B IN LINE
         LINE  LINE39,P=Y          PRINT ERROR MESSAGE IDENTIFYING DUPL
         MVI   CB20FLAG,X'00'      ALTER C/B ID TO IGNORE IN FUTURE
         B     CCLCB135            LOOP BACK TO TEST NEXT C/B FOR DUP
         SPACE 1
CCLCB132 L     R10,CB20CB20        GET ADDR OF NEXT CB2X/3X/4X
         B     CCLCB131            LOOP BACK TO PROCESS
         EJECT
***********************************************************************
*        INTERCONNECT CONTROL BLOCKS ( CONT'D )                       *
***********************************************************************
         SPACE 1
CCLCB13E OI    SWERROR,SWENMSXX    SHOW AN MSXX CARD IS MISSING
         OI    CB13SW,SW13NTST     NO ASSOC C/B SO NO-OP CB13
         MVC   LINE36TL,CB13CBID   ADD DSEIRED CBXX LABEL TO MASSAGE
         CCNO  LINE36N1,CB13       ADD C/C SEQ NO TO MESSAGE
         LINE  LINE36,P=Y          PRINT ERROR MESSAGE IDENTIFYING MS13
CCLCB13X SUBOUT RESTORE=R4         RESTORE & RETURN TO CALLER
         SPACE 1
         DROP  R6,R8,R9,R10        DROP C/B ADDRESSABILITY
         SPACE 1
CCLINKX1 EQU   *                   END OF CB13-CBXX CHAINING
         EJECT
***********************************************************************
*        CONSTRUCT ISAM DCB'S FOR CB20'S                              *
***********************************************************************
         SPACE 1
         USING CB20NTRY,R6         ESTABLISH CB20 ADDRESSABILITY
         USING IHADCB,R10          ESTABLISH DCB ADDRESSABILITY
         L     R6,PTR1CB20         GET 1ST C/B IN CHAIN
CCISDCB  LTRR  R6,R6               TEST FOR END OF CHAIN
         BZ    CCLINKX2            EXIT IF END OF CHAIN
         CLI   CB20FLAG,FLAGCB20   IS THIS A CB20
         BNE   CCISDCB6            BR IF NOT TO GET NEXT C/B
         OC    CB20IDCB+1(3),CB20IDCB+1 DOES DCB ALREADY EXIST
         BNZ   CCISDCB6            BR IF YES TO GET NEXT C/B
         LA    R2,DCBWKPT6-IHADCB+4 SET LENGTH OF IS DCB
         CBAL  R4,GETMAIN          ACQUIRE CORE FOR DCB
         IC    R10,CB20ISW         PRESERVE STATUS SWITCH
         ST    R1,CB20IDCB         PRESERVE DCB ADDR IN C/B
         STC   R10,CB20ISW         RESTORE SWITCH
         LR    R10,R1              ESTABLISH DCB ADDRESSABILITY
         L     R8,CB20CB20         USE R8 TO CHAIN FORWARD
CCISDCB1 LTRR  R8,R8               TEST FOR END OF CHAIN
         BZ    CCISDCB3            BR IF END OF CHAIN
         CLI   CB20FLAG-CB20NTRY(R8),FLAGCB20 IS THIS A CB20
         BNE   CCISDCB2            BR IF NOT TO GET NEXT
         CLC   CB20IDDN,CB20IDDN-CB20NTRY(R8) IS IT SAME DD NAME
         BNE   CCISDCB2            BR IF NOT TO CHAIN FORWARD
         MVC   CB20IDCB-CB20NTRY(4,R8),CB20IDCB POINT C/B AT SAME DCB
CCISDCB2 L     R8,CB20CB20-CB20NTRY(R8) GET ADDR OF NEXT C/B
         B     CCISDCB1            POOL BACK TO PROCESS
CCISDCB3 MVC   DCBDDNAM,CB20IDDN   ADD DDNAME TO DCB
         MVI   DCBDSORG,DCBDSGIS   FLAG AS ISAM DCB
         MVI   DCBOFLGS,DCBOFUEX   FLAG AS WITHIN IOS
         LA    R8,ISIOERR          GET ADDR OF SYNAD EXIT
         ST    R8,DCBSYNAD          ... AND STOR IN DCB
         MVI   DCBMACR,DCBMRRD+DCBMRDBF FLAG AS BISAM READ ...
*                                   ... WITH DYNAMIC BUFFERING
         LA    R8,1                PUT A(1) IN REG 8
         SR    R9,R9               ZEROISE WORK REGISTER
         L     R7,ADCBTAB1         POINT R7 AT TABLE OD  DISPLACEMENTS
         EJECT
**************************************<********************************
*        CONSTRUCT ISAM DCB'S ( CONT'D )                              *
**************************************<********************************
         SPACE 1
CCISDCB4 CLI   0(R7),X'FF'         TEST FOR END OF TABLE
         BE    CCISDCB5            BR IF EOT
         IC    R9,0(R7)            GET DISPLACEMENT WITHIN DCB
         ST    R8,IHADCB(R9)       STORE A(1) IN DCB + XXX
         LA    R7,1(,R7)           INCREMENT TO NEXT TABLE ENTRY
         B     CCISDCB4            LOOP BACJ TO PROCESS
CCISDCB5 LA    R2,EXITLISX         POINT R2 AT EXIT LIST
         ST    R2,DCBEXLST         POINT DCB AT EXIT LIST
         LA    R2,CB20DCBS         POINT AT DCB SWITCH FOR OPEN
         CBAL  R4,ISOPEN           OPEN DCB & GET REC SAVE AREA
CCISDCB6 L     R6,CB20CB20         GET ADDRESS OF NEXT C/B
         B     CCISDCB             LOOP BACK TO PROCESS
         DROP  R6,R10              DROP ADDRESSABILITY
         SPACE 1
CCLINKX2 EQU   *
         EJECT
***********************************************************************
*        LOAD ANY REQUIRED ROUTINES                                   *
***********************************************************************
         SPACE 1
         TM    SWINIT,SWLDDATE     TEST IF UT458 REQUIRED
         BZ    CCLOAD01            BR IF NOT REQUIRED
         LOAD  EP=UT458            LOAD SUB-ROUTINE UT458
         ST    R0,ADRUT458         PRESERVE ADDRESS OF DATA ROUTINE
CCLOAD01 TM    SWINIT,SWLD435      TEST IF CURRENCY CONVERSION RTN REQD
         BZ    CCLOAD02            BR IF NOT REQUIRED
         LOAD  EP=UT460            LOAD CURRENCY CONVERSION RTN
         ST    R0,ADRUT460         PRESERVE ADDRESS OF ROUTINE
         LA    R2,UT460LGT         SET LENGTH OF LINKAGE AREA
         CBAL  R4,GETMAIN          ACQUIRE CORE FOR LINKAGE AREA
         ST    R1,PRMUT460         PRESERVE ADDRESS OF LINKAGE AREA
         USING UT460LNK,R1         ESTABLISH LINKAGE AREA ADDREESSABILY
         MVC   UT460OTC,=C'VN'     RESUEST VERSION NUMBER
         LA    R1,PRMUT460         ESTABLISH LINKAGE FOR UT460
         L     R15,ADRUT460        GET ADDRESS OF UT460
         BALR  R14,R15             DETERMINE VERSION NUMBER
         L     R1,PRMUT460         RETRIEVE LINKAGE AREA ADDRESS
         MVC   VERSNO,UT460OTV     PRESERVE CURRENCY ROUTINE VERSION NO
         DROP  R1                  DROP LINKAEG AREA ADDRESSABILITY
CCLOAD02 TM    SWINIT,SWLDRIGM     TEST IF RIGAM REQUIRED
         BZ    CCLOAD03            BR IF NOT REQUIRED
         LOAD  EP=RIGAM            LOAD RIGAM INTO CORE
         ST    R0,ADRRIGAM         PRESERVE ADDRESS OF RIGAM
CCLOAD03 EQU   *
         SPACE 1
         OI    VBUDG3H,POOLUSE+POOLGTM FLAG CSECT BUDGIE3H AVAILABLE
*                                   AS POOL FOR GETAMINS/WORKFILE
         B     MAINLNE2            RETURN TO MAIN LINE
         CNOP  0,8                 ENSURE CSECT LENGTH IS MULTIPLE OF 8
LGTHM    EQU   *                   END OF CSECT BUDGIE3M
         DROP  R11                 DROP BUDGIE3M ADDRESSABILITY
         TITLE 'BUDGIE3C - BUILD CONTROL BLOCKS: SUBROUTINES'
        SCSECT C
***********************************************************************
*        INVOKE ROUTINE 'PRINT' FROM CSECT BUDGIE3C                   *
***********************************************************************
         SPACE 1
*        SUB-CSECT BUDGIE3C ISSUES MANY CALLS TO THE SUB-ROUTINE PRINT
*         WHICH IS IN ANOTHER CSECT.  IN ORDER TO REDUCE THE AMOUNT
*         OF GENERATED CODE, 'PRNNT' IS INVOKED VIA THIS ROUTINE,
*         WHICH IS THE ONLY ONE TO ESTABLISH THE NECESSARY LINKAGE.
         SPACE 1
PRINT3C  SUBIN SAVE=R4             PRESERVE R4
         CBAL  R4,PRINT            PRINT LINE
        SUBOUT RESTORE=R4          RESTORE R4 & RETURN
         EJECT
***********************************************************************
*        INVOKE ROUTINE 'PPLPL' FROM CSECT BUDGIE3C                   *
***********************************************************************
         SPACE 1
PPLPLC   SUBIN SAVE=R4             PRESERVE RETURN ADDRESS
         CBAL  R4,PPLPL            INVOKE PL ROUTINE
        SUBOUT RESTORE=R4          RESTORE REG AND RETURN TO CALLER
         SPACE 3
***********************************************************************
*        INVOKE ROUTINE 'PPPLPL' FROM BUDGIE3C                        *
***********************************************************************
         SPACE 1
PPPLPLC  SUBIN SAVE=R4             PRESERVE RETURN AFDRESS
         CBAL  R4,PPPLPL           INVOKE PPPLPL ROUTINE
        SUBOUT RESTORE=R4          RESTORE REG & RETURN TO CALLER
         EJECT
***********************************************************************
*        INVOKE ROUTINE 'PPLLPL' FROM CSECT BUDGIE3C                  *
***********************************************************************
PPLLPLC  SUBIN SAVE=R4             RRESERVE RETURN ADDRESS
         CBAL  R4,PPLLPL           PERFORN PL CONVERSION
        SUBOUT RESTORE=R4          RESTORE AND RETURN TO CALLER
         SPACE 3
***********************************************************************
*        INVOKE ROUTINE 'PPPLLPL' FROM CSECT BUDGIE3C                 *
***********************************************************************
PPPLLPLC SUBIN SAVE=R4             PRSSERVE RETURN ADDRESS
         CBAL  R4,PPPLLPL          PERFORM PL CONVERSION
        SUBOUT RESTORE=R4          RESTORE & RETURN TO CALLER
         EJECT
***********************************************************************
*        INVOKE ROOUTINE 'NUMERIC' FROM BUDGIE3C                      *
***********************************************************************
         SPACE 1
NUMERICC SUBIN SAVE=R4             PRESERVE RETURN ADDRESS
         ZAP   WORKPACK,ZERO       ZEROISE WORK AREA LEST NONNUMERIC
         CBAL  R4,NUMERIC          TEST FIELD FOR NUMERIC
         BCTR  R15,0               DECREMENT FOR EXECUTE
         BNE   *+8                 BR IF NOT NUMERIC
         EX    R15,SFPACK          PACH FIELD INTO 'WORKPACK'
         BNH   NUMERCCX            BR IF FIELD NOT NONNUMERIC
         LINE  LINE09              SET UP ERROR MESSAGE
         MVC   COMPCODE,COND16     SET COMPLETION CODE
         OI    SWERROR,SWEFLUSH    SET TO TERNINATE AFTER C/C SCAN
NUMERCCX SUBOUT RESTORE=R4         RESTORE & RETURN TO CALLER
         EJECT
***********************************************************************
*        INVOKE ROUTINE 'NUMERICS' FROM CSECT BUDGIE3C                *
***********************************************************************
         SPACE 1
NUMERCSC SUBIN SAVE=R4             PRESERVE RETURN ADDRESS
         ZAP   WORKPACK,ZERO       ZEROISE WORK AREA LEST NONNUMERIC
         CBAL  R4,NUMERICS         TEST FIELD FOR NUMERICS
         BNE   *+10                BR IF NOT NUMERIC
         BCTR  R15,0               DECREMENT FOR EXECUTE
         EX    R15,SFPACK          PACK FIELD INTO 'WORKPACK'
         BNH   NUMRCSCX            BR IF FIELD NOT NONNUMERIC
         LINE  LINE09              SET UP ERROR MESSAGE
         MVC   COMPCODE,COND16     SET COMPETION CODE
         OI    SWERROR,SWEFLUSH    SET TO TERMINATE AFTER C/C SCAN
NUMRCSCX SUBOUT RESTORE=R4         RESTORE & RETURN TO CALLER
         CNOP  0,8                 ENSURE CSECT LENGTH IS MULTIPLE OF 8
LGTHC    EQU   *                   END OF CSECT BUDGIE3C
BUDGIE3  CSECT
         DROP  R11                 DROP BUDGIE3C ADDRESSABILITY
         TITLE 'BUDGIE3B - DETERMINE IPL DATE'
BUDGIE3B CSECT
         USING BUDGIE3B,R11        ESTABLISH SUB-CSECT ADDRESSABILITY
***********************************************************************
*        CALL UT458 FOR IPL DATE & DEFINE FIELDS                      *
***********************************************************************
UT458O0  SUBIN ,                   DETERMINE IPL DATE
         UT458 ,                   DETERMINE IPL DATE
         MVC   DTEYYDDD,UTYYDDD    PRESERVE JUIIAN IPL DATE
         MVC   DTEREPRT,UTREPORT   PRESERVE REPORT FORMAT IPL DATE
         MVC   DD(6),UTDDMMYY      PRESERVE CURRENT DAY,MONTH,YEAR NO.S
        SUBOUT ,                   RETURN TO CALLER
         DROP  R11                 DROP BUDGIE3B ADDRESS'Y
BUDGIE3  CSECT
         TITLE 'BUDGIE3G - PRINT TERMINATION MESSAGES AND SUMMARIES'
        SCSECT G
***********************************************************************
*        TERMAINATE BATCH LOG PROCESSING                              *
***********************************************************************
         SPACE 1
PRINTERM MVI   CURRUT1,X'FF'       MOVE HIGH VALUES TO SYSUT1 ....
         MVC   CURRUT1+1(L'CURRUT1-1),CURRUT1 ... B/NO STORE
         CLC   CURRUT1,CURRLIN     HAVE WE REACHED EOF ON LOGIN
         BE    MAINLNE6            BR IF YES
         CBAL  R4,GETLOG           READ LOGIN TO EOF & WRITE TO LOGOUT
         SPACE 5
***********************************************************************
*        TERMINATE SUSPENSE FILE PROCESSING                           *
***********************************************************************
         SPACE 1
MAINLNE6 CLC   CURRUT1,CURRSUSP    HAVE WE REACHED EOF ON SUSPIN
         BE    MAINLNE7            BR IF YES
         CBAL  R4,GETSUSP          READ SUSPIN TO EOF & PUT TO SUSPOUT
MAINLNE7 EQU   *                   CONTINUE PROCESSING
         EJECT
***********************************************************************
*        TERMINATE INTERNAL READER PROCESSING                         *
***********************************************************************
         SPACE 1
         CP    INTRDR+IOPSRCNT(4),ZERO WAS INTERNAL READER USED
         BE    TERMINTX            BYPASS ROUTINE IF NOT USED
         TM    YPSWITCH,YPSWNEOF   IS '/*EOF' SIPPRESSED
         BO    TERMINTX            BYPASS ROUTINE IF YES
         L     R6,DBUFF            GET ADDRESS OF DUMMY BUFFER
         MVI   0(R6),C' '          MOVE BLANK TO START OF BUFFER
         MVC   1(79,R6),0(R6)      PROPAGATE BLANKS THROUGH 80 BYTES
         MVC   0(5,R6),=C'/*EOF'   SET INTRDR TERMINATION CHARACTERS
         CBAL  R4,PUTINTRD         GO WRITE '/*EOF' TO INTRDR
TERMINTX EQU   *                   END ON INTRDR TERMINATION ROUTINE
         EJECT
***********************************************************************
*        TERMINATE BATCH BALANCING REPORT                             *
***********************************************************************
         SPACE 1
         MVI   0(R7),PAGESKIP      ESTABLISH SKIP TO NEW PAGE
         ZAP   PRINTBB+IOPSRCNT(4),ZERO PREVERT HEADING ROUTINE
         CBAL  R4,PRINTBBL         PRINT BLANK LINES
         MVC   WORKAREA,EDITPL3    MOVE EDIT PATTERN TO WORK AREA
         ED    WORKAREA(L'EDITPL3),CNTREJ EDIT CNT OF REJECTED BATCHES
         MVC   BBLINE10+36(4),WORKAREA+3 ADD COUNT TO MESSAGE
         BNZ   *+22                BR IF REJECT CNT NOT ZERO TO PRINT
         MVC   BBLINE10+7(6),SPACES BLANK OUT 'NUMBER'
         MVC   BBLINE10+34(6),SPACES BLANK OUT '= NNNN'
         MVC   BBLINE10+14(2),=C'NO' SET ' NO BATCHES REJECTED '
         LA    R3,10               ESTABLISH LOOP
TERMBBR1 MVC   3(L'BBLINE10,R7),BBLINE10 ADD MESSAGE TO BUFFER
         CBAL  R4,PRINTBBL         PRINT COUNT OF REJECTS
         BCT   R3,TERMBBR1         PRINT MESSAGE 10 TIMES
         EJECT
***********************************************************************
*        TERMINATE BATCH BALANCING REPORT ( CONT'D )                  *
***********************************************************************
         SPACE 1
         CBAL  R4,PRINTBBL         PRINT BLANK LINE
         MVC   3(L'BBLINE11,R7),BBLINE11 TELL OF END OF REPORT
         L     R7,LOGLIST+IOPSRECA GET LOGLIST BUFFER ADDRESS
         MVI   0(R7),SPCE2AFT      ESTABLISH DOUBLE SPACE
         CBAL  R4,PRINTLOG          AND SPACE FORWARD 2 LINES
         L     R7,LOGLIST+IOPSRECA GET LOGLIST BUFFER ADDRESS
         ADDR  LOGMESS3,D          POINT AT 'END OF REPORT' MESSAGE
         MVC   3(L'LOGMESS3,R7),0(R1) TELL OF END OF REPORT
         EJECT
***********************************************************************
*        PRINT SUMMARY OF I/O ACTIVITY                                *
***********************************************************************
         SPACE 1
         L     R5,SYSPRINT+IOPSRECA RETRIVE CURRENT BUFFER DDDRESS
         OI    PRINTBB+IOPSSW,IOSWEOP   FORCE IND TO SHOW PRINT D/S
         AP    SYSPRINT+IOPSRCNT(4),IOPSLCNT FORCE LCNT TO PAGE LIMIT
         CBAL  R4,PRINT            PRINT LINE TO FORCE EOP
         OI    SYSPRINT+IOPSSW,IOSWEOP  FORCE IND TO SHOW PRINT D/S
         OI    LOGLIST+IOPSSW,IOSWEOP   FORCE IND TO SHOW PRINT D/S
         IOM   SUMMARY,SYSUT1,(R5),PRESENT,RTN=PRINT,LOOP=IOMMAXDD
         EJECT
***********************************************************************
*        PRINT SUMMARY OF I/O ACTIVITY FOR USER-SPECIFIED D/S         *
***********************************************************************
         SPACE 1
         USING CB20NTRY,R10        ESTABLISG CB20 ADDRESSABILIYT
         L     R10,PTR1CB20        GET ADDRESS OF 1ST CB20
         B     *+8                 BYPASS FORWARD CHAINING
IOSUMM   L     R10,CB20CB20        GET ADDRESS OF NEXT CB20
         LTRR  R10,R10             TET FOR END OF CHAIN
         BZ    IOSUMMX             EXIT IF END OF CHAIN
         CLI   CB20FLAG,FLAGCB20   VERIFY THAT THIS IS A CB20
         BNE   IOSUMM              BR IF NOT TO GET NEXT C/B
         MVI   L'LINE12+8(R5),C'(' ADD PARENTHESES ...
         MVI   L'LINE12+11(R5),C')' ... TO LINE
         MVC   L'LINE12+9(2,R5),CB20TID ADD CB20 ID FOR IDENT
         IOM   SUMMARY,CB20DCBS,(R5),RTN=PRINT3G
         LA    R2,CB20DCBS         POINT R2 AT DCB SW
         CBAL  R4,ISCLOSE          CLOSE DATA SET
         B     IOSUMM              LOOP BACK TO GET NEXT C/B
IOSUMMX  CBAL  R4,PRINT3G          PRINT BLANK LINE
         DROP  R10                 DROP CB20 ADDRESSABILITY
         EJECT
***********************************************************************
*        TELL OF CORE USED FOR CONTROL BLOCKS                         *
***********************************************************************
         SPACE 1
         L     R1,GETMUSED         GET AMOUNT OF CORE USED
         CVD   R1,WORKAREA         CONVERT TO DECIMAL
         ED    LINE18M,WORKAREA+5  ADD BYTE COUNT TO MESSAGE
         LINE  LINE18,P=Y          PRINT MESSAGE
         SPACE 3
***********************************************************************
*        TELL CAPACITY OF INTERNAL STORAGE POOLS                      *
***********************************************************************
         SPACE 1
         L     R1,POOLMAX          GET CAPACITY OF STAOAGE POOLS
         CVD   R1,WORKAREA         CONVERT CAPACTTY TO DECIMAL
         ED    LINE28M,WORKAREA+5  ADD CAPACITY TO MESSAGE
         LINE  LINE28,P=Y          PRINT MESSAGE
         SPACE 3
***********************************************************************
*        CHECK IF ANY BATCHED ACCEPTED                                *
***********************************************************************
         SPACE 1
         CP    CNTACC,ZERO         TEST IF ACCEPTED COUNT GREATER THAN
         BH    *+10                BYPASS COND CODE SETTING IF > 0
         MVC   COMPCODE,COND16     SET CONDITION CODE TO 26
         EJECT
***********************************************************************
*        TELL OF CORE REQUIRED FOR ISAM INDICES                       *
***********************************************************************
         SPACE 1
         L     R1,SIZEISMX         RETRIEVE CORE SISE OF ISAM INDICES
         LTRR  R1,R1               DETREMONE IF SIZE IS ZERO
         BZ    PRINTER0            BYPASS MESSAGE IF NO CORE USED
         CVD   R1,WORKAREA         CONVERT SIZE TO DECIMAL
         ED    LINE34M,WORKAREA+5  INSERT SIZE INTO MESSAGE
         LINE  LINE34,P=Y          PRINT MESSAGE
         TM    YPSWITCH,YPSWNOIX   WERE INDICES SUPPREDSED
         BZ    PRINTER0            BR IF NOT
         LINE  LINE35,P=Y          TELL THAT INDICES WERE SUPPREDSED
         SPACE 5
***********************************************************************
*        TELL OF CORE DYNAMICALLY ACQUIRED                            *
***********************************************************************
         SPACE 1
PRINTER0 L     R1,GETMMCG          GET AMOUNT OF CORE ACQUIRED
         LTRR  R1,R1               TEST IF NO CORE ACQUIRED
         BZ    PRINTR12            BR IF NO CORE TO AVOID MESSAGE
         CVD   R1,WORKAREA         CONVERT SIZE TO DECIAL
         ED    LINE38M,WORKAREA+4  INSERT SIZE INTOMESSAGE
         LINE  LINE38,P=Y          PRINT MESSAGE
PRINTR12 EQU   *                   CONTINUE PRICESSING
         EJECT
***********************************************************************
*        PRINT ANY ERROR MESSAGES                                     *
***********************************************************************
         SPACE 1
         TM    SWERROR,SWEGETM     TEST IF STORAGE POOL TOO SMALL
         BZ    PRINTER1            BRANCH IF NO
         L     R1,GETMXCES         GET AMOUNT OF ADDITIONAL GETMAINS
         CVD   R1,WORKAREA         CONVERT AMOUNT TO DECIMAL
         ED    LINE19M,WORKAREA+5  ADD COUNT TO MESSAGE
         LINE  LINE19,P=Y          TELL OF ERROR
PRINTER1 TM    SWERROR,SWEURTN     DID USER RTN PASS BAD PPLL DATA
         BZ    PRINTER2            BRANCH IF NO
         LINE  LINE20,P=Y          TELL OF ERROR(S)
PRINTER2 EQU   *                   ERROR MESSAGE REMOVED
PRINTER3 EQU   *                   ERROR MESSAGE REMOVED
PRINTER4 EQU   *                   ERROR MESSAGE REMOVED
PRINTER5 EQU   *                   ERROR MESSAGE REMOVED
PRINTER6 EQU   *                   ( ERROR MESSAGE REMOVED )
PRINTER8 EQU   *                   ERROR MESSAGE REMOVED
PRINTER9 CLC   LRECLUT1,LRECL256   IS INPUT RCORD > 256 CHARACTERS
         BH    PRINTR10            BR IF GREATER TO TELL OF ERROR
         CLC   LRECLUT2,LRECL256   OUTPUT RECORD GREATER THAN 256
         BH    PRINTR10            BR IF GREATER TO TELL OF RRROR
         CLC   LRECLINT,LRECL256   INTERNAL RECORD GREATER THAN 256
         BNH   PRINTR11            BYPASS MESSAGE IF NOT
PRINTR10 LINE  LINE37,P=Y          TELL OF UNADDRESSABLE LENGTH
PRINTR11 EQU   *
         EJECT
***********************************************************************
*        PRINT SUMMARY OF ACTIVITY BY RECORD TYPE                     *
***********************************************************************
         SPACE 1
         USING CB02NTRY,R8         ESTABLISH CB02 ADDRESSABILITY
         USING CB11NTRY,R10        ESTABLISH CB11 ADDRESSABILITY
         ZAP   SYSPRINT+IOPSRCNT(4),=P'0' ZEROISE LINE COUNT
         LINE  S=P                 SKIP TO NEW PAGE
         LINE  LINE21              PRINT SUBHEADING
         L     R8,PTR1CB02          RETRIVE POINTER TO 1ST BATCH TYPE
         B     *+8                 BYPASS FORWARD CHAINING
SUMMACT  L     R8,CB02CB02         GET NEXT CB02 CONTROL BLOCK
         LTRR  R8,R8               PURIFY & TETS IF ZERO
         BZ    SUMMACTX            TERMINATE SUMMARY IF END OF CHAIN
         LINE  ,                   PRINT BLANK LINE
         EJECT
***********************************************************************
*        PRINT SUMMARY OF ACTIVITY BY RECORD TYPE ( CONT'D )          *
***********************************************************************
         SPACE 1
         MVC   LINE22+26(8),CB02BCI MOVE BATCH CARD ID TO MESSAGE
         MVCD  5,LINE22            MOVE MESSAGE TO BUFFER
         MVCD  5+L'LINE22,SUMMMASK EDIT MASK TO BUFFER
         ED    5+L'LINE22(L'SUMMMASK,R5),CB02CNT PUT COUNT IN BUFFER
         CBAL  R4,PRINT3G          PRINT MESSAGE
         L     R10,CB02CB11        GET ADDRESS OF 1ST CB11 BLOCK
         B     *+8                 BYPASS FORWARD CHAINING
SUMMACT1 L     R10,CB11CB11        GET ADDRESS OF NEXT CB11 BLOCK
         LTRR  R10,R10             PURIFY & TEST FOR END OF CHAIN
         BZ    SUMMACT             IF END OF CB11 GET NEXT CB02
         MVC   LINE23+26(8),CB11RTI MOVE DETAIL CARD ID TO MESSAGE
         MVCD  5,LINE23            MESSAGE TO BUFFER
         MVCD  5+L'LINE23,SUMMMASK EDIT MASK TO BUFFER
         ED    5+L'LINE23(L'SUMMMASK,R5),CB11CNT PUT REC COUNT IN MESS
         CBAL  R4,PRINT3G          PRINT MESSAGE
         B     SUMMACT1            LOOP TO NEXT CB11 BLOCK
SUMMACTX LINE  ,                   PRINT BLANK LINE
         LINE  LINE24,S=2          PRINT 'END OF SUMMARY'
         DROP  R8,R10              DROP CONTROL BLOCK ADDRESSABILITY
         EJECT
***********************************************************************
*        TERMINATE ANY USER MODULES                                   *
***********************************************************************
         SPACE 1
         USING CB02NTRY,R10        ESTABLISH CB02 ADDRESSABILITY
         L     R10,PTR1CB02         POINT AT 1ST CB02
         MVC   URTNRTN,SPACES      BLANK OUT SUBROUTINE NAME
         B     DLETRTN+4           BRANCH OVER FORWARD CHAINING
DLETRTN  L     R10,CB02CB02        GET ADDRESS OF NEXT CB02
         LTRR  R10,R10             PURIFY & TEST FOR END OF CHAIN
         BZ    DLETRTNX            EXIT IF CHAIN EXHAUSTED
         TM    CB02SW,SW02IRTN     WAS USER RTN INVOKED
         BZ    DLETRTN             GET NEXT CB02 IF NOT
         CBAL  R4,URTNDLET         TERMINATE USER MODULE
         B     DLETRTN             GO GET NEXT CB02 ADDRESS
DLETRTNX EQU   *                   TERMINATE DELETION ROUTINE
         DROP R10                  DROP CB02 ADDRESSABILITY
         EJECT
***********************************************************************
*        FREE ANY DYNAMICALLY ACQUIRED CORE                           *
***********************************************************************
         SPACE 1
         USING POOLDEFN,R5         ESTABLISH STORAGE POOL ADDRESSABILIT
         LA    R5,GETMMCA          POINT AT 1ST DEFINITION
         LA    R10,5               ESTABLISH LOOP OF 5 BUCKETS
FRECORE1 TM    POOLSW,POOLUSE      WAS POOL USED
         BZ    FRECOREX            EXIT IF POOLS EXHAUSTED
         MVC   GETMMCWA(8),POOLADR SET ADDRESS & SIZE IN W/A
         FREEMAIN V,A=GETMMCWA     FREE CORE
         LA    R5,POOLLGTH(,R5)    POINT AT NEXT DEFINITION
         BCT   R10,FRECORE1        LOOP BACK IF ANY BUCKETS LEFT
FRECOREX EQU   *                   END OF FREEMAIN ROUTINE
         DROP  R5                  DROP STORAGE POOL ADDRESSABILITY
         EJECT
***********************************************************************
*        PRINT CONDITION CODE                                         *
***********************************************************************
         SPACE 1
PRINTCDE SUBIN ,                   PRINT CONDITION CODE
         L     R5,SYSPRINT+IOPSRECA RETRIEVE BUFFER ADDRESS
         MVI   0(R5),SPCE2AFT      ESTABLISH DOUBLE SPACE
         LINE  LINE02,P=N          SET UP MESSAGE
         LH    R2,COMPCODE         GET CONDITION CODE
         CVD   R2,WORKPACK         CONVERT IT TO DECIMAL
         MVC   WORKEDIT,EDITCOND   SET UP EDIT PATTERN
         ED    WORKEDIT,WORKPACK+6 EDIT CONDITION CODE
         MVC   L'LINE02+6(2,R5),WORKEDIT+2 ADD CODE TO MESSAGE
         CBAL  R4,PRINT3G          PRINT CONDITION CODE
         SPACE 1
         B     JOBEND              GO TERMINATE JOB
         SPACE 5
***********************************************************************
*        INVOKE SUBROUTINE 'PRINT' FROM CSECT 'BUDGIE3G'              *
***********************************************************************
         SPACE 1
PRINT3G  SUBIN SAVE=R4             PRESERVE RETURN ADDRESS
         CBAL  R4,PRINT            INVOKE ROUTINE 'PRINT'
        SUBOUT RESTORE=R4          RESTORE & RETURN
         SPACE 1
         DROP  R11                 DROP BUDGIE3G ADDRESSABILITY
BUDGIE3  CSECT
         TITLE 'JOB TERMINATION ROUTINES'
***********************************************************************
*        TERMINATE JOB                                                *
***********************************************************************
         SPACE 1
JOBEND   SUBIN ,                   CERMINATE JOB
         BC    0,ABEND04           TERMINATE ABNORMALLY IF REQUESTED
         IOM   CLOSE,SYSUT1,LOOP=IOMMAXDD CLOSE ANY OPEN FILES
        PGMOUT RC=COMPCODE,DC=YES  SET COND CODE & RETURN
         EJECT
***********************************************************************
*        TERMAINATE ABNORMALLY                                        *
***********************************************************************
         SPACE 1
ABEND04  L     R1,DUMP04           USER REQUESTED DUMP IN TERMINATION
         SVC   13                  ISSUE DUMP SVC
         SPACE 1
ABEND08  L     R1,DUMP08           POTENTIALLY CRITICAL ERROR IN C/C
         SVC   13                  ISSUE DUMP SVC
          SPACE                    1
ABEND12  L     R1,DUMP12           MANDATORY DD STATEMENT MISSING
         SVC   13                  ISSUE DUMP SVC
         SPACE 1
ABEND16  L     R1,DUMP16           SHOW 1ST DATA CARD NOT A BATCH CARD
         SVC   13                  ISSUE DUMP SVC
         SPACE 1
ABEND20  L     R1,DUMP20           SEQUENSE ERRROR SYSUT1
         SVC   13                  ISSUE DUMP SVC
         SPACE 1
ABEND24  L     R1,DUMP24           SEQUENXE ERROR LOGIN
         SVC   13                  ISSUE DUMP SVC
         SPACE 1
ABEND28  L     R1,DUMP28           SEQUENSE ERROR SUSPIN
         SVC   13                  ISSUE DUMP SVC
         SPACE 1
ABEND32  L     R1,DUMP32           UNSUPPORTED FUNCTIOM
         SVC   13                  ISSUE DUMP SVC
         SPACE 1
ABEND36  L     R1,DUMP36           SEVERE ERRORS IN CONTROL CARDS
         SVC   13                  ISSUE DUMP SVC
         SPACE 1
ABEND40  L     R1,DUMP40           INTERNAL REORD  OUTPUT LENNGTH
         SVC   13                  ISSUE DUMP SVC
         SPACE 1
ABEND44  L     R1,DUMP44           ISAM ERROR OTHER THAN RECORD NOT FOU
         SVC   13                  ISSUE DUMP SVC
         SPACE 1
ABEND48  L     R1,DUMP48           CB13 SPECIFIES NCORRECT ISAM KEY LEN
         SVC   13                  ISSUE DUMP SVC
         SPACE 1
ABEND52  L     R1,DUMP52           NO WORK DD STAT & BATCH EXCEEDS CORE
         SVC   13                  ISSUE DUMP SVC
         SPACE 1
ABEND56  L     R1,DUMP56           TOO MANY ENTRIES BUILDING C1-TYPE LI
         SVC   13                  ISSUE DUMP SVC
         SPACE 1
ABEND60  L     R1,DUMP60           UER REQUESTED DUMP BY 'AB'
         SVC   13                  ISSUE DUMP SVC
         SPACE 1
ABEND64  L     R1,DUMP64           NO CONTROL CARDS FOUND
         SVC   13                  ISSUE DUMP SVC
         EJECT
***********************************************************************
*        TERMAINATE ABNORMALLY ( CONT'D )                             *
***********************************************************************
         SPACE 1
ABEND68  L     R1,DUMP68           INSUFFICIENT CORE FOR INITIALISATION
         SVC   13                  ISSUE DUMP SVC
         SPACE 1
*        THE FOLLOWING DUMP ROUTINE RECEIVES CONTROL AFTER A TIMER
*         INTERRUPT, WHEN REGISTER CONTENETS ARE UNPREDICTABLE.  R15
*         POINTS AT THE ROUTINE ITSELF, AND IS USED TO ESTABLISH ADDR'Y
         USING ABEND72,R15         ESTABLISH TEMPORARY ADDRESSABILITY
ABEND72  L     R1,CODE72           RETRIEVE ABEND CODE
         SVC   13                  ISSUE DUMP SVC
         DS    0F                  ENSURE ALIGNMENT
CODE72   DC    AL1(128),AL3(72)    POTENTIAL USER LOOP: NO READ FOR 5 S
         DROP  R15                 DROP TEMPORARY ADDRESSABILITY
         SPACE 1
ABEND100 L     R1,DUMP100          BUDGIE3 INTERNAL LOGIC ERROR
         SVC   13                  ISSUE DUMP SVC
         EJECT
***********************************************************************
*        PATCH AREA FOR APPLYING SUPERZAPS                            *
***********************************************************************
         SPACE 1
*        ( 'B  *'  SIMPLIFIES CALCULATING ADDRESSES )
         SPACE 1
         B     *
         B     *
         B     *
         B     *
         B     *
         B     *
         B     *
         B     *
         B     *
         B     *
         B     *
         B     *
         B     *
         B     *
         B     *
         B     *
         B     *
         B     *
         B     *
         B     *
         B     *
         B     *
         B     *
         B     *
         B     *
         B     *
         B     *
         B     *
         B     *
         B     *
         B     *
         B     *
         B     *
         B     *
         B     *
         B     *
         B     *
         B     *
         B     *
         B     *
         B     *
         B     *
         B     *
         B     *
         B     *
         B     *
         TITLE 'BUDGIE3G - TEST IF CURRENT RECORD IS A BATCH CARD'
         SCSECT                    G
***********************************************************************
*        DETERMINES WHETHER IT IS A BATCH CARD.  ON INPUT, R6 POINTS  *
*         AT THE RECRD TO BE TESTED.  ON OUTPUT, 'NEXTSCAN' CONTAINS
*         THE BATCH NUMBER ( IF ANY ), AND 'NEXTMS02' CONTAINS THE
*         ADDRESS OF THE RELEVANT MS02 CONTROL BLOCK.  THE CONDITION
*         CODE IS SET SUCH THAT THE CALLER CAN MAKE THE FOLLOWING TESTS
*              BE  - CARD IS A BATCH CARD
*              BNE - CARD IS NOT A BATCH CARD
***********************************************************************
         PRINT NOGEN               SUPPRESS EXPANSION OF SUBIN
         USING CB02NTRY,R10        ESTABLISH CB ADDRESSABILITY
BCSCAN   SUBIN SAVE=(R4,R10)       PRESERVE REGISTERS
         PRINT GEN                 ALLOW EXPANSION OF MACROS
         MVI   BCSCANX,C'Y'        ASSUME CARD IS NOT A BATCH CARD
         MVI   NEXTSCAN,C' '       BLANK OUT RESULTANT ...
         MVC   NEXTSCAN+1(15),NEXTSCAN ... BATCH NUMBER
         XC    NEXTMS02,NEXTMS02   ZEROISE RESULTANT CB POINTER
         TM    BRSWITCH,SWBRKB     TEST FOR 'KEYBREAK' SPECIFIACTION
         BO    BCSCAN03            BR IF YES
         L     R10,PTR1CB02         PICK UP 1ST CONTROL BLOCK
         B     *+8                 BYPASS LOAD 1ST TIME
BCSCAN01 L     R10,CB02CB02        GET NEXT CONTROL BLOCK
         LA    R10,0(,R10)         PURIFY HIGH-ORDER BYTE
         LTR   R10,R10             TEST IF END OF CHAIN
         BZ    BCSCANX1            BRANCH IF YES
         LA    R2,WORKAREA         POINT R2 AT WORK AREA
         LA    R3,CB02PBCI         POINT R3 AT CARD ID 'PL'
         MVC   WORKAREA,SPACES     BLANK OUT WORK AREA
         CBAL  R4,EXTRACT          MOVE CARD ID TO WORKAREA
         CLC   CB02BCI,WORKAREA    TEST IF FIELD IS BATCH CARD ID
         BNE   BCSCAN01            BRANCH IF NO TO TEST NEXT
         ST    R10,NEXTMS02        PRESERVE CB POINTER
         LA    R2,NEXTSCAN         POINT AT BATCH NO STORAGE AREA
         MVC   NEXTSCAN,SPACES     BLANK OUT RECEIVING AREA
         LA    R3,CB02PBN1         POINT AT 1ST BATCH NO COMPONENT PL
         LA    R9,5                ESTABLISH LOOP FOR 5 COMPONENTS
BCSCAN02 CBAL  R4,EXTRACT          ADD BATCH NO COMPONENT TO STORE
         LA    R3,2(,R3)           POINT AT NEXT COMPONENT PL
         BCT   R9,BCSCAN02         LOOP BACK FOR NEXT COMPONENT
         MVI   BCSCANX,C'X'        SET TO HSOW BATCH CARD
BCSCANX1 CLI   BCSCANX,C'X'        SET CONFITION CODE FOR CALLER
        SUBOUT RESTORE=(R4,R10)    RETURN TO CALLER
         EJECT
***********************************************************************
*        BATCH CARD RECOGNITION ( CONT'D )                            *
***********************************************************************
         SPACE 1
BCSCAN03 L     R10,PTR1CB02        PICJ UP 1ST - & PRESUMABLY ONLY - CB
         ST    R10,NEXTMS02        PRESERVE C/B POINTER LEST CONTROL BR
         MVC   NEXTSCAN,SPACES     BLANK OUT WORK AREA
         LA    R2,NEXTSCAN         POINT R2 AT OUTPUT AREA
         LA    R3,CB02PBN1         POINT R3 AT 1ST 'PL' OF BNO
         LA    R9,5                ESTABLISH LOOP OF 5 COMPONENTS
         CBAL  R4,EXTRACT          MOVE BNO COMONENT TO OUTPUT RAEA
         LA    R3,2(,R3)           POINTA AT NET COMPONNET PL
         BCT   R9,*-8              LOOP BACK FOR NEXT COMPONENT
         CLC   CURRSCAN,NEXTSCAN   HAS THE KEY ( ABTCH NO ) CHANGED
         BE    BCSCANX1            RETURN TO SHOW SAME BATCH IF NOT
         MVI   BCSCANX,C'X'        SET TO SHOW CHABGE OF BATCH
         B     BCSCANX1            RETURN TO SET COND CODE
         TITLE 'BUDGIE3G - TEST IF CURRENT RECORD IS A DETAIL RECORD'
***********************************************************************
*        DETERMINES WHETHER THE CURRENT RECORD IS A KNOWN DETAIL      *
*         CARD TYPE.  ON INPUT, R6 POINTS AT THE RECORD TO BE TESTED  *
*         AND 'CURRMS02' CONTAINS THE ADDRESS OF THE RELEVANT CB02    *
*         CONTROL BLOCK.  ON OUTPUT, 'CURRMS11' POINTS AT THE         *
*         APPROPRIATE MS11 CONTROL BLOCK.  THE CONDITION CODE IS      *
*         SET SUCJ THAT THE USER CAN MAKE THE FOLLOWING TESTS -       *
*              BE  - CARD IS A KNOWN DETAIL TYPE                      *
*              BNE - CARD TYPE UNKNOWN                                *
***********************************************************************
         SPACE 1
         USING CB02NTRY,R10        ESTABLISH CB02 ADDRESSABILITY
         USING CB11NTRY,R8         ESAABLISH CB11 ADDRESSABILITY
         PRINT NOGEN               SUPPRESS EXPANSION OF SUBIN
DCSCAN   SUBIN SAVE=(R4,R8,R10)    PRESERVE REGISTERS
         PRINT GEN                 ALLOW EXPANSION OF MAXROS
         MVI   DCSCANX,C'Y'        ASSUME UNKNOWN CARD TYPE
         L     R10,CURRMS02        RETRIEVE B/C CONTROL BLOCK ADDRESS
         XC    CURRMS11,CURRMS11   ZEROISE D/C CONTROL BLOCK POINTER
         L     R8,CB02CB11         GET 1ST CB11 ADDRESS
         B     *+8                 BYPASS FORWARD CHAINNNG
DCSCAN01 L     R8,CB11CB11         GET ADDRESS OF NEXT CB11
         LTRR  R8,R8               PURIFY AND TEST
         BZ    DCSCANX1            GO RETURN TO CALLER IF END OF CHAIN
         LA    R2,WORKAREA         POINT R2 AT WORK AREA
         LA    R3,CB11PRTI         POINT AT CARD ID 'PL'
         MVC   WORKAREA,SPACES     BLANK OUT WORK AREA
         CBAL  R4,EXTRACT          MOVE CARD ID TO WORK AREA
         CLC   CB11RTI,WORKAREA    TEST IF CARD ID MATCHES CB11
         BNE   DCSCAN01            BRANCH IF NO TO NEXT TEST
         ST    R8,CURRMS11         PRESERVE ADDRESS OF CURRENT CB11
         AP    CB11CNT,ONE         INCREMENT COUNT OF THIS TYPE
         MVI   DCSCANX,C'X'        SET TO SHOW CARD TYPE KNOWN
DCSCANX1 CLI   DCSCANX,C'X'        SET COND CODE FOR CALLER
        SUBOUT RESTORE=(R4,R8,R10) RESTORE EEGISTERS AND RETURN
         SPACE 1
BCSCANX  DC    C' '                COMPARAND FOR COND CODE SETTING
DCSCANX  DC    C' '                COMPARAND TO SET COND CODE
         DROP  R8,R10              DROP CONTROL BLOCK ADDRESSABILITY
         SPACE 1
LGTHG    EQU   *                   END OF CSECT BUDGIE3G
         DROP  R11                 DROP BUDGIE3G ADDRESSABILITY
BUDGIE3  CSECT
         TITLE 'BUDGIE3F - USER ROUTINE PROCESSING'
        SCSECT F
***********************************************************************
*        LOAD & INITIALISE THE USER'S ROUTINE.  ON ENTRY,             *
*         R10 POINTS AT THE RELEVANT CB02 CONTROL BLOCK, AND          *
*         R9 POINTS AT THE LINKAGE AREA CONTROL INFO.                 *
***********************************************************************
         SPACE 1
URTNLOAD SUBIN ,                   LOAD USER'S ROUTINE
         USING URTNPARM,R9         ESTABLISH L/A ADDRESSABILITY
         USING CB02NTRY,R10        ESTABLISH CB02 ADDRESSABILITY
         MVC   URTNRTN,CB02URTN    RETRIEVE SUBROUTINE NAME
         LOAD  EPLOC=URTNRTN       LOAD SUBROUTINE
         LR    R2,R0               SAVE ENTRY POINT ADDRESS
         LR    R15,R0              ESTABLISH ROUTINE ADDRESS FOR BALR
         LA    R1,PTRPARM          POINT R1 AT ADDRESS OF L/A
         MVI   URTNCSW,C'1'        INDICATE INITIALISATION
         BALR  R14,R15             EXECUTE USER ROUTINE
         DROP  R10,R9              DROP ADDRESSABILITY
         USING CB02NTRY,R3         RE-ESTABLISH CB02 ADDRESSABILITY
         L     R3,PTR1CB02          GET ADDRESS OF 1ST CONTROL BLOCK
         B     *+8                 BYPASS LOAD 1ST TIME
URTNL01  EQU   *                   LOOP BACK POINT FOR MULTIPLE PASSES
         L     R3,CB02CB02         RETRIEVE NEXT POINTER
         LTRR  R3,R3               TEST FOR END OF CHAIN
         BZ    URTNL02             BRANCH IF END
         CLC   CB02URTN,URTNRTN    TEST IF SAME ROUTINE
         BNE   URTNL01             PROCESS NEXT IF NOT
         ST    R2,CB02ARTN         STORE ADDRESS OF ENTRY POINT
         OI    CB02SW,SW02IRTN     INDICATE RTN LOADED & INITIALISED
         B     URTNL01             PROCESS NEXT
URTNL02 SUBOUT ,                   RETURN TO CALLER
         DROP  R3                  DROP CB02 ADDRESSABILITY
         EJECT
***********************************************************************
*        TERMINATE AND DELETE A USER'S SUBROUTINE.  ON ENTRY,         *
*         R10 POINTS AT THE RELEVANT CB02 CONTROL BLOCK9              *
***********************************************************************
         SPACE 1
URTNDLET SUBIN SAVE=R10            PRESERVE REGISTER 10
         USING URTNPARM,R9         ESTABLISH L/A ADDRESSABILITY
         USING CB02NTRY,R10        ESTABLISH CB02 ADDRESSABILITY
         L     R9,PTRPARMU         POINT R9 AT L/A CONTROL INFO
         LA    R1,PTRPARM          POINT R1 AT PARM ADDRESS
         MVI   URTNCSW,C'4'        INDICATE TERMINATION
         MVC   URTNRTN,CB02URTN    PRESERVE NAME OF USER ROUTINE
         L     R15,CB02ARTN        GET ROUTINE ENTRY POINT ADDRESS
         BALR  R14,R15             ALLOW ROUTINE TO TERMINATE
         DROP  R10,R9              DROP ADDRESSABILITY
         USING CB02NTRY,R3         RE-ESTABLISH CB02 ADDRESSABILITY
        DELETE EPLOC=URTNRTN       DELETE SUBROUTINE FROM CORE
         L     R3,PTR1CB02          GET ADDRESS OF 1ST CONTROL BLOCK
         B     *+8                 BYPASS LOAD 1ST TIME
URTND01  EQU   *                   LOOP BACK POINT FOR MULTIPLE PASSES
         L     R3,CB02CB02         GET NEXT POINTER
         LA    R3,0(,R3)           PURIFY HIGH ORDER BYTE
         LTR   R3,R3               TEST FOR END OF CHAIN
         BZ    URTND02             BRANCH IF END
         CLC   CB02URTN,URTNRTN    TEST IF SAME ROUTINE
         BNE   URTND01             PROCESS NEXT IF NOT
         XC    CB02ARTN,CB02ARTN   ZEROISE ENTRY POINT ADDRESS
         NI    CB02SW,FF-SW02IRTN  INDICATE ROUTINE NOT PRESENT
         B     URTND01             PROCESS NEXT
         DROP  R3                  DROP CB02 ADDRESSABILITY
URTND02 SUBOUT RESTORE=R10         RESTORE REGISTERS & RETURN
         EJECT
***********************************************************************
*        INVOKE USER ROUTINE                                          *
***********************************************************************
         SPACE 1
*        ON ENTRY, R10 POINTS AT THE CURRENT CB02 ELEMENT
         SPACE 1
         USING CB02NTRY,R10        ESTABLISH ADDRESSABILITY TO CB02
         USING URTNPARM,R9         ESTABLISH LINKAGE AREA ADDRESSABILIT
         USING DETAILBB,R7         ESTABLISH B/B REPORT ADDRESSABI.TY
URTNCALL SUBIN SAVE=(R4,R9)        PRESERVE AREGISTERS
         L     R9,PTRPARMU         GET ADDRESS OF L/A CONTROL INFO
         L     R10,CURRMS02        GET CURRENT MS02 ADDRESS
         TM    CB02SW,SW02IRTN     TEST IF RTN LOADED & INITIALISED
         BO    URTNC00             BYPASS INITIALISATION IF DONE
         CBAL  R4,URTNLOAD         LOAD AND INITIALISE USER ROUTINE
URTNC00  MVI   URTNRSW2,C'0'       INDICTAE 'DO NOT RETURN' LEST USER F
         CLI   URTNCSW,C'5'        IS THIS AN R5 INVAOCATION
         BE    URTNC01             BR IF ONVOKED BY R5
         CLI   URTNCSW,C'6'        IS THIS END-IF-BATCH
         BE    URTNC01             BR IF END-OF-BATCH
         MVI   URTNCSW,C'3'        ASSUME DETAIL RECORD
         TM    PSWITCH,PSWBCARD    TEST IF BATCH CARD
         BNO   *+8                 BRANCH IF NOT
         MVI   URTNCSW,C'2'        INDICATE BATCH CARD
URTNC01  EQU   *                   LOOP BACK POINT FOR MULTIPLE PASSES
         MVI   URTNRSW1,C' '       CLEAR ...
         MVC   URTNMESS,SPACES      ... LINKAGE ...
         MVC   URTNPOS(4),ZEROES    ... FIELDS
         LA    R1,PTRPARM           POINT R1 AT ADDRESS OF L/A
         L     R15,CB02ARTN        GET ENTRY POINT ADDRESS
         BALR  R14,R15             EXECUTE USER'S ROUTINE
         CLI   URTNRSW1,C'2'       IS RECORD TO BE DELETED
         BNE   *+14                BR IF NOT
         MVC   DTBBFLAG-1(6),=C'DELETE' SET UP DELETE MESSAGE
         OI    MASTER,SWMPRINT     ENSURE LINE WILL BE PRINTED
         CLI   URTNRSW1,C'1'       IS BATCH TO BE REJECTED
         BNE   *+14                BR IF NOT
         MVC   DTBBFLAG,=C'****'   ADD REJECT FLAG
         OI    MASTER,SWMPRINT     ENSURE LINE WILL BE PRINTED
         CLC   URTNMESS,SPACES     TEST IF MESSAGE SUPPLIED
         BE    *+14                BRANCH IF NOT
         MVC   DTBBEMSS,URTNMESS   ADD MESSAGE TO LINE
         OI    MASTER,SWMPRINT     INDICATE PRINT NECESSARY
         CLC   URTNPOS(4),ZEROES   TEST IF ERROR FIELD INDICATED
         BE    URTNC02             BRANCH IF NOT
         EJECT
***********************************************************************
*        INVOKE USER RTN ( CONT'D )                                   *
***********************************************************************
         SPACE 1
         OI    MASTER,SWMPRINT     INDICATE PRINT NECESSARY
         LA    R3,WORKPL           POINT AT WORK AREA
         LA    R2,URTNPOS          POINT R2 AT PPLL
         CBAL  R4,PPLLPL           CONVERT PPLL TO PL
         CBAL  R4,UNDRSCOR         UNDERLINE FIELD IN ERROR
URTNC02  TM    MASTER,SWMPRINT     TEST IF LINE SHOULD BE PRINTED
         BZ    URTNC03             BYPASS PRINTING IF NOT
         CBAL  R4,PRINTBBL         PRINT ERROR MESSAGE
         NI    MASTER,FF-SWMPRINT  SET OFF PRINT SWITCH
         SPACE 5
***********************************************************************
*        CONT'D OVERLEAF                                              *
***********************************************************************
         EJECT
***********************************************************************
*        INVOKE USER RTN ( CONT'D )                                   *
***********************************************************************
         SPACE 1
URTNC03  CLI   URTNRSW1,C'2'       IS RECORD TO BE DELETED
         BNE   *+12                BR IF NOT TO BE DELETED
         OI    PSWITCH,PSWDLETE    FLAG TO DELETE RECORD
         B     URTNC04             BYPASS FURTHER FLAG SETTINF
         CLI   URTNRSW1,C'1'       IS IT A HARD ERROR
         BNE   *+22                BR IF NOT
         OI    PSWITCH,PSWHARD     SET ON HARD ERROR SW FOR CARD
         OI    MASTER,SWMHARD      SET ON HARD ERROR SW FOR BATCH
         AP    CB02HCNT,ONE        INCREMENT HARD ERROR CNT
         B     URTNC04             BYPASS FUTTHER SETTING
         CLC   URTNMESS,SPACES     IS MESSAGE SUPPLIED
         BE    URTNC04             NO MESSAGE, SO NO ERROR FOUND
         OI    MASTER,SWMSOFT      SET ON SOFT ERROR SW FOR BATCH
         OI    PSWITCH,PSWSOFT     SET ON SOFT ERROR SW FOR CARD
         AP    CB02SCNT,ONE        INCREMENT SOFT ERROR COUNT
URTNC04  CLI   URTNRSW2,C'0'       TEST IF RECORD REQUIED AGAIN
         BNE   URTNC01             LOOP BACK IF YES
         MVI   URTNCSW,C' '        NULLIFY CALL SWITCH FOR NEXT TIME
        SUBOUT RESTORE=(R4,R9)     RESTORE REGISTERS & RETURN
         DROP  R9,R10              DROP ADDRESSABILITY
         DROP  R11                 DROP CSECT ADDRESSABILITY
BUDGIE3  CSECT
         TITLE 'SELECT EDIT PATTERN AND EDIT VALUE'
***********************************************************************
*        SELECT APPROPRIATE EDIT PATTERN & EDIT VALUE                 *
***********************************************************************
         SPACE 1
*        ON ENTRY, R8 POINTS AT THE REPORT LINE 'BUCKET', R9
*         CONTAINS THE ADDRESS OF THE CURRENT CB05, AND R1 POINTS
*         AT THE FIELD TO BE EDITED
         SPACE 1
         USING CB05NTRY,R9         ESTABLISH CB05 ADDRESSABILITY
FLDEDIT  SUBIN ,                   EDIT FIELD
         MVC   0(18,R8),EDITPL84   ASSUME 4 DECIMAL PLACES
         CP    CB05NDEC,=P'4'      TEST IF 4 DECIMAL PLACES
         BE    FLDEDIT1            BR IF YES
         MVC   0(18,R8),EDITPL83   ASSUME 3 DECIMAL PLACES
         CP    CB05NDEC,=P'3'      TEST IF 3 DECIMAL PLACES
         BE    FLDEDIT1            BR IF YES
         MVC   0(18,R8),EDITPL82   ASSUME 2 DECIMAL PLACES
         CP    CB05NDEC,=P'2'      TEST IF 2 DECIMAL PLACES
         BE    FLDEDIT1            BR IF YES
         MVC   0(18,R8),EDITPL81   ASSUME 1 DECIMAL PLACES
         CP    CB05NDEC,=P'1'      TEST IF 1 DECIMAL PLACES
         BE    FLDEDIT1            BR IF YES
         MVC   0(18,R8),EDITPL80   ASSUME 0 DECIMAL PLACES
FLDEDIT1 ED    0(18,R8),0(R1)      EDIT VALUE INTO BUCKET
        SUBOUT ,                   RETURN TO CALLER
         TITLE 'BUDGIE3B - SELECT APPROPRIATE TEST ROUTINE'
        SCSECT B
***********************************************************************
*        SELECT APPROPRIATE TEST ROUTINE.  ON ENTRY, R1               *
*         CONTAINS 'AAAAAAXX' WHERE XX IS THE INTERNAL REPRESENTATION *
*         OF THE TEST CODE, AND AAAAAA IS THE ADDRESS OF AN ASSOCIATED*
*         C/B ( WHERE RELEVANT), R3 POINTS AT THE PL OF THE FIELD TO  *
*         BE TESTED, AND R6 POINTS AT THE RECORD.  R4 CONTAINS THE    *
*         RETURN ADDRESS.                                             *
***********************************************************************
         SPACE 1
TESTSEL  SUBIN SAVE=(R4,R6,R9)     PRESERVE REGISTERS
         MVC   FLDP(2),0(R3)       PRESERVE PL LEST REEQUIRD LATER
         SR    R2,R2               ZEROISE WORK REGISTER
         IC    R2,0(R3)            RETRIEVE POSN OF FIRLD
         BCTR  R2,0                DECREMENT ( POSN - 1 = DISPLACEMENT)
         AR    R6,R2               POINT R6 AT FIELD TO BE TESTED
         SR    R15,R15             ZEROISE WORK REGISTER
         IC    R15,1(R3)           RETRIEVE LENGTH OF FIELD
         LTR   R15,R15             VERIFY THAT LENGTH EXISTSS
         BZ    *+10                BYPASS EXECUTE IF NO LENGTH
         BCTR  R15,0               DECREMENT LENGTH FOR EXECUTE
         EX    R15,TESTMVC         MOVE FIELD TO WORK AREA
         LR    R4,R1               INTERNAL TEST REPRESENTATIO TO R4
         N     R4,MASKFFF0         ZEROISE 3 HIGH ORDER BYTES
         LR    R2,R1               C/B ADDRESS TO R2
         SRL   R2,8                ALTER 'AAAAAAXX' TO '00AAAAAA'
         LR    R1,R15              LENGTH OF FIELD INTO R1
         LA    R14,TESTAREA        POINT AT START OF TEST FIELD
         AR    R15,R14             POINT R15 AT END OF FIELD
         MVI   TESTTSTX,C'X'       ASSUME TEST SATISFIED
         L     R9,VBUDG3O          POINT R9 AT BUDGIE3O
         EJECT
*        REGISTERS ARE NOW SET THUS :-
*              R15 - END OF FIELD TO BE TESTED
*              R14 - START OF FIELD TO BE TESTED
*              R1  - EXECUTABLE LEBGTH
*              R2  - ADDRESS OF ASSOC C/B ( WHERE RELEVANT )
*              R4  - TEST CODE
*              R6  - POINTS AT FIELD IN RECORD
*              R8  - ADDRESS OF CURRENT CB13
*              R10 - ADDRESS OF CURRENT CB02
*        R9  - ADDRESS OF BUDGIE3O FOR TEMP ADDRESSABILITY
         SPACE 1
         USING BUDGIE3O,R9         ESTABLISH TEMPORARY ADDRESSABILITY
         SPACE 1
*        THE VARIOUS FIELD TESTS AND OPERATIONS ARE TOO LARGE TO BE
*         CONTAINED IN A SINGLE CSECT, AND ARE SPREAD BETWEEN BUDGIE3B,
*         BUDGIE3J, AND BUDGIE3O.  THE FOLLOWING INDEXED BRANCH PASSES
*         CONTROL TO THE APPROPRIATE ROUTINE IN THE APPROPRIATE CSECT
*         BY TEMPORARILY ESTABLISHING ADDRESSABILITY TO ALL THE CSECTS.
         EJECT
***********************************************************************
*        SELECT APPROPRIATE TEST ROUTINE                              *
***********************************************************************
         SPACE 1
         SLA   R4,2                MULTIPLY R4 BY 4 TO CONVERT TEST CDE
*                                   TO INDEX FOR THE FOLLOWING BR .....
         B     TESTBR(R4)           ... TO SELECT APPROPRIATE ROUTINE
TESTBR   B     TESTL1              TEST TYPE L1 - SUPPORTED
         B     TESTL2              TEST TYPE L2 - SUPPORTED
         B     TESTL3              TEST TYPE L3 - SUPPORTED
         B     TESTL4              TEST TYPE L4 - SUPPORTED
         B     TESTL5              TEST TYPE L5 - SUPPORTED
         B     TESTL6              TEST TYPE L6 - SUPPORTED
         B     TESTL7              TEST TYPE L7 - SUPPORTED
         B     TESTL8              TEST TYPE L8 - SUPPORTED
         B     TESTL9              TEST TYPE L9 - SUPPORTED
         B     TESTLT              TEST TYPE LT - SUPPORTED
         B     TESTLE              TEST TYPE LE - SUPPORTED
         B     TESTEQ              TEST TYPE EQ - SUPPORTED
         B     TESTNE              TEST TYPE NE - SUPPORTED
         B     TESTGT              TEST TYPE GT - SUPPORTED
         B     TESTGE              TEST TYPE GE - SUPPORTED
         B     TESTNN              TEST TYPE NN - SUPPORTED
         B     TESTNS              TEST TYPE NS - SUPPORTED
         B     TESTNZ              TEST TYPE NZ - SUPPORTED
         B     TESTNB              TEST TYPE NB - SUPPORTED
         B     TESTUNS             TEST TYPE TX - UNSUPPORTED
         B     TESTC1              TEST TYPE C1 - SUPPORTED
         B     TESTC2              TEST TYPE C2 - SUPPORTED
         B     TESTC3              TEST TYPE C3 - SUPPORTED
         B     TESTUNS             TEST TYPE C4 - UNSUPPORTED
         B     TESTUNS             TEST TYPE C5 - UNSUPPORTED
         B     TESTC6              TEST TYPE C6 - SUPPORTED
         B     TESTC7              TEST TYPE C7 - SUPPORTED
         B     TESTC8              TEST TYPE C8 - SUPPORTED
         B     TESTR1              TEST TYPE R1 - SUPPORTED
         B     TESTR2              TEST TYPE R2 - SUPPORTED
         B     TESTR3              TEST TYPE R3 - SUPPORTED
         B     TESTR4              TEST TYPE R4 - SUPPORTED
         B     TESTR5              TEST TYPE R5 - SUPPORTED
         B     TESTR6              TEST TYPE R6 - SUPPORTED
         B     TESTR7              TEST TYPE R7 - SUPPORTED
         B     TESTR8              TEST TYPE R8 - SUPPORTED
         B     TESTR9              TEST TYPE R8 9 SUPPORTED
         B     TESTD1              TEST TYPE D1 - SUPPORTED
         B     TESTD2              TEST TYPE D2 - SUPPORTED
         B     TESTD3              TEST TYPE D3 - SUPPORTED
         B     TESTD4              TEST TYPE D4 - SUPPORTED
         B     TESTD5              TEST TYPE D5 - SUPPORTED
         B     TESTD6              TEST TYPE D6 - SUPPORTED
         EJECT
***********************************************************************
*        SELECT APPROPRIATE TEST ROUTINE ( CONT'D )                   *
***********************************************************************
         SPACE 1
         B     TESTD7              TEST TYPE D7 - SUPPORTED
         B     TESTUNA             TEST TYPE D8 - UNALLOCATED
         B     TESTUNA             TEST TYPE D9 - UNALLOCATED
         B     TESTI               TEST TYPE I  - SUPPORTED
         B     TESTUNS             TEST TYPE JX - UNSUPPORTED
         B     TESTUNS             TEST TYPE C9 - UNSUPPORTED
         B     TESTE1              TEST TYPE E1 - SUPPORTED
         B     TESTE2              TEST TYPE E2 - SUPPORTED
         B     TESTE3              TEST TYPE E3 - SUPPORTED
         B     TESTE4              TEST TYPE E4 - SUPPORTED
         B     TESTUNA             TEST TYPE E5 - UNSUPPORTED
         B     TESTUNA             TEST TYPE E6 - UNSUPPORTED
         B     TESTUNA             TEST TYPE E7 - UNSUPPORTED
         B     TESTUNA             TEST TYPE E8 - UNSUPPORTED
         B     TESTUNA             TEST TYPE E9 - UNSUPPORTED
         B     TESTUNA             TEST TYPE F1 - UNSUPPORTED
         B     TESTUNA             TEST TYPE F2 - UNSUPPORTED
         B     TESTUNA             TEST TYPE F3 - UNSUPPORTED
         B     TESTUNA             TEST TYPE F4 - UNSUPPORTED
         B     TESTUNA             TEST TYPE F5 - UNSUPPORTED
         B     TESTUNA             TEST TYPE F6 - UNSUPPORTED
         B     TESTUNS             TEST TYPE M1 - UNSUPPORTED
         B     TESTUNA             TEST TYPE M2 - UNALLOCATED
         B     TESTUNA             TEST TYPE M3 - UNALLOCATED
         B     TESTUNA             TEST TYPE M4 - UNALLOCATED
         B     TESTUNA             TEST TYPE M5 - UNALLOCATED
         B     TESTUNA             TEST TYPE M6 - UNALLOCATED
         B     TESTUNA             TEST TYPE M7 - UNALLOCATED
         B     TESTUNA             TEST TYPE M8 - UNALLOCATED
         B     TESTUNA             TEST TYPE M9 - UNALLOCATED
         B     TESTUS              TEST TYPE US - SUPPORTED
         B     TESTUZ              TEST TYPE UZ - SUPPORTED
         B     TESTUB              TEST TYPE UB - SUPPORTED
         B     TESTS               TEST TYPE S  - SUPPORTED
         B     TESTUNS             TEST TYPE NM - UNSUPPORTEE
         B     TESTSX              TEST TYPE SW - SUPPORTED
         B     TESTIT              TEST TYPE IT - SUPPORTED
         B     TESTON              TEST TYPE ON - SUPPORTED
         B     TESTOF              TEST TYPE OF - SUPPORTED
         B     TESTWR              TEST TYPE WR - SUPPORTED
         B     TESTRTN             TEST TYPE DM - DUMMY OPERATION
         B     TESTRTNY            TEST TYPE ER - DUMMY OPERATION
         B     TESTUNS             TEST TYPE NR - UNSUPPORTED
         B     TESTUNS             TEST TYPE UR - UNSUPPORTED
         B     TESTAB              TEST TYPE AB - SUPPORTED
         B     TESTWI              TEST TYPE WI - SUPPORTED
         DROP  R9                  DROP BUDGIE3O ADDRESSABILITY
         EJECT
***********************************************************************
*        FORCE RETURN WITH ERROR CONDITION                            *
***********************************************************************
         SPACE 1
TESTRTNY MVI   TESTTSTX,C'Y'       SET ON ERROR LFAG
        BBMESS 17                  SET UP DEFAULT ERROR MESSAGE
         SPACE 5
***********************************************************************
*        PREPARE TO RETURN TO CALLER                                  *
***********************************************************************
         SPACE 1
*        THE CONDITION CODE IS SET SUCH THAT THE USER CAN MAKE THE
*         FOLLOWING TESTS -
*              BL - SPECIAL CASE SATISFIED ( E.G. ALL BLANK )
*              BNH  TEST SATISFIED
*              BE - GENERAL CASE SATISFIED
*              BH - TEST NOT SATISFIED
         SPACE 1
TESTRTN  EQU   *                   PREPARE TO RETURN TO CALLER
         CLI   TESTTSTX,C'X'       SEE IF TEST SATISFIED
         BNH   TESTRTN1            BYPASS ERROR PROCESSING IF SATISFIED
         LA    R3,ULINEPL          POINT AT FIELD TO BE UNDERLINED
         CBAL  R4,ADDCOLS          ADD POSN TO ERROR MESSAGE
         CBAL  R4,UNDRSCOR         ADD UNDER-SCORE TO PRINT LINE
         B     *+10                BYPASS RESETTING ERROR MESSAGE
TESTRTN1 MVC   DTBBEMSS(L'DTBBEMSS+1),SPACES BLANK OUT MESSAGE AREA
         CLI   TESTTSTX,C'X'       SET COND CODE FOR USER
        SUBOUT RESTORE=(R4,R6,R9)  RESTORE AND RETURN
         EJECT
***********************************************************************
*        DUMMY TEST ROUTINES                                          *
***********************************************************************
         SPACE 1
TESTUNS  MVC   LINE29M,LINE29S     ALTER ERROR MESSAGE
         B     TESTERM             GO PRINT ERROR MESSAGE
         SPACE 1
TESTUNA  MVC   LINE29M,LINE29A     ALTER ERROR MESSAGE
         B     TESTERM             GO PINR ERROR MESSAGE
         SPACE 1
TESTERM  SUBIN SAVE=R5             PRESERVE REGISTER 5
         OI    CB13SW-CB13NTRY(R8),SW13NTST FLAG TEST AS NO-OP
         MVC   LINE29TT,CB13TST0-CB13NTRY(R8) MOVE TEST ID TO MESSAGE
         USING CB13NTRY,R8         ESTABLISG TEMPORARY ADDRESSABILITY
         CCNO  LINE29N1,CB13       ADD CARD SEQ NO TO ERROR MESSAGE
         DROP  R8                  DROP CB13 ADDRESSABILITY
         L     R5,SYSPRINT+IOPSRECA GET BUFFER ADDRESS
         LINE  LINE29,P=Y          PRINT ERROR MESSAGE
        SUBOUT RESTORE=R5,RETURN=TESTRTN RESTORE & PREPARE TO RETURN
         TITLE 'BUDGIE3B - TEST ROUTINES'
***********************************************************************
*        L1 - ALPHABETIC: A-Z | BLANK                                 *
***********************************************************************
         SPACE 1
TESTL1   SUBIN ,                   TEST FOR ALPHABETIC
         MVC   DTBBEMSS(L'BBMESS10),BBMESS10 ADD ERROR MESSAGE TO LINE
         EX    R1,TESTTR           TRANSLATE AGAINST MAIN TABLE
         EX    R1,TESTTRL1         TRANSLATE & TEST WITH L1 TABLE
         BE    *+8                 BR IF TEST SATIFIED
         MVI   TESTTSTX,C'Y'       SHOW TEST NOT SATISFIED
         B     TESTRTN             GO RETURN TO CALLER
         SPACE 5
***********************************************************************
*        L2 - ALPHAMERIC: A - Z | 0 - 9 | BLANK                       *
***********************************************************************
         SPACE 1
TESTL2   SUBIN ,                   TEST FOR ALPHAMERIC
         MVC   DTBBEMSS(L'BBMESS11),BBMESS11 ADD ERROR MESSAGE TO LINE
         EX    R1,TESTTR           TRANSLATE AGAINST MAIN TABLE
         EX    R1,TESTTRL2         TRANSLATE & TEST WITH L2 TABLE
         BE    *+8                 BR IF TEST SATIFIED
         MVI   TESTTSTX,C'Y'       SHOW TEST NOT SATISFIED
         B     TESTRTN             GO RETURN TO CALLER
         SPACE 5
***********************************************************************
*        L3 - ALPHAMERIC: A - Z | 0 - 9 | BLANK | SPECIAL CHARS       *
***********************************************************************
         SPACE 1
TESTL3   SUBIN ,                   TETS FOR ALPHAMERIC
         MVC   DTBBEMSS(L'BBMESS11),BBMESS11 ADD ERROR MESSAGE TO LINE
         EX    R1,TESTTR           TRANSLATE AGAINST MAIN TABLE
         EX    R1,TESTTRL3         TRANSLATE & TEST WITH L3 TABLE
         BE    *+8                 BR IF TEST SATIFIED
         MVI   TESTTSTX,C'Y'       SHOW TEST NOT SATISFIED
         B     TESTRTN             GO RETURN TO CALLER
         EJECT
***********************************************************************
*        L4 - NON-BLANK                                               *
***********************************************************************
         SPACE 1
TESTL4   SUBIN ,                   TEST FOR NON-BLANK
         MVC   DTBBEMSS(L'BBMESS13),BBMESS13 ADD ERROR MESSAGE TO LINE
         EX    R1,TESTCLC          TEST IF FIELD BLANK
         BNE   *+8                 BR IF FIELD NOT BLANK
         MVI   TESTTSTX,C'Y'       SHOW TEST NOT SATISFIED
         B     TESTRTN             GO TETURN TO CALLER
         SPACE 5
***********************************************************************
*        L5 - BLANK                                                   *
***********************************************************************
         SPACE 1
TESTL5   SUBIN ,                   TEST FOR BLANK
         MVC   DTBBEMSS(L'BBMESS12),BBMESS12 ADD ERROR MESSAGE TO LINE
         EX    R1,TESTCLC          TEST IF FIELD BLANK
         BE    *+8                 BR IF TEST SATIFIED
         MVI   TESTTSTX,C'Y'       SHOW TEST NOT SATISFIED
         B     TESTRTN             GOT RETURN TO CALLER
         SPACE 5
***********************************************************************
*        NN - ALL UNSIGNED NUMERIC                                    *
***********************************************************************
         SPACE 1
TESTNN   SUBIN ,                   TEST FOR UNSIGNED NUMERIC
         MVC   DTBBEMSS(L'BBMESS03),BBMESS03 ADD ERROR MESSAGE TO LINE
         EX    R1,TESTTR           TRANSLATE AGAINST MAIN TABLE
         EX    R1,TESTTRNN         TRANSLATE & TEST AGAINST (( TABLE
         BE    *+8                 BR IF TEST SATIFIED
         MVI   TESTTSTX,C'Y'       SHOW TEST NOT SATISFIED
         B     TESTRTN             GO RETURN TO CALLER
         EJECT
***********************************************************************
*        NS - SIGNED/UNSIGNED NUMERIC WITH LEADING BLANKS             *
***********************************************************************
         SPACE 1
TESTNS   SUBIN ,                   TEST FOR SIGNED/UNSIGNED NUMERIC
        BBMESS 03                  MOVE ERROR MESSAGE TO LINE
         CBAL  R4,TESTSN           TEST FOR SIGNED/UNSIGNED NUMERIC
         B     TESTRTN             GO RETURN TO CALLER
         SPACE 5
***********************************************************************
*        NZ - AS NS, BUT REPLACE LEADING BLANKS BY ZERO               *
***********************************************************************
         SPACE 1
TESTNZ   SUBIN ,                   TEST FOR NUMERIC
        BBMESS 03                  MOVE ERROR MESSAGE TO LINE
         CBAL  R4,TESTSN           TEST FOR SIGNED/UNSIGNED NUMERIC
         BH    TESTNZX             BR IF FIELD NOR NUMERIC
         CBAL  R4,TESTORZ          SET LEADING BLANKS TO ZERO
         CLI   0(R14),C' '         TEST IF LAST BYTE BLANK
         BNE   *+8                 BRANCH IF LAST BYTE NOT BLANK
         MVI   0(R14),C'0'         ALTER LAST BLANK TO ZERO
TESTNZX  B     TESTRTN             GO TETURN TO CALLER
         SPACE 5
***********************************************************************
*        NB - AS 'NZ' BUT ALL BLANK FIELDS ARE NOT ZEROISED           *
***********************************************************************
         SPACE 1
TESTNB   SUBIN ,                   TEST FOR NUMERIC
        BBMESS 03                  MOVE ERROR MESSAGE TO LINE
         CBAL  R4,TESTSN           TEST IF NUMEROC
         BNE   TESTNBX             BR IF NIN-NUMERIC OR ALL BLANK
         CBAL  R4,TESTORZ          SET LEADING BLANKS TO ZERO
TESTNBX  B     TESTRTN             GO RETURN TO CALLER
         EJECT
***********************************************************************
*        US - UNSIGNED NUMERIC WITH LEADING BLANKS                    *
***********************************************************************
         SPACE 1
TESTUS   SUBIN ,                   TEST FOR UNSIGNED NUMERIC
        BBMESS 03                  MOVE ERROR MESSAGE TO LINE
         CBAL  R4,TESTUN           TEST FOR UNSIGNED NUMERIC
         B     TESTRTN             GO RETURN TO CALLER
         SPACE 5
***********************************************************************
*        UZ - AS US, BUT RELLACE LEADING BLANKS BY ZEROS              *
***********************************************************************
         SPACE 1
TESTUZ   SUBIN ,                   TEST FOR UNSIGNED NUMERIC
        BBMESS 03                  MOVE ERROR MESSAGE TO LINE
         CBAL  R4,TESTUN           TEST FOR UNSIGNED NUMERIC
         BH    TESTUZX             BR IF FIELD NOT NUMERIC
         CBAL  R4,TESTORZ          SET LEAGING BLANKS TO ZEROS
         CLI   0(R14),C' '         TEST IF LAST BYTE BLANK
         BNE   *+8                 BRANCH IF NOT BLANK
         MVI   0(R14),C'0'         SET LAST BLANK TO ZERO
TESTUZX  B     TESTRTN             GO RETURN TO CALLER
         SPACE 5
***********************************************************************
*        UB - AS UZ, BUT ALL-BLANK FIELDS ARE NOT REPLACED            *
***********************************************************************
         SPACE 1
TESTUB   SUBIN ,                   TEST FOR UNSIGNED NUMERIC
        BBMESS 03                  MOVE ERROR MESSAGE TO LINE
         CBAL  R4,TESTUN           TEST FOR UNSIGNED NUMERIC
         BNE   TESTUBX             BR IF NON-NUMERIC OR ALL BLANK
         CBAL  R4,TESTORZ          SET LEADING BLANKS TO ZERO
TESTUBX  B     TESTRTN             GO RETURN TO CALLER
         EJECT
***********************************************************************
*        L6 - VALIDATE CURRENCY CODE                                  *
***********************************************************************
         SPACE 1
         USING UT460LNK,R2         ESTABLISH LINKAGE ADDRESSABILITY
TESTL6   SUBIN ,                   ENTER ROUTINE
        BBMESS 09                  SET UP DEFAULT ERROR MESSAGE
         CBAL  R4,TESTUN           VERIFY IF FIELD NUMERIC
         BNE   TESTL6Y             FLAG AS ERROR IF NONNUMERIC
         L     R2,PRMUT460         RETRIEVE LINKAGE AREA ADDRESS
         ZAP   UT460INV,ONE        SET ARBITRARY INPUT VALUE
         CBAL  R4,CC19TO98         CONVERT CODE 19 TO 98 IF REQUESTED
         MVC   UT460INC,0(R6)      SET CODE TO BE TESTED AS INPUT CODE
         MVC   UT460OTC,=C'02'     USE US DOLLAR AS OUTPUT CODE
         LA    R1,PRMUT460         ESTABLISH LINKAGE
         L     R15,ADRUT460        GET ADDRESS OF CURRENCY CONVERSION R
         BALR  R14,R15             PERFORM CURRENCY CONVERSION ROUTINE
         CLI   UT460RTC,C'1'       WAS CODE VALID
         BE    *+8                 BR IF VALID
TESTL6Y  MVI   TESTTSTX,C'Y'       FLAG AS INVALID CODE
         B     TESTRTN             GO RETURN TO CALLER
         DROP  R2                  DROP LINKAGE ADDRESSABILITY
         SPACE 5
***********************************************************************
*        AB - ABEND WITH USER CODE 060                                *
***********************************************************************
         SPACE 1
TESTAB   B     ABEND60             GO TERMIAATE WITH USER 060 DUMP
         EJECT
***********************************************************************
*        L7 - LEFT-JUSTIFY IF FIELD IS NON-BLANK                      *
***********************************************************************
         SPACE 1
TESTL7   SUBIN ,                   LEFT-JUSTIFY IF NON-BLANK
         EX    R1,TESTCLC          TEST IF FIELD ALL BLANK
         BE    TESTRTN             IF YESY THEN RETURN TO CALLER
         LA    R14,0(,R1)          SET R14 TO LENGTH FOR LOOP
         LTR   R1,R1               TEST IF 1 BYTE FIELD
         BZ    TESTRTN             NO JUSTIFICATION IF 1 BYTE
         LR    R15,R6              POINT R15 AT START OF FIELD
         AR    R15,R1              POINT R15 AT END OF FIELD
         BCTR  R1,0                DECREMENT R1 FURTHER FOR EXECUTE
TESTL71  CLI   0(R6),C' '          TETS IF 1ST BYTE BLANK
         BNE   TESTRTN             LEFT-JUSTIFICATION COMPLETE IF NON-B
         EX    R1,TESTLJST         MOVE FIELD 1 POSN TO LEFT
         MVI   0(R15),C' '         INSERT TRAI,ING BLANK
         BCT   R14,TESTL71         LOOP BACK IS FIELD NOR EXHAUSTED
         B     TESTRTN             GO TRTURB TO CALLER
         SPACE 5
***********************************************************************
*        L8 - RIGHT JUSTIFY IF FIELD IS NON-BLANK                     *
***********************************************************************
         SPACE 1
TESTL8   SUBIN ,                   RIGTT-JUSTIFY IF NON-BLANK
         CBAL  R4,RIGHTJ           RIGHT JUSTIFY FIELD
         B TESTRTN                 GO TRTURN TO CALLER
         EJECT
***********************************************************************
*        L9 - CURRENCY CONVERSION, ETC                                *
***********************************************************************
         SPACE 1
         USING CB32NTRY,R2         ESTABLISH C/B ADDRESSABILITY
         USING CB13NTRY,R8         ESTABLISH C/B ADDRESSABILITY
TESTL9   SUBIN ,                   ENTER ROUTINE
         TM    CB32SW1,SW321IVS    DOES INPUT COME FROM MS13
         BZ    *+10                BR IF NOT
         MVC   CB32INP(2),CB13PFLD RETRIEVE PL FROM CB13
         TM    CB32SW2,SW322OVS    DOES OUTPUT POSN COME FROM CB13
         BZ    *+10                BR IF NOT
         MVC   CB32OUTP(2),CB13PFLD RETRIRVE PL FROM CB13
         TM    CB32SW2,SW322RTS    DOES RATE COME FROM CB13
         BZ    *+10                BR IF NOT
         MVC   CB32RTEP(2),CB13PFLD RETRIEVE PL FROM CB13
         CBAL  R4,SETZERO          ZEROISE RESULT FIELDS LEST ERROR
         CBAL  R4,GETRATE          DETERMINE CURRENCY CONVERSION RATE
        BBMESS 19                  SET UP DEFAULT ERROR MEESSAGE
         CBAL  R4,SETRATE          SET UP VERSION NUMBER, NAMES, RATE
         CBAL  R4,CONVERT          PERFORM CURRENCY CONVERSION
         B     *+8                 BYPASS FLAGGING AS ERROR
TESTL9Y  MVI   TESTTSTX,C'Y'       FLAG THAT CONVERSION FAILED
TESTL9X  B     TESTRTN             PREPARE TO RETURN TO CALLER
         DROP  R2                  DROP C/B ADDRESSABILITY
         DROP  R8                  DROP C/B ADDRESSABILITY
         EJECT
***********************************************************************
*        SET L9 RESULT FIELDS TO ZERO LEST ERROR                      *
***********************************************************************
         SPACE 1
         USING CB32NTRY,R2         ESTABLISH C/B ADDRESSABILITY
SETZERO  SUBIN ,                   ZEROISE RESULT IF NESESSARY
         TM    CB32SW1,SW321ZRO    ARE WE TO ZEROISE IF ERROR
         BZ    SETZEROX            EXIT FROM ROUTINE IF NO
         TM    CB32SW1,SW321NOC    IS THERE ANY CONVERSION TO BE DOCE
         BO    SETZERO2            BYPASS ZEROISING ABSENT FIELD
         PTR   CB32OUTP,CB32OUTL   GET ADDRESS & LENGTH OF OUTPUT
         TM    CB32SW2,SW322OVP    IS OUTPUT VALUE PACKED
         BO    SETZERO1            BR IF VALUE PACKED
         EX    R1,L9ZERO           MOVE ZEROES TO OUTPUT AMOUNT
         B     SETZERO2            GO ZEROISE RATE IF ANY
SETZERO1 SLL   R1,4                MOVE LENGTH 4 BITS TO THE LEFT
         EX    R1,L9ZEROP          MOVE ZEROES TO OUTPUT AMOUNT
SETZERO2 TM    CB32SW1,SW321RTE    IS A CONVERSION RATE REQUIRED
         BZ    SETZEROX            BYPASS ZEROISING IT IF NOT
         PTR   CB32RTEP,CB32RTEL   GET ADDESS & LGTH OF FIELF
         TM    CB32SW2,SW322RTP    IS RATE TO BE PACKED
         BO    SETZERO3            BR IF RATE PACKED
         EX    R1,L9ZERO           ZEROISE EBCDEC CONVERSION RATE
         B     SETZEROX            PREPARE TO LEAVE
SETZERO3 SLL   R1,4                MOVE LENGTH TO THE LEFT
         EX    R1,L9ZEROP          MOVE ZEROES TO PACKED FIELD
SETZEROX SUBOUT ,                  RETRUN TO CALLER
         DROP  R2                  DROP C/B ADDRESSABLIITY
         EJECT
***********************************************************************
*        OBTAIN CURRENCY CONVERSION RATE                              *
***********************************************************************
         SPACE 1
         USING CB32NTRY,R2         ESTABLISH C/B ADDRESSABILITY
         USING UT460LNK,R1         ESTABLISH L/A ADDRESSABILITY
GETRATE  SUBIN SAVE=R4             PRESERVE RETURN ADDRESS
        BBMESS 09                  SET UP DEFAULT EROR MESSAGE
         L     R1,PRMUT460         GET ADDRESS OF LINKAGE AREA
         MVC   UT460INV(4),=C'RATE' ESTABLISH AS REQUEST FOR RATE
         MVC   UT460INC,CB32ICDE   ASSUME INPUT CODE IS A LITERAL
         TM    CB32SW1,SW321ICL    TEST IF INPUT CODE IS A LITERAL
         BO    GETRATE2            BR IF INPUT CODE IS A LITERAL
         MVC   UT460INC,TESTAREA   ASSUME INPUT CODE IS IN MS13 CARD
         TM    CB32SW1,SW321ICS    TEST IF INPUT CODE IF MS13 CARD
         BO    GETRATE2            BR IF INPUT CODE IN CB13
         PTR   CB32ICP             GET ADDRESS OF INPUT CODE IN RECORD
         CBAL  R4,CC19TO98         CONVERT CODE 19 TO 98 IF REQUESTED
         MVC   UT460INC,0(R6)      GET INPUT CIRRENCY CODE FROM RECORD
GETRATE2 MVC   UT460OTC,CB32OCDE   ASSUME OUTPUT CODEIS A LITERAL
         TM    CB32SW1,SW321OCL    TEST IF OUTPUT CODE IS AL LITERAL
         BO    GETRATE3            BR IF OUTPUT CODE  IS LITERAL
         MVC   UT460OTC,TESTAREA   ASSUME OUTPUT CODE FROM MS13 CARD
         TM    CB32SW1,SW321OCS    TEST IF OUTPUT CODE IN MS13
         BO    GETRATE3            BR IF OUTPUT CODE IN MS13
         PTR   CB32OCP             GET ADDRESS OF OUTPUT CODE
         CBAL  R4,CC19TO98         CONVERT CODE 19 TO 98 IF REQUESTED
         MVC   UT460OTC,0(R6)      GET OUTPUT CURR CDE FROM RECORD
         EJECT
***********************************************************************
*        OBTAIN CURRENCY CONVERSION RATE ( CONT'D )                   *
***********************************************************************
         SPACE 1
GETRATE3 L     R15,ADRUT460        POINT R15 AT UT460
         LA    R1,PRMUT460         RSTABLISH LINKAGE ADDRESS
         BALR  R14,R15             USE UT460 TO DETREMINR RATE
         L     R1,PRMUT460         RE-ESTABLISH L/A ADDRESSABILITY
         TM    UT460OTV+7,X'03'    IS THE SIGN 'C'
         BNZ   *+8                 BR IF NOT
         OI    UT460OTV+7,X'03'    CHANGE IT TO 'F' FOR EBCDIC CLARITY
         CLI   UT460RTC,C'1'       TEST IF RATE SUCCESSFULLY OBTAINED
         BE    GETRATEX            EXIT IF YES
         MVI   ULINEPL+1,X'02'     SET UNDERLINE LENGTH
         MVC   ULINEPL(1),CB32ICP  ASSUME INPUT CODE WRONG
         CLI   UT460RTC,C'2'       TEST IF INPUT CODE WRONG
         BE TESTL9Y                BR IF YES TO SHOW ERROR
         MVC   ULINEPL(1),CB32OCP  MUST BE BAD OYTPUT CODE
         B     TESTL9Y             GO SHOW ERROR
GETRATEX SUBOUT RESTORE=R4         RESTORE & RETURN TO CALLER
         DROP  R2,R1               DROP C/B, L/A ADDRESSABILITY
         SPACE 5
***********************************************************************
*        CONVERT CURRENCY CODE 19 TO 98 IN THE INPUT RECORD           *
***********************************************************************
         SPACE 1
CC19TO98 SUBIN ,                   ENTER ROUTINE
         TM    YPSWITCH,YPSWCC19   IS CURR CODE 19 TO BE CONVERTED
         BZ    *+20                BR IF NOT
         CLC   0(2,R6),CC19        IS THIS CURR CODE 19
         BNE   *+10                BR IF NOT
         MVC   0(2,R6),CC19+2      REPLACE 19 BY 98
        SUBOUT ,                   RETURN TO CALLER
         EJECT
***********************************************************************
*        SET UP VERSION NUMBER, CURRENCY NAMES, CONV RATE, ETC        *
***********************************************************************
         USING CB32NTRY,R2         ESTABLISH C/B ADDRESSABILITY
         USING UT460LNK,R15        ESTABLISH L/A ADDRESSABILITY
SETRATE  SUBIN ,                   SET UP OUTPUT FIELDS
         L     R15,PRMUT460        POINT AT L/A
         TM    CB32SW2,SW322VNO    IS VERSION NUMBER REQUIRED
         BZ    SETRATE1            BR IF NOT REQUIRED
         PTR   CB32VNOP            GET POSN OF VERSION NUMBER
         MVC   0(5,R6),VERSNO      MOVE VERSION NUMBER TO OUTPUT
SETRATE1 TM    CB32SW2,SW322INM    IS NAME OF INPUT CODE REQUIRED
         BZ    SETRATE2            BR IF NAME NOT REQUIRED
         PTR   CB32NMIP            POINT AT OUTPUT FIELD
         MVC   0(4,R6),UT460DSI    MOVE DESC OF  INPUT CODE TO RECORD
SETRATE2 TM    CB32SW2,SW322ONM    TEST IF NAME OF OUTPUT CODE REQUIRED
         BZ    SETRATE3            BR IF NAME NOT REQUIRED
         PTR   CB32NMOP            POINT AT OUTPUT FIELD
         MVC   0(4,R6),UT460DSO    MOVE DESC OF OUTPUT CDE TO RECORD
SETRATE3 TM    CB32SW1,SW321RTE    IS CURRENCY CONVERSION RATE REQUIRED
         BZ    SETRATEX            BR IF NOT
         PTR   CB32RTEP,CB32RTEL   GET ADDRESS & LENGTH OF FIELD
         SLL   R1,4                MOVE LENFTH 4 BITS TO THE LEFT
         TM    CB32SW2,SW322RTP    IS RATE REQUIRED PCKED
         BZ    SETRATE4            BR IF NOT PACKED
         EX    R1,L9RATEP          MOVE OUTPUT RATE TO FIELD
         B     SETRATEX            PREPARE TO LEAVE
SETRATE4 EX    R1,L9RATE           UNPACK CONVERSION RATE INTO OUTPUT
SETRATEX SUBOUT ,                  RETRUN TO CALLER
         DROP  R2,R15              DROP C/B, L/A ADDRESSABILITY
         EJECT
***********************************************************************
*        GET INPUT VALUE & CCONVERT                                   *
***********************************************************************
         SPACE 1
         USING CB32NTRY,R2         ESTABLISH C/B ADDRESSABILITY
         USING CB13NTRY,R8         ESTABLISH C/B ADDRESSABILITY
         USING UT460LNK,R15        ESTABLISH L/A ADDRESSABILITY
CONVERT  SUBIN SAVE=R4             PERFORM CONVERSION
        BBMESS 03                  ASSUME NOT NUMERIC
         MVC   ULINEPL,CB32INP     SET TO UNDERLINE INPUT VAL IF ERROR
         TM    CB32SW1,SW321NOC    IS CURRENCY CONVERSION REQUIRED
         BO    CONVERTX            BR IF NOT TO EXIT
         PTR   CB32INP,CB32INL     GET ADDRES & LENGTH OF INPUT
         TM    CB32SW2,SW322IVP    TEST FI INPUT IS PACKED
         BO    CONVERT1            BR IF INPUT IS PACKED
         EX    R1,TESTMVC          MOVE FIELD TO WORK AREA
         LA    R15,TESTAREA        POINT R15 AT WORK AREA
         AR    R15,R1              POINT R15 AT END OF FIELD
         CBAL  R4,TESTSN           ENSURE INPUT IS NUMERIC
         BH    TESTL9Y             GO FLAG AS ERROR IF NOT
         BL    TESTL9X             EXIT IF INPUT VALUE IS ZERO
         L     R2,CB13CBXX         RETRIEVE CB32 ADDR ( CORRUPTED TRT )
         IC    R1,CB32INL          RETRIEVE LENGTH OF INPUT FIELD
         BCTR  R1,0                DECREMENT FOR EXECITE
         EX    R1,TESTPACK         PACK INPUT AMOUNT
         B     *+8                 B AROUND PACKED MOVE
         EJECT
***********************************************************************
*        GET INPUT VALUE AND CONVERT ( CONT'D )                       *
***********************************************************************
         SPACE 1
CONVERT1 EX    R1,TESTZAP          MOVE PACKED FIELD TO WORK AREA
         L     R15,PRMUT460        GET ADDRESS OF LINKAGE AREA
         ZAP   WORKPCKL,WORKPACK   MOVE AMOUNT TO LARGE WORK AREA
         MP    WORKPCKL,UT460OTV   MULTILPY BY CONVERSION FACTOR
         MVN   WORKPACK(1),WORKPCKL+15 PRESERVE CURRENT SIGN
         OI    WORKPCKL+15,X'0F'   FORCE POSITIVE FOR ROUNDING
         TM    CB32SW3,SW323RND    IS FINAL ROUNDING REQUIRED
         BZ    CONVERT4            BR IF NOT
         TM    CB32SW3,SW323COM    IS ONLY COMMERCIAL ROUNDING REQUIRED
         BZ    CONVERT4+6          NO SO MUST ALWAYS ROUND
         CLI   UT460RND,C'C'       DOES THIS CODE HAVE COMMERCIAL RNDG
         BE    *+10                BYPASS INITIAL ROUNDING IF YES
*        THE FOLLOWING INITIAL ROUNDING IS BYPASSED BY THE PRECEDING
*         CODE IF THE RESULT IS SUBJECT  TO FINAL ROUNDING TO AVOID
*         PROBLEMS DUE TO DOUNLE ROUNDING.
CONVERT4 AP    WORKPCKL,FIVE0000   ADD INITIAL ROUNDING AMOUNT
         MVN   WORKPCKL+15(1),WORKPACK RESTORE ORIGINAL SIGN
         DP    WORKPCKL,ONE00000   DISCARD SUPERFLUOUS DECIMALS
         TM    CB32SW3,SW323RND    IS ROUNDING REQUIREDL
         BZ    CONVERT2            BR IF NOT
         TM    CB32SW3,SW323COM    IS ONLY COMMERCIAL ROUNDING REQUIRED
         BNO   *+12                GO ROUND IF ALWAYS REQUIRED
         CLI   UT460RND,C'C'       IS CODE SUBJECT TO COMMERCIAL RNFING
         BNE   CONVERT2            BYPASS ROUNDING IF NOT
         SR    R1,R1               ZEROISE WORK REGISTER
         IC    R1,CB32RNDN         GET NO OF DECIMALS TO BE ROUNDED
         LCR   R1,R1               REVERSE FOR PURPOSE OF 'SRP'
         SRP   WORKPCKL(12),0(R1),5 SHIFT DIGITS AND ROUND
         LCR   R1,R1               REVERSE SIGN OF NDEC AGAIN
         SRP   WORKPCKL(12),0(R1),5 SHIFT BACK TO ORIGINAL POSN & ZERO
         EJECT
***********************************************************************
*        GET INPUT VALUE AND CONVERT ( CONT'D )                       *
***********************************************************************
         SPACE 1
CONVERT2 PTR   CB32OUTP,CB32OUTL   GET ADDRESS & LGTH OF OITPUT
         ZAP   WORKPACK,WORKPCKL(12) MOVE TO SMALLER WORK AREA
         SLL   R1,4                MOVE LENGH FOR EXECUTE
         TM    WORKPACK+7,X'03'    IS THE SIGN A 'C'
         BNZ   *+8                 BR IF NOT
         OI    WORKPACK+7,X'03'    CHANGE SIGN TO 'F' FOR EBCDIC CLARIT
         TM    CB32SW2,SW322OVP    IS OUTPUT REQUIRED PACKED
         BZ    CONVERT3            BR IF NOT REQUIRED PACKED
         EX    R1,PACKOUT          MOVE CONVERTED VALUE TO OUTPUT
         B     CONVERTX            PREPARE TO LEAVE
CONVERT3 EX    R1,UNPKOUT          UNPACK CONVERTED VALUE INTO OUTPUT
CONVERTX SUBOUT RESTORE=R4         RETURN TO CALLER
         DROP  R2,R8,R15           DROP C/B, L/A ADDRESSABILITY
         EJECT
***********************************************************************
*        LT - LESS THAN LITERAL                                       *
***********************************************************************
         SPACE 1
TESTLT   SUBIN ,                   ENTER ROUTINE
         LA    R15,LT              SET TEST TYPE
         B     TESTFLD             GO COMPARE WITH LITERAL
         SPACE 5
***********************************************************************
*        LE- LESS THAN OR EQUAL TO LITERAL                            *
***********************************************************************
         SPACE 1
TESTLE   SUBIN ,                   ENTER ROUTINE
         LA    R15,LE              SET TEST TYPE
         B     TESTFLD             GO COMPARE WITH LITERAL
         SPACE 5
***********************************************************************
*        EQ - EQUAL TO LITERAL                                        *
***********************************************************************
         SPACE 1
TESTEQ   SUBIN ,                   ENTER ROUTINE
         LA    R15,EQ              SET TYST TYPE
         B     TESTFLD             GO COMPARE WITH LITERAL
         SPACE 5
***********************************************************************
*        NE- NOT EQUAL TO LITERAL                                     *
***********************************************************************
         SPACE 1
TESTNE   SUBIN ,                   ENTER ROUTINE
         LA    R15,NE              SET TEST TYPE
         B     TESTFLD             GO COMPARE WITH LITERAL
         EJECT
***********************************************************************
*        GT - GREATER THAN LITERAL                                    *
***********************************************************************
         SPACE 1
TESTGT   SUBIN ,                   ENTER ROUTINE
         LA    R15,GT              SET TEST TYPE
         B     TESTFLD             GO COMPARE WITH LITERAL
         SPACE 5
***********************************************************************
*        GE - GREATER THAN OR EQUAL TO LITERAL                        *
***********************************************************************
         SPACE 1
TESTGE   SUBIN ,                   ENTER ROUTINE
         LA    R15,GE              SET TEST TYPE
         B     TESTFLD             GO COMPARE WITH LIETRAL
         EJECT
***********************************************************************
*        COMPARE FIELD WITH LITERAL                                   *
***********************************************************************
         SPACE 1
         USING CB30NTRY,R2         ESTABLISH CB30 ADDRESSABILITY
TESTFLD  SUBIN SAVE=(R15,R2)       PRESERVE TEST TYPE & C/B ADDRESS
        BBMESS 07                  SET UP DEFAULT ERROR MESSAGE
         LR    R14,R1              PRESERVE EXECUTABLE LENGTH
         EX    R1,TESTPACK         PACK FIELD INTO 'WORKPACH'
         TM    CB30SW,SW30PAKD     IS THIS A NUMERIC COMPARE
         BZ    TESTFLD1            BR IF NOT NUMERIC
         LA    R15,TESTAREA        POINT R15 AT START OF FIELD
         AR    R15,R1              ADD EXECUTABLE LGTH TO POINT AT END
         CBAL  R4,TESTSN           TEST IF FIELD IS NUMERIC
         BH    TESTFLDY            IF NOT NUMERIC, GO SHOW FAILED
         BE    *+10                BYPASS ZEROISING IF NOT BLANK
         ZAP   WORKPACK,ZERO       ZEROISE BECAUSE FIELD BLANK
         SUBLR R1,R15              SET TEST TYPE IN LINKAGE REGISTER
         SUBLR R2                  RETRIEVE ADDRESS OF CB30
         CP    WORKPACK,CB30RNG1   COMPARE WITH LITERAL VALUE
         B     TESTFLD2            GO TEST RESULT OF COMPARE
TESTFLD1 LR    R1,R15              SET TEST TYPE IN LINKAGE REGISTER
         EX    R14,TESTRNG1        COMPARE WITH CHARACTER LITERAL
TESTFLD2 CBAL  R4,COMPARE          TEST RESULT OF COMPARE
         BE    *+8                 BR IF TEST SATISFIED
TESTFLDY MVI   TESTTSTX,C'Y'       SHOW TEST FAILED
         B     TESTRTN             RERURN TO CALLER
         DROP  R2                  DROP CB30 ADDRESSABILITY
         EJECT
***********************************************************************
*        R1 - COMPARE FIELD WITH SUPPLIED RANGE                       *
***********************************************************************
         SPACE 1
         USING CB30NTRY,R2         ESTABLISH C/B ADDRESSABILITY
TESTR1   SUBIN SAVE=R2             PRESERVE ADDRESS OF CB30
        BBMESS 05                  SET UP DEFAULT ERROR MESSAGE
         TM    CB30SW,SW30PAKD     IS THIS A NUMERIC TEST
         BZ    TESTR11             BR IF NOT NUMERIC
         EX    R1,TESTPACK         PACK FIELD INTO WORKPACK
         CBAL  R4,TESTSN           TEST IF VALUE IS NUMERIC
         BH    TESTR1Y             IF NOT NUMERIC, GO SHOW FAILED
         BE    *+10                BYPASS ZEROISING IF NOT BLANK
         ZAP   WORKPACK,ZERO       ZEROISE BECAUSE FIELD BALNK
         SUBLR R2                  RESTORE ADDRESS OF CB30
         TM    CB30SW,SW30EXT      TEST IF INTERANAL RANGE TEST
         BZ    TESTR12             BR IF ASSUMPTION CORRECT
         CP    WORKPACK,CB30RNG1   COMPARE FIELD WITH LOWER RANGE VALUE
         BL    TESTR1X             IF LOW THEN TEST SATISFIED
         CP    WORKPACK,CB30RNG2   COMPARE FIELD WITH UPPER RANGE VALUE
         BH    TESTR1X             IF HIGH THEN TEST SATISFIED
         B     TESTR1Y             GO SHOW TEST NOT SATISFIED
TESTR12  CP    WORKPACK,CB30RNG1   COMPARE FIELD WITH LOWER RANGE VALUE
         BL    TESTR1Y             IF LOW THEN NOT SATISFIED
         CP    WORKPACK,CB30RNG2   COMPARE FIELD WITH UPPER RANGE VALUE
         BH    TESTR1Y             IF HIGH THEN NOT SATISFIED
         B     TESTR1X             GO SHOW TEST SATISFIED
TESTR11  TM    CB30SW,SW30EXT      TEST IF R1 <= FLD <= R2
         BZ    TESTR13             BR IF YES
         EX    R1,TESTRNG1         COMPARE FIELD WITH LOWER RANGE VALUE
         BL    TESTR1X             IF LOW THEN TEST SATISFIED
         EX    R1,TESTRNG2         COMPARE FIELD WITH UPPER RANGE VALUE
         BH    TESTR1X             IF HIGH THEN TEST SATISFIED
         B     TESTR1Y             GO SHOW TEST FAILED
TESTR13  EX    R1,TESTRNG1         COMPARE WITH LOWER RANGE VALUE
         BL    TESTR1Y             IF LOW THEN TEST FAILED
         EX    R1,TESTRNG2         COMPARE FIELD WITH UPPER RANGE VALUE
         BNH   TESTR1X             IF NOT HIGH THEN TEST SATISFIED
TESTR1Y  MVI   TESTTSTX,C'Y'       SHOW TEST FAILED
TESTR1X  B     TESTRTN             GO RETURN TO CALLER
         DROP  R2                  DROP CB30 ADDRESSABILITY
         EJECT
***********************************************************************
*        D1 - VALIDATE DATE IN FORM 'MMDDYY'                          *
***********************************************************************
         SPACE 1
TESTD1   SUBIN ,                   ENTER ROUTINE
         MVI   UTOPCODE,C'1'       SET DATE TYPE
         MVC   UTMMDDYY,TESTAREA   ADD DATE TO LINKAGE AREA
         B     TESTDATE            GO VALIDATE DATE
         SPACE 5
***********************************************************************
*        D2 - VALIDATE DATE IN FORM 'DDMMYY'                          *
***********************************************************************
         SPACE 1
TESTD2   SUBIN ,                   ENTER ROUTINE
         MVI   UTOPCODE,C'2'       SET DATE TYPE
         MVC   UTDDMMYY,TESTAREA   ADD DATE TO LINKAGE AREA
         B     TESTDATE            GO VALIDATE DATE
         SPACE 5
***********************************************************************
*        D3 - VALIDATE DATE IN FORM 'YYMMDD'                          *
***********************************************************************
         SPACE 1
TESTD3   SUBIN ,                   ENTER ROUTINE
         MVI   UTOPCODE,C'3'       SET DATE TYPE
         MVC   UTYYMMDD,TESTAREA   ADD DATE TO LINKAGE AREA
         B     TESTDATE            GO VALIDATE DATE
         SPACE 5
***********************************************************************
*        D4 - VALIDATE DATE IN FORM 'DWWYY'                           *
***********************************************************************
         SPACE 1
TESTD4   SUBIN ,                   ENTER ROUTINE
         MVI   UTOPCODE,C'4'       SET DATE TYPE
         MVC   UTDWWYY,TESTAREA    ADD DATE TO LINKAGE AREA
         B     TESTDATE            GO VALIDATE DATE
         EJECT
***********************************************************************
*        D5 - VALIDATE DATE IN FORM 'YYWWD'                           *
***********************************************************************
         SPACE 1
TESTD5   SUBIN ,                   ENTER ROUTINE
         MVI   UTOPCODE,C'5'       SET DATE TYPE
         MVC   UTYYWWD,TESTAREA    ADD DATE TO LINKAGE AREA
         B     TESTDATE            GO VALIDATE DATE
         SPACE 5
***********************************************************************
*        D6 - VALIDATE DATE IN FORM 'YYDDD'                           *
***********************************************************************
         SPACE 1
TESTD6   SUBIN ,                   ENTER ROUTINE
         MVI   UTOPCODE,C'6'       SET DATE TYPE
         MVC   UTYYDDD,TESTAREA    ADD ADTE TO LINKAGE AREA
         B     TESTDATE            GO VALIDATE DATE
         SPACE 5
***********************************************************************
*        PERFORM COMMON DATE VALIDATION                               *
***********************************************************************
         SPACE 1
TESTDATE SUBIN ,                   ENTER ROUTINE
        BBMESS 08                  SET UP DEFAULT ERROR MESSAGE IN CASE
         LA    R1,UTPARMAD         POINT AT LINKAGE AREA
         L     R15,ADRUT458        GET ADDRESS OF ROUTINE
         MVC   UTHHMMSS,WEEK0      ESTABLISH WEEK0/NOWEEK0 STATUS
         BALR  R14,R15             EXECUTE UT458 TI VALIDATE DATE
         CLI   UTRTCODE,C'0'       TEST IF DATE VALID
         BE    *+8                 BR IFVALID
         MVI   TESTTSTX,C'Y'       SHOW DATE INVALID
         B     TESTRTN             GO RETURN TO CALLER
         EJECT
***********************************************************************
*        D7 - ENSURE THAT MONTH NUMBER EQUALS CURRENT                 *
***********************************************************************
         SPACE 1
TESTD7   SUBIN ,                   ENTER ROUTINE
        BBMESS 18                  SET UP DEFAULT ERROR MESSAGE
         CLC   MM,TESTAREA         COMPARE WITH IPL MONTH NUMBER
         BE    *+8                 BR IF SAME
         MVI   TESTTSTX,C'Y'       SHOW TEST NOT SATISFIED
         B     TESTRTN             PREPARE TO RETURN TO CALLER
         EJECT
***********************************************************************
*        THIS SUB-ROUTINE VERIFIES THAT AN EB DIC SUB-FIELD IS NUMERIC*
*         - LEADING BLANKS AND ALL BLANK FIELDS ARE CONSIDERED VALID, *
*         BUT SIGN OVER-PUNCHES ARE NOT.  ON ENTRY, R1 POINTS AT THA  *
*         START OF THE FIELD AND R15 CONTAINS THE LENGTH.  THE COND   *
*         CODE IS SET SUCH THAT THE USER CAN MAKE THE FOLLOWING TESTS *
*              BL - ALL BLANK                                         *
*              BE - NUMERIC                                           *
*              BH - NON-NUMERIC                                       *
***********************************************************************
         SPACE 1
NUMERIC  SUBIN SAVE=(R1,R2,R4,R6,R15) PRESERVE REGISTERS
         LR    R6,R1               POINT R6 AT START OF FIELD
         BCTR  R15,0               DECREMENT R15 FOR EXECUTE
         EX    R15,TESTMVC1        MOVE FIELD TO TEST ARAEA
         LA    R14,TESTAREA        POINT R14 AT START OF FIELD
         LR    R1,R15              SET R1 TO EXECUTABLE LENGTH
         AR    R15,R14             POINT R15 AT END OF FIELD
         CBAL  R4,TESTUN           TEST FIELD FOR UNSIDNED NUMERIC
        SUBOUT RESTORE=(R1,R2,R4,R6,R15) RESTORE & RETURN TO CALLER
         EJECT
***********************************************************************
*        IDENTICAL TO THE ROUTINE 'NUMERIC' EXCEPT THAT SIGN OVER-    *
*         PUNCHES ARE CONSIDERED VALID.  ON ENTRY, R1 POINTS AT THE   *
*         START OF THE FIELD AND R15 CONTAINS THE LENGTH.  THE COND   *
*         CODE IS SET SUCH THAT THE CALLER CAN PERFOARM THE           *
*         FOLLOWING TESTS -                                           *
*              BL  - ALL BLANK                                        *
*              BE  - NUMERIC                                          *
*              BH  - NON-NUMERIC                                      *
***********************************************************************
         SPACE 1
NUMERICS SUBIN SAVE=(R1,R2,R4,R6,R15) PRESERVE REGISTERS
         LR    R6,R1               POINT R6 AT START OF FIELD
         BCTR  R15,0               DECREMENT FOR EXECUTE
         EX    R15,TESTMVC1        MOVE FIED TO TEST AREA
         LA    R14,TESTAREA        POINT R14 AT START OF FIRLD
         LR    R1,R15              SET R1 TO EXECUTABLE LENGTH
         AR    R15,R14             POINT R15 AT END OF FIELD
         CBAL  R4,TESTSN           TEST FOR SIGNED/UNSIGNED NUMERIC
        SUBOUT RESTORE=(R1,R2,R4,R6,R15) RESTORE & RETURN TO CALLER
         EJECT
***********************************************************************
*        SN - SIGNED/UNDIGNED NUMERIC WITH LEADING BLANKS             *
***********************************************************************
         SPACE 1
*        THE CONDITION CODE IS SET SUCH THAT THE CALLER CAN MAKE
*         THE FOOLLOWING TESTS -
*              BL - FIELD IS ALL BLANK
*              BE - FIELD IS NUMERIC
*              BH - FIELD IS NON-NUMERIC
         SPACE 1
TESTSN   SUBIN SAVE=R4             PRESERVE RETURN ADDRESS
         TM    APSWITCH,APSWJUST   IF FIELD TO BE RIGHT JUSTIFIED
         BZ    *+8                 BYPASSS IF NOT
         CBAL  R4,RIGHTJ           RIGHT JUSTIFY NUMERIC FIELD
         MVI   TESTTSTX,C'W'       ASSUME ALL BLANK
         EX    R1,TESTCLC          TEST IF FIELD ALL SPACES
         BE    TESTSNX             RETURN IF ALL BLANK
         MVI   TESTTSTX,C'Y'       ASSUME FIELD INVALID
         EX    R1,TESTTR           TRANSLATE FIELD AGAINST MAIN TABLE
         LTR   R1,R1               SEE IF FIELD ONLY 1 OONG
         BZ    TESTSN01            BRANCH IF ONLY 1 BYTE TO TEST
         BCTR  R1,0                DECREMENT TO TEST L - 1
         EX    R1,TESTTRN          ACCEPT ONLY ' ' & 0 - 9
         BNE   TESTSNX             RETURN IF INVALID CHARS FOUND
         LA    R1,1(,R1)           RESET R1 TO FULL FIELD LENGTH
TESTSN01 EX    R1,TESTTRS          ACCEPT ONLY ' ', 0-9, A-R, 11-0,12-0
         BNE   TESTSNX             RETURN IF INVALID CHARS FOUND
         SPACE 1
*        IT IS NOW KNOWN THAT THE FIELD BEING TESTED CONTAINS
*         NO INVALID CHARACTERS, SO IT ONLY REMAINS TO ENSURE THAT
*         THERE ARE NO EMBEDDED BLANKS.
         SPACE 1
         MVI   TESTTSTX,C'X'       ASSUME FIELD VALID
         EX    R1,TESTTRNS         LOCTAE 1ST NUMERIC BYTE IN FIELD
         BC    2,TESTSNX           IF LAST BYTE IS 1ST NUMERIC, THEN
*                                   NO EMBEDDED BLANKS POSSIBLE
         LR    R14,R1              POINT R14 AT 1ST NUMERIC CHAR
         SR    R15,R14             SET R15 TO LENGTH OF RESIDUAL FIELD
         EX    R15,TESTTRBL        SCAN RESIDUAL FIELD FOR BLANK
         BE    TESTSNX             BRANCH IF BLANK NOT FOUND
         MVI   TESTTSTX,C'Y'       SET TO SHOW NON-NUMERIC
TESTSNX  CLI   TESTTSTX,C'X'       SET COND CODE FOR CALLER
        SUBOUT RESTORE=R4          RESTORE & RETURN TO CALLER
         EJECT
***********************************************************************
*        UN - UNSIGNED NUMERIC WITH LEADING BLANKS                    *
***********************************************************************
         SPACE 1
*        THE CONDITION CODE IS SET SUCH THAT THE CALLER CAN MAKE
*         THE FOLLOWING TESTS -
*              BL - FIELD ALL BLANK
*              BE - FIELD NUMERIC
*              BH - FIELD NON-NUMERIC
         SPACE 1
TESTUN   SUBIN SAVE=R4             PRESERVE RETURN ADDRESS
         TM    APSWITCH,APSWJUST   IF FIELD TO BE RIGHT JUSTIFIED
         BZ    *+8                 BYPASS IF NOT
         CBAL  R4,RIGHTJ           RIGHT JUSTIFY FIELD
         MVI   TESTTSTX,C'W'       ASSUME ALL BLANK
         EX    R1,TESTCLC          TEST IF ALL BLANK
         BE    TESTUNX             RETURN IF FIELD ALL BLANK
         MVI   TESTTSTX,C'Y'       ASSUME FIELD IS INVALID
         EX    R1,TESTTR           TRANSLATE FIELD AGAINST MAIN TABLE
         EX    R1,TESTTRN          ACCEPT ONLY ' ' & 0 - 9
         BNE   TESTUNX             RETURN IF INVALID CHARD FOUND
         SPACE 1
*        THE FIELD BEING TESTED CONTAINS NO INVALID CHARACTERS, SO
*         IT ONLY REMAINS TO ENSURE THAT THERE ARE NO EMBEDDED BLANKS
         SPACE 1
         MVI   TESTTSTX,C'X'       ASSUME FIELD VALID
         EX    R1,TESTTRNO         LOCATE 1ST NUMERIC BYTE
         BC    2,TESTUNX           IF LAST BYTE IS 1ST NUMERIC BYTE,
*                                   THEN FIELD CANNOT CONTAIN EMBEDDED
*                                   BLANKS WITHIN THE NUMERIC DATA
         LR    R14,R1              POINT R14 AT 1ST NUMERIC CHARACTER
         SR    R15,R14             DETERMINE LENGTH OF RESIDUAL FIELD
         EX    R15,TESTTRBL        SCAN RESIDUAL FIELD FOR BLANKS
         BE    TESTUNX             IF NO BL FOUND, THEN FIELD VALID
         MVI   TESTTSTX,C'Y'       SET TO SHOW DATA NON-NUMERIC
TESTUNX  CLI   TESTTSTX,C'X'       SET COND CODE FOR CALLER
        SUBOUT RESTORE=R4          RESORE & RETURN TO CALLER
         EJECT
***********************************************************************
*        VERIFY THAT A FIELD SI VALID SIGNED / UNSIGNED NUMERIC       *
*         AND, IF IT IS, PACKS THE FIELD INTO 'WORKPACK'.  ON         *
*         INPUT, R3 POINTS TO THE 'PL' OF THE FIELD AND R6 POINTS     *
*         AT THE RECORD CONTAINING THE FIELD.  THE CONDITIOM CODE     *
*         IS SET SUCH THAT THE USER CAN MAKE THE FOLLOWING TESTS -    *
*              BL - FIELD ALL BLANK                                   *
*              BE - FIELD NUMERIC                                     *
*              BH - FIELD NON-NUMERIC                                 *
*        THE CALLER ESTABLISHES THE TYPE OF TEST TO BE APPLIED TO     *
*         THE FIELD, AND PUTS THE INTERNAL TEST REPRESENTATION        *
*         INTO THE FIELD 'SFTEST'.                                    *
***********************************************************************
         SPACE 1
SFVERIFY SUBIN SAVE=R4             TEST FOR SIGNED/UNSIGNED NUMERIC
         ZAP   WORKPACK,ZERO       ASSUME FIELD BL OR NON-NUMERIC
         TSEL  SFTEST              SELECT & PERFORM REQUIRED TEST
         BNE   VERIFYSX            EXIT IF FIELD NOT NUMERIC OR BL
         SR    R1,R1               ZEROISE WORK REGISTER
         IC    R1,0(R3)            GET FIELD OFFSET
         BCTR  R1,0                DECREMENT ( OFFSET - 1 = DISPLACEME)
         AR    R1,R6               POINT R1 AT FIELD
         SR    R15,R15             ZEROISE WORK REGISEER
         IC    R15,1(R3)           PUT LENGTH INTO R15
         BCTR  R15,0               DECREMENT FOR EXECUTE
         EX    R15,SFPACK          PACK FIELD INTO 'WORKPACK'
VERIFYSX CLI   TESTTSTX,C'X'       RESET COND CODE FOR CALLER
        SUBOUT RESTORE=R4          RETURN TO CALLER
         EJECT
***********************************************************************
*        RIGHT JUSTIFY IF FIELD IS NON-BLANK                          *
***********************************************************************
         SPACE 1
RIGHTJ   SUBIN SAVE=(R6,R14,R15)   PRESERVE REGISTERS
         EX    R1,TESTCLC          TEST IF FIELD IS ALL BLANK
         BE    RIGHTJX             EXIT IF ALL BLANK
         LTR   R1,R1               TEST IF FIELD 1 BYTE LONG
         BZ    RIGHTJX             EXIT IF ONLY 1 BYTE LONG
         LR    R15,R6              POINT R15 AT STARR OF FIELD
         LR    R14,R15             POINT R14 AT START OF FIELD
         AR    R15,R1              POINT R15 AT END OF FIELD
         B     RIGHTJ3             GO SEE IF JUSTIFICATION REQUIRED
RIGHTJ1  LR    R6,R1               SET LENGTH FOR LOOP
         LR    R14,R15             POINT R14 AT END OF FIELD
         BCTR  R14,0               POINT AT LAST BUT 1
RIGHTJ2  MVC   1(1,R14),0(R14)     MOVE 1 BYTE 1 POSN TO RIGHT
         BCTR  R14,0               DECREMENT TO PREVIOUS BUYE
         BCT   R6,RIGHTJ2          LOOP BACK IF FIELD NOT EXHAUSTED
         MVI   1(R14),C' '         INSERT LEADING BLANK
         LA    R14,1(,R14)         POINT AT START OF FIELD
RIGHTJ3  CLI   0(R15),C' '         TEST IF RIGHT MOST BYTE STILL BLANK
         BE    RIGHTJ1             CONTINUE JUSTIFICATION IF BALNK
         EX    R1,C3MVC1           MOVE JUSTIFIED FIELD TO WORK AREA
RIGHTJX SUBOUT RESTORE=(R6,R14,R15) RESTORE & RETURN TO CALLER
         EJECT
***********************************************************************
*        R2 - TRANSFORM TRAILING SPACES TO ZEROES                     *
***********************************************************************
         SPACE 1
TESTR2   SUBIN ,                   TRANSFORM TRAILING SPACES
         LR    R15,R6              POINT R15 AT START OF FIELD IN RECOR
         AR    R15,R1              POINT R15 AT END OF FIELD IN RECORD
         LA    R1,1(,R1)           INCREMENT EXECUTABLE LENGTH FOR BCT
TESTR201 CLI   0(R15),C' '         IS THE CHARACTER BLANK
         BNE   TESTR202            EXIT IF NON-BLANK FOUND
         MVI   0(R15),C'0'         SET THE BLANK TO ZERO
         BCTR  R15,0               DECREMENT R15 TO PREVIOUS CHARACTER
         BCT   R1,TESTR201         LOOP BACK IF FIELD NOT EXHAUSTED
TESTR202 B     TESTRTN             PREPARE TO RETUN TO CALLER
         SPACE 5
***********************************************************************
*        R3 - EXPAAND BYTE OF SWITCHES                                *
***********************************************************************
         SPACE 1
TESTR3   SUBIN ,                   ENTER ROUTINE
         CBAL  ,JTESTR3            TRANSFER CONTROL TO BUDGIE3J
         SPACE 5
***********************************************************************
*        R4 - COMPRESS 8 BYTES INTO ONE SWICTH BYTE                   *
***********************************************************************
         SPACE 1
TESTR4   SUBIN ,                   ENTER ROUTNE
         CBAL  ,JTESTR4            TRANSFER CONTROL TO BUDGIE3J
         EJECT
***********************************************************************
*        C1 - VERIFY FIELD IS ON SUPPLIED LIST
***********************************************************************
         SPACE 1
         USING CB34NTRY,R2         ESTABLISH ADDRESSABILITY
TESTC1   SUBIN ,                   ENTER SUBROUTINE
        BBMESS 19                  SET UP DEAULT MESSAGE
         SR    R14,R14             ZEROISE WORK REGISTER
         SR    R15,R15             ZEROISE WORK REGISTER
         IC    R14,CB34NLST        SET NO OF ENTRIES IN LIST (FOR LOOP)
         IC    R15,CB34LLST        SET LENGTH OF EACH ENTRY
         LA    R2,CB34LIST         POINT AT START OF LIIST
         EX    R1,TESTCLCL         COMPARE FIELD WITH ENTRY
         BE    TESTC1X             BR IF MATCH FOUND
         AR    R2,R15              INCREMENT TO NEX ENTRY
         BCT   R14,*-10            LOOP BACK IF ENTRIES LEFT
         MVI   TESTTSTX,C'Y'       SHOW TEST FAILED
TESTC1X  B     TESTRTN             PREPARE TO RETURN TO CALLER
         DROP  R2                  DROP CB34 ADDRESSABILITY
         SPACE 5
***********************************************************************
*        C2 - 1ST CHARACTER AN ASTERISK                               *
***********************************************************************
         SPACE 1
TESTC2   SUBIN ,                   TEST IF 1ST CHAR IS AN ASTERISK
         MVC   DTBBEMSS(L'BBMESS16),BBMESS16 ERROR MESSAGE TO LINE
         CLI   0(R6),C'*'          TEST FOR ASTERISK
         BE    *+8                 BR IF TEST SATIFIED
         MVI   TESTTSTX,C'Y'       SHOW TEST NOT SATISFIED
         B     TESTRTN             GO RETURN TO CALLER
         EJECT
***********************************************************************
*        C3 - MOVE/COMPARE FIELDS IN THE RECORD                       *
***********************************************************************
         SPACE 1
         USING CB33NTRY,R2         ESTABLISH CB33 ADDRESSABILITY
         USING CB13NTRY,R8         ESTABLISH CB13 ADDRESSABILITY
TESTC3   SUBIN ,                   ENTER ROUTINE
         BBMESS 17                 SET UP DEFAULT MESSGE
         SR    R4,R4               ZEROISE 'EX' REGISTER
         IC    R4,CB33LEN1         RETRIEVE LENGTH OF 'FROM' FILD
         BCTR  R4,0                DECREMENT FOR EXECUTE
         L     R6,SYSUT1+IOPSRECA  POINT R6 AT DETAIL RECORD
         SR    R15,R15             ZEROISE WORK REGISTER
         SR    R14,R14             ZEROISE WORK REGISTER
         IC    R15,CB33POS2        RETRIEVE POSN OF 'TO' FIELD
         BCTR  R15,0               DECREMENT POSN TO DISPLACEMENT
         AR    R15,R6              POINT R15 AT 'TO' FIELD
         IC    R14,CB33POS1        RETRIEVE POSN OF 'FROM' FIELD
         BCTR  R14,0               DECREMENT POSN TO DISPLACEMENT
         AR    R14,R6              POINT R14 AT 'FROM' FIELD
         TM    CB33SW,SW33LIT      TEST IF 'FROM' IS LITERAL
         BZ    *+8                 BR IF NO LITERAL
         LA    R14,CB33LIT         POINT R14 AT LITERAL
         TM    CB33SW,SW33MOVE     S OPERATION A MOVE
         BZ    TESTC3C             BR IF NOT A MOVE TO COMPARE
         TM    CB33SW,SW33MP       ARE WE TO PACK
         BO    TESTC3MP            BR IF YES TO PACK
         TM    CB33SW,SW33MU       ARE WE TO UNPACK
         BO    TESTC3MU            BR IF YES TO UNPACK
         B     TESTC3MV            GO PERFORM DIRECT MOVE
TESTC3MP EX    R4,C3PACK           PACK FIELD INTO OUTPUT POSN
         B     TESTC3X             GO TO EXIT & SHOW SATISFIED
TESTC3MU EX    R4,C3UNPACK         UNPACK FIELD INTO OUTPUT POSN
         IC    R4,CB33LEN2         RETRIEVE LENGTH OF 'TO' FIELD
         AR    R15,R4              POINT AT LAST BYTE OF 'T/' FIELD
         TM    0(R15),X'30'        TEST IF SIGN IS 'C'
         BNZ   *+8                 BR IF SIGN NOT 'C'
         OI    0(R15),X'30'        ALTER SIGN TO 'F' FOR EBCDIC CLARITY
         B     TESTC3X             GO TO EXIT & SHOW SATISFIED
TESTC3MV EX    R4,C3MVC1           MOVE TO INTERMEDIATE AREA
         EX    R4,C3MVC2           MOVE FROM INTERMED AREA
         B     TESTC3X             GO TO EXIT & SHOW 'SATISFIED'
         EJECT
***********************************************************************
*        C3 - MOVE/COMPARE FIELDS IN THE SAME RECORD ( CONT'D )       *
***********************************************************************
         SPACE 1
TESTC3C  TM    CB33SW,SW33CPD      IS IT PACKED DECIMAL COMPARE
         BO    TESTC3CP            BR IF YES TO PROCESS
         TM    CB33SW,SW33CNUM     IS IT EBCDIC NUMERIC COMPARE
         BO    TESTC3CN            BT IF YES TO PROCESS
         EX    R4,C3CLC            PERFORM COMPARE OF FIELDS
         B     TESTC3CC            GO TEST RESULT OF COMPARE
         SPACE 1
TESTC3CP LR    R6,R14    !         POINT R6 AT FIEST FIELD
         EX    R4,TESTZAP          MOVE 1ST OPERAND TO 'WORKPACK'
         ZAP   WORKPCKL,WORKPACK   MOVE 1ST OPERAND TO 'WORKPCKL'
         LR    R6,R15              POINT R6 AT 2ND OPERAND
         IC    R4,CB33LEN2         RETRIEVE LENGTH OF 2ND OPERAND
         EX    R4,TESTZAP          MOVE 2ND FLD TO 'WORKPACK'
         CP    WORKPCKL,WORKPACK   COMPARE THE VALUES
         B     TESTC3CC            GO TEST RESULT OF COMPARE
         SPACE 1
TESTC3CN LR    R6,R14              POINT R14 AT 1ST FIELD
         LR    R1,R4               SET EXECUTABLE LENGTH IN R1
         EX    R4,TESTMVC          MOVE 1ST FIELD TO WORKAREA
         EX    R4,TESTPACK         ASSUME NUMERIC & MOVE INTO 'WORKPACK
         LA    R15,TESTAREA        POINT R15 AT TEST AREA
         AR    R15,R1              POINT R15 AT END OF 1ST OPERAND
         CBAL  R4,TESTSN           ENSURE 1ST OPERND IS NUMERIC
         BH    TESTC3Y             IF NOT NUMERIC THEN FORCE COMPARE FL
         BE    *+10                BR F NUMERIC
         ZAP   WORKPACK,ZERO       SET PACKED FIELD TO ZERO IF SOURCE B
         ZAP   WORKPCKL,WORKPACK   MOVE 1ST OPERAND TO 'WORKPCKL'
         L     R2,CB13CBXX         RETRIEVE CB33 ADDRESS
         SR    R6,R6               ZEROISE WORK REGISTER
         IC    R6,CB33POS2         GET POSN OF 2ND OPERAND
         BCTR  R6,0                DECREMENT POSN TO DISPLACEMENT
         A     R6,SYSUT1+IOPSRECA  ADD RECORD ADDRESS TO POIN A T FIELD
         SR    R1,R1                ZEROISE WORK REHISTER
         IC    R1,CB33LEN2         GET LENGHT OF 2ND OPERAND
*        BCTR  R1,0                DECREMENT DONE IN INITIALISATION
         EX    R1,TESTPACK         ASSUME FILED NUMERIC & MOVE TO WORKP
         EX    R1,TESTMVC          MOVE 2ND OPERAND TO TEST AREA
         LA    R15,TESTAREA        POINT R15 AT TEST AREA
         AR    R15,R1              POINT R15 AT END OF 2ND OPEREND
         EJECT
***********************************************************************
*        C3 - MOVE/COMPARE FIELDS IN THE SAME RECORD ( CONT'D )       *
***********************************************************************
         SPACE 1
         CBAL  R4,TESTSN           ENSURE FLD IS NUMERIC
         BH    TESTC3Y             IF NOT NUMRIC THEN COMPARE FAILED
         BE    *+10                BR IF NUMERIC
         ZAP   WORKPACK,ZERO       ZEROISE PD FLD IF SOURCE BLANK
         L     R2,CB13CBXX         RETRIEVE CB33 ADDRESS
         SR    R1,R1               ZEROISE WORK REGISTER
         CP    WORKPCKL,WORKPACK   COMPARE THE 2 VALUES
TESTC3CC IC    R1,CB33TYPE         SET COMPARISON TYPE
         CBAL  R4,COMPARE          TEST RESULT OF COMPARE
         BE    *+8                 BR IF COMPARISON SATISFIED
TESTC3Y  MVI   TESTTSTX,C'Y'       FLAG TEST AS NOT SARISFIED
TESTC3X  B     TESTRTN             PREPARE TO RETRUN TO CALLER
         DROP  R8                  DROP CB13 ADDRESSABILITY
         SPACE 5
***********************************************************************
*        C6 - TRANSFORM SPACES TO ZEROES                              *
***********************************************************************
         SPACE 1
TESTC6   SUBIN ,                   ENTER ROUTINE
         LR    R15,R6              POINT R15 AT START OF FLD IN RECORD
         AR    R15,R1              POINT R15 AT END OF FIELD IN RECORD
         LA    R1,1(,R1)           INCREMENT EXECUTABLE LENGTH FOR BCT
TESTC601 CLI   0(R15),C' '         IS THE POSITION BLANK
         BNE   *+8                 BR IF NOT
         MVI   0(R15),C'0'         ALTER BLANK TO ZERO
         BCTR  R15,0               POINT R25 AT PREVIOUS CHATACTER
         BCT   R1,TESTC601         LOOP BACK IF FIELD NOT EXHAUSTED
         B     TESTRTN             PREPARE TO RETURN TO CALLER
         EJECT
***********************************************************************
*        C7 - PERFORM ARITHMETIC                                      *
***********************************************************************
         SPACE 1
TESTC7   SUBIN ,                   PERFROM MATHS
         CBAL  ,JTESTC7            TRANSFER CONTROL TO BUDGIE3J
         SPACE 5
***********************************************************************
*        C8 - ALIGN FLOATING DECIMAL FIELD                            *
***********************************************************************
         SPACE 1
TESTC8   SUBIN ,                   ALIGN FLOATING DECIMAL
         CBAL  ,JTESTC8            TRANSFER CONTROL TO BUDGIE3J
         SPACE 5
***********************************************************************
*        WR - WRITE ADDITIONAL REORD                                  *
***********************************************************************
TESTWR   SUBIN ,                   WRITE ADDITIONAL OUTPUT RECORD
         CBAL  ,JTESTWR            TRANSFER CONTROL TO CSECT BUDGIE3J
         EJECT
***********************************************************************
*        S  - LINK IN THE CB13 ROUTINE                                *
***********************************************************************
         SPACE 1
TESTS    SUBIN ,                   ENTER ROUTINE
         CBAL  ,JTESTS             TRANSFER CONTROL TO CSECT BUDGIE3J
         SPACE 5
***********************************************************************
*        SX - TERMINATE CB13 ROUTINE                                  *
***********************************************************************
         SPACE 1
TESTSX   SUBIN ,                   TERMIANET SUBROUTINE
         CBAL  ,JTESTSX            TRANSFER CONTROL TO CSECT BUDHIE&K
         SPACE 5
***********************************************************************
*        I - ISAM LOOK-UP                                             *
***********************************************************************
         SPACE 1
TESTI    SUBIN ,                   ISAM LOOK-UP ENTRY POINT
         CBAL  R4,JTESTI           TRANSFER CONTROL TO CSECT BUDGIE3J
         EJECT
***********************************************************************
*        WI - WRITE TO INTERNAL READER                                *
***********************************************************************
         SPACE 1
TESTWI   SUBIN ,                   ENTER ROUTINE
         CBAL  ,JTESTWI            TRANSFER CONTROL TO CSECT BUDGIE3J
         SPACE 5
***********************************************************************
*        R5 - CALL USER EXIT                                          *
***********************************************************************
         SPACE 1
TESTR5   SUBIN ,                   ENTER ROUTINE
         CBAL  ,JTESTR5            TRANSFER CONTROL TO CSECT BUDGIE3J
         SPACE 5
***********************************************************************
*        R6-R9 - CONDITIONAL B/C & C/R ACCUMULATING                   *
***********************************************************************
         SPACE 1
TESTR6   EQU   *                   B/C ACCUM: INPUT EBCDIC
TESTR7   EQU   *                   B/C ACCUM: INPUT PACKED
TESTR8   EQU   *                   C/R ACCUM: INPUT EBCDIC
TESTR9   EQU   *                   C/R ACCUM: INPUT PACKED
         SUBIN ,                   ENTER ROUTINE
         CBAL  ,JTESTR6            TRANSFER CONTROL TO CSECT BUDGIE3J
         SPACE 1
         DROP  R11                 DROP BUDGIE3B ADDRESSABILITY
         TITLE 'BUDGIE3J - ISAM LOOKUP'
        SCSECT J                   START CSECT BUDGIE3J
***********************************************************************
*        I  - ISAM LOOK-UP                                            *
***********************************************************************
         SPACE 1
         USING CB20NTRY,R8         ESTABLISH CB20 ADDRESSABILITY
JTESTI   SUBIN SAVE=(R3,R8)        PRESERVE REGISTERS
        BBMESS 06                  MOVE DEFAULT MEDSAGE TO LINE
         LR    R8,R2               POINT R8 AT CB20 C/B
         CBAL  R4,BUILDKEY         BUILD KEY & COMPARE WITH PREVIOUS
         BE    TESTI01             BYPASS I/O IF SAME AS PREVIOUS KEY
         CBAL  R4,ISRANDM          PERFORM ISAM LOOK-UP
         BL    ABEND44             BR IF I/O ERROR
TESTI01  CBAL  R4,MOVECB21         PERFORM ANY NECESSARY MOVES
         MVC   TESTTSTX,CB20XORY   SET COND CODE FOR USER
         SUBLR R3                  RESTORE R3 FROM SAVE AREA
         SUBLR R8                  RESTORE R8 FROM SAVE AREA
         CBAL  ,TESTRTN            RETURN TO CALLER
         DROP  R8                  DROP CB20 ADDRESSABILITY
BUDGIE3  CSECT
         DROP  R11                 DROP BUDGIE3B ADDRESSABILITY
         TITLE 'BUDGIE3B - TEST ROUTINES'
***********************************************************************
*        EXECUTED INSTRUCTIONS                                        *
***********************************************************************
         SPACE 1
TESTMVC  MVC   TESTAREA(0),0(R6)   MOVE FIELD TO TEST AREA
TESTMVC1 MVC   TESTAREA(0),0(R1)   MOVE FIELD TO TEST AREA
TESTLJST MVC   0(0,R6),1(R6)       LEFT JUSTIFY FIELD
TESTOC   OC    0(0,R6),ZEROES      'OR' LEADING BLANKS TO ZEROES
TESTCLC  CLC   TESTAREA(0),SPACES  COMPARE FIELD WITH SPACES
TESTCLCL CLC   TESTAREA(0),0(R2)   COMPARE FIELD WITH SUPPLIED LIST
TESTPACK PACK  WORKPACK,0(0,R6)    PACK FIELD INTO WORK AREA
TESTRNG1 CLC   TESTAREA(0),CB30RNG1-CB30NTRY(R2) LOWER RANGE COMPARE
TESTRNG2 CLC   TESTAREA(0),CB30RNG2-CB30NTRY(R2) UPPER RANGE COMPARE
TESTTR   TR    TESTAREA(0),TTABLE  TRANSLATE AGAINST MAIN TABLE
TESTTRL1 TRT   TESTAREA(0),TTABLEL1 ACCEPT A - Z AND BLANK
TESTTRL2 TRT   TESTAREA(0),TTABLEL2 ACCEPT A - Z, 0 - 9, BLANK
TESTTRL3 TRT   TESTAREA(0),TTABLEL3 ACCEPT A - Z, 0 - 9, BLANK, SPECIAL
TESTTRNN TRT   TESTAREA(0),TTABLENN ACCEPT 0 - 9
TESTTRN  TRT   TESTAREA(0),TTABLEN  ACCEPT 0 - 9, BLANK
TESTTRS  TRT   TESTAREA(0),TTABLES  ACCEPT 0-9, BLANK, A-R, 11-0, 12-0
TESTTRNS TRT   TESTAREA(0),TTABLENS LOCATE 1ST 0-9, A-R, 11-0, 12-0
TESTTRNO TRT   TESTAREA(0),TTABLENO LOCATE 1ST 0-9
TESTTRBL TRT   0(0,R14),TTABLEBL    LOCATE FIRST BLANK
TESTITB  TM    0(R14),OO           TEST INDICATOR STATUS AT BATCH LEVEL
TESTITD  TM    0(R15),OO           TEST INDICATOR STATUS AT DETAIL LEVL
CLCKEY   CLC   0(0,R15),0(R14)     COMPARE CURRENT & PREVIOUS KEY
MVCKEY   MVC   0(0,R15),0(R14)     MOVE CURRENT KEY TO PREVIOUS
C3CLC    CLC   0(0,R14),0(R15)     COMPARE TWO CHARACTER FIELDS
C3MVC1   MVC   TESTAREA(0),0(R14)  MOVE TO INTERMEDIATE AREA
C3MVC2   MVC   0(0,R15),TESTAREA   MOVE FROM INTERMEDIATE AREA
C3MVC    MVC   0(0,R15),0(R14)     MOVE SOURCE TO DESTINATION
C3PACK   PACK  0(0,R15),0(0,R14)   PACK SOURCE INTO DESTINATION
C3UNPACK UNPK  0(0,R15),0(0,R14)   UNPACK SOURCE INTO DESTINATION
MOVELIT  MVC   0(0,R6),CB21LIT-CB21NTRY(R10) MOVE DEFAULT LITERAL
MOVEPAD  MVC   1(0,R15),0(R15)     PROPAGATE PAD CHARCATER
MOVEFLD  MVC   0(0,R6),0(R2)       MOVE MATCHED DATA TO RRCORD
L9ZERO   MVC   0(0,R6),ZEROES      MOVE EBCDIC ZEROES TO OUTPUT FIELD
L9ZEROP  ZAP   0(0,R6),ZERO        ZEROISE PACKED OUTPUT FIELD
L9RATEP  ZAP   0(0,R6),UT460OTV-UT460LNK(L'UT460OTV,R15)
L9RATE   UNPK  0(0,R6),UT460OTV-UT460LNK(L'UT460OTV,R15)
L9MOVE   MVC   0(0,R6),0(R14)      MOVE EBCDIC FIELD TO OUTPUT RECORD
TESTZAP  ZAP   WORKPACK,0(0,R6)    MOVE PACKED INPUT TO WORKAREA
PACKOUT  ZAP   0(0,R6),WORKPACK    MOVE PACKED FIELD TO OUTPUT
UNPKOUT  UNPK  0(0,R6),WORKPACK    UNPACK VALUE INTO OUTPUT RECORD
SETMASKB MVI   OFFINDB+1,OO        INSERT MASK INTO 'AND' INSTRUCTION
SETMASKD MVI   OFFINDD+1,OO        INSERT MASK INTO 'AND' INSTRUCTION
OFFINDB  NI    0(R14),OO           SET OFF IND ( VIA INVERTED MASK )
OFFINDD  NI    0(R15),OO           SET OFF IND ( VIA INVERTED MASK )
SB11AP04 AP    CB04BACC-CB04NTRY(L'CB04BACC,R15),0(0,R14)
SB11AP05 AP    CB05BACC-CB05NTRY(L'CB05BACC,R15),0(0,R14)
SB11AT05 AP    CB05BVAL-CB05NTRY(L'CB05BVAL,R15),0(0,R14) ACCUM TOTAL
TESTTSTX DC    C'X'                COMPARAND TO SET COND CODE
COMPARET DC    C'X'                USED TO SET COND CODE FOR COMPARE RT
         EJECT
        SCSECT B                   RESTART BUDGIE3B CSECT
***********************************************************************
*        REPLACE LEADING BLANKS BY ZEROS BAR THE LAST BYTE            *
***********************************************************************
         SPACE 1
TESTORZ  SUBIN ,                   SET LEADING BLANKS TO ZERO
         SR    R15,R15             ZEROISE WORK REGISTER
         LR    R14,R6              POINT R14 AT STRAT OF FIELD
         IC    R15,1(R3)           GET LENGTH OF FIELD BEING TESTED
         BCTR  R15,0               DECREMENT LENGTH FOR EXECUTE
         LTR   R15,R15             TEST IF ONLY 1 BYTE LONK
         BZ    *+14                BYPASS 'OR' IF FIELD ONLY 1 LONG
         BCTR  R15,0               DECREMENT TO AVOIS LAST BYTE
         EX    R15,TESTOC          SET LEADING BLAKS TO ZEROS
         LA    R15,1(,R15)         RESET R15 TO EXECUTABLE LENGTH
         AR    R14,R15             POINT R14 AT LAST BYRE OF FILED
        SUBOUT ,                   RETURN TO CALLER
         TITLE 'BUDGIE3B - INDICATOR PROCESSING'
***********************************************************************
*        IT - TEST INDICATOR STATUS                                   *
***********************************************************************
         SPACE 1
*        NOTE THAT THIS TEST WORKS IN REVERSE.  IF ALL SPECIFIED
*         INDICATORS HAVE THE SPECIFIED STATUS THEN TTHE CARD/BATCH
*         IS CONSIDERED TO BE IN ERROR.  THUS, IF THE TESTS ARE       *
*         SATISFIED, 'TESTTSTX' IS SET TO 'Y' AND NOT 'X'.
         SPACE 1
         USING CB14NTRY,R6         ESTABLISH CB14 ADDRESSABILITY
TESTIT   SUBIN SAVE=(R3,R5,R9)     PRESERVE REGISTERS
         LR    R6,R2               POINT R6 AT CB14
        BBMESS 17                  ADD ERROR MESSAGETO LINE
         LA    R9,9                ESTABLISH LOOP OF 9 BUCKTES
         LA    R5,CB14IND          POINT AT 1ST BUCKET
TESTIT1  SR    R3,R3               ZEROISE WORK REGISTER ...
         IC    R3,0(R5)             ... AND INSERT IND NUMBER
         SR    R1,R1               ZEROISE WIRK REGISTER ...
         IC    R1,1(,R5)            .. AND INSERT DESIRED IND STATUS
         CLI   0(R5),FF            TEST IF IND NUMBER NULLIFIED
         BE    TESTIT2             BR IF NULLIFIED TO GET NEXT
         CBAL  R4,WHICHBIT         DETERMINE WHICH BIT WE WANT
         TM    CB14SW,SW14BTCH     TEST IF BATCH LEVEL TEST
         BO    *+12                BR IF BATCH LEVEL TEST
         EX    R2,TESTITD          TEST STATE OF DETAIL LEVEL INDICATOR
         B     *+8                 GO DETERMINE RESULT OF TEST
         EX    R2,TESTITB          TEST STATUS OF BATCH LEVEL INDICATOR
         CBAL  R4,COMPARE          DETERMINE RESULT OF TEST
         BNE   TESTITX             EXIT IF STATUS NOT AS REQUIRED
TESTIT2  LA    R5,2(,R5)           INCREMENT TO NEXT BUCKET
         BCT   R9,TESTIT1          LOOP BACK IF ANY LEFT
         MVI   TESTTSTX,C'Y'       ALL STATUS CORRECT SO TEST FAILED
TESTITX SUBOUT RESTORE=(R3,R5,R9),RETURN=TESTRTN RESTORE & RETURN
         DROP  R6                  DROP CB14 ADDRESSABILITY
         EJECT
***********************************************************************
*        TEST STATUS IF DETAIL LEVEL INDICATOR                        *
***********************************************************************
         SPACE 1
TESTINDD SUBIN SAVE=(R3,R4)        PRESERVE REGISTERS
         CLI   0(R3),FF            TEST IF INDICATOR NUMBER NULLIFIED
         BE    TESTNDDX            BYPASS ROUTINE IF YES
         CBAL  R4,TESTINDS         COMPUTE BIT ADDRESS
         EX    R2,TESTITD          TEST DETAIL LEVEL BIT
         CBAL  R4,COMPARE          DETERMINE RESULT OF TEST
TESTNDDX SUBOUT RESTORE=(R3,R4)    RESTORE & RETURN TO CALLER
         SPACE 4
***********************************************************************
*        TEST STATUS OF BATCH LEVEL INDICATOR                         *
***********************************************************************
         SPACE 1
TESTINDB SUBIN SAVE=(R3,R4)        PRESERVE REGISTERS
         CLI   0(R3),FF            TEST IN INDICATOR NUMBER NULLIFIED
         BE    TESTNDBX            BYPASS ROUTINE IF YES
         CBAL  R4,TESTINDS         COMPUET BIT ADDRESS
         EX    R2,TESTITB          TEST BATCH LEVEL INDICATOR STATUS
         CBAL  R4,COMPARE          DETERMINE RESULT OF TEST
TESTNDBX SUBOUT RESTORE=(R3,R4)    RESTORE & RETURN TO CALLER
         EJECT
***********************************************************************
*        PREPARE TO COMPUTE BIT ADDRESS                               *
***********************************************************************
         SPACE 1
*        ON ENTRY, R3 POINTS AT TWO 1-BYTE BINARY FIELDS CONTAINING
*         THE INDICATOR NUMBER AND THE INTERNAL REPRESENTATION OF THE
*         DESIRED INDICATOR STATUS *
         SPACE 1
TESTINDS SUBIN SAVE=R4             PRESERVE RETURN ADDRESS
         SR    R1,R1               ZEROISE WORK REGISTER
         SR    R2,R2               ZEROISE WORK REGISTER
         IC    R1,1(,R3)           PLACE STATUS IN R1
         IC    R2,0(R3)            GET IND NUMBER IF R2
         LR    R3,R2               SET IND NUMBER IN R3
         CBAL  R4,WHICHBIT         COMPUTE BIT ADDRESS
        SUBOUT RESTORE=R4          RESTOE & RETURN TO CALLER
         EJECT
***********************************************************************
*        ON - SET IN SPECIFIED INDICATOR                              *
***********************************************************************
         SPACE 1
TESTON   SUBIN ,                   ENTER ROUTINE
         CBAL  R4,SETINDS          SET INDICATOR ON
         B     TESTRTN             GO RETURN TO CALLER
         SPACE 5
***********************************************************************
*        OF- SET OFF SPECIFIED INDICATOR                              *
***********************************************************************
         SPACE 1
TESTOF   SUBIN ,                   ENTER ROUTINE
         USING CB13NTRY,R8         ESTABLISH CB13 ADDRESSABILITY
         SR    R3,R3               ZEROISE WORK REGISTER
         IC    R3,CB13RIND         OBTAIN INDICATOR NUMBER
         CBAL  R4,WHICHBIT         CALCALATE BIT ADDRESS
         EX    R2,SETMASKB         INSERT MASK INTO 'NI' FOR BATCH LEVL
         EX    R2,SETMASKD         INSERT MASK INTO 'NI' FOR DETAIL LVL
         XI    OFFINDB+1,FF        INVERT MASK FOR NI
         XI    OFFINDD+1,FF        INVERT MASK FOR NI
         EX    R0,OFFINDB          SET OFF INDICATOR AT BATCH LEVEL
         EX    R0,OFFINDD          SET OFF INDICATOR AT DETAIL LEVEL
         B     TESTRTN             RETURN TO CALLER
         DROP  R8                  DROP CB13 ADDRESSABILITY
         EJECT
***********************************************************************
*        SET SPECIFIED INDICATOR ON                                   *
***********************************************************************
         SPACE 1
*        ON ENTRY, R10 POINTS AT THE CB02 CONTAINING THE INDICATOR
*         AREAS AND R8 POINTS AT THE CB13 CONTAINING THE INDICATOR NUMB
*         THIS ROUTINE ONLY RECEIVES CONTROL IF THE INDICATOR IS TO BE
*         SET ON ( I.E. IF THE ASSOCIATED TEST HAS FAILED )
         SPACE 1
         USING CB02NTRY,R10        ESTABLISH CB02 ADDEESSABILITY
         USING CB13NTRY,R8         ESTABLIST CB13 ADDEESSABILITY
SETINDS  SUBIN SAVE=R4             PRESERVE RETURN ADDRESS
         SR    R3,R3               ZEROISE LINKAGE REGISTER
         IC    R3,CB13RIND         INSERT INDICATOR NUMBER
         CLI   CB13RIND,X'FF'      TEST IF INDICATOR SPECIDIED
         BE    SETINDSX            BYPASS ROUTINE IF NO IND SPECIFIED
         CBAL  R4,WHICHBIT         DETERMINE WHICH BIT IS REQUIRED
         EX    R2,SETINDB          SET ON BETCH LEVEL INDICATOR
         EX    R2,SETINDD          SET ON DETAIL LEVEL INDICATOR
SETINDSX SUBOUT RESTORE=R4         RESTORE & RETURB TO CALLER
         SPACE 1
SETINDB  OI    0(R14),X'00'        SET ON BATCH LEVEL INDICATOR
SETINDD  OI    0(R15),X'00'        SET ON DETAIL LEVEL INDICATOR
         DROP  R8,R10              DROP C/B ADDRESSABILITY
         EJECT
***********************************************************************
*        CONVERT INDICATOR NUMBER INTO A BIT ADDRESS                  *
***********************************************************************
         SPACE 1
*        ON ENTRY, R10 CONTAINS THE ADDRESS OF THE CB02 CONTAINING THE
*         INDICATOR AREAS, AND R3 CONTAINS THE INDICATOR NUMBER.  ON
*         EXIT, R14 POINTS AT THE RELEVANT BATCH INDICATOR BYTE, R15
*         POINTS AT THE RELEVANT DETEIL INDICATOR BYTE, AND R3 CONTAINS
*         THE NECESSARY BIT MASK TO ADDRESS THE CORRECT BIT.
         SPACE 1
         USING CB02NTRY,R10        ESTABLISH CB02 ADDRESSABILITY
WHICHBIT SUBIN ,                   ENTER SUB-ROUTINE
         SR    R2,R2               ZEROISE WORK REGISTER
         D     R2,=F'8'            CONVERT BIT NO TO BYTES & BITS
         LA    R14,CB02INDB        POINT R14 AT BATCH LEVEL SWITCHES
         LA    R15,CB02INDD        PONT R15 AT THE DETAIL LEVEL INDICAT
         AR    R14,R3              POINT R14 AT CORRECT BATCH  LEVEL BY
         AR    R15,R3              POINT R15 AT CORRECT DETAIL LEVEL BY
         STC   R2,WORKAREA         PRESERVE REMAINDER IN WORK AREA
         TR    WORKAREA(1),REMAINDR TRANSLATE REMAINDER INTO RELEVANT B
         IC    R2,WORKAREA         INSERT BIT MASK INTO R2 FOR EX'S
        SUBOUT ,                   RETURN TO CALLER
         DROP  R10                 DROP CB02 ADDRESSABILITY
         EJECT
***********************************************************************
*        PERFORM SPECIFIED RELATIONSHIP TEST                          *
***********************************************************************
         SPACE 1
*        THIS SUBROUTINE RECEIVES CONTROL AFTER A TEST ( COMPARE ) HAS
*         BEEN MADE, AND PERFORMS THE RELATIONSHIP TEST SPECIFIED IN
*         R1 IN THE FORM OF AN INTERNAL CODE ( SEE MISCELLANAOUS EQU )
*         AND SETS THE CONDITION CODE SUCH THAT THE CALLER CAN MAKE THE
*         FOLLOWING CONDITIONAL BRANCHES -
*              BE  - SPECIFIED RELATIONSHIP SATISFIED
*              BNE - SPECIFIED RELATIOSHIP NOT SATISFIED
         SPACE 1
COMPARE  SUBIN ,                   ENTER SUBROUTINE
         MVI   COMPARET,C'X'       ASSUME TEST SATISFIED
         SLL   R1,3                MULTIPLY INTERNAL REPRESENTATION OF
*                                   THE TEST BY 8 TO CONVERT IT TO AN I
*                                   INDEX FOR THE FOLLONG BR TO PERFORM
*                                   THE APPROPRIATE RELATIONSHIP TEST
         B     *-4(R1)             GO TO APPROPRIATE CONDITIONAL BRANCH
         BE    COMPAREX       (EQ) GO SET COND CODE IF TEST SATISFIED
         B     COMPAREY            GO SHOW TEST NOT SATISFIED
         BNE   COMPAREX       (NE) GO SET COND CODE IF TEST SATISFIED
         B     COMPAREY            GO SHOW TEST NOT SATISFIED
         BH    COMPAREX       (GT) GO SET COND CODE IF TEST SATISFIED
         B     COMPAREY            GO SHOW TEST NOT SATISFIED
         BNL   COMPAREX       (GE) GO SET COND CODE IF TEST SATISFIED
         B     COMPAREY            GO SHOW TEST NOT SATISFIED
         BL    COMPAREX       (LT) GO SET COND CODE IF TEST SATISFIED
         B     COMPAREY            GO SHOW TEST NOT SATISFIED
         BNH   COMPAREX       (LE) GO SET COND CODE IF TEST SATISFIED
         B     COMPAREY            GO SHOW TEST NOT SATISFIED
         BO    COMPAREX       (ON) GO SET COND CODE IF TEST SATISFIED
         B     COMPAREY            GO SHOW TEST NOT SATISFIED
         BZ    COMPAREX       (OF) GO SET COND CODE IF TEST SATISFIED
         B     COMPAREY            GO SHOW TEST NOT SATISFIED
COMPAREY MVI   COMPARET,C'Y'       SET TO SHOW TEST NOT SATISFIED
COMPAREX CLI   COMPARET,C'X'       SET COND CODE FOR CALLER
        SUBOUT ,                   RETURN TO CALLER
         CNOP  0,8                 ENSURE CSECT LENGTH IS MULTIPLE OF 8
LGTHB    EQU   *                   END OF CSECT BUDGIE3B
         DROP  R11                 DROP BUDGIE3B ADDRESSABILITY
         TITLE 'BUDGIE3J - BUILD KEY AND COMPARE WITH PREVIOUS'
        SCSECT J                   RESTART CSECT BUDGIE3J
***********************************************************************
*        BUILD KEY FOR ISAM/RIGAM/TABLE LOOK-UP                       *
***********************************************************************
         SPACE 1
*        ON ENTRY, R8 POINTS AT THE CB20 DEFINING THE KEY.  ON RETURN,
*         THE CONDITION CODE IS SET SUCH THAT THE CALLER CAN MAKE THE
*         FOLLOWING TESTS :-
*              BE  - KEY SAME AS PREVIOUS KEY
*              BNE - KEY NOT SAME AS PREVIOUS KEY
         SPACE 1
         USING CB20NTRY,R8         ESTABLISH CB20 ADDRESSABLITY
BUILDKEY SUBIN SAVE=(R4,R10)       PRESERVE REGISTERS
         LA    R10,8               SET LOOP OF 8 COMPONENTS
         L     R2,CB20TKEY         POINT R2 AT KEY AREA
         LA    R3,CB20FLD1         POINT R3 AT 1ST CONPONENT
BUILDK01 L     R6,SYSUT1+IOPSRECA  POINT R6 AT DETAIL RECORD
         CLI   2(R3),C'D'          TEST IF SOURCE IS DETAIL
         BE    BUILDK02            BR IF SOURCE IS DETAIL
         CLI   2(R3),C'S'          IS THIS COMPONENT DYNAMICALLY ACQUID
         BNE   *+14                BR IF NOT
         MVC   0(2,R3),FLDP        INSERT PL FROM CB13 INTO CB20
         B     BUILDK02            GO EXTRACT FIELD FROM DETAIL RECORD
         L     R6,CB20POOL         POINT R6 AT LITERAL POOL
         CLI   2(R3),C'L'          IS THIS COMPONENT A LITERAL
         BE    BUILDK02            BR IF COMPONENT IS LITERAL
*        COMPONENT MUST BE A BATCH CARD FIELD
         L     R6,SYSUT1+IOPSRECA  ASSUME THIS IS THE BATCH CARD
         TM    PSWITCH,PSWBCARD    TEST IF PROCESSING BATCH CARD
         BO    BUILDK02            BR IF YES TO USE CURRENT RECORD
         L     R6,AWORKBC          POINT R6 AT BATCH CARD IN WORK FILE
BUILDK02 CBAL  R4,EXTRACT          ADD COMPONENT TO KEY
         LA    R3,3(,R3)           POINT AT NEEXT KEY COMPONENT
         BCT   R10,BUILDK01        LOOP BACK IF COMPONENTS LEFT
         L     R14,CB20TKEY        POINT R14 AT NEW KEY
         L     R15,CB20LKEY        POINT R15 AT PREVIOUS KEY
         SR    R1,R1               ZEROISE R1
         IC    R1,CB20KLEN         RETRIEVE KEY LENGTH
         BCTR  R1,0                DECREMENT FOR EXECUTE
         EX    R1,CLCKEY           COMPARE THIS KEY WITH LAT
         BE    *+8                 BR IF KEYKEYS SAME
         EX    R1,MVCKEY           PRESERVE NEW KEY AS LAST
        SUBOUT RESTORE=(R4,R10)    RESTORE REG AND RETRUN TO CALLER
         EJECT
***********************************************************************
*        PERFORM MOVES DEFINED BY CB21 C/B'S                          *
***********************************************************************
         SPACE 1
         USING CB21NTRY,R10        ESTABLISH CB21 ADDRESSABILITY
MOVECB21 SUBIN SAVE=(R10)          PRESERVE REGISTES
         L     R10,CB20CB21        POINT R10 AT 1ST CB21 IN CHAIN
         L     R9,CB20IREC         POOINT AT ISAM/RIGAM/TABLE RECORD
MOVE2101 LTRR  R10,R10             TEST FOR END OF CHAIN
         BZ    MOVE21X             LEAVE ROUTINE IF END OF CHAIN
         SR    R15,R15             ZEROISE WORK REGISTER
         IC    R15,CB21DPOS        GET POSN OF OUTPUT FIELD
         BCTR  R15,0               ALTER POSN TO DISPLACEMENT
         L     R6,SYSUT1+IOPSRECA  POINT R6 AT OUTPUT RECORD
         AR    R15,R6              POINT R15 AT DESTINATION FIELD
         SR    R1,R1               ZEROIZE EXECUTUON REGISTER
         IC    R1,CB21SLEN         RETRIEVE LENGTH OF FIELD
         BCTR  R1,0                DECREMENT FOR EXECUTE
         CLI   CB20XORY,C'X'       TES IF KEY MATCH FOUND
         BE    MOVE2103            BR IF YES TO DERIVE  DATA
         TM    CB21SW,SW21PAD      IS DERIED FIELD TO BE PADED
         BO    MOVE2102            BR IF PADDING REQUIRED
         TM    CB21SW,SW21LIT      IS THERE A DEFAULT LITERAL
         BZ    MOVE2104            BR IF NOT TO GET NEXT CB21
         LA    R14,CB21LIT         POINT R14 AT LITERAL
         B     MOVE2105            GO PERFORM DESIRIED MOVE
MOVE2102 MVC   0(1,R15),CB21PADC   INSERT PAD CHAR IN 1ST BYTE
         BCTR  R1,0                DECREMENT FOR PROPAGATING EXECUTE
         LTR   R1,R1               TEST IF ORIGINAL FIELD 1 BYTE LONG
         BM    *+8                 BR IF YES TO AVOID HUGE MOVE
         EX    R1,MOVEPAD          PROPAGATE PAD CHARACTER THRU FIELD
         B     MOVE2104            GO GET NEXT CB21
         EJECT
***********************************************************************
*        PERFORM MOVES DEFINED BY CB21 C/B'S ( CONT'D )               *
***********************************************************************
         SPACE 1
MOVE2103 SR    R14,R14             ZEROISE WORK REGISTER
         IC    R14,CB21SPOS        RETRIEVE POSN OF SOURCE FIELD
         BCTR  R14,0               ALTER POSN TO DISPALCEMENT
         A     R14,CB20IREC        POINT R14 AT SOURCE FIELD
MOVE2105 TM    CB21SW,SW21PACK     IS SOURCE FIELD TO BE PACKED
         BO    MOVE2106            BR IF YES
         TM    CB21SW,SW21UNP      IS SOURCE FIELD TO BE UNPACKED
         BZ    MOVE2107            BR IF NO TO MOVE DIRECT
         EX    R1,C3UNPACK         UNPACJ SOURCE INTO DESTINATIOM
         B     MOVE2104            GO GET NEXT C/B
MOVE2106 EX    R1,C3PACK           PACK SOURCE INTO DESTINATION
         B     MOVE2104            GO GET NEXT C/B
MOVE2107 EX    R1,C3MVC            MOVE SOURCE TO DESTINATION
MOVE2104 L     R10,CB21CB21        GET ADDR OF NRXT CB21
         B     MOVE2101            LOOP BACK TO PROCESS
MOVE21X SUBOUT RESTORE=(R10)       RESTORE & RETURN TO CALLER
         DROP  R8,R10              DROP C/B ADDRESSABILITY
         SPACE 1
         TITLE 'BUDGIE3J - CB13 ROUTINE PROCESSING'
***********************************************************************
*        S  - LINK IN THE CB13 ROUTINE                                *
***********************************************************************
         SPACE 1
         USING CB40NTRY,R2         ESTABLISH CB40 ADDRESSABILITY
JTESTS   SUBIN ,LINK CB13 ROUTINE INTO CHAIN
         L     R14,CB40FRST        GET ADDR OF 1ST CB13 IN ROUTINE
         L     R15,CB40LAST        GET ADDRESS OF LAST CB13 IN CHAIN
         L     R1,CURRCB13         GET EDDRESS OF THIS CB13
         L     R2,CB13CB13-CB13NTRY(R1) GET ADDRESS OF NEXT SEQ CB13
         ST    R2,CB13CB13-CB13NTRY(R15) POINT END OF RTN AT NEXT SEQ
         ST    R14,CB13CB13-CB13NTRY(R1) POINT THIS CB13 AT STRT OF RTN
         ST    R1,CB13CBXX-CB13NTRY(R15) SAVE ADDR OF CURR CB13 IN LAST
*                                   (DUMMY) CB13 AT END OF CHAIN
         OI    APSWITCH,APSWSRTN   FLAG THAT SUBROUTINE HAS CONTROL
         L     R1,SRTNCNT          GET DEPTH OF SUBROUTINE NEST
         LA    R1,1(,R1)           INCREMENT SUBROUTINE COUNT
         ST    R1,SRTNCNT          RESTORE UPDATED DEPTH OF NEST
         CBAL  ,TESTRTN            RETURN TO CALLER
         DROP  R2                  DROP CB40 ADDRESSABULITY
         EJECT
***********************************************************************
*        SX - TERMINATE CB13 SUB-ROUTINE                              *
***********************************************************************
         SPACE 1
*        THE CURRENT CB13 CONTAINS THE FOLLOWIND FIELDS:
*         CB13CB13 - ADDR OF CB13 FOLLOWING ONE INVOKING SUBROUTINE
*         CB13CBXX - ADDR OF CB13 THAT INVOKED SUBROUITNE
         SPACE 1
*        SUBROUTINE MAY HAVE BEEN INVOKED BY :
*         S  - PERFOM SUB-ROUTINE ONCE
*         DW - PERFROM SUBROUTINE WHILE CONDITIONS SATISFIED
*        FOR 'S ' WE WISH TO RETURN TO THE NEXT SEQUENTIAL CB13, WHILE
*         FOR 'DW' WE WISH TO RETURN TO THE SAME CB13.
         SPACE 1
JTESTSX  SUBIN ,                   TERMIANTE SUB-ROUTINE OF CB13'S
*                                  NOTE THAT R2 CONTAINS THE ADDRESS OF
*                                   THE CB13 THAT INVOKED THE ROUTINE
         L     R1,CURRCB13         GET ADDRESS OF THIS (DUMMY) CB13
         L     R1,CB13CB13-CB13NTRY(R1) GET ADDRESS OF NEXT CB13
         ST    R1,CB13CB13-CB13NTRY(R2) RECHAIN THE CB13 THAT INVOKED
*                                   THE SUBROUTINE TO THE SEQ CB13
         USING CB13NTRY,R1         ESTABLISH CURRENT CB13 ADDRESSABILIT
         L     R1,CURRCB13         GET ADDRESS OF THIS CB13
         CLI   CB13TST0-CB13NTRY(R2),C'D' WAS RTN INVOKED BY 'DW'
         BNE   *+10                BR IF NOT BY 'DW'
         MVC   CB13CB13,CB13CBXX   SET TO RETRUN TO 'DW' CB13
         DROP  R1                  DROP CB13 ADDRESSABILITY
         L     R1,SRTNCNT          GET COUNT OF DEPTH OF NEST
         BCTR  R1,0                DECREMENT COUNT
         ST    R1,SRTNCNT          PRESERVE NEEW COUNT OF DEPTH OF NEST
         LTR   R1,R1               TEST IF EMERGED FROM SUBROUTINE NEST
         BNZ   *+8                 BR IF NOT
         NI    APSWITCH,FF-APSWSRTN INDICTA ENO LONGER WITHIN ROUTINE
         CBAL  ,TESTRTN            RETURN TO CALLER
         TITLE 'BUDGIE3J - WRITE ADDITIONAL OUTPUT RECORD'
***********************************************************************
*        WR - WRITE ADDITIONAL OUTPUT RECORD                          *
***********************************************************************
         SPACE 1
JTESTWR  SUBIN ,                   WRITE OUTPUT RECORD
         TM    PSWITCH,PSWDLETE+PSWHARD HAS RECORD BEEN ACCEPTED
         BNZ   TESTWRX             IGNORE WRITE IF NOT ACCEPTED
         TM    MASTER,SWMHARD      HAS BATCH GOT HARD ERROR
         BO    TESTWRX             BYPASS EXTRA WRITE IF YES
         CBAL  R4,DETAL02B         WRITE RECORD TO WORK FILE
TESTWRX  CBAL  ,TESTRTN            RETURN TO CALLER
         EJECT
***********************************************************************
*        WI - WRITE TO INTERNAL READER                                *
***********************************************************************
         SPACE 1
JTESTWI  SUBIN ,                   ENTER ROUTINE
         CBAL  R4,PUTINTRD         WRITE RECORD TO INTERNAL READER
         CBAL  ,TESTRTN            PREPARE TO RETURN TO CALLER
         EJECT
***********************************************************************
*        R5 - CALL USER EXIT ( ITERATIVELY )                          *
***********************************************************************
         SPACE 1
JTESTR5  SUBIN ,                   ENTER ROUTINE
         TM    CB02SW-CB02NTRY(R10),SW02URTN DOES RTN EXIST
         BZ    JTESTR5X            BR IF NO ROUTINE
         L     R1,PTRPARMU         POINT R1 AT LINKAGE AREA
         MVI   URTNCSW-URTNPARM(R1),C'5' SET CALL TYPE IN LINKAGE AREA
         CBAL  R4,URTNCALL         EXECUTE USER ROUTINE
JTESTR5X CBAL  ,TESTRTN            RETURN TO CALLER
         EJECT
***********************************************************************
*        R6-R9 - CONDITIONAL B/C & C/R ACCUMULATING                   *
***********************************************************************
         SPACE 1
         USING CB02NTRY,R10        ESTABLISH CB02 ADDRESSABILITY
         USING SB11NTRY,R8         ESTABLISH SB11 ADDRESSABILITY
JTESTR6  SUBIN SAVE=R8             PRESERVE REGISTER 8 ( CB13 )
        BBMESS 03                  SET UP 'NOT NUMERIC' MESSAGE
         MVC   R6R9TMOD,CB13TMOD-CB13NTRY(R8)  PRESERVE TEST MODIFIER
         LR    R8,R2               POINT R8 AT SB11 (FROM CB13CBXX)
         TM    SB11SW,SW11INPD     IS THE INPUT PACKED
         BZ    TESTR601            BR IF FLD NOT PACKED
         L     R15,SB11CB05        POINT R15 AT ASSOC CB05 IF ANY
         TM    SB11SW,SW11DBCN     IS THIS A B/C ACCUM
         B     *+24                BYPASS ACCUM IF NOT
         CLI   R6R9TMOD,C'T'       ARE WE TO ACCUM TOTAL
         BNE   *+12                BR IF NOT TO ACCUM DETAIL
         EX    R1,SB11AT05         ADD VALUE TO TOTAL ACCUM
         B     *+8                 BYPASS ACCUMING INTO DETAIL
         EX    R1,SB11AP05         ADD VLUE TO CB05 ACCUMULATOR
         L     R15,SB11CB04        GET ADDR OF ASSOC CB04 IF ANY
         TM    SB11SW,SW11DCRN     IS THIS A C/R ACCUM
         BZ    *+8                 BYPSS ACCUM IF NOT
         EX    R1,SB11AP04         ADD VALUE TO CB04 ACCUM
         B     TESTR6X             PREPARE TO RETURN TO CALLER
TESTR601 EX    R1,TESTPACK         ASSUME NUMERIC AND PACK INTO W/A
         CBAL  R4,TESTSN           TES IF FIELD IS NUMERIC
         BH    TESTR6Y             GO INDICATE ERROR IF NOT NUMERIC
         USING CB05NTRY,R1         ESTABLISH CB05 ADDRESSABULITY
         L     R1,SB11CB05         POINT AT ASSOC CB05 IF ANY
         TM    SB11SW,SW11DBCN     TEST IF THIS IS B/C ACCUM
         BZ    *+28                BYPASS ACCUM IF NOT
         CLI   R6R9TMOD,C'T'       ARE WE TO ACCUMULATE 'TOTAL'
         BNE   *+14                BR IF NOT TO ACCUM DETAIL
         AP    CB05BVAL,WORKPACK   ADD INTO 'TOTAL' FIELD
         B     *+10                BYPASS ACCUMULATING INTO DETAIL
         AP    CB05BACC,WORKPACK   ADD TO B/C ACCUMULATOR
         DROP  R1                  DROP CB05 ADDRESSABILITY
         USING CB04NTRY,R1         ESTABLISH CB04 AFDRESSABILITY
         L     R1,SB11CB04         POINT R1 AT ASSOC CB04 IF ANY
         TM    SB11SW,SW11DCRN     TEST IF THIS IS C/R ACCUM
         BZ    *+10                BYPASS ACCUM IF NOT
         AP    CB04BACC,WORKPACK   ADD TO C/R ACCUM
         DROP  R1                  DROP CB04 ADDRESSABILITY
         B     TESTR6X             BYPASS INDICTAING ARROR
TESTR6Y  MVI   TESTTSTX,C'Y'       SHOW FIELD NOT NUMERIC
TESTR6X  SUBLR R8                  RESTORE R8 FROM SAVE AREA
         CBAL  ,TESTRTN            PREPARE TO RETURN TO CALLER
         SPACE 1
         TITLE 'BUDGIE3J - PERFROM MATHEMATICAL OPERATION'
***********************************************************************
*        C7 - PERFORM MATHEMATICAL OPERATIPN                          *
***********************************************************************
         SPACE 1
         USING CB13NTRY,R8         ESTABLISH CB13 ADDRESSABLIITY
         CNOP  0,8                 ENSURE LENGTH STARTS ON DOUBLEWORD
FREEC7S  EQU   *                   START OF POTENTIAL FREEMAIN AREA
         USING CB36NTRY,R10        ESTABLISH CB36 ADDRESSABILITY
JTESTC7  SUBIN SAVE=R10            PRESERVE REGISTER
         LR    R10,R2              POINT R10 AT CB36
        BBMESS 21                  SET UP DEFAULT ERROR MESSAGE
         MVC   ULINEPL,CB36POS1    SET UP TO UNDERLINE OP1 IF NOT NUM
         PTR   CB36POS1,CB36LEN1   GET ADDR & LGTH OF 1ST OPERAND
         TM    CB36SW,SW36PCK1     IS OPERAND PACKED
         BO    TESTC701            BR IF YES
         EX    R1,TESTPACK         ASSUME IT IS NUMERIC & PCK IT
         EX    R1,TESTMVC          MOVE FIELD TO WORK AREA
         LA    R15,TESTAREA        PONT R15 AT WORK AREA
         AR    R15,R1              POINT R15 AT END OF FIELD
         CBAL  R4,TESTSN           ENSURE OPERAND IS NUMERIC
         BH    TESTC7Y             GO FLAG AS ERROR IF NOT
         BE    *+10                BYPASS ZAP IF FLD NOT BLANK
         ZAP   WORKPACK,ZERO       ZERPISE WORK FIELD FOR BL OPERAND
         B     *+8                 BR AROUND PACKED MOVE
TESTC701 EX    R1,TESTZAP          MOVE  PACKED FLD TO WORK AREA
         ZAP   WORKPCKL,WORKPACK   MOVE VALUE TO LARGER WORK AREA
         L     R2,CB13CBXX         RETRIEVE CB36 ADDRESS(LOST IN TRT)
         EJECT
***********************************************************************
*        C7 - PERFROM MATHEMATICAL OPERATION 7 CONT'D )               *
***********************************************************************
         SPACE 1
         TM    CB36SW,SW36LIT      IS 2ND OPERAND A SUPPLIED LITERAL
         BZ    *+14                BR IF NOT LITERAL
         ZAP   WORKPACK,CB36LIT    MOVE LITERAL TO WORK AREA
         B     TESTC7A2            BR TO PERFORM MATHS
         MVC   ULINEPL,CB36POS2    SET TO UNDERLINE OP2 IF NOT NUM
         PTR   CB36POS2,CB36LEN2   GET ADDR & LGTH OF 2ND OPERAND
         TM    CB36SW,SW36PCK2     ID OPERAND PACKED
         BO    TESTC702            BR IF PACKED
         EX    R1,TESTPACK         ASSUME OPERAND IS NUMERIC & PACK IT
         EX    R1,TESTMVC          MOVE FLD TO TEST WORK AREA
         LA    R15,TESTAREA        POINT R15 AT WORK AREA
         AR    R15,R1              POINT R15 AT END OF FILED
         CBAL  R4,TESTSN           ENSURE 2ND OPERAND IS NUMERIC
         BH    TESTC7Y             GO FLAG AS ERROR IF NOT NUMERIC
         BE    *+10                BYPASS ZAP IF NOT BLANK OPERAND
         ZAP   WORKPACK,ZERO       ZEROISE FOR BLANK OPERAND
         B     *+8                 BR AOUND PACKED MOVE
TESTC702 EX    R1,TESTZAP          MOVE PACKED FLD TO WORK AREA
         L     R2,CB13CBXX         RETRUEVE CB36 ADRS ( LOST IN TRT )
TESTC7A2 CBAL  R4,MATHSINT         PERFORM MATHEMATICAL OPERATION
         ZAP   $WA2,$RESULT        PUT INTERMED RESULT IN WORK AREA
         MVC   $WA2NDEC,$RESNDEC   PRESERVE NDEC OF INTERMED RESULT
         ZAP   $WA1,ZERO           ZEROISE 1ST W/A
         MVC   $WA1NDEC,CB36NDC3   SET DESIRED NDEC FOR FINAL RESULT
         EJECT
***********************************************************************
*        C7 - PERFORM MATHEMATICAL OPERATION ( CONT'D )               *
***********************************************************************
         SPACE 1
       BBMESS  22                  ASSUME SIGNIFICANCE LOSS
         MVC   ULINEPL,CB36POS3    POINT AT RESULT FIELD FOR UNDERLINE
         LA    R1,$WA1+8           POINT R1 AT 1ST OPERAND
         LA    R2,$WA2+8           POINT R2 AT 2ND OPERAND
         BAL   R4,ALIGN1           SUPPLY REQUESTED OUTPUT ALIGNMENT
         BNE   TESTC7Y             BR IF SIGNIFICANCE OVERFLOW TO FLAG
         BAL   R4,ADDRTN           OBTAIN RESULT WITH DESIRED NDEC
         ZAP   WORKPACK,$WA1       MOVE ALIGNED RESULT TO NEW W/A
         SR    R1,R1               ZEROISE WORJ REGISTER
         IC    R1,CB36RNDN         INSERT NO OF DIGITS TO ROUND
         TM    CB36SW,SW36RND      IS ROUNDING REQUIRED
         BZ    TESTC703            BR IF NO ORUNDING
         MH    R1,=H'3'            CONVERT NO TO INNDEX FOR TABLES
         LA    R15,RNDTAB1         POINT AT TABLE OF INCREMENTS
         AR    R15,R1              POINT AT RELEVANT TAVLE ELEMNT
         MVN   WORKPCKL(1),WORKPACK+7 PRESERVE SIGN
         OI    WORKPACK+7,X'0F'    FORCE POSITVE FOR ABSOLUTE ROUNDING
         AP    WORKPACK,0(3,R15)   ADD ROUNDING INCREMENT
         MVN   WORKPACK+7(1),WORKPCKL RESTORE ORIGINAL SIGN
         LA    R15,RNDTAB2         POINT AT TABLE OF MASKS
         AR    R15,R1              POINT AT CORRECT TABLE ELEMENT
         NC    WORKPACK+5(3),0(R15) ZEROISE LOW ORDER DIGITS
TESTC703 PTR   CB36POS3,CB36LEN3   GET ADDR & LEGH OF RRESULT FLD
         EJECT
***********************************************************************
*        C7 - PERFORM MATHEMATICAL OPERATION                          *
***********************************************************************
         SPACE 1
         SLL   R1,4                MOVE LGTH FOR PD EXECUTE
         TM    WORKPACK+7,X'03'    IS THE SIGN A 'C'
         BNZ   *+8                 BR I NOT
         OI    WORKPACK+7,X'03'    CHANGE TO 'F' FOR EBCDIC CLARITY
         TM    CB36SW,SW36PCK3     IS OUTPUT REQUIRED PACKED
         BZ    TESTC704            BR IF NOT
         EX    R1,PACKOUT          MOVE RESULT TO OUTPUT FIELD
         B     TESTC705            GO PROCESS REMAINDER
TESTC704 EX    R1,UNPKOUT          UNPACK RESULT INTO OUTPUT
TESTC705 TM    CB36SW,SW36REM      IS REMAINDER REQUIRED
         BZ    TESTC707            BYPASS RTN IF NOT
         SPACE 1
*        $WA1 CONTAINS THE RESULT WITH APPROPRIATE ALIGNMENT
         SPACE 1
         MP    $WA1,$WA4+8(8)      MULTIPLY QUOTIENT BY DIVISOR
         LH    R15,$WA1NDEC        GET NDEC OF QUOTIENT
         AH    R15,$WA4NDEC        ADD NDEC OF DIVISOR FOR NEW NDEC
         STH   R15,$WA1NDEC        PRESERVE NEW NDEC
         LA    R1,$WA1+8           POINT R1 AT QUOTIENT*DIVISOR
         LA    R2,$WA3+8           POINT R3 AT ORIGINAL VALUE
         BAL   R4,ALIGN1           ALIBN LIKE NEW RESULT
         SP    $WA3,$WA1           COMPUTE REM = ORIGINAL - QUOT*DIVS
         MVC   $REMNDEC,$WA3NDEC   SAVE NDEC OF REMAINDER
         ZAP   $REMANDR,$WA3       PRESERVE COMPUTED REMAINDER
         ZAP   $WA2,$REMANDR       PUT REMAINDER IN WORK AREA
         MVC   $WA2NDEC,$REMNDEC   PRESERVE NDEC OF REMIANDER
         ZAP   $WA1,ZERO           ZEROISE 1ST W/A
         MVC   $WA1NDEC,CB36NDC4   SET DESIRED NDEC IN 1ST W/A
         LA    R1,$WA1+8           POINT R1 AT 1ST OPERAND
         LA    R2,$WA2+8           POINT R2 AT 2ND OPERAND
         BAL   R4,ALIGN1           SUPPLY REQUESTED ALIGNMENT OFREMAIND
         BAL   R4,ADDRTN           OBTAIN REMAINDER WITH DESIRED NDEC
         ZAP   WORKPACK,$WA1       MONE ALIGNED REMAINDER TO NEW W/A
         EJECT
***********************************************************************
*        C7 - PERFORM MATHEMATICAL ( CONTW'D )                        *
***********************************************************************
         SPACE 1
         PTR   CB36POS4,CB36LEN4   GET ADDR & LGTH OF REMAINDER OUTPUT
         SLL   R1,4                MOVE LENGTH FOR PD EXECUTE
         TM    WORKPACK+7,X'03'    IS THE SIGN 'C'
         BNZ   *+8                 BR IF NOT
         OI    WORKPACK+7,X'03'    CHANGE TO 'F' FOR EBCDIC CLARITY
         TM    CB36SW,SW36REMP     IS REMAINDER DESIRED PACKED
         BZ    TESTC706            BR IF NOR
         EX    R1,PACKOUT          MOVE REMIANDER TO PUTOUT FLD
         B     TESTC707            BYPASS UNPACKED MOVE
TESTC706 EX    R1,UNPKOUT          UNPACK REMAINDER INTO OUTPUT FLD
TESTC707 B     TESTC7X             PREPARE TO LEAVE
TESTC7Y  MVI   TESTTSTX,C'Y'       SHOW MATHS FAILED
         ZAP   WORKPACK,ZERO       ZEROISE RESULT BEACUSE OF ERROR
         B     TESTC703            GO PLACE ZERO IN RESLT FIELD
TESTC7X  SUBLR R10                 RESTORE REGISTER
         CBAL  ,TESTRTN            PREPARE TO RETURN TO CALLER
         EJECT
***********************************************************************
*        PREPARE TO LINK TO MATHS ROUTINES                            *
***********************************************************************
         SPACE 1
MATHSINT SUBIN SAVE=R4             PRESERVE  RETURN ADDRESS
         ZAP   OP1,WORKPCKL        PUT 1ST VALUE INTO OPERAND 1 FIELD
         ZAP   OP2,WORKPACK        PUT 2ND VALUE INTO OPERAND 2 FIELD
         MVC   OP1NDEC,CB36NDC1    SET NDEC FOR OPERAND 1
         MVC   OP2NDEC,CB36NDC2    SET NDEC FOR OPERAND 2
         SR    R15,R15             ZEROISE WORK REGISTER
         IC    R15,CB36OPCD        SET INTERNAL REPRESENTATION OF MATHS
         LA    R1,OP1              POINT R1 AT OPERAND 1
         LA    R2,OP2              POINT R2 AT OPERAND 2
         CBAL  R4,MATHS            PERFORM NECESSARY ROUTINES
         ZAP   WORKPACK,$RESULT    MOVE RESULT TO INTERMED FLD
        SUBOUT RESTORE=R4          RESTORE & RETURN TO CALLER
         EJECT
***********************************************************************
*        MATHS ROUTINES                                               *
***********************************************************************
         SPACE 1
* MAXDEC       - MAXIMISE NO OF DECIMAL PLACES WITHOUT LOSING SIGNIFICA
* MINDEC       - MINIMISE NO OF DECIMAL PLACES WITHOUT LOSING DATA
* ALIGN        - ALIGN DECIMAL PLACES WITHOUT LOSING SIGNIFICANCE
* ALIGN1       - GIVE 2ND OPERAND DECIMAL ALIGNMENT OF 1ST
* SIGNIF       - REDUCE 16-BYT PACKED DECIMAL FLD TO 15 SIGNIFAC DIGITS
* GETNDEC      - COMPUTE NDEC AS SIGNED BINARY NUMBER IN R15
* CNTDIG       - COUNT NO OF SIGNIFICANT DIGITS IN EXCESS OF 15
         SPACE 1
*        THESE ROUTINES MAY LOOK SOMEWHAT PECULIAR AND EXCESSIVE FOR
*         BUDGIEO'S REQUIREMENTS, BUT THEY ARE IN FACT A TEST OF THE
*         MATHS ROUTINES THAT I INTEND TO USE IN THE BAL PARROT.
         SPACE 1
* ADD          - ADD OPERAND 2 TO OPERAND 1
* SUB          - SUBTRAT OPERAND 2 FROM OPERAND 1
* DIVIDE       - DIVIDE OPERAND 1 BY OPERAND 2
* MULT         - MULTIPLY OPERAND 1 BY OPERAND 2
* ZEROADD      - MOVE OPERAND 2 TO OPERAND 1
* EXP          - RAISE OPERAND 1 TO THE POWER OF OPERAND 2
         EJECT
***********************************************************************
*        MATHS - SET UP WORK AREAS AND INITIATE PROCESSING            *
***********************************************************************
         SPACE 1
*        ON ENTRY: R1  - ADDRESS OF OPERAND 1 : 8-BYTE PD + 1-BYTE NDEC
*                  R2  - ADDRESS OF OPERAND 2 : 8-BYTE PD + 1-BYTE NDEC
*                  R15 - INTERNAL REPRESANTATION OF MATHS OPERATION
*        ON RETURN: $RESULT & $RESNDEC CONTAIN THE RESULT VALUE
         SPACE 1
*        NOTE: INPUT FIELDS ARE UNTOUCHED BY HUMAN HANDS, EXCEPT FOR
*         THE 'ZEROADD' OPERATION.
         SPACE 1
MATHS    SUBIN SAVE=R4             PRESERVE RETURN ADDRESS
         ZAP   $WA1,0(8,R1)        MOVE 1ST OPERAND TO WORK AREA
         ZAP   $WA2,0(8,R2)        MOVE 2ND OPERAND TO WORK AREA
         MVC   $WA1NDEC,8(R1)      MOVE NDEC OF 1ST OPERAND TO WORK ARE
         MVC   $WA2NDEC,8(R2)      MOBE NDEC OF 2ND OPERAND TO W/A
         ZAP   $REMANDR,ZERO       ZEROISE REMAINDER LEST NOT DIVIDE
         XC    $REMNDEC,$REMNDEC   SET FO 0 PLACES OF DECIMALS
         SLL   R15,2               MULTIPLY INT REP OF OPERATION BY 4 .
*                                   .. TO CONVERT IT TO INDEX FOR THE
*                                   .. INDEXED BRANCH TO THE ROUTINE
         LA    R4,MATHSX           SET ETURN ADDRESS FOR ROUTINES
*                                   (U.E. SIMULATE A 'CBAL' )
         B     *(R15)              BR TO APPROPRIATE RUTINE
         B     ADDRTN              PERFORM ADDITION
         B     SUBRTN              PERFORM SUBTRACTION
         B     MULTRTN             GO FORTH AND MULTIPLY
         B     DIVRTN              DIVIDE AND CONQUER
*        B     EXPRTN              EXPONENTIATION
*        B     ZAPRTN              ZERO AND ADD
MATHSX  SUBOUT RESTORE=R4          RETORE & RETURN TO CALLER
         EJECT
***********************************************************************
*        ADD - $WA2 TO $WA1                                           *
***********************************************************************
         SPACE 1
ADDRTN   SUBIN SAVE=R4             PRESERVE RETURN ADDRESS
         LA    R1,$WA1+8           POINT R1 AT 8-BYTE 1ST OPERAND
         LA    R2,$WA2+8           POINT R2 AT 8-BYTE 2ND OPERAND
         BAL   R4,ALIGN            ALIGN OPERANDS WITHOUT LOSING SIGNIF
         AP    $WA1,$WA2           ADD SECOND OPERAND TO 1ST
         ZAP   $RESULT,$WA1        MOVE RESULT TO OUTPUT FIELD
         MVC   $RESNDEC,$WA1NDEC   SET NDEC FOR RESULT
        SUBOUT RESTORE=R4          RESTORE REGISTERS AND RETURN TO CALL
         SPACE 5
***********************************************************************
*        SUBTRACT - $WA2 FROM $WA1                                    *
***********************************************************************
         SPACE 1
SUBRTN   SUBIN SAVE=R4             PRESERVE RETURN ADDRESS
         LA    R1,$WA1+8           POINT R1 AT 1ST 8-BYTE OPERAND
         LA    R2,$WA2+8           POINT R2 AT 2ND 8-BYTE OPERAND
         BAL   R4,ALIGN            ALIGN DECIMALS
         SP    $WA1,$WA2           SUBTRACT 2ND OPERAND FROM 1ST
         ZAP   $RESULT,$WA1        MOVE RESULT TO RESULT FIELD
         MVC   $RESNDEC,$WA1NDEC   SET NDEC FOR RESULT FIELD
        SUBOUT RESTORE=R4          RESTORE & RETURN TO CALLER
         EJECT
***********************************************************************
*        ZEROADD - MOVE 2ND OPERAND TO 1ST OPERAND                    *
***********************************************************************
         SPACE 1
*        ON ENTRY: R1 - RECEIVING FIELD ( 8-BYET PD + 1)
*                  R2 - SOURCE FIELD    ( 8-BYET PD + 1)
         SPACE 1
ZEROADD  SUBIN SAVE=R4             PRESERVE RETURN ADDRESS
         ZAP   0(8,R1),$ZERO       ZEROISE RECEIVING FIELD
         BAL   R4,ALIGN            ALIGN DECIMALS
         ZAP   0(8,R1),0(8,R2)     ZAP SOURCE INTO DESTINATION
        SUBOUT RESTORE=R4          RESTORE &  RETURN TP CALLER
         EJECT
***********************************************************************
*        MULTIPLY - $WA1 BY $WA2                                      *
***********************************************************************
         SPACE 1
MULTRTN  SUBIN SAVE=R4             PRESRRVE RETURN ADDRESS
         LH    R15,$WA1NDEC        GET NDEC OF 1ST OPERAND
         AH    R15,$WA2NDEC        ADD NDEC OF 2ND OPERAND
*                                   TO COMPATE NDEC OF RESULT FIELD
         STH   R15,$RESNDEC        PRESERVE NDEC FOR RESULT
         MP    $WA1,$WA2+8(8)      MULTIPLY 1ST OPERAND BY 2ND
         ZAP   $RESULT,$WA1        MOVE RSULT TO RESULR FIELD
         LA    R1,$RESULT          POINT AT RESULT FIELD
         BAL   R4,SIGNIF           REDUCE TO 15 SIGNIFICAT DIGITS
        SUBOUT RESTORE=R4          RETORE & RETURN TO CALLER
         EJECT
***********************************************************************
*        DIVIDE - $WA1 BY $WA2                                        *
***********************************************************************
         SPACE 1
DIVRTN   SUBIN SAVE=R4             PRESERVE RETURN ADDRSS
         ZAP   $WA3,$WA1           RESERVE ORIGINAL VALUE
         MVC   $WA3NDEC,$WA1NDEC   PRESERVE NDEC OF ORIGINAL VALUE
         ZAP   $WA4,$WA2           PRESERVE ALUE OF DIVISOR
         MVC   $WA4NDEC,$WA2NDEC   PRESERVE NDEC OF DIVISOR
         LA    R1,$WA1             POINT AT 1ST OPERAND
         BAL   R4,MAXDEC           MAXIMISE DECIMAL PLACES
         LA    R1,$WA2             POINT AT 2ND OPERAND
         BAL   R4,MINDEC           MINIMISE DECIMALS WITHOUT LOSING DAT
         DP    $WA1,$WA2+8(8)      DIVIDE 1ST OPERAN  BY 2ND
         ZAP   $RESULT,$WA1(8)     MOVE RESULT TO RESULT FIELD
         LH    R15,$WA1NDEC        RETRIEVE NDEC OF 1ST OPERAND
         SH    R15,$WA2NDEC        SUBTRCT NDEC OF 2ND OPERAND
*                                   TO COMPATE NDEC OF RESULT
         STH   R15,$RESNDEC        PRESERVE NDEC FOR RESULT
         ZAP   $REMANDR,$WA1+8(8)  MOVEREMIANDER TO REMAINDER FLD
        SUBOUT RESTORE=R4          RESTORE & RETURN TO CALLER
         EJECT
***********************************************************************
*        ALIGN - ALIGN DECIMALS WHILE PRESRVING MAX SIGNIFICANCE      *
***********************************************************************
         SPACE 1
*        ON ENTRY: R1 - OPERAND 1 ( 8-BYTE PD + 1-BYTE NDEC )
*                  R2 - OPERAND 2 ( 8-BYTE PD + 1-BYTE NDEC )
         SPACE 1
ALIGN    SUBIN SAVE=R4             PRESERVE RETURN ADDRESS
         CLC   8(2,R1),8(R2)       IS DECIMAL ALIGNMENT ALREADT SAME
         BE    ALIGNX              EXIT FROM ROUTINE IF YES
         LH    R14,8(,R1)          RETRIEVE NDEC FOR 1ST OPERAND IN R14
         LH    R15,8(,R2)          RETRIEVE NDEC FOR 2ND OPERAND IN R15
         CR    R14,R15             DOES 1ST OPERAND HAVE LARGSET NUMBER
         BH    ALIGN01             BR IF 1ST OPERAND HS LARGSET NO OD D
         XR    R14,R15             REVERSE CONTENTS OF ...
         XR    R15,R14              ... R14 AND R15 ...
         XR    R14,R15              ... WITH 3 EXCLUSIVE OR'S
         XR    R1,R2               REVERSE CONTENT ...
         XR    R2,R1                ... OF REGISTERS 1 & 2
         XR    R1,R2                ... WITH 3 EXCLUSIVE 3OR'S
ALIGN01  STH   R14,$PDWANDC        SET NDEC FOR WORK AREA
         ZAP   $PDWA,0(8,R2)       MOVE OPERAND WITH LEAST PLACES TO W/
         SR    R14,R15             COMPATE HOW MANY PLACES TO SHIFT
         SRP   $PDWA,0(R14),5      SHIFT X PLACES TO THE LEFT
         CLC   $PDWA(8),$LOWVALU   HAS SHIFT YIELDED > 15 DIGITS
         BNE   ALIGN02             BR IF > 15 DIGITS
         ZAP   0(8,R2),$PDWA       MOVE SHIFTED VALUE TO OPERAND
         MVC   8(2,R2),8(R1)       SET ADJUSTED NDEC FOR OPERAND
         B     ALIGNX              BR TO ROUTINE EXIT
ALIGN02  LA    R14,$PDWA           POINT AT WORK AREA
         BAL   R4,CNTDIG           CALCULATE HOW MANY XCES DIGITS THERE
         LH    R15,$PDWANDC        RETRIEVE NDEC FOR WORK AREA
         SR    R15,R14             COMPUTE NEW NDEC AFTER RIGHT SHIFT
         STH   R15,8(,R1)          PRESERVE NEW NDEC FOR 1ST OPERAND
         STH   R14,8(,R2)          PRSSERVE NEW NDEC FOR 2ND OPERAND
         TM    CB36SW,SW36NRND     IS ALL ROUNDING SUPPRESSED
         BZ    *+20                BR IF RUNDING NOT SUPPRESSED
         SRP   0(8,R1),0(R14),0    SHIFT 1ST OPERAND AS NECESSARY
         SRP   $PDWA,0(R14),0      SHIFT 2ND OPERAND INTIN W/A
         B     *+16                BYPASS ROUNDED SHIFTS
         SRP   0(8,R1),0(R14),5    SHIFT & ROUND 1ST OPERAND AS NECESSA
         SRP   $PDWA,0(R14),5      SHIFT & ROUND 2NE OPERAND IN W/A
         ZAP   0(8,R2),$PDWA       MOVE 2ND OPERND BACK TO SOURCE
ALIGNX  SUBOUT RESTORE=R4          RESTORE & RETURN TO CALLER
         EJECT
***********************************************************************
*        ALIGN1 - ADJUST 2ND OPERAND TO DECAIMAL ALIGNMENT OF 1ST     *
***********************************************************************
         SPACE 1
*        ON ENTRY: R1 - 1ST OPERAND ( 8-BYTE PD + 1-BYTE NDEC )
*                  R2 - 2ND OPERAND ( 8-BYTE PD + 1-BYTE NDEC )
         SPACE 1
*        ON RETURN :
*                  BE  - ALIGNMENT COMPLETED
*                  BNE - LOSS OF SIGNIFICANCE WOULD RESULT - BYPASSED
         SPACE 1
ALIGN1   SUBIN SAVE=R4             PPRESERVE RETURN ADDRESSS
         CLC   8(2,R1),8(R2)       IS ALIGNMENT ALREADY THE SAME
         MVI   ALIGN1T+1,$Y        ASSUME WE WILL LOOSE SIGNIFICANCE
         ZAP   $PDWA,0(8,R2)       MOVE 2ND OPERAND TO WORK AREA
         LH    R14,8(,R1)          RETRIEVE NDEC FOR 1ST OPERAND
         SH    R14,8(,R2)          SUBTRACT NDEC FOR 2ND OPERAND
*        THIS DETERMINES DIRECTION & AMOUNT OF SHIFT
         TM    CB36SW,SW36NRND     IS ALL ROUNDING SUPPRESSED
         BZ    *+14                BR IF NOT
         SRP   $PDWA,0(R14),0      SHIFT AS NECESSARY
         B     *+10                BYPASS ROUNDED SHIFT
         SRP   $PDWA,0(R14),5      SHIFT AND ROUND AS NESACSARY
         CLC   $PDWA(8),$LOWVALU   ARE THERE NOW MORE THAN 15 DIGITS
         BNE   ALIGN1T             BYPASS PERMANENT SHIFT IF >15 DIGITS
         MVI   ALIGN1T+1,$X        SHOW THAT ALIGNMENT COMPLETED
         ZAP   0(8,R2),$PDWA       MOVESHIFTED VALUE T SIURCE FIELD
         MVC   8(1,R2),8(R1)       SET NDEC OF 2ND OPERAND TO THAT OF 1
ALIGN1T  CLI   *,$X                SET COND CODE FOR CALLER
        SUBOUT RESTORE=R4          RETURN TO CALLER
         EJECT
***********************************************************************
*        MINDEC - MINIMISE NO OF DECIMAL PLACES WITHOUT LOSING DATA   *
***********************************************************************
         SPACE 1
*        ON ENTRY: R1 - 16-BYTE PD + 1-BYTE NDEC
         SPACE 1
MINDEC   SUBIN SAVE=R4             PRESERVE RETURN ADDRESS
         CP    0(16,R1),ZERO       IS VALUE ZERO
         BE    MINDECX             BYPASS ROUTINE IF ZERO VALUE
         LH    R15,16(,R1)         RETRIEVE NDEC FOR 1ST OPERAND
MINDEC1  TM    15(R1),X'F0'        IS JUNIOR DIGIT NON-ZERO
         BNZ   MINDEC2             BR IF NON-ZERO DIGIT
         SRP   0(16,R1),RSHIFT1(R0),5 SHIFT 1 DIGIT TO RIGHT
         BCTR  R15,0               DEVREMENT NDEC COUNT
         B     MINDEC1             LOP BACK TO TEST NEW LAST DIGIT
MINDEC2  STH   R15,16(R1)          PRESERVE UPDATED NDEC
MINDECX SUBOUT RESTORE=R4          RETURN TO CALLER
         EJECT
***********************************************************************
*        MAXDEC - MAXIMISE NO F DECIAMALS WITHOUT LOSING SIGNIFICANCE *
***********************************************************************
         SPACE 1
*        ON ENTRY: R1 - 16-BYTE PD + 1-BYT NDEC
         SPACE 1
MAXDEC   SUBIN SAVE=R4             PRESEREV RETURN ADDRESS
         CP    0(16,R1),ZERO       IS VALUE ZERO
         BE MAXDECX                BYPASS ROUTINE IF ZERO VALUE
         LA    R14,8(,R1)          POINT R14 AT LAST 8 BYTES OF PD FLD
         BAL   R4,CNTDIG           DETERMINE NO OF SIGNIFICANT DIGITS
         SPACE 1
*        DUE TO THE NATURE OF 'CNTDIG', R14 WILL CONTAIN ZERO IF THE
*         SOURCE FIELD CONTAINS ONLY 1 DIGIT, AND IT IMMEDIATELY
*         PRECEDES THE SIGN.  THIS WILL RESULT IN AN INCORRECT 16 DIGIT
*         LEFT SHIFT, AND A POTENTIAL 0CB ABEND IN THE DIVIDE ROUTINE,
*         SO WE MUST DETECT AND ADJUST.
         SPACE 1
         LTR   R14,R14             TEST IF R14 CONTAINS ZERO
         BNZ   *+12                BR IF NOT 0 TO NORMAL ADJUST FOR SHI
         LA    R14,14              ESTABLISH CORRECT 14 DIGIT SHIFT
         B     *+10                BR OVER OTHER ADJUSTMENT
         SPACE 1
         LCR   R14,R14             REVERSE SIGN OF NDEC ...
         LA    R14,16(,R14)         ... AND ADD 16 TO NEGATIVE NO
*                                  THIS YIELDS NO OF LEADING ZEROES
         SRP   0(16,R1),0(R14),5   MOVE TO LEFT BY NO OF LEADING ZEROES
         AH    R14,16(,R1)         ADD PRIOR NDEC TO NO OF DIGITS MOVED
         STH   R14,16(,R1)         PRESERVE ADJUSTED NDEC
MAXDECX SUBOUT RESTORE=R4          RESORE & RETURN TP CALLER
         EJECT
***********************************************************************
*        SIGNIF - REDUCE FIELD TO 15 SIGNIFICANT DIGITS               *
***********************************************************************
         SPACE 1
*        ON ENTRY: R1 - 16-BYTE PD + 1-BYTE NDEC
*        ON EXIT:  BE  - FIELD ADJUSTED TO 15 CHARACTERS
*                  BNE - NO ADJUSTMENT REQUIRED
         SPACE 1
SIGNIF   SUBIN SAVE=R4             PRESERVE RETURN ADDRESS
         MVI   SIGNIFT+1,$Y        ASSUME NO ADJUSTMENT REQUIRED
         CLC   0(8,R1),$LOWVALU    TEST IF > 15 DIGITS NOW PRSEENT
         BE    SIGNIFT             BR IF NO ADJUSTMENT REQUIRED
         MVI   SIGNIFT+1,$X        SHOW THAT ADJUSTMENT WAS MADE
         LR    R14,R1              POINT R14 AT FLD
         BAL   R4,CNTDIG           DETERMINE HOW MANY DIGITS TO SHIFT
         LCR   R14,R14             REVERSE SIGN FO PURPOSE OF 'SRP'
         TM    CB36SW,SW36NRND     IS ALL RUNDING SUPPRESSED
         BZ    *+14                BR IF ROUNDED
         SRP   0(16,R1),0(R14),0   SHIFT OUT EXCESS DIGITS
         B     *+10                BYPASS ROUNDED SHIFT
         SRP   0(16,R1),0(R14),5   SHIFT OUT EXCES DIGITS AND ROUND
         AH    R14,16(,R1)         ADD NDEC TO ADJUST FOR EARLIER 'SRP'
         STH   R14,16(,R1)         PRESERVE ADJUSTED NDE
SIGNIFT  CLI   *,$X                SET CONDITION CODE FOR CALLER
        SUBOUT RESTORE=R4          RETURN TO CALLER
         EJECT
***********************************************************************
*        CNTDIG - COUNT NO OF DIGITS > 15 IN 16-BYTE FIELD            *
***********************************************************************
         SPACE 1
*        ON ENTRY: R14 - ADDRESS OF 16-BYTE PG FIELD
*        ON RETURN R14 - COUNT OF NO OF SIGNIFICANT DIGITS IN 1ST 8 BYT
         SPACE 1
*        THE FOLLOWING ROUTINE EWAMINES THE FIRST 8 BYTES OF THE PD
*         FIELD AND DEVELOPS A RATHER CLEVER LITTLE ALGORITHM TO
*         DETERMINE THE NUMBER OF SIGNIFICANT DIGITS THEREIN.
*        THE ALTERNATIVE TO THIS ALGORITHM IS AN 'SRP' LOOP.  THE
*         ALGORITHM IS INCREASINGLY MORE EFFICIENT AS THE NUMBER OF
*         SIGNIFICANT DIGITS IS LESS, AND IS ONLY OUT-PERFORMED BY THE
*         LOOP IN THE CASE OF 16 SIGNIFICANT DIGITS ( AN UNLIKELY
*         OCCURRENCE ).
         SPACE 1
*        THE ALGORITHM IS
*              N = (((8-D)*2)+1)-F
*        WHERE N IS NO OF SIGNIFICANT DIGITS ( IN THE RANGE 1 - 16 )
*              D IS THE DISPLACEMENT OF THE 1ST NON-ZERO BYTE ( 0 - 7 )
*              F IS THE FUNCTION BYTE RETURNED BY 'TRT' ( X'01' OR X'02
         SPACE 1
CNTDIG   SUBIN SAVE=(R1,R2)        PRESERVE REGISTER CONTENTS
         SR    R2,R2               ZEROISE WORK REGISTER
         TRT   0(8,R14),PDTABLE    EXAMINE 1ST 8 BYTES FOR NON-ZERO
         BE    CNTDIG0             IF ALL BYTES ZERO THEN NO SIGNIF
         SR    R1,R14              DETERMINE DISPLACEMENT OF NONZERO BY
         LCR   R1,R1               REVERSE THIS DISPLACEMENT (-D) ...
         LA    R1,8(,R1)            ... AND ADD 8 TO YIELD (8-D)
         SLL   R1,1                MULTIPLY (8-D) BY 2
         LA    R1,1(,R1)           INCREMENT BY 1 TO YOELD (((8-D)*2)+1
         SR    R1,R2               SUBTRACT FUCTION BYTE FROM TRT
*                                  THIS GIVES (((8-D)*2)+1)-F
         LR    R14,R1              SET NO OF SIGNIF DIGITS IN R14
         B     *+6                 BR TO ROUTINE EXIT
CNTDIG0  SR    R14,R14             ZEROISE R14 IF ALL ZEROES
        SUBOUT RESTORE=(R1,R2)     RESTORE REGISTERS & RETURN
         SPACE 1
         DROP  R10                 DROP CB36 ADDRESSABILITY
         EJECT
*        THE FOLLOWING TABLE IS USED TO LOCATE THE 1ST NON-ZERO BYTE
         SPACE 1
PDTABLE  EQU   *
         DC    X'00'               '00'
         DC    9X'02',6X'03'       '01' - '09', '0A' - '0F'
         DC    10X'01',6X'03'      'N0' - 'N9', 'NA' -'NF'
         DC    10X'01',6X'03'      'N0' - 'N9', 'NA' -'NF'
         DC    10X'01',6X'03'      'N0' - 'N9', 'NA' -'NF'
         DC    10X'01',6X'03'      'N0' - 'N9', 'NA' -'NF'
         DC    10X'01',6X'03'      'N0' - 'N9', 'NA' -'NF'
         DC    10X'01',6X'03'      'N0' - 'N9', 'NA' -'NF'
         DC    10X'01',6X'03'      'N0' - 'N9', 'NA' -'NF'
         DC    10X'01',6X'03'      'N0' - 'N9', 'NA' -'NF'
         DC    10X'01',6X'03'      'N0' - 'N9', 'NA' -'NF'
         DC    96X'04'             'A0' - 'FF'
         SPACE 1
*        THE SIGNIFICANCE OF THE FUNCTION BYTES IS:-
*        '00' - SOURCE BYTE CONTAINS LOW VALUES
*        '01' - 1ST HALF OF SOURCE BYTE CONTAINS DIGIT (NN)
*        '02' - 2ND HALF OFSOURCE BYTE CONTAINS DIGIT (0N)
*        '03' - SOURCE BYTE CONTAINS DIGIT AND SIGN
*        '04' - 1ST HALF OF SOURCE BYTE CONTAINS A - F (INVALID)
         EJECT
***********************************************************************
*        MATHS ROUTINES WORJ AREAS                                    *
***********************************************************************
         SPACE 1
         DS    0F                  ENSURE ALIGNMENT
NDECMASK DC    X'FFFFFFC0'         PROPAGTAE SIGN THRU REGISTER
OP1      DS    PL8                 1ST OPERAND
OP1NDEC  DS    H                   NDEC OF 1ST OPERAND
OP2      DS    PL8                 2ND OPZRAND
OP2NDEC  DS    H                   NDEC OF 2ND OPERAND
$WA1     DS    PL16                WORJ AREA FOR 1ST OPERAND
$WA1NDEC DS    H                   NDEC FOR 1ST OPERAND'S W/A
$WA2     DS    PL16                WORK AREA FOR 2ND OPERAND
$WA2NDEC DS    H                   NDEC FOR 2ND OPERAND'S W/A
$WA3     DC    PL16'0'             THIRD WORK RAEA (FOR REMAINDER)
$WA3NDEC DC    H'0'                NDEC OF 3RD WRK AREA
$WA4     DC    PL16'0'             FOURTH WORK AREA ( FRO REMAINDER )
$WA4NDEC DC    H'0'                NDEC FOR FOURTH WORK AREA
$PDWA    DS    PL16                GENERAL PURPOSE PD W/A
$PDWANDC DS    H                   NO OD DECIMALS FOR W/A
$PDWACNT DS    PL16                WORKA AREA FOR 'CNTDIG^ ROUTINE
$RESULT  DS    PL16                RESULT OF MATHS OPERATION
$RESNDEC DS    H                   NO OF DECIMAL PLACES IM RESULT
$REMANDR DS    PL16                REMAINDER FROM MATHEMATICLA OPERATIO
$REMNDEC DS    H                   NO OF DECIMAL PLACES IN REMAINDER
$X       EQU   X'95'
$Y       EQU   X'96'
$LOWVALU DC    X'0000000000000000'
$ZERO    DC    PL1'0'
RSHIFT1  EQU   X'3F'               'SRP' SHIFT 1 POSN TO RIGHT
         SPACE 1
         CNOP  0,8                 ENSURE LENGTH I SMULTIPLE OF 8
FREEC7X  EQU   *                   END OF POTENTIAL FREEAMIN AREA
         EJECT
***********************************************************************
*        C8 - ALIGN FLOATING DECIMAL FIELD                            *
***********************************************************************
         SPACE 1
         USING CB37NTRY,R2         ESTABLISH CB37 ADDRESSABILITY
JTESTC8  SUBIN ,                   ALIGN FLOATING DECIMAL
         CBAL  ,TESTRTN            PREPARE TO RETURN TO CALLER
         DROP  R2                  DROP CB37 ADDRESSABILITY
         DROP  R8                  DROP CB13 ADDRESSABILITY
         EJECT
         EJECT
***********************************************************************
*        R3 - EXPAND BYTE OF SWITCHES                                 *
***********************************************************************
         SPACE 1
JTESTR3  SUBIN ,                   ENTER ROUTINE
         MVC   1(8,R6),SPACES      BLANK OUT RECEIBING AREA
         TM    0(R6),X'01'         IS SWITCH ON
         BZ    *+8                 BR IF SWITCH IS OFF
         MVI   8(R6),C'1'          SET CORRESPONDING BYET ON
         TM    0(R6),X'02'         IS SWITCH ON
         BZ    *+8                 BR IF SWITCH IS OFF
         MVI   7(R6),C'1'          SET CORRESPONDING BYET ON
         TM    0(R6),X'04'         IS SWITCH ON
         BZ    *+8                 BR IF SWITCH IS OFF
         MVI   6(R6),C'1'          SET CORRESPONDING BYET ON
         TM    0(R6),X'08'         IS SWITCH ON
         BZ    *+8                 BR IF SWITCH IS OFF
         MVI   5(R6),C'1'          SET CORRESPONDING BYET ON
         TM    0(R6),X'10'         IS SWITCH ON
         BZ    *+8                 BR IF SWITCH IS OFF
         MVI   4(R6),C'1'          SET CORRESPONDING BYET ON
         TM    0(R6),X'20'         IS SWITCH ON
         BZ    *+8                 BR IF SWITCH IS OFF
         MVI   3(R6),C'1'          SET CORRESPONDING BYET ON
         TM    0(R6),X'40'         IS SWITCH ON
         BZ    *+8                 BR IF SWITCH IS OFF
         MVI   2(R6),C'1'          SET CORRESPONDING BYET ON
         TM    0(R6),X'80'         IS SWITCH ON
         BZ    *+8                 BR IF SWITCH IS OFF
         MVI   1(R6),C'1'          SET CORRESPONDING BYET ON
         CBAL  ,TESTRTN            PREPARE TO RETURN TO CALLER
         EJECT
***********************************************************************
*        R4 - COMPRESS 8 FLAGS INTO ONE BYTE                          *
***********************************************************************
         SPACE 1
JTESTR4  SUBIN ,                   ENTER ROUTINE
         MVI   0(R6),X'00'         BLANK OUT RECEIVING AREA
         CLI   1(R6),C' '          IS SWITCH/FLAG ON
         BE    *+8                 BR IF SWITCH/FLAG NOT ON
         OI    0(R6),X'80'         SET CORRESPONDING BIT ON
         CLI   2(R6),C' '          IS SWITCH/FLAG ON
         BE    *+8                 BR IF SWITCH/FLAG NOT ON
         OI    0(R6),X'40'         SET CORRESPONDING BIT ON
         CLI   3(R6),C' '          IS SWITCH/FLAG ON
         BE    *+8                 BR IF SWITCH/FLAG NOT ON
         OI    0(R6),X'20'         SET CORRESPONDING BIT ON
         CLI   4(R6),C' '          IS SWITCH/FLAG ON
         BE    *+8                 BR IF SWITCH/FLAG NOT ON
         OI    0(R6),X'10'         SET CORRESPONDING BIT ON
         CLI   5(R6),C' '          IS SWITCH/FLAG ON
         BE    *+8                 BR IF SWITCH/FLAG NOT ON
         OI    0(R6),X'08'         SET CORRESPONDING BIT ON
         CLI   6(R6),C' '          IS SWITCH/FLAG ON
         BE    *+8                 BR IF SWITCH/FLAG NOT ON
         OI    0(R6),X'04'         SET CORRESPONDING BIT ON
         CLI   7(R6),C' '          IS SWITCH/FLAG ON
         BE    *+8                 BR IF SWITCH/FLAG NOT ON
         OI    0(R6),X'02'         SET CORRESPONDING BIT ON
         CLI   8(R6),C' '          IS SWITCH/FLAG ON
         BE    *+8                 BR IF SWITCH/FLAG NOT ON
         OI    0(R6),X'01'         SET CORRESPONDING BIT ON
         CBAL  ,TESTRTN            PREPARE TO RETURN TO CALLER
         SPACE 1
         CNOP  0,8                 ENSURE CSECT LENGTH IS MULTIPLE OF 8
LGTHJ    EQU   *                   END OF CSECT BUDGIE3J
BUDGIE3  CSECT
         DROP  R11                 DROP SUB-CSECT ADDRESSABILITY
         TITLE 'BUDGIE3O - TEST ROUTINES'
        SCSECT O                   START CSECT BUDGIE3O
         SPACE 1
*        ON ENTRY, THE REGISTERS ARE SET THUS:-
*        R15 - END OF FIELD TO BE TESTED
*        R14 - START OF FIELD TO BE TESTED
*        R10 - ADDRESS OF CURRENT CB02
*        R8  - ADDRESS OF CURRENT CB13
*        R6  - ADDRESS OF FIELD IN RECORD
*        R4  - TEST CODE * 4 ( HAS BEEN USED FOR INDEXED BRANCH )
*        R2  - ADDRESS OF ASSOC C/B ( WHERE RELEVANT )
*        R1  - EXECUTABLE LENGTH OF FIELD UNDER TEST
         SPACE 5
*        THE VARIOUS ROUTINES IN THIS CSECT RECEIVE CONTROL FROM THE
*         INDEXED BRANCH AT THE START OF BUDGIE3B, USING R9 TO
*         ESTABLISH TEMPORARY ADDRESSABILITY.  THUS, THE FIRST INSTRUCT
*         IN EACH OF THESE ROUTINES MUST BE TO SET THE ADDRESS OF
*         BUDGIE3O IN R11 TO ESTABLISH PERMANENT ADDRESSABILITY.
         SPACE 5
***********************************************************************
*        RETURN TO BUDGIE3B FOR TERMINATION PROCESSING                *
***********************************************************************
         SPACE 1
OTESTRTN CBAL  ,TESTRTN            TRANSFER CONTROL TO BUDGIE3B
         TITLE 'BUDGIE3O - PARTIAL KEY MATCHING'
***********************************************************************
*        E1 - PARTIAL KEY MATCH                                       *
***********************************************************************
         SPACE 1
         USING CB33NTRY,R2         ESTABLISH CB33 ADDRESSAILITY
         USING CB13NTRY,R8         ESTABLISH CB13 ADDRESSABILITY
         CNOP  0,8                 ENSURE CODING STARTS ON DOUBLEWORD
FREEE1S  EQU   *                   START OF POTENTIAL FREEMAIN AREA
         SPACE 1
*        THIS CLEVER LITTLE ROUTINE ( EXTRACTED FROM THE SUBROUTINE
*         UT493 ), COMPARES A TEST KEY WITH THE NON-BLANK PAORTIONS OF
*         A MASTER KEY.  THE ROUTINE PERFROMS THIS FUNCTION AT THE FIEL
*         LEVEL, AND NOT BYTE BY BYTE.  IT ACCOMPLISHES THIS BY :-
*              . SET NON-BLANK PORTION OF PARTIAL KEY TO X'FF', AND SET
*                BLANKS TO X'00'
*              . SET TO LOW VALUES THE PARTS OF THE KEY UNDER TEST THAT
*                CORRESPOND TO BLANKS IN THE MASTER PARTIAL KEY
*              . RESTORE THE NONBLANK PORTIONS OF THE MASTER KEY,
*                LEAVING THE BLANK PARTS SET TO X'00'
*              . ALTER THE 'MUST BE BLANK' CHARACTER IN THE MASTER KEY
*                TO BLANKS
*              . COMPARE THE MODIFIED KEYS.  IN EACH KEY, THE POSNS
*                CRRESPONDING TO BLANKS IN THE PARTIAL KEY ARE X'00', A
*                WILL GIVE EQUALITY REGARDLESS OF ORIGINAL CONTENTS.
*        NOTE THAT BOTH THE ORIGINAL KEYS HAVE BEEN LEFT UNSULLIED.
*         ALL CHANGES HAVE BEEN TO THE WORK AREAS.
         SPACE 1
TESTE1   SUBIN ,                   ENTER ROUTTINE
         L     R11,VBUDG3O         ESTABLISG PARMANENT ADDRESSABILITY
         OC    CB33POS2(2),CB33POS2 TEST IF 'TO' FIELD SUPPLIED
         BZ    TESTE101            IF NOT, ASSUME SSPECIFIED IN MS13
         SR    R2,R2               ZEROISE WORK REGISTER
         IC    R2,CB33POS2         RETIREVE POSN OF FIELD TO BE TESTED
         BCTR  R2,0                DECREMENT POSN TO DISPLACEMENT
         A     R2,SYSUT1+IOPSRECA  POINT R2 AT FIELD TO BE TESTED
         SR    R1,R1               ZEROISE WORK REGISTER
         IC    R1,CB33LEN2         GET LENGTH OF FIELD
         BCTR  R1,0                DRECEMENT FOR EXECUTE
         EX    R1,TESTMVC          MOVE FIELD TO 'TESTAREA'
TESTE101 BBMESS 17                 SET UP DEFAULT MESSAGE
         SR    R15,R15             ZEROISE WORK REGISTER
         IC    R15,UT493MBB        PICK UP 'MUST BE BLANK' CHARACTER
         IC    R14,SPACES          SET X'40' IN WORK REGISTER
         STC   R14,E1TABLE1(R15)   MODIFY TABLE FOR 'MUST BE BLANK'
         LR    R15,R1              SET EXECUTABLE LENGTH IN R15
         MVC   TESTAREA+50(50),CB33LIT MOVE 'PARTIAL' KEY TO WORKING AR
         EX    R15,E1TRTEST        TRANSLATE PARTIAL KEY TO X'FF' BAR B
         EX    R15,E1NCMAST        SET TEST KET BL TO X'00'
         EX    R15,E1NCTEST        RESTORE PARTIAL KEY WITH BL SET X'00
         EX    R15,E1TRTAB         SET 'MBB' CHAR TO BLANK
         SR    R1,R1               ZEROISE WORK REGISTER
         IC    R1,CB33TYPE         SET COMPARE TYPE
         EX    R15,E1COMPAR        COMPARE NONBLANK PARTS OF KEYS
         CBAL  R4,COMPARE          TEST RESULT OF COMPARE
         BE    *+8                 B IF EQUAL
         MVI   TESTTSTX,C'Y'       INDICATE KEYS NOT EQUAL
        SUBOUT RETURN=OTESTRTN     PREPARE TO RETURN TO CALLER
         EJECT
***********************************************************************
*        TRANSLATE TABLES FOR THE PRTIAL KEY MATCH                    *
***********************************************************************
         SPACE 1
E1TABLE1 DS    0C                  TABLE TO LATER 'MUST BE BLANK' TO BL
         DC    X'000102030405060708090A0B0C0D0E0F'
         DC    X'101112131415161718191A1B1C1D1E1F'
         DC    X'202122232425262728292A2B2C2D2E2F'
         DC    X'303132333435363738393A3B3C3D3E3F'
         DC    X'404142434445464748494A4B4C4D4E4F'
         DC    X'505152535455565758595A5B5C5D5E5F'
         DC    X'606162636465666768696A6B6C6D6E6F'
         DC    X'707172737475767778797A7B7C7D7E7F'
         DC    X'808182838485868788898A8B8C8D8E8F'
         DC    X'909192939495969798999A9B9C9D9E9F'
         DC    X'A0A1A2A3A4A5A6A7A8A9AAABACADAEAF'
         DC    X'B0B1B2B3B4B5B6B7B8B9BABBBCBDBEBF'
         DC    X'C0C1C2C3C4C5C6C7C8C9CACBCCCDCECF'
         DC    X'D0D1D2D3D4D5D6D7D8D9DADBDCDDDEDF'
         DC    X'E0E1E2E3E4E5E6E7E8E9EAEBECEDEEEF'
         DC    X'F0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF'
         SPACE 5
E1TABLE2 DS    0C                  USED TO NULLIFY BLANKS
         DC    64X'FF'             EVERYTHING EXCEPT ...
         DC    X'00'                ... BLANK ...
         DC    191X'FF'             ... IS HIGH VALUES
         SPACE 5
***********************************************************************
*        EXECUTED INSTRUCTIONS                                        *
***********************************************************************
         SPACE 1
E1TRTEST TR    TESTAREA+50(0),E1TABLE2 TRANSLATE PARTIAL KEY BL TO '00'
E1NCMAST NC    TESTAREA(0),TESTAREA+50 TURN OFF UNTESTED PARTS OF TESTF
E1NCTEST NC    TESTAREA+50(0),CB33LIT  TURN OF  BL IN PARTIAL KEY
E1TRTAB  TR    TESTAREA+50(0),E1TABLE1 TRANSLATE MBB CHAR TO BLANK
E1COMPAR CLC   TESTAREA(0),TESTAREA+50 COMPARE MODIFIED KEYS
         SPACE 1
         DROP  R8,R2               DROP ADDRESSABILITY
         CNOP  0,8                 ENSURE LENGTH IS MULTIPLE OF 8
FREEE1X  EQU   *                   END OF POTENTIAL FREEMAIN AREA
         EJECT
**********************************************************************
*        E2 - PROPAGATE CHARACTER STRING                              *
**********************************************************************
         SPACE 1
         USING CB13NTRY,R8         ESTABLISG CB13 ADDRESSABILITY
TESTE2   SUBIN ,                   ENTER ROUTINE
         L     R11,VBUDG3O         ESTABLISH PERMANENT ADDRESSABILITY
         MVC   0(1,R6),CB13CBID    MOVE IN 1ST CHARCATER
         LTR   R1,R1               TEST IF FIELD ONLY 1 BYTE LONG
         BZ    TESTE2X             EXIT IF 1 BYTE
         MVC   1(1,R6),CB13CBID+1  MOVE IN 2ND CHARACTER
         BCTR  R1,0                DECREMENT FOR EXECUTE
         LTR   R1,R1               TEST IF FIELD ONLY 2 BYTES LONG
         BZ    TESTE2X             BR IF FIELD LENGTH WAS 2
         BCTR  R1,0                DECREMENT FOR EXECUTE AGAIN
         EX    R1,TESTE2MV         PROPAGATE CHARACTERS
TESTE2X SUBOUT RETURN=OTESTRTN     PREPARE RO RETURN
         SPACE 1
TESTE2MV MVC   2(0,R6),0(R6)       EXECUTED 2-CHR PROPAGATION
         SPACE 1
         DROP  R8                  DROP CB13 ADDRESSABILITY
         SPACE 5
**********************************************************************
*        E3 - MOVE 'ERROR MESSGAE' CONTENTS TO FIELD                  *
**********************************************************************
         SPACE 1
         USING CB13NTRY,R8         ESTABLISH CB13 ADDRESSABILITY
TESTE3   SUBIN ,                   ENTR ROUTINE
         L     R11,VBUDG3O         ESTABLISG PERMANENT ADDRESSABILITY
         EX    R1,TESTE3MV         MOVE LITERAL TO FIELD
        SUBOUT RETURN=OTESTRTN     PREPARE TO RETURN
         SPACE 1
TESTE3MV MVC   0(0,R6),CB13MESS    EXECUTED MOVE OF LITERAL
         SPACE 1
         DROP  R8                  DROP CB13 ADDERSSABILITY
         EJECT
**********************************************************************
*        E4 - REMOVE ALL EMBEDDED BLANKS AND LEFT-JUSTIFY             *
**********************************************************************
         SPACE 1
TESTE4   SUBIN ,                   ENTER ROUTINE
         L     R11,VBUDG3O         NENT ADDRESSABILITY
         EX    R1,TESTCLC          IS FIELD ALL SPACES ALREADY
         BE    TESTE4X             EXIT IF SPACES
         LTR   R1,R1               TEST IF FIELD LENGTH IS 1
         BZ    TESTE4X             EXIT IF FIELD LENGH3 1
         LR    R14,R6              POINT R14 AT START OF FIELD
         AR    R14,R1              POINT R14 AT END OF FIELD
         LR    R15,R1              SET R15 TO EXECUTABLE LENGTH
         BCTR  R15,0               DECREMENT BY 1 FOR LEFT ADJUSTM&NT
TESTE4L1 EX    R1,TESTE4SP         TEST IF REMAINDER ALL SPACES
         BE    TESTE4X             EXIT IF YES
         CLI   0(R6),C' '          TEST IF THIS BYTE IS BLANK
         BNE   TESTE4L2            BR IF NOT BLANK
         EX    R15,TESTLJST        LEFT JUSTIFY OVER BLANK
         MVI   0(R14),C' '         INSERT TRAILING BLANK
         B     TESTE4L1            GO BACK TO SEE IF STILL BLANK
TESTE4L2 LA    R6,1(,R6)           POINT AT NEXT POSITION
         BCTR  R15,0               DECREMENT R15 FOR NEXT TIME THROUGH
         BCT   R1,TESTE4L1         DECREMENT R1 FOR EXECUTE
*                                   FALL THROUGH IF ALL GONE
TESTE4X SUBOUT RETURN=OTESTRTN     PREPARE TO RETURN TO CALLER
         SPACE 1
TESTE4SP CLC   0(0,R6),SPACES      TEST IF REMAINDER IS BLANK
         SPACE 1
         CNOP  0,8                 ENSURE CSECT LENGTH IS MULTIPLE OF 8
LGTHO    EQU   *                   END OF CSECT BUDGIE3O
BUDGIE3  CSECT
         DROP  R11                 DROP BUDGIE3O ADDRESSSABILITY
         TITLE 'BUDGIE3H - DETERMINE INTERNAL REPRESENTATION'
        SCSECT H                   RESTART CSECT BUDGIE3H
***********************************************************************
*        THIS ROUTINE DETERMINES WHETHER OR NOT A FIELD CONTAINS      *
*         A TEST REQUEST.  AT ENTRY, R2 POINTS AT THE FIELD TO        *
*         BE TESTED, AND AT EXIT, R1 POINTS AT THE APPROPRIATE        *
*         TEST TABLE ENTRY, IF RELEVANT.  THE CONDITION CODE IS       *
*         SET SUCH THAT UPON RETURN THE CALLER CAN -                  *
*              BE  - FIELD CONTAINS TEST REQUEST                      *
*              BNE - FIELD DOES NOT CONTAIN TEST REQUEST              *
***********************************************************************
         SPACE 1
TESTINTL SUBIN ,                   DETERMINE IF TEST REQUEST
         MVI   TESTY,C'X'          ASSUME MATCH FOUND AND SET FOR CC
         ADDR  TESTTABL,I          POINT AT TABLE OF VALID CODES
TESTI1   CLC   0(2,R2),0(R1)       COMPARE FIELD WIRH TABLE
         BE    TESTI2              BRANCH IF EQUAL FOR TEST FOUNF
         LA    R1,4(,R1)           INCREMENT TO NEXT ENTRY
         CLC   0(4,R1),=C'****'    TEST FOR END OF TABLE
         BNE   TESTI1              LOOP BACK IF NOT
         MVI   TESTY,C'Y'          SHOW MATCH NOT FOUND
         B     TESTI3              GO SET COND CODE
TESTI2   CLI   0(R1),C'D'          IS THIS A DATE VALIDATEIOM REQUEST
         BNE   *+8                 BR IF NOT DATE TEST
         OI    SWINIT,SWLDDATE     SET TO LOAD UT457
         CLC   0(2,R1),=C'L9'      TEST FOR CURRECY CONVERSION
         BE    *+10                BR IF YES TO SET SWIRCH
         CLC   0(2,R1),=C'L6'      IS THIS A CURRENCY TEST
         BNE   *+8                 BR IF NOT CURR CDE VALIDATION
         OI    SWINIT,SWLD435      SET TO LOAD UT435
         CLC   0(2,R1),=C'J '      IS THIS A RIGAM REQUEST
         BNE   *+8                 BR IF NOT RIGAM
         OI    SWINIT,SWLDRIGM     SET TO LOAD RIGAM
         CLC   0(2,R1),=C'L9'      IS THIS CURRENCY CONVERSION
         BNE   *+8                 BR IF NOT CURRENCY CONVERSION
         OI    SWINIT,SWLD435      SET TO OLAD UT435
TESTI3   CLC   TESTX,TESTY         SET COND CODE FOR CLLLER
        SUBOUT ,                   RETURN TO CALLER
         SPACE 1
TESTX    DC    C'X'                CONSTANT
TESTY    DC    C' '                ALTERED TO SET CONDITION CODE
         TITLE 'BUDGIE3H - PARM FIELD PROCESSING'
***********************************************************************
*        THIS SUB-ROUTINE RETRIEVES SUB-FIELDS FROM THE PARM          *
*         FIELD IN THE EXEC STATEMENT.  ON RETURN, R2 CONTAINS THE
*         SUB-FIELD ADDRESS AND R3 CONTAINS THE LENGTH.  THE CONDITION
*         CODE IS SET SUCH THAT THE USER CAN MAKE THE FOLLOWING TESTS -
*              BE  - PARM SUB-FIEOLD FOUNF
*              BNE - PARM IS EXHAUSTED
***********************************************************************
         SPACE 1
PARMGET  SUBIN SAVE=(R7,R8,R9,R4)  PRESEVRE REGISTERS
         MVI   PARMTSTX,C'Y'       ASSUME PARM EXHUASTED
         LM    R7,R9,PARMR7R9      RETRIEVE R7 AND R8 VALUES & R9
PARM1TME CBAL  R4,PARMINIT         1ST TIME ONLY, INITIALISE POINTERS
PARMGET2 LA    R8,1                ESTABLISH BXLE INCREMENT
         CR    R7,R9               TEST IF PARM EXHAUSTED
         BNL   PARMGX1             EXIT IF PARM EXHAUSTED
PARMGET3 LR    R2,R7               POINT R2 AT START OF SUBFIELD
PARMLOOP CLI   0(R7),C','          TEST FOR COMMA
PARMT1   BE    PARMLGTH            BRANCH IF YES UNLESS WAITING FOR '
         CLI   0(R7),C'('          TEST FOR START OF PARENTHESIS
         BNE   *+8                 BR IF NOT
         NI    PARMT1+1,X'0F'      NULLIFY ','TEST UNTIL END PARENTHESI
         CLI   0(R7),C')'          TEST FOR       PARENTHESIS
         BNE   *+8                 BRANCH IF NOT
         OI    PARMT1+1,X'80'      ALLOW SCAN FOR COMMA
         BXLE  R7,R8,PARMLOOP      TEST NEXT CHARACTER UNLESS END
         SPACE 3
***********************************************************************
*        CONT'D OVERLEAF                                              *
***********************************************************************
         EJECT
***********************************************************************
*        RETRIEVE PARM SUB-FIELDS ( CONT'D )                          *
***********************************************************************
PARMLGTH LR    R3,R7               POINT AT END OF SUBFIELD
         SR    R3,R2               DETERMINE SUBFIELD LENGTH
         LA    R7,1(,R7)           POINT AT START OF NEXT SUBFIELD
         STM   R7,R9,PARMR7R9      PRESERVE WORK REGISTERS
         MVI   PARMTSTX,C'X'       SET TO SHOW SUB-FIELD FOUND
         MVI   TESTAREA,C' '       INSERT LEADING BLANK
         MVC   TESTAREA+1(L'TESTAREA-1),TESTAREA & PROPAGATE
         BCTR  R3,0                DECREMENT LENFTH FOR EXECUTE
         LTRR  R3,R3               ENSURE NOT -VE (INPLIES ',,')
         BM    *+8                 BYPASS EX IF -VE
         EX    R3,PARMMVC          MOVE SUB-PARM TO WORKAREA
         LA    R3,1(,R3)           RE-ESTABLISH PARM FIELD LENGTH
PARMGX1  CLI   PARMTSTX,C'X'       SE  CONDITION CODE
        SUBOUT RESTORE=(R7,R8,R9,R4) RESTORE & RETURN
         SPACE 1
PARMTSTX DC    C' '                COMPARAND TO SET CONDITION CODE
PARMMVC  MVC   TESTAREA(0),0(R2)   MOVE PARM TO TESTAREA
         EJECT
***********************************************************************
*        INITIALISE PARM ROUTINE POINTERS                             *
***********************************************************************
         SPACE 1
PARMINIT SUBIN SAVE=(R4)           PRESERVE REGISTERS
         MVC   PARM1TME(2),=X'4700' CONVERT CBALTO NOP
         L     R9,PARMPNTR         RETRIEVE PARM POINTER
         L     R9,0(,R9)           POINT R9 AT PARAMETER AREA
         LH    R8,0(R9)            RETRIEVE COUNT FIELD
         LA    R7,2(,R9)           POINT R7 AT START OF DATA
         LINE  LINE06,P=N          ASSUME NO PARM & SET UP MESSAGE
         LTR   R8,R8               TEST IF PARM SUPPLIED
         BZ    PARMP1              BRANCH IF NOT
         BCTR  R8,0                DECREMENT R8 FOR EXECUTE
         LINE  LINE10,P=N          ADD MESSAGE
         EX    R8,PARMPMVC         ADD PARM TO MESSAGE
         LA    R8,1(,R8)           RESET R8 AFTER EXECUTE
PARMP1   CBAL  R4,PRINT            PRINT LINE
         LTR   R8,R8               TEST IF PARM SUPPLIED
         BZ    PARMGX1             EXIT IF NOT
         LA    R9,2(,R9)           POINT R9 AT START OF DATA
         AR    R9,R8               POINT R9 AT EOD
         BCTR  R9,0                DECREMENT R9 FOR USE AS BXLE COMPARE
        SUBOUT RESTORE=(R4)        RETURN TO CALLER
         SPACE 1
PARMPMVC MVC   L'LINE10+5(0,R5),0(R7) EXECUTED MOVE INSTRUCTION
         SPACE 1
         CNOP  0,8                 ENSURE CSECT LENGTH IS MULTIPLE OF 8
LGTHH    EQU   *                   END OF CSECT BUDGIE3H
BUDGIE3  CSECT
         DROP  R11                 DROP BUDGIE3H ADDRESSABILITY
         TITLE 'GETMAIN ROUTINE FOR BUDGIE CONTROL BLOCKS'
***********************************************************************
*        GETMAIN ROUTINE - SUB-ALLOCATE POOLS OF STORAGE              *
***********************************************************************
         SPACE 1
*        ON ENTRY:      R2 - LENGTH OF AREA REQUIRED
*        ON RETURN:     R1 - ADDRESS OF ALLOCATED AREA (LOW-VALUES INT)
         SPACE 1
         USING POOLDEFN,R15        ESTABLISH POOL ADDRESSABILITY
GETMAIN  SUBIN SAVE=R4             GET CORE
         LA    R2,3(,R2)           POUND UP REQUEST TO ....
         N     R2,GETMASK2          .... A FULLWORD MUPLTIPLE
         LA    R15,POOLADR1        POINT R15 AT 1ST POOL DESCRIP
         LH    R14,POOLNO          GET MAX NUMBER OF AVAILABLE POOLS
GETMAIN3 TM    POOLSW,POOLGTM      IS POOL AVAILABLE FOR GETMAINS
         BZ    GETMAIN4            BR IF NOT TO GET NEXT POOL
         TM    POOLSW,POOLWORK     IS POOL BEING USED BY WORKFILE
         BO    GETMAIN4            BR TO GET NEXT POOL IF YES
         L     R3,GETMNLEN         GET LENGTH OF THIS POOL
         CR    R2,R3               TEST IF REQUIRED LENGTH WILL FIT
         BNH   GETMAIN1            BR IF POOL LARGE ENOUGH
GETMAIN4 LA    R15,POOLLGTH(,R15)  INCREMENT TO NEXT POOL
         BCT   R14,GETMAIN3        LOOP BACK IF ANY LEFT
         OI    SWERROR,SWEGETM     SET ON ERROR SWITCH
         LR    R0,R2               PLACE REQUIRED LENGTH IN R0
         A     R2,GETMXCES         ADD PREVOUS GETMAIN EXCESS TO THIS
         ST    R2,GETMXCES         PRESERFE UPDTED EXCESS AMOUNT
         LR    R2,R0               RESTORE LENGT FOR SUBSEQUENT INITIL
       GETMAIN R,LV=(0)            ACQUIRE CORE
         B     GETMAIN2            GO RECORD & INITIALISE
GETMAIN1 SR    R3,R2               DECREMENT UNALLOCATED COUNTER
         ST    R3,GETMNLEN         STORE RESIDUAL LENGTH
         L     R1,GETMNPOS         GET ADDRESS OF START OF POOL
         AR    R1,R3               INCREMENT TO START OF ALLOCATION
GETMAIN2 L     R3,GETMUSED         GET COUNT OF CORE ALLOCATED
         AR    R3,R2               ADD THIS REQUEST ...
         ST    R3,GETMUSED          ... AND STORE COUNT
         CBAL  R4,OOINIT           INITIALISE AREA TO LOW-VALUES
        SUBOUT RESTORE=R4          RETURN TO CALLER
         DROP  R15                 DROP POOL C/B ADDRESSABILITY
         TITLE 'INITIALISE AREA OF CORE TO LOW-VALUES'
***********************************************************************
*        ROUTINE TO INITIALISE AN AREA OF CORE TO LOW-VALUES.         *
*         ON ENTRY, R1 POINTS AT THE AREA AND R2 CONTAINS THE         *
*         LENGTH.                                                     *
***********************************************************************
         SPACE 1
OOINIT   SUBIN SAVE=(R1,R2,R4)     PRSERVE REGISTERS
OOINIT1  MVI   0(R1),X'00'         MOVE IN PROPAGATION CHARACTER
         LA    R3,1(,R1)           POINT R3 AT R1 + 1
         BCTR  R2,0                DECREMENT LENGTH FOR OFFSET + 1
         CBAL  R4,VARMOVE          PRRFORM VARIABLE LENGTH PROPAGATION
        SUBOUT RESTORE=(R1,R2,R4)  RESTORE REGISTERS & RETURN
         EJECT
***********************************************************************
*        MOVE A FIELD OF UNKNOWN LENGTH.  ON ENTRY, R3 POINTS AT      *
*         THE RECEIVING AREA, R2 CONTAINS THE LENGTH TO BE MOVED,     *
*         AND R1 POINTS AT THE SOURCE FILLD..                         *
***********************************************************************
         SPACE 1
VARMOVE  SUBIN ,                   MOVE VARIABLE LENGTH FIELD
VARMOVE1 C     R2,=F'256'          TEST IF MORE THAN 256 BYTES LEFT
         BNH   VARMOVE2            BR IF NOT
         MVC   0(256,R3),0(R1)     MOVE 256 BYTES TO RECEIVING AREA
         S     R2,=F'256'          DECREMENT LENGTH BY 256 BYTES
         LA    R1,256(,R1)         INCREMENT SOURCE POINTER BY 256
         LA    R3,256(,R3)         INCREMENT RECEIVIBG POINTER BY 256
         B     VARMOVE1            REPEAT FOR NEXT 256 BYTES
VARMOVE2 BCTR  R2,0                DECREMENT REMAIMING LENGTH FOR ECECU
         EX    R2,VARMVC           MOVE RENAINDER
        SUBOUT ,                   RETURN TO CALLER
         SPACE 1
VARMVC   MVC   0(0,R3),0(R1)       EXECUTED MOVE INSTRUCTION
         TITLE 'ROUTINE TO UNDERLINE ERRORS'
***********************************************************************
*        THIS SUBROUTINE UNDERLINES ERRONEOUS SUBFIELDS IN THE        *
*         PRECEDING PRINT LINE.  ON ENTRY, R3 POINTS AT THE PL        *
*         OF THE FIELD TO BE UNDERLINED.                              *
***********************************************************************
         SPACE 1
UNDRSCOR SUBIN ,                   UNDERLINE ERROR
         SR    R14,R14             ZEROISE REGISTER 14
         SR    R15,R15             ZEROISE REGISTER 15
         IC    R14,0(R3)           RETRIEVE START OF FIELD
         IC    R15,1(R3)           RETRIEVE LENGTH OF FUELF
         AR    R14,R15             ADD LENGTH TO START TO GET END
         CH    R14,=H'81'          TEST IF END EXCEEDS CARD IMAGE
         BH    ADDCOLSX            EXIT IF UNDER-LINE EXCEEDS CARD IMA
         LA    R2,DTBBCARD         POINT R2 AT RECORD IMAGE
         SR    R1,R1               ZEROISE WORK REGISTER
         IC    R1,0(R3)            RETRIEVE POSITION
         LTR   R1,R1               VERIFY OFFSET SUPPLIED
         BZ    0(R4)               SHOULD NEVER HAPPEN BUT RETURN IF NO
         BCTR  R1,0                DECREMENT (OFFSET - 1 = DISPLACEMNT)
         AR    R2,R1               POINT R2 AT FIELD IN ERROR
         SR    R1,R1               ZEROISE WORK REGISTER
         IC    R1,1(R3)            RETRIEVE LENGTH
         LTR   R1,R1               VERIFY LENGTH SUPPLIED
         BZ    0(R4)               RETURN IF NOT
         BCTR  R1,0                DECREMENT LENGTH FOR EXECUTE
         MVC   0(1,R2),UNDRLINE    MOVE IN 1ST UNDER-SCORE CHAR
         LTR   R1,R1               TEST IF FIELD LENGTH ONLY 1
         BZ    0(R4)               RETURN IF ONLY 1 BYTE TO UNDERLINE
         BCTR  R1,0                DECREMENT AGAIN FOR EXECUTE
         EX    R1,UNDRMVC          PROPAGATE UNDERSCORES
        SUBOUT ,                   RETURN TO CALLER
         SPACE 1
UNDRMVC  MVC   1(0,R2),0(R2)       EXECUTED MOV  INSTRUBTION
         TITLE 'ADD FIELD POSN TO ERROR MESSAGE'
***********************************************************************
*        THIS SUBROUTINE ADDS THE START AND END POSITIONS OF          *
*         THE NON-NUMERIC FIELD TO BBMESS03.  AT ENTRY, R3            *
*         CONTAINS THE ADDRESS OF TWO 1-BYTE FIELDS CONTAINING        *
*         THE POSITION AND LENGTH OF THE FIELD IN ERROR.              *
***********************************************************************
         SPACE 1
ADDCOLS  SUBIN ,                   ADD COL NOS TO BBMESS03
         LA    R2,DTBBEMSS         POINT R2 AT ERROR MESSAGE
         SR    R1,R1               ZEROISE WORK REGISTER
         IC    R1,0(R3)            GET POSINION OF START
         LTR   R1,R1               VERIFY POSN WAS SUPPIED
         BZ    ADDCOLSX            BYPASS ROUTINE IF NOT
         CVD   R1,WORKAREA         CONVERT START TO DECIMAL
         EDIT  WORKEDIT,WORKAREA+6,'XX0' EDIT START
         MVC   11(2,R2),WORKEDIT+2 ADD START POSN TO MESSAGE
         CLI   WORKEDIT+1,C' '     TEST FOR LEADING DIGIT
         BE    *+14                BR IF ONLY 2-DIGIT NUMBER
         MVC   10(1,R2),WORKEDIT+1 ADD LEADING DIGIT TO MESSAGE
         MVI   16(R2),C' '         BLANK OUT TRAILING BRACKET IF ANY
         SR    R15,R15             ZEROISE WORK RECISTER
         IC    R15,1(R3)           GET LENGTH OF FIELD
         BCTR  R15,0               DECREMENT TO GET 'ADDITIVE' LGTH
         AR    R1,R15              ADD LEN TO START TO GET END
         CVD   R1,WORKAREA         CONVERT END TO DECIMAL
         EDIT  WORKEDIT,WORKAREA+6,'X0X' EDIT END POSN
         MVC   14(2,R2),WORKEDIT+2 ADD END POSN TO ERROR MESSAGE
ADDCOLSX SUBOUT ,                  RETURN TO CALLER
         SPACE 1
         TITLE 'BUDGIE3F - CONVERT CONTROL CARD DATA TO BINARY'
        SCSECT F
***********************************************************************
*        THIS SUBROUTINE CONVERTS A TWO-BYTE POSITION AND             *
*         ONE-BYTE LENGTH INTO TWO ONE-BYTE BINARY FIELDS.            *
*         IF AN INPUT FIELD IS NON-NUMERIC - LEADING BLANKS           *
*         AND ALL BLANK FIELDS ARE VALID - AN ERROR MESSAGE           *
*         IS WRITTEN AND THE JOB TERMINATED.  ON ENTRY R2             *
*         POINTS AT THE INPUT 'PPL' AND R3 POINTS AT THE              *
*         OUTPUT 'PL'.                                                *
*        NOTE THAT, IF PARM=PPL+ WAS SPECIFIED, A '-' OVERPUNCH ON    *
*         THE 1ST DIGIT REPESENTS A LEADING '1', AND '&' IS A '2'.    *
***********************************************************************
         SPACE 1
PPLPL    SUBIN SAVE=R4             CONVERT EBCDIC PPL TO BINARY PL
         MVI   PPLOP,X'FF'         ASSUME PPL HAS NO OVERPUNCH
         TM    YPSWITCH,YPSWPLOP   IS OVERPUNCH VALID
         BZ    PPLPL01             BR IF NOT VALID
         CLI   0(R2),C' '          IS 1ST BYTE OF PPL BLANK
         BE    PPLPL01             BR IF BLANK
         MVC   PPLOP,0(R2)         PRESERVE OVERPUNCH IF ANY
         OI    0(R2),X'F0'         OVERRIDE OVERPUNCH IF ANY
PPLPL01  EQU   *                   CONTINUE PROCESSING
         XC    0(2,R3),0(R3)       SET TO ZERO LEST BLANK
         LA    R1,0(,R2)           POINT R1 AT PP
         LA    R15,2               SET R15 TO LENGTH OF PP
         CBAL  R4,NUMERICF         VERIFY FIELD IS NUMERIC
         BH    PLERROR             ERROR IF NON-NUMERIS
         BL    *+18                BYPASS MATHS IF BLANK
         PACK  WORKPACK,0(2,R2)    PACK PP
         CVB   R1,WORKPACK         CONVERT PP TO BINARY
         TM    PPLOP,X'20'         WQS THERE A '-' OVERPUNCH
         BO    *+8                 BR IF NOT
         LA    R1,100(,R1)         INSERT LEADING '1' IFYES
         TM    PPLOP,X'10'         WAS IT IN FACT A '&' OVERPUNCH
         BO    *+8                 BR IF NOT
         LA    R1,100(,R1)         ADD A FURTHER 100 IF YES
         STC   R1,0(R3)            STORE BINARY P
         LA    R1,2(,R2)           POINT R1 AT L
         LA    R15,1               SET R15 TO LENGTH OF L
         CBAL  R4,NUMERICF         VERIFY FIELD NUMERIC
         EJECT
***********************************************************************
*        PPL TP PL CONVERSION ( CONT'D )                              *
***********************************************************************
         SPACE 1
         BH    PLERROR             ERROR IF NON-NUMERIC
         BL    *+18                BYPASS MATHS IF BLANK
         PACK  WORKPACK,2(1,R2)    PACK L
         CVB   R1,WORKPACK         CONVERT L TO BINARY
         STC   R1,1(R3)            STORE BINARY L
        SUBOUT RESTORE=R4          RETURN TO CALLER
         SPACE 1
PLERROR  SUBIN SAVE=R4             PRESERVE CONTENTS OF R4
PLERRORS BC    0,PLERROR1          BR IF NOT PROCESSING CONTROL CARD
         OI    SWERROR,SWEFLUSH    SET ERROR SWITCH
         MVC   COMPCODE,COND16     SET COMPLETION CODE TO 16
         LINE  LINE09,S=2,P=N      SET UP ERROR MESSAGE
         CBAL  R4,PRINT            PRINT ERROR MESSAGE
        SUBOUT RESTORE=R4,RETURN=22(R4) RETURN AFTER 'STC' INSTRUCTION
PLERROR1 OI    SWERROR,SWEURTN     SET ON ERROR SWITCH
         XC    0(2,R3),0(R3)       ZEROISE RESULT
         B     PPLLPLX             RETURN - IF NOT CONTROL CARD SCAN
*                                   THEN MUST BE FROM PPLL FOR USER RTN
         EJECT
***********************************************************************
*        THIS SUB-ROUTINE CONVERTS A TWO-BYTE POSITION AND A          *
*         TWO-BYTE LENGTH INTO TWO ONE-BYTE BINARY FIELDS.            *
*         IF AN INPUT FIELD IS NON-NUMERIC - LEADING BLANKS           *
*         AND ALL BLANK FIELDS ARE VALID - AN ERROR MESSAGE           *
*         IS WRITTEN AND THE JOB TERMINATED.  ON ENTRY, R2            *
*         POINTS AT THE INPUT PPLL AND R3 POINTS AT THE               *
*         OUTPUT PL.                                                  *
***********************************************************************
         SPACE 1
PPLLPL   SUBIN SAVE=R4             CONVERT EBCDIC PPLL TO BINARY PL
         XC    0(2,R3),0(R3)       ZEROISE RESULT LEST BLANK
       NUMERIC (R2),2              VERIFY PP NUMERIC
         BH    PLERROR             ERROR IF NON-NUMERIC
         BL    *+18                BYPASS MATHS IF BLANK
         PACK  WORKPACK,0(2,R2)    PACK PP
         CVB   R1,WORKPACK         CONVERT PP TO BINARY
         STC   R1,0(R3)            STORE BINARY P
       NUMERIC 2(,R2),2            VERIFY LL NUMERIC
         BH    PLERROR             ERROR IF NON-NUMERIC
         BL    *+18                BYPASS MATHS IF BLANK
         PACK  WORKPACK,2(2,R2)    PACK LL
         CVB   R1,WORKPACK         CONVERT LL TO BINARY
         STC   R1,1(R3)            STORE BINARY L
PPLLPLX  EQU   *                   RETURN POINT FOR ERRORS IN USER RTN
        SUBOUT RESTORE=R4          RETURN TO CALLER
         EJECT
***********************************************************************
*        THIS SUB-ROUTINE CONVERTS A THREE-BYTE POSITION AND          *
*         A TWO-BYTE LENGTH INTO TWO ONE-BYTE BINARY FIELDS.          *
*         IF AN INPUT FIELD IS NON-NUMERIC - LEADING BLANKS           *
*         AND ALL BLANK FIELDS ARE VALID - AN ERROR MESSAGE           *
*         IS WRITTEN AND THE JOB TERMINATED.  ON ENTRY, R2            *
*         POINTS AT THE INPUT 'PPPLL' AND R3 POINTS AT THE            *
*         OUTPUT 'PL'.                                                *
***********************************************************************
         SPACE 1
PPPLLPL  SUBIN SAVE=R4             CONVERT EBCDIC PPPLL TO PL
         XC    0(2,R3),0(R3)       ZEROISE RESULT LEST BLANK
       NUMERIC (R2),3              VERIFY PPP NUMERIC
         BH    PLERROR             ERROR IF NON-NUMERIC
         BL    *+18                BYPASS MATHS IF BLANK
         PACK  WORKPACK,0(3,R2)    PACK PPP
         CVB   R1,WORKPACK         CONVERT PPP TO BINARY
         STC   R1,0(R3)            STORE BINARY P
       NUMERIC 3(,R2),2            VERIFY LL IS NUMERIC
         BH    PLERROR             ERROR IF NON-NUMERIC
         BL    *+18                BYPASS MATHS IF BLANK
         PACK  WORKPACK,3(2,R2)    PACK LL
         CVB   R1,WORKPACK         CONVERT LL TO BINARY
         STC   R1,1(R3)            STORE BINARY L
        SUBOUT RESTORE=R4          RETURN TO CALLER
         EJECT
***********************************************************************
*        THIS SUB-ROUTINE CONVERTS A THREE-BYTE POSITION AND A        *
*         ONE-BYTE LENGTH INTO TWO ONE-BYTE BINARY FIELDS.  IF AN     *
*         INPUT FIELD IS NON-NUMERIC - ALL BLANK FIELDS AND LEADIN    *
*         BLANKS ARE VALID - AN ERROR MESAGE IS WRITTEN AND THE JOB   *
*         IS TERMIAATED.  ON ENTRY, R2 POINTS AT THE INPUT 'PPPL',    *
*         AND R3 POINTS AT THE PUTPUT 'PL'.                           *
***********************************************************************
         SPACE 1
PPPLPL   SUBIN SAVE=R4             PRESERVE RETURN ADDRESS
         XC    0(2,R3),0(R3)       ZEROISE RESULT LEST BLANK
       NUMERIC (R2),3              VERIFY PPP IS NUMERIC
         BH    PLERROR             ERROR IF NON-NUMERIC
         BL    *+18                BYPASS MATHS IF BLANK
         PACK  WORKPACK,0(3,R2)    PACK PPP
         CVB   R1,WORKPACK         CONVERT PPP TO BINARY
         STC   R1,0(R3)            STORE BINARY P
       NUMERIC 3(,R2),1            VERIFY THAT L IS NUMERIC
         BH    PLERROR             ERROR IF NONNUMERIC
         BL    *+18                BYPASS MATHS IF BLANK
         PACK  WORKPACK,3(1,R2)    PACK 'L'
         CVB   R1,WORKPACK         CONVERT L TO BINARY
         STC   R1,1(R3)            STORE BINARY L
        SUBOUT RESTORE=R4          RESTORE AND RETURN TO CALLER
         EJECT
***********************************************************************
*        INVOKE ROUTINE 'NUMERIC' FROM BUDGIE3F                       *
***********************************************************************
         SPACE 1
NUMERICF SUBIN SAVE=R4             PRESERVE RETORN ADDRESS
         CBAL  R4,NUMERIC          INVOKE 'NUMERIC'
        SUBOUT RESTORE=R4          RESTORE AND RETURN TO CALLER
         SPACE 1
         CNOP  0,8                 ENSURE CSECT LENGTH IS MULTIPLE OF 8
LGTHF    EQU   *                   END OF SSECT BUDGIE3F
         DROP  R11                 DROP CSECT ADDRESSABILITY
BUDGIE3  CSECT
         TITLE 'ROUTINE TO EXTRACT AND MOVE SUBFIELD'
***********************************************************************
*        THIS SUBROUTINE EXTRACTS A SUB-FIELD FROM THE INPUT          *
*         RECORD AND MOVES IT TO THE REQUESTED DESTINATION            *
*         FIELD.  ON INPUT, R2 POINTS AT THE DESTINATION              *
*         FIELD, RJ POINTS AT TWO 1-BYTE BINARY FIELDS                *
*         CONTAINING THE POSITION AND LENGTH OF THE SUB-FIELD         *
*         TO BE EXTRACTED, AND R6 POINTS AT THE RECORD THAT           *
*         CONTAINS THE SUB-FIELD.  ON EXIT, R2 POINTS AT THE          *
*         BYTE FOLLOWING THE EXTRACTED AND MOVED SUB-FIELD.           *
***********************************************************************
         SPACE 1
EXTRACT  SUBIN ,                   EXTRACT SUB-FIELD
         SR    R1,R1               ZEROISE WORK REGISTER
         IC    R1,0(,R3)           OBTAIN SUB-FIELD OFFSET
         LTR   R1,R1               VERIFY OFFSET SUPPLIED
         BZ    EXTRACTX            EXIT IF NOT
         BCTR  R1,0                DECREMENT (OFFSET - 1 = DISPLACEMNT)
         AR    R1,R6               POINT R1 AT SUB-FIELD
         SR    R15,R15             ZEROISE WORK REGISTER
         IC    R15,1(,R3)          OBTAIN SUB-FIELD LENGTH
         LTR   R15,R15             VERIFY LENGTH SUPPLIED
         BZ    EXTRACTX            EXIT IF NOT
         BCTR  R15,0               DECREMENT FOR EXECUTE
         EX    R15,EXTRACTM        MOVE SUB-FIELD TO DESTINATION
         AR    R2,R15              ADD LGTH TO DESTINATION ADDRESS
         LA    R2,1(,R2)           POINT AT BYTE AFTER SUB-FIELD
EXTRACTX SUBOUT ,                  RETURN TO CALLER
         SPACE 1
EXTRACTM MVC   0(0,R2),0(R1)       EXECUTED MOVE INSTRUCTION
         SPACE 1
         TITLE 'BUDGIE3A - WORKPOOL AND WORKFILE MANIPULATION'
        SCSECT A
***********************************************************************
*        WRITE TO WORKPOOL(S) OR WORKFILE                             *
***********************************************************************
         SPACE 1
*        ON INPUT, R6 POINTS AT THE RECORD TO BE WRITTEN TO WORK
         USING POOLDEFN,R9         ESTABLISH SUB-BLOCK ADDRESS'Y
WORKPUT  SUBIN SAVE=R4             WRITE TO WORKPOOL OR WORKFILE
         TM    YPSWITCH,YPSWSFIN   WAS SF=IN SPECIFIED
         BZ    WORKPUT0            BR IF NOT
         L     R3,PTRPARM2         GET ADDRESS OF INTERMED W/A FOR RECS
         LH    R2,LRECLUT2         GET LENGTH OF OUTPUT RECORD
         LR    R1,R6               POINY R1 AT OUTPUT RECORD
         CBAL  R4,VARMOVE          MOVE OUTPUT REC TO WORK AREA
         L     R3,PTRPARM2         GET ADDRESS OF INTERMED WORK AREA
         AH    R3,LRECLUT2         POINT PAST OUTPUT RECORD JUST MOVED
         LH    R2,LRECLUT1         SET LENGTH OF INPUT RECORD
         L     R1,PTRPARM          POINT R1 AT INPUT RECORD IMAGE
         CBAL  R4,VARMOVE          MOVE INPUT REC AFTER OUTPUT REC
         L     R6,PTRPARM          POINT AT INPUT RECORD IMAGE AGAIN
         MVI   0(R6),X'00'         FLAG RECORD AS WRITTEN LEST SF=IN
         L     R6,PTRPARM2         POINT R6 AT CONCATENATED RECORDS
WORKPUT0 LA    R9,POOLADR1         POINT AT 1ST STORAGE POOL DEFN
         L     R1,POOLCNT          GET CURRENT RECORD COUNT
         LA    R1,1(,R1)           INCREMENT RECORD COUNT
         ST    R1,POOLCNT          STORE NEW RECORD COUNT
         ST    R1,POOLEOD          PRESERVE RECORD COUNT LEST LAST RECO
         LH    R2,POOLRECL         GET RECORD LENGTH
         LH    R3,POOLNO           ESTABLISH LOOP
         B     *+8                 BYPASS INCREMENTING TO NEXT BLOCK
WORKPUT1 LA    R9,POOLLGTH(,R9)    INCREMENT TO NEXT SUB-BLOCK
         C     R1,POOLCAP          COUNT > CAPACITY OF POOL ?
         BH    WORKPUT2            BRANCH IF GREATER TO LOOP BACK
         L     R1,POOLPTR          GET ADDRESS OF NEXT AVAILABLE SLIT
         LR    R3,R1               PRESERVE ADDRESS ON NEW SLOT
         AR    R1,R2               POINT TO NEXT AVAILABLE SLOT
         ST    R1,POOLPTR          PRESERVE ADDRESS OF SLOT
         ST    R1,WORK+IOPSRECA    PRESERVEA ADDRESS OF NEXT SLOT
         LR    R1,R6               POINT R1 AT SOUTCE RECORD
         CBAL  R4,VARMOVE          MOVE RECORD TO ASSIGNED SLOT
         OI    POOLSW,POOLWORK     FLAG BEING USED AS WORKFILE
         B     WORKPUT3            GO LEAVE SUBROUTINE
         EJECT
***********************************************************************
*        WRITE TO WORKPOOL(S) OR WORKFILE ( CONT'D )                  *
***********************************************************************
         SPACE 1
WORKPUT2 BCT   R3,WORKPUT1         LOOP BACK I F POOLS LEFT
         TM    WORK+IOPSSW,IOSWOPEN TEST IF WORKFIEE OPEN
         BO    WORKPUT4            BRANCH IF OPEN
         TM    WORK+IOPSSW,IOSWPRES DOES WORK DD STATEMENR EXIST
         BZ    ABEND52             BR IF NOT TO ABEND
         IOM   OPEN,WORK           OPEN WORKFILE FOR OUTPUT
WORKPUT4 IOM   PUTM,WORK,(R6)      WRITE RECORD TO WORK FILE
WORKPUT3 SUBOUT RESTORE=R4         RETURN TO CALLER
         EJECT
***********************************************************************
*        ESTABLISH WORKPOOL(S) AND WORKFILE FOR INPUT                 *
***********************************************************************
         SPACE 1
WORKOPI  SUBIN SAVE=R4             SET UP FOR INPUT
         OI    WORK+IOPSSW,IOSWINPT SET ON INPUT FLAG
         CBAL  R4,WORKOPC          CLOSE FILE & ZEROISE POINTERS
        SUBOUT RESTORE=R4          RETURN TO CALLER
         SPACE 5
***********************************************************************
*        ESTABLISH WORKPOOL(S) AND WORKFILE FOR OUTPUT                *
***********************************************************************
         SPACE 1
WORKOPO  SUBIN SAVE=R4             SET UP FOR OUTPUT
         NI    WORK+IOPSSW,IOSWOUTP SET OFF 'INPUT' FLAG
         CBAL  R4,WORKOPC          CLOSE FILE & ZEROISE POINTERS
        SUBOUT RESTORE=R4          RETURN TO CALLER
         SPACE 5
******* REMEMBER ******************************************************
*        WHEN SF=IN CODING IS ADDED, **-** OUT INPUT RECORD AFTER
*         FIRST WRITE, LEST WR OPTION IS USED.  ON RETURNING FROM
*         WORK FILE, DISCARD **-** RECORDS
         EJECT
***********************************************************************
*        CLOSE FILE AND ZEROISE PTRS                                  *
***********************************************************************
         SPACE 1
         USING POOLDEFN,R9         ESTABLISH ADDRESS'Y FOR SUB-BLOCK
WORKOPC  SUBIN SAVE=R4             CLOSE FILE AND ZEROISE PTRS
         IOM   CLOSE,WORK          CLOSE WORKFILE IF OPEM
         XC    POOLCNT,POOLCNT     ZEROISE CURRENT RECORD COUNT
         LA    R9,POOLADR1         POINT AT 1ST DESCRIPTIVE SUB-BLOCK
         LH    R3,POOLNO           ESTABLISH LOOP
         MVC   POOLPTR,POOLADR     SET POINTER TO START OF POOL
         LA    R9,POOLLGTH(,R9)    INCREMENT TO NEXT SUB-BLOCK
         TM    WORK+IOPSSW,IOSWINPT ARE WE PREPARING FOR NPUT
         BO    *+8                 BR IF YES
         NI    POOLSW,FF-POOLWORK  SHOW NOT BEING USED BY WORKFILE
         BCT   R3,*-22             LOOP BACK IF SUB-BLOCKS LEFT
         LH    R3,POOLNO           ESTABLISH LOOP
         LA    R9,POOLADR1         POINT R3 AT 1ST POOL DEFINITION
         TM    POOLSW,POOLUSE      TEST IF POOL AVAILABLE FOR USE
         BZ    *+14                BR TO GET NEXT DEFN IF NOT IN USE
         OC    POOLCAP,POOLCAP     CAN POOL HOLD ANY RECORDS ?
         BNZ   *+12                BR IF IT CAN AS THIS IS 1ST POOL
         LA    R9,POOLLGTH(,R9)    POINT AT NEXT POOL
         BCT   R3,*-22             LOOP BACK TO PROCESS NEXT POOL
         MVC   AWORKBC,POOLADR     SAVE ADDRESS OF 1ST WORK FILE RECORD
        SUBOUT RESTORE=R4          RESTORE & RETURN TO CALLER
         DROP  R9                  DROP SUB-BLOCK ADDRESSABILITY
         EJECT
***********************************************************************
*        READ FROM WORKPOOL(S) OR WORKFILE                            *
***********************************************************************
         SPACE 1
*        THIS SUB-ROUTINE RETRIEVES THE NEXT RECORD FROM THE STORAGE
*         POOL(S) OR, IF THE POOL(S) ARE EXHAUSTED, FROM THE WORK DATA
*         SET.  IF A RECORD IS AVAILABLE, THA ADDRESS OF THE RECORD IS
*         PLACED IN R6.  THE CONDITION CODE IS SET SUCH THAT THE CALLER
*         CAN MAKE THE FOLLOWING TESTS -
*              BE  - RECORD RETURNED
*              BNE - WORKPOOL(S) AND WORKFIEL EXHAUSTED
         SPACE 1
         USING POOLDEFN,R9         ESTABLISH SUB-BLOCK ADDRESS'Y
WORKGET  SUBIN SAVE=R4             READ FROM WORKPPOOL OR WORKFILE
         MVI   WORKTSTX,C'Y'       ASSUME RECORDS EXHAUSRED
         L     R1,POOLCNT          GET CURRENT RECORD COUNT
         LA    R1,1(,R1)            ADD 1 TO RECORD COUNT
         C     R1,POOLEOD          TEST IF > TOTAL RECORDS WRITTEN
         BH    WORKEOD             BR IF > TO SIMULATE EOD
         ST    R1,POOLCNT          PRESERVE NEW RECORD COUNT
         LA    R9,POOLADR1         POINT AT 1ST DESCRIPTIVE SUB-BLOCK
         LH    R2,POOLRECL         GET RECORD LENGTH
         LH    R3,POOLNO           ESTABLISH LOOP
         B     *+8                 BYPASS INCREMENTING TO NEXT BLOCK
WORKGET1 LA    R9,POOLLGTH(,R9)    INCRENENT TO NEXT SUB-BLOCK
         C     R1,POOLCAP          ? COUNT > CAPACITY OT THIS POOL
         BH    WORKGET2            BRANCH IF GREATER TO LOOP
         L     R6,POOLPTR          POINT R6 AT CURRENT SLOT
         ST    R6,WORK+IOPSRECA    PREERVE RECORD POINTER
         AR    R6,R2               INCREMENT TO NEXT SLOT
         ST    R6,POOLPTR          PRESERVE PTR TO NEXT SLOT
         L     R6,WORK+IOPSRECA    RETRIVE ADDRESS OF CURRENT RECORD
         B     WORKGET3            GO RETURN TO USER
         EJECT
***********************************************************************
*        READ FROM WORKPOOL(S) OR WORKFILE ( CONT'D )                 *
***********************************************************************
         SPACE 1
WORKGET2 BCT   R3,WORKGET1         LOOP BACK IF PPOOLS LEFT
         IOM   GET,WORK,(R6)       GET NEXT REC ( OPEN IS AUTOMATIC )
WORKGET3 MVI   WORKTSTX,C'X'       SET TO SHOW RECORD FOUND
WORKEOD  CLI   WORKTSTX,C'X'       SET COND CODE FOR CALLER
        SUBOUT RESTORE=R4          RETURN TO CALLER
         SPACE 1
WORKTSTX DC    C' '                COMPARAND TO SET CODD CODE
         DROP  R9                  DROP SUB-BLOCK ADDRESS'Y
         EJECT
***********************************************************************
*        INITIALISE CAPACITY OF STORAGE POOLS                         *
***********************************************************************
         SPACE 1
         USING POOLDEFN,R9         ASTABLISH SBB-BLOCK ADDRESS'Y
WORKCAP  SUBIN ,                   ESTABLISHH POOL'S CAPACITY
         LH    R2,POOLRECL         GET RECORD LENGHT FOR WORK
         L     R1,WORK+IOPSDCB     GET ADDRESS OF WORK DCB
         USING IHADCB,R1           ESTABLISH DCB ADDRESSABILITY
         STH   R2,DCBLRECL         PUT LRECL IN WORK DCB
         SR    R14,R14             ZEROIZE R14
         L     R15,WORKMBLK        PLACE MAX BLKSIZE IN R15
         DR    R14,R2              DIVIDE LRECL INTO MAX BLKSIZE
         MR    R14,R2              MULTIPLY QUOTIENT BY LRECL
         STH   R15,DCBBLKSI        MOVE QUARTER TRACK BLOCK TO SCB
         DROP  R1                  DROP DCB ADDRESSABILITY
         LA    R9,POOLADR1         GET ADDRESS OF 1ST SUB-BLOCK
         LH    R3,POOLNO           ESTABLISH LOOP
         SR    R1,R1               ZEROISE WORK REG FOR CUMULATIVE COUN
         B     *+8                 BYPASS INCREMENTING TO NEXT BLOCK
WORKCAP1 LA    R9,POOLLGTH(,R9)    INCREMENT TO NEXT SUB-BLOCK
         ST    R1,POOLCAP          ASSUME NOT AVAIL & ZEROISE CAPACITY
         TM    POOLSW,POOLUSE      TEST IF POOL AVAILABLE FOR USE
         BZ    WORKCAP2            BR IF ANAVAILABLE TO LOOP
         SR    R14,R14             ZEROISE 1ST REG OF DIVIDEND
         L     R15,POOLSIZ         SET 2ND REG OF DIVIDEND TO SIZE
         DR    R14,R2              DIVIDE LRECL INTO POOL SIZE
         AR    R1,R15              ADD POOL CAPACITY TO CUMULATIVE TOTA
         ST    R1,POOLCAP          ESTABLISH POOL'S UPPER LIMIT
WORKCAP2 BCT   R3,WORKCAP1         POOP BACK IF SUB-BLOCKS LEFT
         ST    R1,POOLMAX          PRESERVE TOTAL POO CAPACITY
        SUBOUT ,                   RETURN TO CALLER
         SPACE 1
         CNOP  0,8                 ENSURE CSECT LENGTH IS MULTIPLE OF 8
LGTHA    EQU   *                   END OF BUDGIE3A CSECT
         DROP  R11                 DROP BUDGIE3A ADDRESSABILITY
BUDGIE3  CSECT
         TITLE 'BUDGIE3D - I/O SUB-ROUTINES'
        SCSECT D                   START BUDGIE3D CSECT
***********************************************************************
*        OPEN ROUTINE                                                 *
***********************************************************************
         SPACE 1
OPEN     IOM   OPEN,TYPE=DEF       GENERATE OPEN ROUTINE
         EJECT
***********************************************************************
*        OPEN ROUTINE FOR ISAM FILES                                  *
***********************************************************************
         SPACE 1
         USING CB20NTRY,R6         ESTABLISH CB20 ADDRESSABILITY
ISOPEN   SUBIN SAVE=(R4,R5,R6)     PRESERVE REGISTERS
         LR    R5,R2               PRESERVE ADDRESS OF DCB SW
         CBAL  R4,OPEN             OPEN ISAM D/S
         TM    IOPSSW(R5),IOSWOPEN TEST IF OPEN SUCCESSFUL
         BZ    ISOPENX             BYPASS REMAINDER IF NOT
         L     R6,PTR1CB20         RETRIEVE ADDRESS OF 1ST CB20
ISOPEN1  LTRR  R6,R6               TEST FOR END OF CHAIN
         BZ    ISOPENX             EXIT IF END OF CHAIN
         CLI   CB20FLAG,FLAGCB20   VERIFY THAT THIS IS S CB20
         BNE   ISOPEN2             BR IF NOT CB20 TO GET NEXT C/B
         CLC   CB20IDDN,IOPSDDN(R5) IS THIS THE SAME DD NAME
         BNE   ISOPEN2 BR IF NOT TO GET NEXT
         OI    CB20ISW,IOSWOPEN    FLAG DCB AS OPEN
         OC    CB20IREC,CB20IREC   TEST IF REC SAVE AREA ALLOCATED
         BNZ   ISOPEN3             BR IF ALLOCATED
         L     R2,CB20IDCB         GET ADDRESS OF DCB
         USING IHADCB,R2           ESRABLISH DCB ADDRESSABILITY
         LH    R2,DCBLRECL         GET RECORD LENGTH
         CBAL  R4,GETMAIN          GET CORE FOR RECORD SAVE AREA
         ST    R1,CB20IREC         PRESERVE STORAGE AREA ADDRESS
ISOPEN3  L     R2,CB20IDCB         GET ADDRESS OF DCB
         CLC   CB20KLEN,DCBKEYLE   COMPARE DCB LEKLEN WITH COMPUTED
         BNE   ABEND48             GO DUMP IF NOT SAME
         DROP  R2                  DROP DCB ADDRESSABILITY
ISOPEN2  L     R6,CB20CB20         GET ADDRESS OF NEXT CB20
         B     ISOPEN1             LOOP BACK TO PROCESS
ISOPENX SUBOUT RESTORE=(R4,R5,R6)  RESTORE AND RETURN TO CALLER
         DROP  R6                  DROP CB20 ADDRESSABILITY
         EJECT
***********************************************************************
*        CLOSE ROUTINE                                                *
***********************************************************************
         SPACE 1
CLOSE    IOM   CLOSE,TYPE=DEF      GENERATE CLOSE ROUTINE
         EJECT
***********************************************************************
*        CLOSE ROUTINE FOR ISAM FILES                                 *
***********************************************************************
         SPACE 1
         USING CB20NTRY,R6         ESTABLISH CB20 AADDRESSABILITY
ISCLOSE  SUBIN SAVE=(R4,R5,R6)     PRESERVE RGISTERS
         LR    R5,R2               PRESERVE ADDRESS OF DCB SW
         L     R2,IOPSDCB(R2)      GET ADDRESS OF DCB
         TM    IOPSSW(R5),IOSWOPEN TEST IF D/S IS OPEN
         BZ    ISCLOSEX            BYPASS ROUTINE IF CLOSED
         CLOSE ((R2))              CLOSE IS D/S (WITH NO FREEPOOL)
         L     R6,PTR1CB20         RETRIEVE ADDRESS OF 1ST CB20
ISCLOSE1 LTRR  R6,R6               TEST FOR END OF CHAIN
         BZ    ISCLOSEX            EXIT IF END OF CHAIN
         CLI   CB20FLAG,FLAGCB20   VERIFY THAT THIS ISI A CB20
         BNE   ISCLOSE2            BR IF NOT CB20 TO GET NEXT C/B
         CLC   CB20IDDN,IOPSDDN(R5) IS THIS THE SAME DD NAME
         BNE   ISCLOSE2            BR IF NOT TO GET NEXT C/B
         NI    CB20ISW,IOSWCLOS    INDICATE DATA SET IS CLOSED
ISCLOSE2 L     R6,CB20CB20         GET ADDRESS OF NEXT CB20
         B     ISCLOSE1            LOOP BACK TO PROCESS
ISCLOSEX SUBOUT RESTORE=(R4,R5,R6) RESTORE & RETURN TO CALLER
         DROP  R6                  DROP CB20 ADDRESSABILITY
         EJECT
***********************************************************************
*        THIS ROUTINE SCANS THE TIOT TO DETERMINE WHETHER OR          *
*         NOT A SPECIFIC DD STATEMENT IS PRESENT IN THE JCL.          *
***********************************************************************
         SPACE 1
         IOM   TIOTSCAN,TYPE=DEF   GENERATE TIOTSCAN
         EJECT
***********************************************************************
*        READ INPUT BATCHES                                           *
***********************************************************************
         SPACE 1
READUT1  SUBIN SAVE=R4             READ SYSUT1
         L     R6,SYSUT1+IOPSRECA  GET ADDRESS OF RECORD AREA
         LH    R2,LRECLUT2         GET LENFTH OF SYSUT2 RECORD
         CH    R2,LRECLUT1         TEST IF OUTPUT LONGER THEN INPUT
         BNH   READUT1G            BR IF OUTPUT NOT LONGER
         MVI   0(R6),C' '          MOVE BLANK TO START OF RECORD
         LR    R1,R6               POINT R1 AT R6 + 0
         LA    R3,1(,R1)           POINT R3 AT R6 + 1
         BCTR  R2,0                DECREMENT R2 TO LENGTH - 1
         CBAL  R4,VARMOVE          PAD OUT RECORD WITH BLANKS
READUT1G IOM   GETM,SYSUT1,(R6)    READ SYSUT1 INTO AREA
         TM    APSWITCH,APSWSID    IS SUBMITTOR ID TO BE ADDED
         BZ    *+8                 BR IF NOT
         CBAL  R4,ADDID            ADD SUBMITTOR ID TO RECORD
         L     R3,PTRPARM          PIINT R3 AT INPUT REC S/A
         LH    R2,LRECLUT1         EGT SYSUT1 RECORD LENGTH
         LR    R1,R6               POINT R1 AT SOURCE RECORD
         CBAL  R4,VARMOVE          MOVE RECORD TO SAVE AREA
         EJECT
***********************************************************************
*        READ INPUT BATCHES ( CONT'D )                                *
***********************************************************************
         SPACE 1
*        THE EXISTENCE OF SUCH INSTRUCTIONS AS 'DW' ALLOW CRETINOUS
*         USERS TO PROGRAM A LOOP SO THE FOLLOWING CODE ISSUES A TASK
*         STIMER TO FORCE A U072 ABEND IF NO READ OF SYSUT1 OCCURS FOR
*         5 SECINDS.  ( DISABLED AFTER EOF ).
         SPACE 1
READUT1R STIMER TASK,ABEND72,DINTVL=DINTVL SET 5 SECOND TIMER
         CLI   READUT1X,C'X'       SET COND CODE FOR CALLER
        SUBOUT RESTORE=R4          RETURN TO CALLER
         EJECT
***********************************************************************
*        READ INPUT BATCHES - EOD ROUTINE                             *
***********************************************************************
         SPACE 1
EODUT1   MVI   READUT1X,C'Y'       SET TO SHOW EOF
         OI    SYSUT1+IOPSSW,IOSWEOF INDICTAE EOF
         MVI   DINTVL,C'1'         ALTER TIMER INTERVAL TO 10 HOURS
         B     READUT1R            GO SET COND CODE FOR SEER
READUT1X DC    C'X'                USED TO SET COND CODE FOR ACLLER
         SPACE 5
***********************************************************************
*        ADD SUBMITTOR ID IF REQUIRED                                 *
***********************************************************************
         SPACE 1
ADDID    SUBIN SAVE=R4             PRESERVE RETURN ADDRESS
         TM    APSWITCH,APSWBCID   IS ID FOR BATCH CARDS ONLY
         BZ    ADDID01             NO, SO GO ADD REGARDLESS
         CBAL  R4,BCSCAN           DETERMINE IF THIS IS BATCH CARD
         BNE   ADDIDX              NOT BATCH CARD SO EXIT
ADDID01  SR    R14,R14             ZEROISE WORK REGISTER
         IC    R14,PARMIDP         RETRIEVE OUTPUT POSN OF ID
         BCTR  R14,0               DECREMENT POSN TO DISPLACEMENT
         A     R14,SYSUT1+IOPSRECA POINT AT FIELD WITHIN RECORD
         SR    R1,R1               ZEROISE WORK REGISTER
         IC    R1,PARMIDL          RETRIEVE LENGTH OF ID
         BCTR  R1,0                DECREMENT FOR EXECUTE
         EX    R1,MVCSUBID         ADD USER ID TO RECORD
ADDIDX  SUBOUT RESTORE=R4          RESTORE & RETURN
         EJECT
***********************************************************************
*        READ BUDGIE CONTROL CARDS                                    *
***********************************************************************
         SPACE 1
READIN   SUBIN SAVE=(R4)           READ SYSIN
         IOM   GET,SYSIN,(R6)      GET CONTROL CARD
         AP    SYSINCNT,ONE        INCREMENT TRUE RECORD COUNT
         MVC   10(80,R5),0(R6)     MOVE RECORD TO PRINT LINE
         MVC   WORKAREA(8),EDITCNO MOVE EDIT MASK TO WORK AREA
         ED    WORKAREA(8),SYSIN+IOPSRCNT EDIT CARD NO IN W/A
         MVC   1(4,R5),WORKAREA+4  ADD CARD SEQ NO TO LINE
         CLC   0(2,R6),=C'MS'      DOES CARD START WITH 'MS'
         BE    READIN02            BR IF YES
         TM    AFSWITCH,AFSWSEQA   ARE ALL CONTROL CARDS TO BE SEQUENCE
         BO    *+16                BYPASS RESETTING IF YES
         SP    SYSIN+IOPSRCNT(4),ONE DECREMENT CARD COUNT
         MVC   1(4,R5),SPACES      BLANK OUT COUNT FROM LINE
READIN02 EQU   *                   CONTINUE PROCESSING
         EJECT
***********************************************************************
*        RAED BUDGIE CONTROL CARDS ( CONT'D )                         *
***********************************************************************
         SPACE 1
*        BUDGIE CONTROL CARDS MAY INCLUDE THE PRINTER CONTROL
*         STATEMENTS TITLE, EJECT, SKIPN.
         SPACE 1
         CLC   0(5,R6),=C'TITLE'   IS THIS A TITLE CARD
         BNE   *+14                BR IF NOT TITLE TO TEST FOR EJECT
         MVC   LINE07T,5(R6)       SET UP TITLE IN HEADING LINE
         B     *+14                GO TREAT AS EJECT CARD
         CLC   0(5,R6),=C'EJECT'   IS IT EJECT REQUEST
         BNE   *+14                BR IN NOT EJECT CARD
         MVI   0(R5),SPCE1NPR      SET TO NOT PRINT CARD CONTENTS
         AP    SYSPRINT+IOPSRCNT(4),IOPSLCNT FORCE LINE COUNT TO PAGE L
         CLC   0(4,R6),=C'SKIP'    IS IT A SKIP REQUEST
         BNE   READIN01            BR IF NOT SKIP REQUEST
         MVI   0(R5),SPCE1NPR      ASSUME IT IS SKIP 1
         CLI   4(R6),C'1'          IS IT SKIP1
         BE    READIN01            BR IF IT IS SKIP1 REQUEST
         MVI   0(R5),SPCE2NPR      ASSUME IT IS SKIP2
         AP    SYSPRINT+IOPSRCNT(4),ONE ADJUST LINE COUNT FOR DOUBLE SP
         CLI   4(R6),C'2'          IS IT SJIP2
         BE    READIN01            BR IF IT IS SKIP2 RQUEST
         MVI   0(R5),SPCE3NPR      ASSUME IT MUST BE SKIP3
         AP    SYSPRINT+IOPSRCNT(4),ONE ADJUST LINE COUNT AGAIN
READIN01 EQU   *                   GO PRINT LINE
         SPACE 1
         CBAL  R4,PRINT            PRINT CONTROL CAD
READINR  CLI   READINX,C'X'        SET COND CODE FOR USER
        SUBOUT RESTORE=(R4)        RETURN TO CALLER
         SPACE 5
EODIN    MVI   READINX,C'Y'        SET TO SHOW EOF
         IOM   EOF,SYSIN           FLAG SYSIN AS EOF
         ZAP   SYSIN+IOPSRCNT(4),SYSINCNT RESTORE TRUE RECORD COUNT
         B     READINR             GO SET COND CODE FOR USER
         SPACE 1
READINX  DC    C'X'                USED TO SET COND CODE FOR CALLER
         EJECT
***********************************************************************
*        READ AND PRINT BUDGIE LOGO                                   *
***********************************************************************
         SPACE 1
READLIN  SUBIN SAVE=R4             PRESERVE RETURN ADDRESS
         TM    SYSLIN+IOPSSW,IOSWPRES TEST IF DD STATEMENT PRESENT
         BZ    EODLIN              BYPASS ROUTINE IF NOT THERE
READLIN1 IOM   GET,SYSLIN          HET LINE OF LOGO
         MVC   0(133,R7),0(R1)     MOVE TO PRINT LINE
         ZAP   PRINTBB+IOPSRCNT(4),ZERO PREVENT UNWANTED PAGE SKIP
         CBAL  R4,PRINTBBL         WRITE LINE OF LOGO
         B     READLIN1            LOOP BACK FOR NEXT LINE
EODLIN SUBOUT  RESTORE=R4          RETURN TO CALLER
         EJECT
***********************************************************************
*        READ LOGIN                                                   *
***********************************************************************
         SPACE 1
*        AT ENTRY, CURRUT1 CONTAINS THE BATCH NO FROM THE BATCH CARD
*         JUST READ FROM SYSUT1.  THIS ROUTINE READS LOGIN, AND PROCESS
*         IS AS FOLLOWS :-
*              LOGIN > CURRUT1 D RETURN
*              LOGIN < CURRUT1 : WRITE LOGIN TO LOGOUT
*                                LOOP BACK TO READ
*              LOGIN = CURRUT1 & LOGIN ON SUSPENSE :
*                                RETURN
*              LOGIN = CURRUT1 & LOGIN ACCEPTED :
*                                SET FLAG
*                                RETURN
         SPACE 1
GETLOG   SUBIN SAVE=R4             PRESERVE RETURN ADDRESS
         TM    LOGIN+IOPSSW,IOSWEOF HAS EOF BEEN TEACHED OR SIMULATED
         BO    GETLOGX             EXIT IF YES
         TM    LOGIN+IOPSSW,IOSWPRES TEST IF LOG EXISTS
         BZ    EODLOGIN            BYPASS PROCESSING IF NO
         BC    0,GETLOGT           BR EXCEPT 1ST TIME
         OI    *-3,X'F0'           SET ON 1ST TIME BR
GETLOGR  MVC   PREVLIN,CURRLIN     PRESERVE CURRNET AS LAST
         IOM   GET,LOGIN           READ LOGIN
         SPACE 2
***********************************************************************
*        CONT'D OVERLEAF                                              *
***********************************************************************
         EJECT
***********************************************************************
*        READ LOGIN ( CONT'D )                                        *
***********************************************************************
         SPACE 1
         MVC   CURRLIN,LOGBNO-LOGCARD(R1) RETRIEVE BATCH NO.
         CLC   PREVLIN,CURRLIN     VERIFY LOG IS IN SEQUENCE
         BNL   ABEND24             GO TELL OF SEQUEBCE ERROR IF NOT
GETLOGT  L     R1,LOGIN+IOPSRECA   RETRIEVE INPUT BUFFER ADDRESS
         CLC   CURRLIN,CURRUT1     COMPARE LOG & SYSUT1 BATCH NOS
         BH    GETLOGX             RETURN IF LOG I GREATER
         BE    GETLOGE             GO PROCESS EQUALITY
*                                  LOG MUST BE LESS THAN SYSUT1
         CBAL  R4,PUTLOG           GO WRITE LOGIN TO LOGOUT
         B     GETLOGR             GO GET NEXT LOGIN RECORD
GETLOGE  L     R9,LOGOUT+IOPSRECA  GET ADDRESS OF LOG WORK AREA
         CLI   LOGSW-LOGCARD(R1),C'P' IS LOG FOR PASSED SUSPENSE BATCH
         BE    GETLOGEP            BR IF YES
         OI    MASTER,SWMDUPLG     FLAG SYSUT1 AS DUPLICATE BATCH
         CBAL  R4,PUTLOG           WRITE THIS LOG ENTRY
         B     GETLOGR             GO READ NEXT ENTRY
GETLOGEP MVC   0(80,R9),0(R1)      MOVE BATCH LOG ENTRY TO WORK RAE
         B     GETLOGR             GO READ NEXT ENTRY
GETLOGX SUBOUT RESTORE=R4          RESTORE AND RETURN
         SPACE 5
EODLOGIN MVI   CURRLIN,X'FF'       MOVE HIGH VALUES TO LOG BATCH ....
         MVC   CURRLIN+1(L'CURRLIN-1),CURRLIN ... NUMBER STORE
         IOM   EOF,LOGIN           FLAG LOGIN AS EOF
         B     GETLOGX             GO RETURN TO CALLER
         EJECT
***********************************************************************
*        READ SUSPIN                                                  *
***********************************************************************
         SPACE 1
*        AT ENTRY, CURRUT1 CONTAIBS THE BATCH NUMBER FROM THE BATCH
*         CARD JUST READ FROM SYSUT1.  THIS ROUTINE READS SUSPIN,
*         AND PROCESSING IS AS FOLLOWS:-
*              SUSPIN ^ B/C        : WRITE TO SUSPOUT
*                                  : LOOP BACK TO READ SUSPIN
*              SUSPIN > CURRUT1    : RETURN TO CALLER
*              SUSPIN < CURRUT1    : WRITE SUSPIN TO SUPOUT
*                                  : LOOP BACK TO READ SUSPIN
*              SUSPIN = CURRUT1    SET DUPLICATE FLAG
*                                  : WRITE SUSPIN TO SUSPOUT
*                                  : LOOP BACK TO READ SUSPIN
         SPACE 1
GETSUSP  SUBIN SAVE=(R4,R6)        PRESERVE REGISTERS
         TM    SUSPIN+IOPSSW,IOSWEOF TEST IF EOF REACHED
         BO    GETSUSPX            RETURN TO CALLER IF YES
         TM    SUSPIN+IOPSSW,IOSWPRES TEST IF SUSPIN PRESENT
         BZ    EODSUSP             SIMULATE EOF IF NO SYSPIN
         BC    0,GETSUSPT          BR EXCEPT 1ST TIME
         OI    *-3,X'F0'           SET ON 1ST TIME BR
GETSUSPR MVC   PREVSUSP,CURRSUSP   PRESERVE CURRENT B/NO AS LAST
         IOM   GET,SUSPIN,(R6)     READ SUSPIN
         EJECT
***********************************************************************
*        READ SUSPIN ( CONT'D )                                       *
***********************************************************************
         SPACE 1
         CBAL  R4,BCSCAN           TEST IF RECORD IS BATCH CARD
         BNE   GETSUSPW            BR TO WRITE IF NOT B/C
         MVC   CURRSUSP,NEXTSCAN   RETRIEVE BATCH NUMBER
         CLC   PREVSUSP,CURRSUSP   VERIFY SUSPENSE FILE IN SEQUENCE
         BNL   ABEND28             GO TELL OF SEQUENCE ERROR IF NOT
GETSUSPT L     R6,SUSPIN+IOPSRECA  RETRIEVE RECORD ADDRESS
         CLC   CURRSUSP,CURRUT1    COMPARE SUSPIN & SYSUT1 B/NOS
         BH    GETSUSPX            RETURN IF SUSPIN IS GREATER
         BL    GETSUSPW            GO WRITE IF SUSPOUT IS LESS
*                                  THE BATCH NUMBERS ARE EQUAL
         OI    MASTER,SWMDUPLG     FLAG SYSUT1 AS DUPLICATE BATCH
GETSUSPW CBAL  R4,PUTSUSP          WRITE RECORD TO SUSPOUT
         B     GETSUSPR            GO READ NEXT SUSPIN RECORD
GETSUSPX SUBOUT RESTORE=(R4,R6)    RESTORE REGISTERS & RETRUN TO CALLER
         SPACE 5
EODSUSP  IOM   EOF,SUSPIN          FLAG SUSPIN AS EOF
         MVI   CURRSUSP,X'FF'      MOVE HIGH VALUES TO SYSPIN BATCH ...
         MVC   CURRSUSP+1(L'CURRSUSP-1),CURRSUSP ..... NUMBR STARE
         B     GETSUSPX            GO RETURN TO CALLER
         EJECT
***********************************************************************
*        READ ISAM FILE RANDOMLY                                      *
***********************************************************************
         SPACE 1
*        ON ENTRY, R8 CONTAINS THE ADDRESS OF THE CB20 DEFINING THE KEY
*         AND THE ISAM FILE.  FIELD CB20XORY IS SET ( BY THIS ROUTINE
*         AND THE SYNAD EXIT ) THUS :-
*              W - ERROR OTHER THAN RECORD NOT FOUND
*              X - RECORD FOUND
*              Y - RECORD NOT FOUND
         SPACE 1
         USING CB20NTRY,R8         ESTABLISH CB20 ADDRESSABILITY
ISRANDM  SUBIN SAVE=R4             PRESERVE RETURN ADDRESS
         MVI   CB20XORY,C'Y'       ASSUME DD STATEMENT IS MISSING
         TM    CB20ISW,IOSWPRES    TEST IF DD SSTATEMENT MISSING
         BZ    ISRANDMX            BR IF DD STAT MISSING TO BYPASS I/O
         TM    CB20ISW,IOSWOPEN    TEST IF DCB OPEN YET
         BO    ISRANDM1            BR IF OPEN
         LA    R2,CB20DCBS         POINT R2 AT DCB SWITCH
         CBAL  R4,ISOPEN           GO OPEN ISAM D/S
ISRANDM1 L     R3,CB20TKEY         POINT R3 AT KEY AREA
         L     R2,CB20IDCB         POINT R2 AT USAM DCB
         MVI   CB20XORY,C'Y'       ASSUME RECORD NOT FOUND
         READ  ISDECB,K,(R2),'S','S',(R3) READ RANDOMLY
         WAIT  ECB=ISDECB          WAIT FOR COMPLETION OF I/O
         EJECT
***********************************************************************
*        READ ISAM FILE RANDOMLY ( CONT'D )                           *
***********************************************************************
         SPACE 1
         TM    ISDECB+24,DCBEXNKY  TEST IF RECORD NOT FOUND
         BO    ISRANDMX            EXIT IF RECORD NOT FOUND
         MVI   CB20XORY,C'W'       ASSUME I/O ERROR
         CLC   ISDECB+24(2),=X'0000' TEST IF ANY ERROR CONDITION
         BNE   ISRANDMX            EXIT IF ANY ERROR CONDITION
         MVI   CB20XORY,C'Y'       ASSUME RETRIEVED RECORD WAS DELETED
         L     R1,ISDECB+16        GET ADDRESS OF RECORD
         L     R2,CB20IDCB         GET ADDRESS OF DCB
         TM    DCBOPTCD-IHADCB(R2),DCBOPTL DOES DELETE FLAG EXIST
         BZ    *+12                BR IF DLETE OPRION NOT IN USE
         CLI   0(R1),FF            TEST IF RECORD DELETED
         BE    ISRANDMX            BR IF YES TO IGNORE
         MVI   CB20XORY,C'X'       SHOW RECORD FOUND
         L     R1,CB20IDCB         POINT R1 AT DCB
         LH    R2,DCBLRECL-IHADCB(R1) RETRIEVE RECORD LENGTH
         L     R3,CB20IREC         POINT R3 AT RECORD SAVE AREA
         L     R1,ISDECB+16        GET ADDRESS OF RECORD
         CBAL  R4,VARMOVE          MOVE RECORD TO STORAGE AREA
         AP    CB20ICNT,=P'1'      INCREMENT RECORD COUNT
ISRANDMX CLI   CB20XORY,C'X'       SET COND CODE FOR CALLER
        SUBOUT RESTORE=R4          RESTORE & RETURN TO CALLER
         DROP  R8                  FROP CB20 ADDRESSABILITY
         EJECT
***********************************************************************
*        PRINT ROUTINES                                               *
***********************************************************************
         SPACE 1
***********************************************************************
*        WRITE TO SYSPRINT                                            *
***********************************************************************
         SPACE 1
PRINT    SUBIN ,                   PRINT MESSAGE ON SYSPRINT
         IOM   PUT,SYSPRINT,(R5),PRINT,RTN=HEADPRNT WRITE TO SYSPRINT
         L     R5,SYSPRINT+IOPSRECA GET BUFFER ADDRESS (LEST NO DD ST)
         BLANK (R5),,SPCE1AFT      BLANK NEW BUFFER
        SUBOUT ,                   RETURN TO CALLER
         EJECT
***********************************************************************
*        WRITE HEADING FOR SYSPRINT ( CONTROL CRADS ONLY )            *
***********************************************************************
         SPACE 1
HEADPRNT SUBIN SAVE=R4             PRESERVE RETURN ADDRESS
         ZAP   SYSPRINT+IOPSRCNT(4),=P'0' ZEROISE LINE COUNTER
         MVI   0(R5),PAGESKIP      SET TO SKIP TO NEW PAGE
         CBAL  R4,PRINT            SKIP TO NEW PAGE
         TM    SWINIT,SWCCPRNT     ARE WE PRINTING CONTROL CARDS
         BZ    HDPRNTX             BYPASS HEADING LINES IF NOT
         MVI   0(R5),SPCE2AFT      ESTABLISG DOUBLE SPACE
         MVC   1(132,R5),LINE07    SET UP HEADING LINE
         ED    LINE07P-LINE07+1(4,R5),PGECNTSY EDIT PAGE COUNT
         AP    PGECNTSY,ONE        INCREMENT PAGE COUNT
         CBAL  R4,PRINT            PRINT HEADING LINE
         MVC   10(80,R5),BBHEAD03+11 MOVE IN 1S HEADING LINE
         CBAL  R4,PRINT             ... AND PRINT IT
         L     R1,=A(BBHEAD04+11) RESSOLVE ADDRESSABILITY PROBLEM
         MVC   10(80,R5),0(R1)     MOVE IN 2ND JEADING LINE
         MVI   0(R5),SPCE2AFT      SET TO DOUBLE SPACE
         CBAL  R4,PRINT            PRINT 2ND HEADING LINE
         COUNT SYSPRINT,1          ALLOW FOR DOUBLE SPACE
HDPRNTX SUBOUT RESTORE=R4          RESTORE & RETURN TO CALLER
         EJECT
***********************************************************************
*        WRITE BATCH BALANCING REPORT ( DDNAME PRINT )                *
***********************************************************************
         SPACE 1
PRINTBBL SUBIN ,                   WRITE TO PRINT
         TM    BRSWITCH,SWBRDETL   IS CARD TO BE ADDED TO LINE
         BZ    PRNTBBL1            BR IF NOT
         NI    BRSWITCH,FF-SWBRDETL SET OF 'CARD ADD ' FLAG
         OI    BRSWITCH,SWBRPCRD   INDICATE CURRENTLY ADDING CARD TO LN
         L     R1,DBUFF            POINT R1 AT DUMMY BUFFER
         MVC   0(133,R1),0(R7)     PRESERVE CURRENT PRINT LINE
         BLANK (R7)                BLANK OUT BUFFER
         MVC   0(1,R7),DTBBSPCE    SET DEFAULT LINE SPACING
         MVC   WORKAREA(8),EDITCNO SET  UP EDIT PATTERN
         ED    WORKAREA(8),CB02LCNT-CB02NTRY(R10) EDIT CURRENT REC NO
         MVC   1(6,R7),WORKAREA+2  MOVE EBCDIC NO TO PRINT LINE
         L     R1,PTRPARM          GET ADDRESS OF PRESERVED INPUT CARD
         MVC   12(80,R7),0(R1)     ADD CARD IMAGE TO INE
PRNTBBL1 IOM   PUT,PRINTBB,(R7),PRINT,RTN=HEADBB PRINT B/B REPORT LINE
         EJECT
***********************************************************************
*        WRITE BATCH BALANCING REPORT ( DDNAME PRINT ) ( CONT'D )     *
***********************************************************************
         SPACE 1
         L     R7,PRINTBB+IOPSRECA RETRIVEV CURRENT BUFFER ADDRESS
         BLANK (R7),,SPCE1AFT      BLANK OUT NEW BUFFER
         TM    BRSWITCH,SWBRPCRD   ARE WE CURRENTLY ADDING CARD TO LINE
         BZ    PRNTBBLX            EXIT IF NOT ON
         NI    BRSWITCH,FF-SWBRPCRD SET OFF 'ADDING CARD' FLAG
         L     R1,DBUFF            POINT R1 AT DUMMY BUFFER
         MVC   0(133,R7),0(R1)     REPLACE ORIBINAL LINE IN BUFFER
         SP    PRINTBB+IOPSRCNT(4),ULINDECR DECREMENT L/CNT IF NO SPACE
         B     PRNTBBL1            GO PRINT LINE
PRNTBBLX SUBOUT ,                  RETURN TO CALLER
         EJECT
***********************************************************************
*        BATCH BALANCING REPORT HEADING ROUTINE                       *
***********************************************************************
         SPACE 1
HEADBB   SUBIN SAVE=(R4)           PRESERVE RETURN ADDRESS
         MVC   BB01DATE,DTEREPRT   ADD DATE TO HEADING LINE
         ZAP   PRINTBB+IOPSRCNT(4),=P'0' ZEROISE LINE COUNTER
         LINE  ,,(R7),S=P,P=Z      SKIP TO NEW PAGE
         LINE  BBHEAD01,1,(R7),S=2,P=Z WRITE 1ST HEADING LINE
         MVI   0(R7),SPCE3AFT      SET FOR TRIPLE SPACE
         TM    BRSWITCH,SWBRNOBC   IS THERE NO B/C THIS RUN
         BO    *+10                BR IF NO B/C
         MVC   1(L'BBHEAD02,R7),BBHEAD02 MOVE HEADING TO LINE
         CBAL  R4,PRINTBBL         PERFORM PRINT SUB-ROUTINE
         LINE  BBHEAD03,1,(R7),P=Z WRITE THIRD HEADING LINE
         L     R1,=A(BBHEAD04)     RESOLVE ADDRESSABILITY PROBLEM
         MVC   1(L'BBHEAD04,R7),0(R1) MOVE HEADING TO LINE
         MVI   0(R7),SPCE2AFT      ESTABLISH DOUBLE SPACE
         CBAL R4,PRINTBBL          PERFORM SUBROUTINE
         COUNT PRINTBB,4           INCREMENT LINE COUNT
         AP    PGECNTBB,ONE        INCREMENT PAGE COUNT
         EDIT  BB01PAGE,PGECNTBB,'XX0' EDIT PAGE NUMBER
         TM    MASTER,SWMDETL      TEST IF PROCESSING CARD AT MOMENT
         BZ    *+8                 BR IF NOT
         OI    BRSWITCH,SWBRDETL   INDICATE RECORD TO BE ADDED TO LINE
        SUBOUT RESTORE=(R4)        RETURN TO CALLER
         EJECT
***********************************************************************
*        CREATE DETAIL LINE FOR BATCH LOG STATUS REPORT               *
***********************************************************************
         SPACE 1
         USING LLOGLINE,R15        ESTABLISH BUFFER ADDRESSABILITY
         USING LOGCARD,R1          ESTABLISH BUFFER ADDRESSABILITY
BUILDLOG SUBIN SAVE=(R1,R4)        PRESERVE REGISTERS
         TM    LOGLIST+IOPSSW,IOSWPRES TEST IF DD STAT PRESENT
         BZ    BLDLOGX             BYPASS ROUTINE IF NOT
         L     R15,LOGLIST+IOPSRECA GET CURRENT BUFFER ADDRESS
         MVC   LLOGBNO,LOGBNO      SET UP BATCH NUMBER
         MVC   LLOGMACC,LOGMESS1   ASUME BATCH ACCEPTED
         CLI   LOGSW,C'A'          TEST IF BATCH ACCEPTED
         BE    *+16                BR IF BATCJ ACCEPTED
         MVC   LLOGMACC,SPACES     BLANK OUT ACCEPTED MESSAGE
         MVC   LLOGMSUS,LOGMESS2   INDICTE BATCH ON SUSPENSE
         MVC   LLOGEDTE,LOGIDTE2   ADD DATE BATCH ENTERED SYSTEM
         MVC   LLOGADTE,LOGADTE2   ADD DATE BATCH ACCEPTED
         MVC   LLOGTYPE,LOGBTYPE   ADD BATCH CARD TYPE
         MVC   LLOGSUB,LOGSUBID    ADD SUBMITTOR ID
         CLC   LOGRCNT(9),SPACES   ENSURE PACKED FIELDS ARE PRESENT
         BE    BLDLOG1             BRANCH IF NOT
         MVC   LLOGRCNT,EDITPL3+1  SET UP EDIT PATTERN
         MVC   LLOGLCNT,EDITPL3+1  SET UP EDIT PATTERN
         MVC   LLOGHCNT,EDITPL3+1  SET UP EDIT PATTERN
         MVC   LLOGSCNT,EDITPL3+1  SET UP EDIT PATTERN
         ED    LLOGRCNT,LOGRCNT    EDIT CARDS ENTERED
         ED    LLOGLCNT,LOGLCNT    EDIT CARDS RETAINED
         ED    LLOGHCNT,LOGHCNT    EDIT HARD ERRORS
         CLI   LOGSCNT,X'A0'       TEST IF NONNUMERIC (OLD FORMAT)
         BL    *+14                IF NUMERIC THEN GO EDIT
         MVC   LLOGSCNT,SPACES     BLANK OUT EDIT MASK
         B     *+10                BYPASS EDIT & AVOID 0C7
         ED    LLOGSCNT,LOGSCNT    EDIT SOFT ERRORS
BLDLOG1  CBAL  R4,PRINTLOG         WRITE BATCJ LOG REPORT
BLDLOGX SUBOUT RESTORE=(R1,R4)     RESTORE & RETURN TO CALLER
         DROP  R1,R15              DROP BUFFER ADDRESSABILITY
         EJECT
***********************************************************************
*        WRITE BATCH LOG STATUS REPORT ( DDNAME LOGLIST )             *
***********************************************************************
         SPACE 1
PRINTLOG SUBIN ,                   WRITE TO LOGLIST
         IOM   PUT,LOGLIST,,PRINT,RTN=HEADLOG PRINT LINE
         L     R1,LOGLIST+IOPSRECA RETRIEVE CURRENY BUFFER ADDRESS
         BLANK (R1),,SPCE1AFT      BLANK OUT NEW BUFFER
         TM    PRINTSW,PRSWBLS2    IS DOUBLE SPACING REQUIRED
         BZ    *+14                BR IF NOT
         AP    LOGLIST+IOPSRCNT(4),=P'1' ADJUST LINE COUNT
         MVI   0(R1),SPCE2AFT      ESTABLISH NEXT DOUBLE SPACE
         TM    PRINTSW,PRSWBLS3    IS TRIPLE SPACING REQUIRED
         BZ    *+14                BR IF NOT
         AP    LOGLIST+IOPSRCNT(4),=P'2' ADJUST LINE COUNT
         MVI   0(R1),SPCE3AFT      ESTABLISH NEXT TRIPLE SPACE
        SUBOUT ,                   RETURN TO CALLER
         EJECT
***********************************************************************
*        BATCH LOG STATUS REPORT HEADING ROUTINE                      *
***********************************************************************
         SPACE 1
HEADLOG  SUBIN SAVE=R4             PRINT HEADINGS
         MVC   LOGDATE,DTEREPRT    ADD DATE TO HEADING LINE
         LINE  ,,(R1),S=P,P=L      SKIP TO NEW PAGE
         LINE  LOGHEAD1,1,(R1),S=3,P=L WRITE 1ST HEADING LINE
         LINE  LOGHEAD2,1,(R1),S=1,P=L WRITE 2ND HEADING LINE
         LINE  LOGHEAD3,42,(R1),S=2,P=L WRITE 3RD HEADING LINE
         COUNT LOGLIST,3           INCREMENT LINE COUNTER
         AP    PGECNTLG,ONE        INCREMENT PAG E COUNT
         EDIT  LOGPAGE,PGECNTLG,'XXX0' EDIT PAGE NUMBER IN LINE
        SUBOUT RESTORE=R4          RETURN
         EJECT
***********************************************************************
*        WRITE TO SYSUT2                                              *
***********************************************************************
         SPACE 1
PUTUT2   SUBIN SAVE=R4             PRESERVE REGISTERS
         IOM   PUTM,SYSUT2,(R6)    WRITE TO SYSUT2
        SUBOUT RESTORE=R4          RETURN TO CALLER
         EJECT
***********************************************************************
*        WRITE TO SUSPOUT                                             *
***********************************************************************
         SPACE 1
PUTSUSP  SUBIN SAVE=R4             PRESERVE REGISTERS
         IOM   PUTM,SUSPOUT,(R6)   WRITE TO SUSPOUT
        SUBOUT RESTORE=R4          RESTOE  EGISTERS & RETURN TO CALLER
         EJECT
***********************************************************************
*        WRITE TO DELETED                                             *
***********************************************************************
         SPACE 1
PUTDLETE SUBIN SAVE=R4             PRESERVE REGISTERS
         IOM   PUTM,DELETED,(R6)   WRITE TO DELETED
        SUBOUT RESTORE=R4          RETURN TO CALLER
         EJECT
***********************************************************************
*        WRITE TO DUPLICATE                                           *
***********************************************************************
         SPACE 1
PUTDUP   SUBIN SAVE=R4             PRESERVE RETURN ADDRESS
         IOM   PUTM,DUPLICAT,(R6)  WRITE TO 'DUPLICAT'
        SUBOUT RESTORE=R4          RESTORE & RETRN TO CALLER
         EJECT
***********************************************************************
*        WRITE TO INTRDR                                              *
***********************************************************************
         SPACE 1
PUTINTRD SUBIN SAVE=R4             PRESERVE RETURN ADDRESS
         IOM   PUTM,INTRDR,(R6)    WRITE TO IINTRDR
        SUBOUT RESTORE=R4          RESTORE REGISTERS AND RETURN
         EJECT
***********************************************************************
*        WRITE TO LOGOUT                                              *
***********************************************************************
         SPACE 1
*        ON ENTRY, R1 POINTS AT THE RECORD TO BE WRITTEN
         SPACE 1
PUTLOG   SUBIN SAVE=R4             PRESERVE RETRUN ADDRESS
         CBAL  R4,BUILDLOG         WRITE BATCH LOG STATUS REPORT
         CLI   0(R1),C'R'          HAS BATCH BEEN REJECTED FROM SYSTEM
         BE    PUTLOGX             DON'T WRITE TO BATCH LOG IF YES
         IOM   PUTM,LOGOUT,(R1)    WRITE TO LOGOUT
PUTLOGX SUBOUT RESTORE=R4          RESTORE & RETURB TO CALLER
         EJECT
***********************************************************************
*        SUPPLY DEFAULT BLOCKSIZE IF NOT CODED                        *
***********************************************************************
         SPACE 1
BLKSZRTN IOM   BLKSZRTN,TYPE=DEF   GENERATE DEFAULT ROUTINE
         SPACE 5
***********************************************************************
*        COMPLETE SYSUT1 DCB                                          *
***********************************************************************
         SPACE 1
UT1LRECL SUBIN ,                   SUPPLY DEFAULT LRECL
         USING IHADCB,R1           ESTABLISH DCB ADDRESSABILITY
         CLC   DCBLRECL,=F'0'      TEST IF LRECL SUPPLIED
         BNE   *+8                 BYPASS DEFAULT IF YES
         MVI   DCBLRECL+1,80       FORCE LRECL TO 80
         MVC   LRECLUT1,DCBLRECL   PRESERVE SYSUT1 LRECL
         DROP  R1                  DROP DCB ADDRESSABILITY
        SUBOUT RETURN=BLKSZRTN     GO TEST BLKSIZE
         EJECT
***********************************************************************
*        COMPLETE SYSUT2 DCB                                          *
***********************************************************************
         SPACE 1
UT2LRECL SUBIN ,                   SUPPLY DEFAULT LRECL
         USING IHADCB,R1           ESTABLISH DCB ADDRESSABILITY
         CLC   DCBLRECL,=F'0'      TEST IF LRECL SUPPLIED
         BNE   *+14                BRANCH TO VALIDATE IF YES
         MVC   DCBLRECL,LRECLUT2   SUPPLY DEFAULT LRECL
         B     BLKSZRTN            GO TEST BLKSIZE
         CLC   DCBLRECL,LRECLUT2   TEST IF SAME AS MS02 SPECIFICATION
         BE    BLKSZRTN            GO TEST BLKSIZE IF SAME
         MVC   COMPCODE,COND16     SET COMPLETION CODE TO 16
         MVI   0(R5),SPCE2AFT      ESTABLISH DOUBLE SPACE
         CBAL  R4,PRINT             AND PRINT IT
         LINE  LINE04,P=N          SET UP ERROR MESSAGE
         CBAL  R4,PRINT             AND PRINT
         B     ABEND36             GO TERMINATE ABNORMALLY
         DROP  R1                  DROP DCB ADDRESSABILITY
         EJECT
***********************************************************************
*        SET UP I.S. MASTER INDICES IN CORE                           *
***********************************************************************
         SPACE 1
ISINDEX  SUBIN ,                   ENTER ROUTINE
         USING IHADCB,R1           ESTABLISH DCB ADDRESSABILITY
         LH    R4,DCBNCRHI         GET SIZE OF MASTER INDEX FROM LABEL
         A     R4,SIZEISMX         ADD SIZE OF INDICES SO FAR
         ST    R4,SIZEISMX         PRESERVE UPDTED INDEX SIZE
         TM    YPSWITCH,YPSWNOIX   IS MASTER INDEX REQUIRED
         BO    ISINDXX             BR IF INDEX SUPPRESSED
         MVC   DCBSMSI,DCBNCRHI    SET SIZE OF INDEX WORK AREA
         LR    R3,R1               PRESERVE DCB ADDRESS
         LH    R0,DCBNCRHI         SET REQUIRED CORE SIZE FOR GETMAIN
         LTR   R1,R0               IS INDEX SIZE ZERO
         BZ    ISINDXX             BR IF INDEX OF ZERO SIZE
       GETMAIN R,LV=(0)            ACQUIRE CORE FOR INDEX
         STCM  R1,7,DCBMSHI-IHADCB+1(R3) PUT ADDRESS OF AREA IN DCB
         LR    R1,R3               RESTORE DCB ADDRESS
ISINDXX SUBOUT RETURN=(R14)        RETURN TO CO,PLETE OPEN
         SPACE 1
         CNOP  0,8                 ENSURE CSECT LENGTH IS MULTIPLE OF 8
LGTHD    EQU   *                   END OF CSECT BUDGIE3D
BUDGIE3  CSECT
         EJECT
***********************************************************************
*        COMPLETE INTRDR DCB                                          *
***********************************************************************
         SPACE 1
EXINTRDR SUBIN ,                   ENTER ROUTINE
         USING IHADCB,R1           ESTABLISF DCB ADDRESSABILITY
         CLI   DCBBUFNO,X'00'      IS BUFNO SUPPLIED
         BNE   *+8                 BR IF BUFNO SUPPLIED
         MVI   DCBBUFNO,X'01'      FORCE SINGLE BUFFERING
         CLC   DCBLRECL,=H'0'      TEST IF LRECL SUPPLIED
         BNE   *+10                BR IF LRECL SUPPLIED
         MVC   DCBLRECL,=H'80'     FORCE LRECL OF 80
        SUBOUT RETURN=BLKSZRTN     GO DET BLKSIZE
         DROP  R1                  DROP DCB AGGRESSABILITY
         EJECT
***********************************************************************
*        I/O ERROR ROUTINE                                            *
***********************************************************************
         SPACE 1
IOERROR  IOM   IOERROR,(R5),PRINT,IOERRORX,TYPE=DEF
IOERRORX CBAL  ,PRINTCDE           GO PRINT CONDITION CODE
         EJECT
***********************************************************************
*        I/O ERROR ROUTINE FOR RANDOM ISAM SEARCH                     *
***********************************************************************
         SPACE 1
         USING CB20NTRY,R8         ESTABLISH CB20 ADRESSABILITY
         USING IHADCB,R1           ESTABLISH DCB ADDRESSABULITY
ISIOERR  SUBIN ,                   ENTER SYNAD EXIT
         MVI   CB20XORY,C'Y'       ASSUME RECORD NOT FOUND
         TM    DCBEXCD1,DCBEXNKY   TEST IF RECORD NOT FOUND
         BO    *+8                 BR IF RECOR  NOT FOUND
         MVI   CB20XORY,C'W'       SHOW OTHER ERROR
        SUBOUT RETURN=(R14)        RETURN TO I/O SUPERVISOR
         DROP  R1,R8               DROP ADDRESSABILITY
         TITLE 'MISCELLANEOUS EQUATES, CONSTANTS AND WORK AREAS'
*        EQUATES
         SPACE 1
SWNONNUM EQU   1                   SUB-FIELD NOT NUMERIC
FF       EQU   255                 ALL-1 MASK
OO       EQU   0                   ALL-0 MASK
SWNOSUB EQU    2                   NO SUB-FIELD FOUND
SPCE0AFT EQU   X'01'               NO SPACE AFTER PRINT
SPCE1AFT EQU   X'09'               SPACE 1 AFTER PRINTING
SPCE2AFT EQU   X'11'               SPACE 2 AFTER PRINTING
SPCE3AFT EQU   X'19'               SPACE 3 AFTER PRINTING
PAGESKIP EQU   X'8B'               SKIP TO NEW PAGE
SPCE1NPR EQU   X'0B'               SPACE 1 : NO PRINTING
SPCE2NPR EQU   X'13'               SPACE 2 : NO PRINTING
SPCE3NPR EQU   X'1B'               SPACE 3 : NO PRINTING
         SPACE 5
*        EQUATES USED TO ESTABLISH INDEXED BRANCHES AFTER A TEST
         SPACE 1
EQ       EQU   1                   INTERNAL REPRESENTATION OF 'EQ'
NE       EQU   2                   INTERNAL REPRESENTATION OF 'NE'
GT       EQU   3                   INTERNAL REPRESENTATION OF 'GT'
GE       EQU   4                   INTERNAL REPRESENTATION OF 'GE'
LT       EQU   5                   INTERNAL REPRESENTATION OF 'LT'
LE       EQU   6                   INTERNAL REPRESENTATION OF 'LE'
ON       EQU   7                   INTERNAL REPRESENTATION OF 'ON'
OF       EQU   8                   INTERNAL REPRESENTATION OF 'OF'
         TITLE 'MISCELLANEOUS CONSTANTS AND WORK AREAS'
LINE01   DC    C'BUDGIE3 - MESSAGE DATA SET'
LINE02   DC    C'BDG3-002-I  CONDITION CODE = '
LINE04   DC    C'BDG3-004-C  MS02 SPECIFICATION OF RECORD LENGTH DIFFER*
               S FROM THE JCL - RUN TERMINATED'
WTOEND   EQU   *
LINE06   DC    C'BDG3-006-I  THERE IS NO PARM'
LINE07   DC    CL9' '
LINE07T  DC    CL75'BUDGIE CONTROL CARDS ARE -'
         DC    CL5' '
         DC    C'PAGE'
LINE07P  DC    X'40202021'         EDIT AMSK FOR PAGE COUNT
         DC    CL35' '
LINE08   DC    C'END OF BUDGIE CONTROL CARDS'
LINE09   DC    C'BDG3-009-C  THE PREVIOUS CONTROL CARD CONTAINS NON-NUM*
               ERIC DATA'
LINE10   DC    C'BDG3-010-I  THE CONTENTS OF THE PARM FIELD ARE - '
LINE11   DC    C'BDG3-011-E  PARM SUB-FIELD IS NON-NUMERIC - DEFAULT VA*
               LUE USED - '
LINE12   DS    0CL62
         DC    C'BDG3-012-I  NUMBER OF RECORDS '
LINE12M1 DS    CL11
LINE12DD DS    CL8
         DC    C' '
         DC    C' ='
LINE12M2 DS    CL10
LINE12R  DC    C'READ FROM  '
LINE12W  DC    C'WRITTEN TO '
LINE12M  DC    X'40206B2020206B202120'
LINE13   DS    0CL47
         DC    C'BDG3-013-I  '
LINE13M1 DS    CL9
         DC    C' DATA SET '
LINE13M2 DS    CL8
         DC    C' '
LINE13M3 DS    CL7
LINE13MA DC    C'MANDATORY'
LINE13OP DC    C' OPTIONAL'
LINE13PR DC    C'PRESENT'
LINE13MI DC    C'MISSING'
LINE14   DC    C'BDG3-014-W  SOURCE OF CONTROL RECORD FIELD IS IN INPUT*
                RECORD AREA AND WILL ACCESS NEXT BATCH CARD'
LINE15   DC    C'BDG3-015-W  UNRECOGNISABLE CONTROL CARD - IGNORED'
LINE16   DC    C'BDG3-016-C  SEVERE CONTROL CARD ERRORS WERE DETECTED -*
                RUN TERMINATED'
LINE17   DC    C'BDG3-017-C  NUMBER OF MS40 CARDS DOES NOT EQUAL THE NU*
               MBER OF MS41 CARDS - UNBALANCED SUBROUTINES - RUN TERMIN*
               ATED'
LINE18   DS    0CL66
         DC    C'BDG3-018-I  '
         DC    C'AMOUNT OF CORE USED FOR CONTROL BLOCKS IS'
LINE18M  DC    X'4020206B202021'   EDIT MASK FOR BYTE COUNT
         DC    C' BYTES'
LINE19   DS    0CL125
         DC    C'BDG3-019-E  '
         DC    C'STORAGE POOL TOO SMALL FOR BUDGIE CONTROL BLOCKS - GET*
               MAINS WERE REQUIRED - INCREASE BY'
LINE19M DC X'4020206B202021'
 DC C' BYTES FOR NEXT RUN'
LINE20   DC    C'BDG3-020-E  USER EXIT PASSED INVALID POSN AND LGTH'
LINE21   DC    C'BDG3-021-I  SUMMARY OF ACTIVITY BY RECORD TYPE'
LINE22   DC    C'BDG3-022-I   BATCH CARD - ........ - RECORD COUNT ='
LINE23   DC    C'BDG3-023-I  DETAIL CARD - ........ - RECORD COUNT ='
LINE24   DC    C'BDG3-024-I  END OF RECORD TYPE SUMMARY'
LINE25   DC    C'BDG3-025-E  UNRECOGNISABLE OR INVALID SUB-FIELD IN THE*
                PARM - '
LINE26   DS    0CL82
         DC    C'BDG3-026-E  MS11/12 CARD NO.'
LINE26N1 DS    CL4
         DC    C' SPECIFIES AN UNMATCHED BATCH CARD FIELD NAME ('
LINE26ID DS    CL2
         DC    C')'
LINE27   DS    0CL84
         DC    C'BDG3-027-E  MS11/12 CARD NO.'
LINE27N1 DS    CL4
         DC    C' SPECIFIES AN UNMATCHED CONTROL RECORD FIELD NAME ('
LINE27ID DS    CL2
         DC    C')'
LINE28   DS    0CL74
         DC    C'BDG3-028-I  '
         DC    C'SIZE OF BATCH THAT CAN BE PROCESSED INTERNALLY IS'
LINE28M  DC    X'4020206B202021'   EDIT MASK FOR POOL CAPACITY
         DC    C' CARDS'
LINE29   DS    0CL70
         DC    C'BDG3-029-E  CARD NO.'
LINE29N1 DS    CL4
         DC    C' SPECIFIES TEST TYPE '''
LINE29TT DS    CL2
         DC    C''' WHICH IS UN'
LINE29M  DS    CL9
LINE29S  DC    C'SUPPORTED'
LINE29A  DC    C'ALLOCATED'
LINE30   DC    C'BDG3-030-C  THE LENGTH OF THE LITERAL IS MANDATORY IN *
               THE PRECEDING MS33 CARD - CORE HAS BEEN CORRUPTED'
LINE31   DC    C'BDG3-031-C  THIS MS41 WAS NOT PRECEDED BY AN MS40 WITH$
               THE SAME NAME'
LINE32   DC    C'BDG3-032-E  UNRECOGNISABLE TEST CODE'
LINE33   DS    0CL57
         DC    C'BDG3-033-E  TEST TYPE '''
LINE33TT DS    CL2
         DC    C''' MAY ONLY APPEAR IN AN MS13 CARD'
LINE34   DS    0CL75
         DC    C'BDG3-034-I  '
         DC    C'AMOUNT OF CORE REQUIRED BY ISAM MASTER INDICES WAS'
LINE34M  DC    X'4020206B202021'   EDIT MASK FOR CORE COUNT
         DC    C' BYTES'
LINE35   DC    C'BDG3-035-I   BUT THE INDICES WERE SUPPRESSED ( BY PARM*
               =NOISINDEX )'
LINE36   DS    0CL67
         DC    C'BDG3-036-E  MS13 CARD NO.'
LINE36N1 DS    CL4
         DC    C' REQUIRES AN MSXX CARD WITH LABEL '''
LINE36TL DS    CL2
         DC    C''''
LINE37   DC    C'BDG3-037-W  INPUT/INTERNAL/OUTPUT RECORD LENGTH EXCEED*
               S 256 BYTES AND IS PARTIALLY UNADDRESSABLE'
LINE38   DS    0CL67
         DC    C'BDG3-038-I  '
         DC    C'AMOUNT OF CORE DYNAMICALLY ACQUIRED WAS'
LINE38M  DC    X'40206B2020206B202021' EDIT MASK FOR ACQUIRED CORE
         DC    C' BYTES'
LINE39   DS    0CL89
         DC    C'BDG3-039-E  CONTROL CARD NO.'
LINE39N1 DS    CL4
         DC    C' HAS DUPLICATE LABEL TO CARD NO.'
LINE39N2 DS    CL4
         DC    C' AND HAS BEEN IGNORED'
LINE39ID DS    CL1                 ID OS MSXX TYPE BEING CHECKED
LINE40   DC    C'BDG3-040-E  MS05 CARD REQUIRES EITHER A FIELD PPLL OR *
               A LITERAL VALUE'
         SPACE 5
*        WARNING: ADDITIONAL ERROR MESSAGES WILL CAUSE ADDRESSABILITY
*              ERRORS UNTIL BUDGIE HAS BEEN RESTRUCTURED
         EJECT
        SCSECT D                   PUT HEADINGS IN BUDGIE3D
LOGSPCE  DC    X'09'               SPACE 1 BY DEFAULT
LOGHEAD1 DS    0CL126              1ST HEADING LINE
         DC    C'BUDGIE3:  BATCH  LOG  STATUS  REPORT'
         DC    CL52' '
         DC    C'DATE: '
LOGDATE  DS    CL9                 RUN DATE
         DC    CL15' '
         DC    C'PAGE'
LOGPAGE  DC    C'   1'             PAGE NUMBER
LOGHEAD2 DC    C'*-BATCH NUMBER-*   *-----STATUS-----*     DATE        *
               DATE       CARDS      CARDS     HARD     SOFT    BATCH  *
                   SUBMITTOR'
LOGHEAD3 DC    C'ENTERED     ACCEPTED   ENTERED   RETAINED   ERRORS   E*
               RRORS    TYPE         ID'
         SPACE 1
LOGMESS1 DC    C'ACCEPTED'
LOGMESS2 DC    C'SUSPENSEREJECTED'
LOGMESS3 DC    C'END OF BATCH LOG STATUS REPORT'
         SPACE 2
BBSPCE   DC    X'09'               SPACE 1 BY DEFAULT
BBHEAD01 DS    0CL127              FIRST HEADING LINE
         DC    CL2' '
BB01MS01 DC    CL74'BUDGIE3: BATCH BALANCING REPORT'
         DC    CL13' '
         DC    C'DATE: '
BB01DATE DS    CL9                 RUN DATE
         DC    CL15' '
         DC    C'PAGE'
BB01PAGE DC    CL4'   1'           PAGE NUMBER
BBHEAD02 DS    0CL87               SECOND HEADING LINE
         DC    CL2' '
         DC    C'BATCH NUMBER: '
BB02BNO  DC    CL21' '             BATCH NUMBER
         DC    CL20' '
BB02SUB  DC    C'SUBMITTOR: '
BB02SID  DC    CL19' '             SUBMITTOR ID ( OPTIONAL )
BB02SUBN DC    C'SUBMITTOR: '
BBHEAD03 DS    0CL132              THIRD HEADING LINE
         DC    CL2' '
         DC    C'CARD     0        1         2         3         4     *
                   5         6         7         8'
         DC    CL35' '
         DC    C'REJECT'
BBHEAD04 DS    0CL132
         DC    CL2' '
         DC    C' NO.     123456789012345678901234567890123456789012345*
               67890123456789012345678901234567890'
         DC    C'   *--------- MESSAGE ----------*  (****)'
         DROP  R11                 DROP BUDGIE3D ADDRESSABILITY
BUDGIE3  CSECT
         EJECT
BBLINE01 DC    C'BATCH BALANCED AND ACCEPTED'
BBLINE02 DC    C'BATCH OUT OF BALANCE BUT ACCEPTED'
BBLINE03 DC    C'BATCH OUT OF BALANCE  -  REJECTED'
BBLINE04 DC    C'BATCH IN BALANCE BUT REJECTED'
BBLINE05 DC    C'BATCH NO. ON ACCEPTED BATCH LOG  -  REJECTED'
BBLINE06 DC    C'SUSPENSE'
BBLINE07 DC    C' TO SUSPENSE FILE'
BBLINE08 DC    C' FROM SYSTEM'
BBLINE09 DC    C'ALL BATCHES ACCEPTED'
BBLINE10 DC    C'****** NUMBER OF BATCHES REJECTED = 9999 ******'
BBLINE11 DC    C'END OF BATCH BALANCING REPORT'
BBLINE12 DC    C'FIRST CARD NOT A BATCH CARD - RUN ABORTED'
BBLINE13 DC    C'*** WARNING - NO DATA INPUT ***'
BBLINE14 DC    C'  RECORD'
BBLINE15 DC    C'   COUNT'
BBLINE16 DC    C' BATCH CARD'
BBLINE17 DC    C'INPUT TOTAL'
BBLINE18 DC    C'DISCREPANCY'
BBLINE19 DC    C'BATCH NO. ALREADY ENCOUNTERED IN INPUT - REJECTED'
BBLINE20 DC    C' TO DUPLICATES FILE'
BBMESS01 DC    C'UNIDENTIFIED CARD TYPE IGNORED'
BBMESS02 DC    C'UNIDENTIFIED CARD TYPE DROPPED'
BBMESS03 DC    C'FIELD COLS   -   NOT NUMERIC'
BBMESS04 DC    C'FIELD COLS   -   NOT IN TABLE'
BBMESS05 DC    C'FIELD COLS   -   NOT IN RANGE'
BBMESS06 DC    C'FIELD COLS   -   NOT IN FILE'
BBMESS07 DC    C'FIELD COLS   -   NOT VALID'
BBMESS08 DC    C'DATE (COLS   -  ) INVALID'
BBMESS09 DC    C'CURR CODE (  -  ) INVALID'
BBMESS10 DC    C'FIELD COLS   -   NOT ALPHABETIC'
BBMESS11 DC    C'FIELD COLS   -   NOT ALPHAMERIC'
BBMESS12 DC    C'FIELD COLS   -   NOT BLANK'
BBMESS13 DC    C'FIELD COLS   -   ARE BLANK'
BBMESS14 DC    C'** GENERATED CONTROL RECORD **'
BBMESS15 DC    C'CURR CODE (  -  ) NOT NUMERIC'
BBMESS16 DC    C'FIELD COLS   -   : NO ASTERISK'
BBMESS17 DC    C'FIELD COLS   -   FAILED TEST'
BBMESS18 DC    C'MONTH NO. (  -  ) NOT CURRENT'
BBMESS19 DC    C'FIELD COLS   -   NOT IN LIST'
BBMESS20 DC    C'FIELD COLS   -   OUT OF BALANCE'
BBMESS21 DC    C'MATHS (FLD   -   ) FAILED'
BBMESS22 DC    C'MATHS ERR (  -  ) OVERFLOW'
         SPACE 1
UNDRLINE DC    C'_'                CHARACTER USED TO UNDERLINE ERRORS
DTBBSPCE DC    X'01'               BY DEFAULY PRINT WIRH NO SPACE
         EJECT
FLDP     DS    C                   POSN OF LOCATED FIELD
FLDL     DS    C                   LGTH OF LOCATED FIELD
DINTVL   DS    0D                  TIMER INTERVAL TO DETECT LOOPS
         DC    C'00000500'         INTERVAL OF 5 SECONDS
WORKPACK DS    D                   WORK AREA FOR DECIMAL MATHS
WORKPCKL DS    CL16                LARGE PACKED DECIMAL WORK AREA
WORKAREA DS    CL18                GENERAL PURPOSE WORK AREA
TESTAREA DS    CL100               WORK AREA FOR TEST ROUTINES
ZERO     DC    PL1'0'              PACKED CONSTANT OF ZERO
ONE      DC    PL1'1'              PACKED CONSTANT OF 1
CNTACC   DC    PL3'0'              COUNT OF ACCEPTED BATCHES
PARMIDP  DS    CL1                 POSN OF SUBMITTORS ID IN CARD
PARMIDL  DS    CL1                 LGTH OF SUBMITTORS ID IN CARD
PARMIDC  DS    CL8                 LIT  OF SUBMITTORS ID IN CARD
APSWITCH DC    X'00'               ANOTHER PROCCESSINF SWITCH
YPSWITCH DC    X'00'               YET ANOTHER PROCESSING SWITCH
AFSWITCH DC    X'00'               A FURTHER PROCESSING SWITCH
SWINIT   DC    X'00'               INITIALISATION SWITCH
MASTER   DC    X'00'               MASTER CONTROL SWITCH
PSWITCH  DC    X'00'               FLAGS USED DURING RECORD PROCESSING
SWCARD   DC    X'00'               8 SWITCHES REFLECTING CARD STATUS
SWERROR  DC    X'00'               8 SWITCHES OF ERROR-STATUS
SWERROR2 DC    X'00'               ANOTHER ERROR STATUS SWITCH
BRSWITCH DC    X'00'               SWITCHES UDED DURINR REPROT PROCESSI
PRINTSW  DC    X'00'               SWITCH TO CONTROL LINE SPACING
BBLNECNT DC    PL2'0'              COUNT OF LINES FOR THIS RECORD
SFPACK   PACK  WORKPACK,0(0,R1)    EXECUTED PACK INSTRUCTION
MVCR14R2 MVC   0(0,R2),0(R14)      MOVE REC NO TO CARD IMAGE
EDITCNO  DC    X'4020202120202020' EDIT MASJ FOR CARD NO
MVCSUBID MVC   0(0,R14),PARMIDC    MOVE SUBMITTORS ID TO RECORD
CB20MOVL MVC   0(0,R2),MS20LIT-MS20CARD(R6) ADD KEY LITERAL TO POOL
WORKEDIT DS    CL6                 EDIT WOR AREA
EDITPATN DC    X'40212020'         EDIT PATTERN FOR 999
EDITCOND DC    X'40202120'         EDIT PATTERN FOR ZZ9
EDITPL3  DC    X'4040202020212040'
EDITPL84 DC    X'4020202020202020202020214B2020202060'
EDITPL83 DC    X'402020202020202020202020214B20202060'
EDITPL82 DC    X'40202020202020202020202020214B202060'
EDITPL81 DC    X'4020202020202020202020202020214B2060'
EDITPL80 DC    X'404020202020202020202020202020212060'
SUMMMASK DC    X'40206B2020206B202120' EDIT MASK FOR ACTIVITY SUMMARY
PPLOP    DS    CL1                 SAVE AREA FOR PPL OVERPUNCH
UT493MBB DC    C'^'                'NUST BE BLANK' CHARCTER FOR UT493
WORKPL   DS    CL2                 BINARY PL FOR USER RTN PPLL
ULINEPL  DS    CL2                 'PL' OF FIELD TO BE UNDERLINED
TABLEPTR DC    A(0)                ADDRESS OF 1ST MS02-TABLE ENTRY
BATCHPTR DC    A(0)                ADDRESS OF LAST MATCHED TABLE ENTRY
SPACES   DC    CL80' '             CONSTANT OF SPACES
ZEROES   DC    20C'0'              CONSTANT OF EBCDIC ZEROES
VERSNO   DC    C'99/99'            CURRENCY ROUTINE VERSION NUMBER
WEEK0    DC    CL6'WEEK0'          SPECIFY WEEK0 STATUS TO UT458
CC19     DC    C'19',C'98'         UK CURRENCY CODES
LRECL256 DC    H'256'              MAXIMUM ADDRESSABLE RECORD LENGTH
LRECLUT2 DC    H'80'               SYSUT2 LRECL
LRECLINT DC    H'0'                INTERNAL 7 PSEUDO ) RECORD LENGTH
LRECLUT1 DS    H                   SUPPLIED SYSUT1 LRECL
CURRSCAN DC    CL16' '             CURRENT BATCH NO FROM BCSCAN
PREVSCAN DC    CL16' '             PREVIOUS BATCH NO FROM BCSCAN
CURRUT1  DC    XL16'00'            CURRENT BTCH NUMBER FROM SYSUT1
PREVUT1  DC    CL16' '             PREVIOUS BATCH NO FROM SYSUT1
CURRLIN  DC    XL16'00'            CURRENT BATCH NUMBER FROM LOGIN
PREVLIN  DC    CL16' '             PREVIOUS BATCH NO FROM LOGIN
CURRSUSP DC    XL16'00'            CURRENT BATCH NUMBER FROM SUSPIN
PREVSUSP DC    CL16' '             PREVIOUS BATCH NO FROM SUSPIN
NEXTUT1  DC    CL16' '             JUSTREAD BATCH NO FROM SYSUT1
NEXTLIN  DC    CL16' '             JUSTREAD BATCH NO FROM LOGIN
NEXTSUSP DC    CL16' '             JUSTREAD BATCH NO FROM SUSPIN
SUBID    DC    CL20' '             SUBMITTOR ID ( ALLOW 20 FOR SAFETY )
CMS02UT1 DC    F'0'                CURRENT MS02 C/B FOR SUSUT1
         ORG   CMS02UT1            REDEFINE TO SAVE SPACE
SAVELITL DS    F                   MS20 PROCESSING - CURRENT LIT LENGTH
SAVELITP DS    F                   MS20 PROCESSING - CURRENT LIT POSITN
SAVEKEYL DS    F                   MS20 PROCESSING - CURRENT KEY LENGTH
NMS02UT1 DC    F'0'                NEXT    MS02 C/B FOR SUSUT1
PMS02UT1 DC    F'0'                PREVIOUSMS02 C/B FOR SUSUT1
ULINDECR DC    P'1'                DECREMENT TO PRINT LINE COUNTER IF
*                                   UNDERSCORE IS UNDERLINE CHARACTER
PGECNTBB DC    PL2'1'              PAGE COUNT FOR B/B REPORT
PGECNTLG DC    PL2'1'              PAGE COUNT FOR LOG LIST
PGECNTSY DC    PL2'1'              PAGE COUNT FOR SYSPRINT C/C LIST
CNTREJ   DC    PL3'0'              COUNT OF REJECTED BATCHES
SYSINCNT DC    PL4'0'              TRUE SYSIN COUNT ( C/C PLUS COMMENTS
FIVE0000 DC    P'50000'            USED TO ROUND CURR CONV
ONE00000 DC    P'100000'           USED TO ROUND CURR CONV
NEXTSCAN DC    CL16' '             JUSTREAD BATCH NO FROM BCSCAN
XB11PRTI DS    CL1                 TEMP STORE: POSN OF REC TYPE ID
XB11LTRI DS    CL1                 TEMP STORE: LGTH OF REC TYPE ID
XB11RTI  DS    CL8                 TEMP STORE: LITERAL REC TYPE ID
LOGSUSP  DC    C'S'                'S'/'R' DEPENDING ON SUSPENSE FILE
MS13COMM DC    X'FF'               CHARACTER TO SHOW ERROR MESSAGE IS C
DD       DC    C'  '               CURRENT DAY NUMBER
MM       DC    C'  '               CURRENT MONTH NUMBER
YY       DC    C'  '               CURRENT YEAR NUMBER
CURRMS02 DS    F                   ADDRESS OF CURR MS02 CONTROL BLOCK
PREVMS02 DS    F                   ADDRESS OF PREV MS02 CONTROL BLOCK
NEXTMS02 DS    F                   ADDRESS OF NEXT MS02 CONTROL BLOCK
CURRMS05 DS    F                   ADDRESS OF CURR MS05 CONTROL BLOCK
PREVMS05 DS    F                   ADDRESS OF PREV MS05 CONTROL BLOCK
NEXTMS05 DS    F                   ADDRESS OF NEXT MS05 CONTROL BLOCK
CURRMS11 DS    F                   ADDRESS OF CURRENT CB11 CONTROL B,OC
CURRCB13 DS    F                   ADDRESS OF CURRENT CB13 CONTROL BLOC
CURRCB05 DS    F                   ADDRESS OF 1ST CB05 IN TOTAL LINE CH
DBUFF    DC    A(0)                ADDRESS OF DUMMY BUFFER FOR OMITTED
SRTNCNT  DC    F'0'                COUNT OF NESTED SUBROUTINES WE ARE N
DUMPLIST DS    0F                  START OF DUMP PARAMETER LISTS
DUMP04   DC    AL1(128),AL3(4)     USER REQUESTED DUMP AT TERMINATION
DUMP08   DC    AL1(000),AL3(8)     POTENTIALLY CRITICAL C/C ERROR
DUMP12   DC    AL1(000),AL3(12)    MANDATORY DD STAEMENT MISSING
DUMP16   DC    AL1(000),AL3(16)    1ST DATA CARD NOT BATCH CARD
DUMP20   DC    AL1(000),AL3(20)    1EQUENCE ERROR SYSUT1
DUMP24   DC    AL1(000),AL3(24)    SEQUENCE ERROR LOGIN
DUMP28   DC    AL1(000),AL3(28)    SEQUENCE ERROR SUSPIN
DUMP32   DC    AL1(000),AL3(32)    UNSUPPORTED FUNCTION
DUMP36   DC    AL1(000),AL3(36)    SEVERE ERROR IN CONTROL CARDS
DUMP40   DC    AL1(000),AL3(40)    INTERNAL LRECL< THAN OUT1\
DUMP44   DC    AL1(128),AL3(44)    ISAM ERROR OTHER THAN REC NOT FOUND
DUMP48   DC    AL1(000),AL3(48)    CB13 SPECIFIES INCORRECT IS KEYLEN
DUMP52   DC    AL1(000),AL3(52)    NO WORK DD STAT & BATCH EXCEEDS CORE
DUMP56   DC    AL1(000),AL3(56)    TOO MANY ENTRIES BUILDING CU LIST
DUMP60   DC    AL1(128),AL3(60)    USER REQUESTED DUMP BY 'AB'
DUMP64   DC    AL1(000),AL3(64)    NO CONTROL CARDS FOUND
DUMP68   DC    AL1(000),AL3(68)    INSUFFICIENT CORE FOR INITIALISATION
DUMP72   DC    AL1(128),AL3(72)    USER LOOP: NO READ FOR 5 SECONDS
DUMP100  DC    AL1(128),AL3(100)   BUDGIE3 INTERNAL LOGIC ERROR
         DC    X'FF'               INDICATES END OF DUMP PARAMETER LIST
WORKMBLK DC    F'1693'             MAXIMUM BLKSIZE FOR WORKFILE
GETMUSED DC    F'0'                LENGTH ALLOCATED
GETMXCES DC    F'0'                AMOUNT OF CORE ACQUIRED BY GETMAINS
SIZEISMX DC    F'0'                AMOUNT OF CORE FOR IS MASTER INDICES
GETMMASK DC    X'FFFFFFF8'         MASK TO SET OFF BITS 6, 7, 8
GETMASK2 DC    X'FFFFFFFC'         MAST TO SET OFF BITE 7, 8
MASKFFF0 DC    X'000000FF'         MASK TO SET OFF BITS 0 - 23
PARMR7R9 DS    3F                  PARM ROUTINE SAVE AREA
PARMPNTR DS    F                   POINTER TO PARM FIELD
PTRPARM  DS    F                   ADDRESS OF USER ROUTINE PARM AREA
PTRPARMU DS    F                   POINTER TO CONTROL INFO IN L/A
PTRPARM2 DC    A(0)                ADDRESS OF OUTPUT||INPUT RECS (SF=IN
PTRCB02  DC    F'0'                CURRENT CB02 POINTER
PTRCB03  DC    F'0'                CURRENT CB03 POINTER
PTRCB05  DC    F'0'                CURRENT CB05 POINTER
PTRCB04  DC    F'0'                ADDRESS OF CURRENT CB04
PTRSB11  DC    F'0'                ADDRESS OF CURRENT SB11
PTR1CB02 DC    F'0'                ADDRESS OF 1ST CB02
PTRCB11  DC    F'0'                CURRENT CB11 POINTER
PTRCB13  DC    F'0'                CURRENT CB13 POINTER
PTRCB14  DC    F'0'                CURRENT CB14 POINTER
PTRCB21  DC    F'0'                CURRENT CB21 POINTER
PTRCB22  DC    F'0'                CURRENT CB22 POINTER
PTRCB24  DC    F'0'                CURRENT CB24 POINTER
PTRCB41  DC    F'0'                CURRENT CB41 POINTER
PTRCB20  DS    0F                  CURRENT CB20 POINTER
PTRCB23  DS    0F                  CURRENT CB23 POINTER
PTRCB30  DS    0F                  CURRENT CB30 POINTER
PTRCB31  DS    0F                  CURRENT CB31 POINTER
PTRCB32  DS    0F                  CURRENT CB32 POINTER
PTRCB33  DS    0F                  CURRENT CB33 POINTER
PTRCB34  DS    0F                  CURRENT CB34 POINTER
PTRCB36  DS    0F                  CURRENT CB36 POINTER
PTRCB40  DS    0F                  CURRENT CB40 POINTER
         DC    F'0'                COMMOM C/B POINTER
PTR1CB20 DS    0F                  ADDRESS OF 1ST CB20
PTR1CB23 DS    0F                  ADDRESS OF 1ST CB23
PTR1CB30 DS    0F                  ADDRESS OF 1ST CB30
PTR1CB31 DS    0F                  ADDRESS OF 1ST CB31
PTR1CB32 DS    0F                  ADDRESS OF 1ST CB32
PTR1CB33 DS    0F                  ADDRESS OF 1ST CB33
PTR1CB34 DS    0F                  ADDRESS OF 1ST CB34
PTR1CB40 DS    0F                  ADDRESS OF 1ST CB40
         DC    F'0'                COMMON POINTER TO 1ST C/B
CURRCB40 DC    F'0'                ADDRESS OF CURRENT CB40
ARECIN   DC    F'0'                ADDRESS OF CURRENT SYSUT1 RECORD S/A
ALINKAGE DC    F'0'                ADDRESS OF USER RTN LINKAGE AREA
ARECOUT  DC    F'0'                ADDRESS OF MODIFIED SYSUT1 RECORD
AWORKBC  DS    F                   ADDRESS OF BATCH A RD IN WORKFILE
ADRUT458 DC    A(0)                ADDRESS OF DATE VALIDATION ROUTINE
ADRUT460 DC    A(0)                ADDRESS OF CURRENCY CONVERSION ROUTI
ADRRIGAM DC    A(0)                ADDRESS OF RIGAM
PRMUT460 DC    A(0)                ADDRESS OF UT460 LINKAGE AREA
PRMRIGAM DC    A(0)                ADDRESS OF RIGAM LINKAGE AREA
RIGMAREA DC    A(0)                ADDRESS OF RIGAM RECORD AREA
RIGMEXCP DC    A(0)                ADDRESS OF RIGAM EXCEPTIONS ROUTINE
GETMSCA  DC    A(8)                ADDRESS OF PRESERVED CORE
GETMSC   DC    A(0)                AMOUNT OF CORE TO BE PRESERVED
GETMMC   DC    F'51200'            AMOUNT OF CORE TO DYNAMICALLY ACQUIR
GETMMCG  DC    A(0)                AMOUNT OF CORE DYNAMICALLY ACQUIRED
GETMMCWA DS    2F                  WORK AREA FOR DNAMIC GETMAINS
GETMMCW2 DS    2F                  ADDR & LGTH OF GETMIANED CORE
ADCBTAB1 DC    A(DCBTABL1)         OVERCOME ADDRESSABILITY PROBLEM
UPARMADR DC    F'0'                ADDRESS OF USERPRM ( IN PARM FLD )
UPARMLEN DC    H'0'                EXECUTABLE LENGTH OF USER PARM
UPARMDES DS    H'0'                DISPLACEMENT OF DSTINATION FIELD
URTNRTN  DS    CL8                 CURRENT USER ROUTINE
MS40CNT  DC    H'0'                COUNT OF MS40 CARDS
MS41CNT  DC    H'0'                COUNT OF MS41 CARDS
DTEYYDDD DS    CL5                 IPL DATE IN JULIAN FORMAT
DTEREPRT DS    CL9                 IPL DATE IN REOORT FORMAT
REMAINDR DC    X'8040201008040201' REMAINDER TO BIT CONVERSION TABLE
R6R9TMOD DS    CL1                 SAVE AREA FOR TEST MODIFIZR
         SPACE 5
*        THE FOLLOWING TABLES ARE USED TO EFFECT DECIMAL ROUNDING IN
*         THE CURRENCY CONVERSION ROUTINE.
         SPACE 1
RNDTAB1  DC    PL3'0'              ROUNDING INCREMENT FOR 0 PLACES RNDG
         DC    PL3'5'              ROUNDING INCREMENT FOR 1 PLACES RNDG
         DC    PL3'50'             ROUNDING INCREMENT FOR 2 PLACES RNDG
         DC    PL3'500'            ROUNDING INCREMENT FOR 3 PLACES RNDG
         DC    PL3'5000'           ROUNDING INCREMENT FOR 4 PLACES RNDG
         DC    PL3'50000'          ROUNDING INCREMENT FOR 5 PLACES RNDG
         SPACE 1
RNDTAB2  DC    X'FFFFFF'           ZERO MASK FOR 0 PLACES ROUNDING
         DC    X'FFFF0F'           ZERO MASK FOR 1 PLACES ROUNDING
         DC    X'FFF00F'           ZERO MASK FOR 2 PLACES ROUNDING
         DC    X'FF000F'           ZERO MASK FOR 3 PLACES ROUNDING
         DC    X'F0000F'           ZERO MASK FOR 4 PLACES ROUNDING
         DC    X'00000F'           ZERO MASK FOR 5 PLACES ROUNDING
         EJECT
*                                  DSECRIPTION OF WORKFILE STORAGE POOL
POOLNO   DC    H'21'               NO OF POTENTIAL STORAGE POOLS
CSECTNO  DC    H'15'               NO OF SUB-CSECT DEFINED BELOW
POOLRECL DC    H'0'                LENGTH OF RECORDS IN POOL
POOLCNT  DC    A(0)                CURRENT RECORD COUNT
POOLEOD  DC    A(0)                RECORDS IN POOL (DEFINES EOD)
POOLMAX  DC    A(0)                TOTAL CAPACITY OF INTERNAL WORK POOL
POOLADR1 DS    0F                  START OF DESCRIPTIVE SUB-POOLS
*                                  DESCRIPTION OF CB STORAG E POOL
GETMSTRT DS    F                   START OF CB POOL AREA
GETMLEN  DC    F'5124'             LENGTH OF UNALLOCATED CB POOL
GETMCAP  DC    A(0)                CAPACITY OF RESIDUAL POOL
GETMPTR  DC    A(0)                PTR TO NEXT AVAILABLE SLOT
      POOLGEN  A                   DESCRIBE CSECT BUDGIE3A
       POOLGEN B                   DESCRIBE CSECT BUDGIE3B
       POOLGEN C                   DESCRIBE CSECT BUDGIE3C
       POOLGEN D                   DESCRIBE CSECT BUDGIE3D
       POOLGEN E                   DESCRIBE CSECT BUDGIE3E
       POOLGEN F                   DESCRIBE CSECT BUDGIE3F
       POOLGEN G                   DESCRIBE CSECT BUDGIE3G
       POOLGEN H                   DESCRIBE CSECT BUDGIE3H
      POOLGEN  I                   DESCRIBE CSECT BUDGIE3I
       POOLGEN J                   DEFINE SCECT BUDGIE3J
       POOLGEN K                   DEFINE CSECT BUDGIE3K
      POOLGEN  L                   DEFINE CSECT BUDGIE3L
       POOLGEN M                   DEFINE CSECT BUDGIE3M
       POOLGEN N                   DEFINE CSECT BUDGIE3N
       POOLGEN O                   DEFINE CSECT BUDGIE3O
GETMMCA  EQU   *                   5 BUCKETS DEFINING DYNAMIVALLY GOT C
         DC    A(0),A(0),A(0),A(0) STORAGE POOL DEFINITION
         DC    A(0),A(0),A(0),A(0) STORAGE POOL DEFINITION
         DC    A(0),A(0),A(0),A(0) STORAGE POOL DEFINITION
         DC    A(0),A(0),A(0),A(0) STORAGE POOL DEFINITION
         DC    A(0),A(0),A(0),A(0) STORAGE POOL DEFINITION
         SPACE 5
FREETNO  DC    F'2'                NO OF POTENTIAL FREEMAINED TESTS
FREEE1   DEFREE E1                 E1 - PARTIAL KEY MATCHING ( 500 BYT
FREEC7   DEFREE C7                 C7 - MATHS ( 1800 BYTES )
         EJECT
BUDGIE3I CSECT
*        NOTE: AN X IN POSN 3 MEANS AN ADDITIONAL CONTROL CARD IS NEEDD
         SPACE 1
TESTTABL EQU   *                   INTERNAL & EXTERNAL TEST CODES
         DC    CL3'L1 ',X'00',CL3'L2 ',X'01',CL3'L3 ',X'02'
         DC    CL3'L4 ',X'03',CL3'L5 ',X'04',CL3'L6 ',X'05'
         DC    CL3'L7 ',X'06',CL3'L8 ',X'07',CL3'L9X',X'08'
         DC    CL3'LTX',X'09',CL3'LEX',X'0A',CL3'EQX',X'0B'
         DC    CL3'NEX',X'0C',CL3'GTX',X'0D',CL3'GEX',X'0E'
         DC    CL3'NN ',X'0F',CL3'NS ',X'10',CL3'NZ ',X'11'
         DC    CL3'NB ',X'12',CL3'T X',X'13',CL3'C1X',X'14'
         DC    CL3'C2 ',X'15',CL3'C3X',X'16',CL3'C4X',X'17'
         DC    CL3'C5X',X'18',CL3'C6 ',X'19',CL3'C7X',X'1A'
         DC    CL3'C8X',X'1B',CL3'R1X',X'1C',CL3'R2 ',X'1D'
         DC    CL3'R3 ',X'1E',CL3'R4 ',X'1F',CL3'R5 ',X'20'
         DC    CL3'R6 ',X'21',CL3'R7 ',X'22',CL3'R8 ',X'23'
         DC    CL3'R9 ',X'24',CL3'D1 ',X'25',CL3'D2 ',X'26'
         DC    CL3'D3 ',X'27',CL3'D4 ',X'28',CL3'D5 ',X'29'
         DC    CL3'D6 ',X'2A',CL3'D7 ',X'2B',CL3'D8 ',X'2C'
         DC    CL3'D9 ',X'2D',CL3'I X',X'2E',CL3'J X',X'2F'
         DC    CL3'C9X',X'30',CL3'E1X',X'31',CL3'E2 ',X'32'
         DC    CL3'E3 ',X'33',CL3'E4 ',X'34',CL3'E5 ',X'35'
         DC    CL3'E6 ',X'36',CL3'E7 ',X'37',CL3'E8 ',X'38'
         DC    CL3'E9 ',X'39',CL3'F1 ',X'3A',CL3'F2 ',X'3B'
         DC    CL3'F3 ',X'3C',CL3'F4 ',X'3D',CL3'F5 ',X'3E'
         DC    CL3'F6 ',X'3F',CL3'M1X',X'40',CL3'M2 ',X'41'
         DC    CL3'M3 ',X'42',CL3'M4 ',X'43',CL3'M5 ',X'44'
         DC    CL3'M6 ',X'45',CL3'M7 ',X'46',CL3'M8 ',X'47'
         DC    CL3'M9 ',X'48',CL3'US ',X'49',CL3'UZ ',X'4A'
         DC    CL3'UB ',X'4B',CL3'S X',X'4C',CL3'NM ',X'4D'
TESTSXCD DC    CL3'SX ',X'4E'
TESTITCD DC    CL3'IT ',X'4F'
         DC    CL3'ON ',X'50',CL3'OF ',X'51',CL3'WR ',X'52'
         DC    CL3'SBX',X'4C',CL3'DM ',X'53',CL3'ER ',X'54'
         DC    CL3'NR ',X'55',CL3'UR ',X'56',CL3'AB ',X'57'
         DC    CL3'WI ',X'58',CL3'DWX',X'4C'
TESTTEND DC    CL4'****'           END OF CONVERSION TABLE
         CNOP  0,8                 ENSURE CSECT LENGTH IS MULTIPLE OF 8
LGTHI    EQU   *                   END OF CSECT BUDGIE3I
BUDGIE3  CSECT
         SPACE 2
SFDFAULT DC    X'11'               BY DEFAULT - TEST NZ FOR NUMERIC FIE
SFNN     DC    X'0F'               USED TO ALTER DEFAULT NUMERIC TEST T
SFNS     DC    X'10'               USED TO ALTER DEFAULT NUMERIC TEST T
SFNZ     DC    X'11'               USED TO ALTER DEFAULT NUMERIC TEST T
SFNB     DC    X'12'               USED TO ALTER DEFAULT NUMERIC TEST T
SFNM     DC    X'4D'               USED TO ALTER DEFAULT NUMERIC TEST
SFBLANK  DC    X'04'               TEST FOR FIELD BLANK
SFASTRSK DC    X'15'               TEST IF 1ST BYTE AN ASTERISK
SFUS     DC    X'49'               USED TO ALTER DEFAULT NUMERIC TEST
SFUZ     DC    X'4A'               USED TO ALTER DEFAULT NUMERIC TEST
SFUB     DC    X'4B'               USED TO ALTER DEFAULT NUMERIC TEST
SFUVALUE DC    X'4A'               DEFAULLT NUMERIC TEST FOR UNSIGNED F
SFTEST   DC    X'00'               TEST TYPE TO BE USED BY SFVERIFY
         EJECT
*        THESE TABLES ARE USED BY VARIOUS TEST ROUTINES TO DETERMINE
*         THE VALIDITY OF FIELDS.  THE MAIN TABLE MERELY TRANSLATES
*         THE VARIOUS TYPES OF CHARACTERS INTO SPECIFIC CODES, WHILE
*         THE SMALL TABLES ARE USED TO TRANSLATE AND TEST THE RESULT
*         OF THE FIRST TRANSLATION TO DETERMINE THE TYPES OF CHARACTERS
*         THE SOURCE FIELD CONTAINED.  THUS, MANY TESTS CAN BE MADE BY
*         ONE TR AND ONE TRT, THUS OBVIATING THE NEED FOR ITERATED
*         MULTILPE TESTS.
         SPACE 1
*        THE SPECIFIC TRANSLATION CODES ASSIGNED RAE:-
*              X'01' : 0 - 9
*              X'02' : A - R
*              X'03' : S - Z
*              X'04' : SPECIAL CHARACTERS
*              X'05' : INVALID MULTI-PUNCHES
*              X'06' : 12-0 & 11-0 MULTI-PUNCHES
*              X'07' : BLANK
         SPACE 1
TTABLE   DS    0CL256              TRANSLATION TABLE FOR TESTS
         DC    64X'05'
         DC    X'07'               BLANK
         DC    9X'05'
         DC    7X'04'              SPECIAL:- H.<(+|&
         DC    9X'05'
         DC    8X'04'              SPECIAL:- !$*);^-/
         DC    9X'05'
         DC    5X'04'              SPECIAL:- ,%_>?
         DC    10X'05'
         DC    6X'04'              SPECIAL:- :#@.="
         DC    64X'05'
         DC    X'06'               12-0 PUNCH
         DC    9X'02'              ALPHA:-   ABCDEFGHI
         DC    6X'05'
         DC    X'06'               11-0 PUNCH
         DC    9X'02'              ALPHA:-   JKLMNOPQR
         DC    8X'05'
         DC    8X'03'              ALPHA:-   STUVWXYZ
         DC    6X'05'
         DC    10X'01'             NUMERIC:- 0123456789
         DC    6X'05'
         SPACE 1
TTABLEL1 DC    X'0101000001010100' ALLOW A-Z, BLANK
TTABLEL2 DC    X'0100000001010100' ALLOW A-Z, 0-9, BLANK
TTABLEL3 DC    X'0100000000010100' ALLOW A-Z, 0-9, BLANK, SPECIAL
TTABLENN DC    X'0100010101010101' ALLOW 0-9
TTABLEN  DC    X'0100010101010100' ALLOW 0-9, BLANK
TTABLES  DC    X'0100000101010000' ALLOW 0-9, A-R, BLANK, 12-0, 11-0
TTABLEBL DC    X'0000000000000001' LOCATE FIRST BLANK
TTABLENO DC    X'0001000000000000' LOCATE FIRST 0-9
TTABLENS DC    X'0001010000000100' LOCATE FIRST 0-9, A-R, 11-0, 12-0
         TITLE 'DCB''S AND I/O CONTROL TABLES'
         PRINT GEN
SYSUT1   IOM   DCBSW,SYSUT1,DCB01,INPUT,MANDAT    INPUT BATCHES
SYSUT2   IOM   DCBSW,SYSUT2,DCB02,OUTPUT          ACCEPTED BATCHES
SYSPRINT IOM   DCBSW,SYSPRINT,DCB03,OUTPUT        MESSAGE DATA SET
SYSIN    IOM   DCBSW,SYSIN,DCB04,INPUT,MANDAT     BUDGIE CONTROL CARDS
LOGIN    IOM   DCBSW,LOGIN,DCB05,INPUT            INPUT BATCH LOG
LOGOUT   IOM   DCBSW,LOGOUT,DCB06,OUTPUT          UPDATED BATCH LOG
LOGLIST  IOM   DCBSW,LOGLIST,DCB07,OUTPUT         BATCH LOG LISTING
PRINTBB  IOM   DCBSW,PRINT,DCB08,OUTPUT      B/B REPORT
WORK     IOM   DCBSW,WORK,DCB09,OUTPUT
SUSPIN   IOM   DCBSW,SUSPIN,DCB10,INPUT           INPUT SUSPENSE FILE
SUSPOUT  IOM   DCBSW,SUSPOUT,DCB11,OUTPUT         OUTPUT SUSPENSE FILE
DELETED  IOM   DCBSW,DELETED,DCB12,OUTPUT
SYSLIN   IOM   DCBSW,SYSLIN,DCB13,INPUT
DUPLICAT IOM   DCBSW,DUPLICAT,DCB14,OUTPUT
INTRDR   IOM   DCBSW,INTRDR,DCB15,OUTPUT
         EJECT
EXITLBLK DC    X'85',AL3(BLKSZRTN) DEFAULT BLOCKSIZE ROUTINE
EXITLUT1 DC    X'85',AL3(UT1LRECL) LRECL ROUTINE FOR SYSUT1
EXITLUT2 DC    X'85',AL3(UT2LRECL) LRECL ROUTINE FOR SYSUT2
EXITLISX DC    X'85',AL3(ISINDEX)  SET UP MASTER INDEX IN CORE
EXITLINT DC    X'85',AL3(EXINTRDR) SET UP INTRDR DEFAULTS
         SPACE 5
         IOM   EQUATES,15          GENERATE EQUATES
         PRINT NOGEN
         SPACE 5
         LTORG
         EJECT
         USING BUDGIE3D,R11        ESTABLISH I/O RTN CSECT ADDRESSABILI
         SPACE 1
DCB01    DCB   DDNAME=SYSUT1,                                          *
               DSORG=PS,                                               *
               MACRF=GM,                                               *
               RECFM=FB,                                               *
               EODAD=EODUT1,                                           *
               SYNAD=IOERROR,                                          *
               EXLST=EXITLUT1
         SPACE 3
DCB02    DCB   DDNAME=SYSUT2,                                          *
               DSORG=PS,                                               *
               MACRF=PM,                                               *
               SYNAD=IOERROR,                                          *
               EXLST=EXITLUT2
         SPACE 3
DCB03    DCB   DDNAME=SYSPRINT,                                        *
               DSORG=PS,                                               *
               MACRF=PL,                                               *
               RECFM=FBM,                                              *
               LRECL=133,                                              *
               SYNAD=IOERROR,                                          *
               EXLST=EXITLBLK
         SPACE 3
DCB04    DCB   DDNAME=SYSIN,                                           *
               DSORG=PS,                                               *
               MACRF=GL,                                               *
               RECFM=FB,                                               *
               LRECL=80,                                               *
               EODAD=EODIN,                                            *
               SYNAD=IOERROR,                                          *
               EXLST=EXITLBLK
         EJECT
DCB05    DCB   DDNAME=LOGIN,                                           *
               DSORG=PS,                                               *
               MACRF=GL,                                               *
               RECFM=FB,                                               *
               LRECL=80,                                               *
               EODAD=EODLOGIN,                                         *
               SYNAD=IOERROR,                                          *
               EXLST=EXITLBLK
         SPACE 3
DCB06    DCB   DDNAME=LOGOUT,                                          *
               DSORG=PS,                                               *
               MACRF=PM,                                               *
               RECFM=FB,                                               *
               LRECL=80,                                               *
               SYNAD=IOERROR,                                          *
               EXLST=EXITLBLK
         SPACE 3
DCB07    DCB   DDNAME=LOGLIST,                                         *
               DSORG=PS,                                               *
               MACRF=PL,                                               *
               RECFM=FBM,                                              *
               LRECL=133,                                              *
               SYNAD=IOERROR,                                          *
               EXLST=EXITLBLK
         SPACE 3
DCB08    DCB   DDNAME=PRINT,                                           *
               DSORG=PS,                                               *
               MACRF=PL,                                               *
               RECFM=FBM,                                              *
               LRECL=133,                                              *
               SYNAD=IOERROR,                                          *
               EXLST=EXITLBLK
         EJECT
DCB09    DCB   DDNAME=WORK,                                            *
               DSORG=PS,                                               *
               MACRF=(PM,GL),                                          *
               RECFM=FB,                                               *
               SYNAD=IOERROR,                                          *
               EODAD=WORKEOD
         SPACE 3
DCB10    DCB   DDNAME=SUSPIN,                                          *
               DSORG=PS,                                               *
               MACRF=GL,                                               *
               RECFM=FB,                                               *
               EODAD=EODSUSP,                                          *
               SYNAD=IOERROR,                                          *
               EXLST=EXITLUT1
         SPACE 3
DCB11    DCB   DDNAME=SUSPOUT,                                         *
               DSORG=PS,                                               *
               MACRF=PM,                                               *
               RECFM=FB,                                               *
               SYNAD=IOERROR,                                          *
               EXLST=EXITLUT1
         SPACE 5
DCB12    DCB   DDNAME=DELETED,                                         *
               DSORG=PS,                                               *
               MACRF=PM,                                               *
               RECFM=FB,                                               *
               SYNAD=IOERROR,                                          *
               EXLST=EXITLUT1
         EJECT
DCB13    DCB   DDNAME=SYSLIN,                                          *
               DSORG=PS,                                               *
               MACRF=GL,                                               *
               RECFM=FB,                                               *
               LRECL=133,                                              *
               SYNAD=IOERROR,                                          *
               EODAD=EODLIN,                                           *
               EXLST=EXITLBLK
         SPACE 5
DCB14    DCB   DDNAME=DUPLICAT,                                        *
               DSORG=PS,                                               *
               MACRF=PM,                                               *
               RECFM=FB,                                               *
               SYNAD=IOERROR,                                          *
               EXLST=EXITLUT1
         SPACE 5
DCB15    DCB   DDNAME=INTRDR,                                          *
               DSORG=PS,                                               *
               MACRF=PM,                                               *
               EXLST=EXITLINT,                                         *
               SYNAD=IOERROR
         EJECT
DCBTABL1 EQU   *                   TABLE OF IS DCB DISPLACEMENTS
         DC    AL1(DCBBUFCB-IHADCB)
         DC    AL1(DCBIOBAD-IHADCB)
         DC    AL1(DCBESETL-IHADCB)
         DC    AL1(DCBRELSE-IHADCB)
         DC    AL1(DCBRELEX-IHADCB)
         DC    AL1(DCBFREED-IHADCB)
         DC    AL1(DCBWKPT1-IHADCB)
         DC    AL1(DCBWKPT2-IHADCB)
         DC    AL1(DCBWKPT3-IHADCB)
         DC    AL1(DCBWKPT4-IHADCB)
         DC    AL1(DCBWKPT5-IHADCB)
         DC    AL1(DCBWKPT6-IHADCB)
         DC    AL1(DCBMSWA-IHADCB)
         DC    AL1(DCBMSHI-IHADCB)
         DC    AL1(DCBSETL-IHADCB)
         DC    AL1(DCBLRAN-IHADCB)
         DC    AL1(DCBLWKN-IHADCB)
         DC    AL1(DCBPUTX-IHADCB)
         DC    X'FF'               END OF TABLE
         EJECT
         PRINT GEN                 ALLOW DCB DSECT EXPANSION
         DCBD  DSORG=(PS,IS)
BUDGIE3  CSECT
         PRINT NOGEN               SUPPRESS MACRO EXPANSION
         CNOP  0,8                 ENSURE CSECT LENGTH IS MULTIPLE OF 8
         SPACE 1
         LTORG
         SPACE 1
$L       EQU   *-BUDGIE3
$L1      EQU   $L/100000*100000
$L2      EQU   ($L-$L1)/10000*10000
$L3      EQU   ($L-$L1-$L2)/1000*1000
$L4      EQU   ($L-$L1-$L2-$L3)/100*100
$L5      EQU   ($L-$L1-$L2-$L3-$L4)/10*10
$L6      EQU   ($L-$L1-$L2-$L3-$L4-$L5)
         SPACE 1
$LENGTH  EQU   $L1/100000*1048576+$L2/10000*65536+$L3/1000*4096+$L4/100*
               256+$L5/10*16+$L6
         SPACE 1
         END
