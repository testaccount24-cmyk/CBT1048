 T586P16: PROC(PARAM) OPTIONS(MAIN);                                      000010
      DCL  (DATE,TIME,ONCHAR,ONSOURCE,ONCODE,ONLOG,ONFILE,ONKEY,EMPTY,    000020
           NULL) BUILTIN, CKPT_RETC FIXED BIN(31),                        000030
           PROCIN  FILE RECORD SEQUENTIAL,                                000040
          PROCOUT  FILE RECORD SEQUENTIAL,                                000050
         /* TWO TABLE FILES DELETED */                                    000060
          INTRDR  FILE RECORD SEQUENTIAL,                                 000070
         ERRLIST  FILE RECORD SEQUENTIAL;                                 000080
     DCL INREC CHAR(80),                                                  000090
         OUTREC CHAR(80),                                                 000100
          PLINE  CHAR(133);                                               000110
     DCL  PARAM CHAR(100) VARYING;                                        000120
     DCL  POOL1 CHAR(500),                                                000130
         POOL2 CHAR(80),                                                  000140
         WAREA CHAR(500) VARYING,                                         000150
         SAREA CHAR(80) VARYING,                                          000160
          P POINTER;                                                      000170
         /* TWO TABLES DELETED */                                         000180
     DCL SWPARM BIT(1) INIT('0'B);   /* ON IF PARM = SPACE */             000190
     DCL                                                                  000200
       1  LINE_AREA,                                                      000210
       3 LINE_CC CHAR(1) INIT(' '),                                       000220
       3  LINE_PROC CHAR(8),                                              000230
       3  LINE_FIL1 CHAR(2) INIT('  '),                                   000240
       3  LINE_STEP CHAR(8),                                              000250
       3  LINE_FIL2 CHAR(2) INIT('  '),                                   000260
       3  LINE_CARD CHAR(80),                                             000270
       3  LINE_FIL3 CHAR(2) INIT('  '),                                   000280
       3  LINE_MESS CHAR(30);                                             000290
     DCL  SWEOD BIT(1) INIT('0'B);      /* EOD ON PROCIN        */        000300
     DCL  SWPROC BIT(1) INIT('0'B);     /* PROC STATEMENT FOUND */        000310
     DCL  RECNT FIXED DEC(3,0) INIT(0);                                   000320
     DCL  SWADD6 BIT(1) INIT('0'B);     /* ADD SYSUT2 STATEMENT */        000330
     DCL  SWUDMP BIT(1) INIT('0'B);     /* SYSUDUMP FOUND       */        000340
     DCL  SWDD1  BIT(1) INIT('0'B);     /* 1ST DD FOUND FOR STP */        000350
     DCL  SWDD   BIT(1) INIT('0'B);     /* PROCESSING DD STAT'T */        000360
     DCL  REXIT  LABEL;                 /* USED BY PERFORM      */        000370
     DCL NINES PIC'9999999V9R';                                           000380
     DCL PACKD FIXED DEC(15,2);                                           000390
     DCL F3 FIXED DEC(7,2) INIT('7294');                                  000400
     DCL F5 FIXED DEC(7,2) INIT('13030');                                 000410
     DCL F19 FIXED DEC(5,2) INIT('19');                                   000420
     DCL F20 FIXED DEC(5,2) INIT('20');                                   000430
     DCL SWSA BIT(1);                   /* ALTRR CYLS TO TRKS        */   000440
     DCL SWSB BIT(1);                   /* SUBLIST IN SPACE PARAM    */   000450
     DCL SWSC BIT(1);                   /* ALLOC IN CYLS             */   000460
     DCL NONES CHAR(9) BASED(NA);       /* REDEFINE TO ALLOW SUBSTR  */   000470
     DCL NUMERIC CHAR(10) INIT('0123456789');                             000480
     DCL NA POINTER;                    /* TO ESTABLISH ADDRESSABILIT*/   000490
         NA = ADDR(NINES);              /* SET REDEFINITION ADDRESS  */   000500
     DCL                                                                  000510
       1  CARD_NUMB,                                                      000520
       3  CARDN_FL1 CHAR(80) INIT('./ NUMBER NEW1=100,INCR=100');         000530
     DCL                                                                  000540
       1 CARD_ADD,                                                        000550
       3 CARDA_FL1 CHAR(13) INIT('./  ADD NAME='),                        000560
       3 CARDA_RST CHAR(67) INIT(' ');                                    000570
     DCL                                                                  000580
       1 CARD_REP,                                                        000590
       3 CARDR_NME CHAR(8);                                               000600
     DCL                                                                  000610
       1  CARD_PROC,                                                      000620
       3  CARDP_FL1 CHAR(2) INIT('//'),                                   000630
       3  CARDP_NME CHAR(8),                                              000640
       3  CARDP_FL2 CHAR(70) INIT('     PROC');                           000650
     DCL                                                                  000660
       1  CARD_SYSUT6,                                                    000670
       3  CARDS_FL1 CHAR(80)                                              000680
          INIT('//SYSUT6       DD   UNIT=SYSDA,SPACE=(TRK,(2,2))');       000690
     DCL                                                                  000700
       1  CARD_UDUMP,                                                     000710
       3  CARDU_FL1 CHAR(80)                                              000720
          INIT('//SYSUDUMP     DD   SYSOUT=A');                           000730
     DCL                                                                  000740
       1 CARD_JOB,                                                        000750
       3 CARD_FL1 CHAR(2) INIT('//'),                                     000760
       3 CARDJ_NME CHAR(8),                                               000770
       3 CARDJ_FL2 CHAR(70)                                               000780
         INIT(' JOB (1140,7,,,,,,,,,N),''CHECK SYNTAX'',CLASS=N');        000790
     DCL                                                                  000800
       1 CARD_PEND,                                                       000810
       3 CARD_PEND_FL1 CHAR(80)                                           000820
         INIT('//             PEND ');                                    000830
     DCL                                                                  000840
       1 CARD_ABCDEF,                                                     000850
       3 CARD_ABCDEF_FL1 CHAR(80)                                         000860
         INIT('//STEP02       EXEC POGM=ABCDEFGH');                       000870
     DCL                                                                  000880
       1 CARD_EXECPR,                                                     000890
       3 CARD_EXECPR_FL1 CHAR(20)                                         000900
         INIT('//STEP01       EXEC '),                                    000910
       3 CARD_EXECPR_NME CHAR(8),                                         000920
       3 CARD_EXECPR_FL2 CHAR(52)                                         000930
         INIT(' ');                                                       000940
     DCL                                                                  000950
       1 CARD_EOF,                                                        000960
       3 CRAD_EOF_FL1 CHAR(80) INIT('/*EOF ');                            000970
     DCL                                                                  000980
       1 CARD_ROUTE,                                                      000990
       3 CARD_ROUTE_FL1 CHAR(15) INIT('/*ROUTE  PRINT '),                 001000
       3 CARD_ROUTE_FL2 CHAR(8) INIT('REMOTE14'),                         001010
       3 CARD_ROUTE_FL3 CHAR(57) INIT(' ');                               001020
     DCL SWUNIT BIT(1);                                                   001030
     DCL SWVOL  BIT(1);                                                   001040
     DCL SWSER  BIT(1);                                                   001050
     DCL SWREF  BIT(1);                                                   001060
     DCL SWSPCE BIT(1);                                                   001070
     DCL SWDSN  BIT(1);                                                   001080
     DCL SWLABL BIT(1);                                                   001090
     DCL SWDCB  BIT(1);                                                   001100
     DCL SWDUMY BIT(1);                                                   001110
     DCL SWSYSO BIT(1);                                                   001120
     DCL REFCNT FIXED BIN(15);                                            001130
     DCL DSN CHAR(44);                                                    001140
     DCL SWCONT BIT(1);                                                   001150
     DCL SWDISP BIT(1);                                                   001160
     DCL SWISAM BIT(1);                                                   001170
     DCL SWGDG  BIT(1);                                                   001180
     DCL SPACE CHAR(24) INIT('SPACE=(TRK,(50,50),RLSE)');                 001190
         DCL DDNAME CHAR(8);                                              001200
     DCL SWSYSD BIT(1);                                                   001210
     DCL SWNEW  BIT(1);                                                   001220
     DCL SWRETP BIT(1);                                                   001230
     DCL LABEL  CHAR(14) INIT('LABEL=RETPD=25');                          001240
     DCL CNTBR  FIXED DEC(5,0);                                           001250
     DCL SWSEP  BIT(1);                                                   001260
     DCL SWTEMP BIT(1);                                                   001270
     DCL SWTAPE BIT(1);                                                   001280
     DCL SWDDN BIT(1);                                                    001290
     DCL SWEX BIT(1);                                                     001300
     DCL IEFPROC BIT(1);                                                  001310
     DCL SWUSYM BIT(1);                                                   001320
     DCL UCHAR CHAR(1);                                                   001330
     DCL SW00E  BIT(1);                                                   001340
     DCL FLDEXEC BIT(1);                                                  001350
     DCL FLDPROC BIT(1);                                                  001360
     DCL FRSTIME BIT(1) INIT('1'B);                                       001370
     DCL FLDJOB  BIT(1);                                                  001380
     DCL FLDDD   BIT(1);                                                  001390
     DCL FLDS    BIT(1);                                                  001400
     DCL SWSRT BIT(1);                                                    001410
     DCL SWINTR BIT(1);                                                   001420
     DCL PROCNT FIXED DEC(5,0);                                           001430
     DCL SWPDS BIT(1);                                                    001440
     DCL SWNOBR BIT(1);                                                   001450
     DCL SWEXEC BIT(1);                                                   001460
     DCL SW467 BIT(1);                                                    001470
     DCL SWIBM BIT(1) INIT('0'B);                                         001480
     DCL A FIXED BIN(15,0);                                               001490
     DCL B FIXED BIN(15,0);                                               001500
     DCL C FIXED BIN(15,0);                                               001510
     DCL D FIXED BIN(15,0);                                               001520
     DCL E FIXED BIN(15,0);                                               001530
     DCL LAREA CHAR(80) VARYING;                                          001540
     DCL SWRIGM BIT(1);                                                   001550
     DCL PARM1 FIXED(1) BASED(Q1);      /* POINTER TO DSN            */   001560
     DCL PARM2 FIXED(1) BASED(Q2);      /* POINTER TO DCB AREA       */   001570
     DCL PARM3 FIXED(1) BASED(Q3);      /* POINTER TO RETURN CODE    */   001580
     DCL PARM4 FIXED(1) BASED(Q4);                                        001590
     DCL Q4 PTR;                                                          001600
     DCL JCLDSCB CHAR(8) INIT('JCLDSCB ');                                001610
         Q4 = ADDR(JCLDSCB);                                              001620
         CALL DYNAML(PARM4);            /* LOAD JCLDSCB INTO CORE    */   001630
     DCL Q1 PTR;                                                          001640
     DCL Q2 PTR;                                                          001650
     DCL Q3 PTR;                                                          001660
     DCL QEXIT LABEL;                                                     001670
     DCL STREF CHAR(8);                                                   001680
     DCL RETCD CHAR(1);                 /* RETURN CODE: 1=GOOD/2=BAD */   001690
         Q1 = ADDR(DSN);                /* POINT PARM1 AT DSN        */   001700
         Q2 = ADDR(POOL2);              /* POINT PARM2 AT POOL1      */   001710
         Q3 = ADDR(RETCD);              /* POINT PARM3 AT RETCD      */   001720
     DCL SWDCBZ BIT(1);                                                   001730
     DCL SWLIB BIT(1);                                                    001740
    DCL  SWRLSE BIT(1);                                                   001750
1/*      READ TABLE OF IS D/S INTO CORE                              */   001760
0/*      THIS TABLE IS USED TO RECOGNISE IS D/S ( FOR SPECIAL             001770
         PROCESSING ) LEST THE DAMN FOOL FORGOT DSORG=IS             */   001780
                                                                          001790
         /* TWO TABLES DELETED */                                         001800
1/*      EXAMINE THE PARM FIELD FOR PARM=SPACE                       */   001810
                                                                          001820
         IF PARAM = 'SPACE'                                               001830
         THEN SWPARM = '1'B;                                              001840
0                                                                         001850
0                                                                         001860
0/*      INITIALISE AND OPEN MAIN FILES                              */   001870
                                                                          001880
         CALL PLIRETC(0);               /* SET COND CODE TO ZERO     */   001890
         ON ENDFILE(PROCIN)                                               001900
         GO TO END;                                                       001910
         OPEN FILE(PROCIN) INPUT;                                         001920
         OPEN FILE(PROCOUT) OUTPUT;                                       001930
         OPEN FILE(ERRLIST) OUTPUT;                                       001940
         OPEN FILE(INTRDR) OUTPUT;                                        001950
               SWDD = '0'B;             /* ENSURE SWITCH ZERO        */   001960
         SWEXEC = '0'B;                 /* SHOW 1ST TIME THRU        */   001970
 READ:   READ FILE(PROCIN) INTO(INREC);                                   001980
1/*      READ UNLOADED INPUT PROCEDURES                              */   001990
         SUBSTR(INREC,73,8) = ' ';      /* BLANK OUT SEQUENCE NUMBER */   002000
         IF INREC = '    '                                                002010
         THEN GO TO READ;                                                 002020
         FLDEXEC = '0'B;                                                  002030
         FLDPROC = '0'B;                                                  002040
         FLDJOB  = '0'B;                                                  002050
         FLDDD   = '0'B;                                                  002060
         FLDS    = '0'B;                                                  002070
           IF SUBSTR(INREC,1,3) ^= './ ' & FRSTIME                        002080
         THEN DO;                                                         002090
               LINE_MESS = 'FIRST CARD NOT CONTROL CARD';                 002100
               WRITE FILE(ERRLIST) FROM(LINE_AREA);                       002110
               CALL PLIRETC(8);                                           002120
               GO TO END;                                                 002130
         END;                                                             002140
         IF SUBSTR(INREC,1,2) ^= './'        /* TEST FOR IEBUPDTE CARD*/  002150
         THEN GO TO MEMBX;              /* BRANCH IF NOT A MEMBER    */   002160
         IF SUBSTR(INREC,4,4) = 'REPL'       /* TEST FOR REPLACE CARD */  002170
               THEN GO TO HDR00;                                          002180
         IF SUBSTR(INREC,4,3) = 'ADD'        /* TEST FOR ADD CARD     */  002190
               THEN GO TO HDR00;                                          002200
               ELSE GO TO MEMBX;                                          002210
 HDR00:                                                                   002220
         IF FRSTIME THEN GO TO MEMB02;  /* BYPASS ROUTINE 1ST TIME   */   002230
               REXIT = MEMB00;  GO TO ENDDD;                              002240
 MEMB00: REXIT = MEMB01;                                                  002250
         GO TO ENDEXEC;                                                   002260
 MEMB01: WRITE FILE(INTRDR) FROM(CARD_PEND);                              002270
         WRITE FILE(INTRDR) FROM(CARD_EXECPR);                            002280
         WRITE FILE(INTRDR) FROM(CARD_ABCDEF);                            002290
         WRITE FILE(INTRDR) FROM(CARD_ROUTE); /* ROUTE OUTPUT        */   002300
 MEMB02: FRSTIME = '0'B;                /* SET OFF 1ST TIME SW       */   002310
         SWEXEC = '0'B;                 /* SET OFF 1ST EXEC SW       */   002320
         IEFPROC = '0'B;                /* ASSUME NOT IBM PROC       */   002330
         PROCNT = 0;                    /* ZEROISE COUNT OF PROC STA */   002340
         CARD_ROUTE_FL2 = 'LOCAL';                                        002350
         IF SUBSTR(INREC,48,2) = ' '                                      002360
               THEN GO TO MEMB04;                                         002370
         IF SUBSTR(INREC,48,2) > '0'                                      002380
               THEN GO TO MEMB03;                                         002390
         LINE_MESS = 'ILLEGAL ROUTING - 14 SUBSTITUTED';                  002400
         WRITE FILE(ERRLIST) FROM(LINE_AREA);                             002410
         GO TO MEMB04;                                                    002420
 MEMB03: CARD_ROUTE_FL2 = 'REMOTE' || SUBSTR(INREC,48,2);                 002430
 MEMB04:                                                                  002440
         CARDJ_NME = SUBSTR(INREC,38,8);                                  002450
         CARD_EXECPR_NME = SUBSTR(INREC,38,8);                            002460
         WRITE FILE(INTRDR) FROM(CARD_JOB);                               002470
         LINE_PROC = SUBSTR(INREC,38,8);                                  002480
               CARDR_NME = SUBSTR(INREC,38,8);                            002490
         SUBSTR(INREC,48,2) = ' ';           /* BLANK OUT ROUTE CODE  */  002500
         WRITE FILE(PROCOUT) FROM(INREC);    /* WRITE IEBUPDTE CARD   */  002510
               WRITE FILE(PROCOUT) FROM(CARD_NUMB);                       002520
               SWPROC = '0'B;                                             002530
         GO TO READ;                                                      002540
 MEMBX:                                 /* END OF MEMBERSHIP         */   002550
         IF SUBSTR(INREC,1,2) ^= '//'   /* TEST FOR JCL CARD         */   002560
         & SUBSTR(INREC,1,2) ^= '/*'    /* ... OR FOR DELIMITTER     */   002570
         THEN DO;                       /* IF NOT ... THEN ...       */   002580
               LINE_CARD = INREC;       /* CARD IMAGE TO LINE        */   002590
               LINE_MESS = 'UNKNOWN CARD TYPE - DROPPED'; /* ADD MESS*/   002600
               CALL PLIRETC(8);        /* SET COND CODE             */    002610
               WRITE FILE(ERRLIST) FROM(LINE_AREA); /* TELL OF ERR   */   002620
               GO TO READ;              /* GO GET NEXT RECORD        */   002630
         END;                           /* END OF ERROR ROUTINE      */   002640
         DO I = 1 TO 71;                /* FIND END OF NAME FIELD    */   002650
               IF SUBSTR(INREC,I,1) = ' ' /* TEST FOR BLANK          */   002660
               THEN GO TO FIND1;        /* BRANCH IF ' ' FOUND       */   002670
         END;                           /* END OF SEARCH             */   002680
 FIND1:  II = I;                        /* PRESERVE END OF NAME      */   002690
         DO I = II TO 71;               /* SEARCH FOR OPERATION      */   002700
               IF SUBSTR(INREC,I,1) ^= ' ' /* TEST FOR NONBLANK      */   002710
               THEN GO TO FIND2;        /* BR IF NONBLANK FOUND      */   002720
         END;                           /* END OF OPERATION SEARCH   */   002730
 FIND2:  IFLD = I;                      /* SAVE POINTER TO OPERATION */   002740
         IF SUBSTR(INREC,I,5) = 'PROC ' THEN FLDPROC = '1'B;              002750
         IF SUBSTR(INREC,I,5) = 'EXEC ' THEN FLDEXEC = '1'B;              002760
         IF SUBSTR(INREC,I,4) = 'JOB '  THEN FLDJOB  = '1'B;              002770
         IF SUBSTR(INREC,I,3) = 'DD '   THEN FLDDD   = '1'B;              002780
         IF SUBSTR(INREC,I,2) = 'S '    THEN FLDS    = '1'B;              002790
         IF ^SWPROC                                                       002800
         THEN DO;                                                         002810
               SWPROC = '1'B;                                             002820
               I = INDEX(INREC,' PROC ');                                 002830
               IF I = 0                                                   002840
               THEN DO;                                                   002850
                    IF FLDJOB           /* IF JOB CARD               */   002860
                    THEN DO;            /* ... THEN ...              */   002870
                     WRITE FILE(PROCOUT) FROM(INREC);                     002880
                     GO TO READ;        /* WRITE JOB & GO BACK       */   002890
                    END;                /* END OF JOB CARD LOOP      */   002900
                    IF SUBSTR(INREC,3,7) = 'IEFPROC' /* IF IBM PROC  */   002910
                    THEN IEFPROC = '1'B; /* .. THEN SET SWITCH       */   002920
                    IF IEFPROC THEN GO TO INRBL; /* IF IBM PROC BR   */   002930
                    CARDP_NME = CARDR_NME;                                002940
                    WRITE FILE(PROCOUT) FROM(CARD_PROC);                  002950
                    WRITE FILE(INTRDR) FROM(CARD_PROC);                   002960
                    GO TO INRBL;                                          002970
               END;                                                       002980
               PROCNT = PROCNT + 1;     /* INCREMENT CURRENT COUNT   */   002990
               II = INDEX(CARDR_NME,' '); /* FIND END OF NAME        */   003000
               IF II = 0 THEN II = 9;   /* IF NO BL THEN 8CHAR NAME  */   003010
               IF SUBSTR(INREC,3,II-1) =                                  003020
                    SUBSTR(CARDR_NME,1,II-1) /* TEST FOR CONSISTENCY */   003030
               THEN GO TO WPROC;        /* GO WRITE PROC IF CONSISTEN*/   003040
               OUTREC = '// ';          /* PRESARE OUTREC            */   003050
               SUBSTR(OUTREC,3,II-1) = SUBSTR(CARDR_NME,1,II-1); /*  */   003060
               SUBSTR(OUTREC,16,4) = 'PROC';                              003070
               SUBSTR(OUTREC,21,72-I) = SUBSTR(INREC,I+6,72-I);           003080
               INREC = OUTREC;          /* MOVE NEW ONTO OLD         */   003090
 WPROC:                                 /* END OF PROC REPLACEMENT   */   003100
               WRITE FILE(PROCOUT) FROM(INREC);                           003110
               WRITE FILE(INTRDR) FROM(INREC);                            003120
               IF SUBSTR(INREC,I+5,76-I) = ' ' /* TEST FOR SYMBOLICS */   003130
               THEN GO TO READ;                                           003140
               IF ^SWPARM THEN GO TO READ; /* DONT TELL IF NOT PARM  */   003150
               LINE_STEP = ' ';                                           003160
               LINE_CARD = INREC;                                         003170
               LINE_MESS = 'PROC HAS SYMBOLIC PARMS';                     003180
               WRITE FILE(ERRLIST) FROM(LINE_AREA);                       003190
               GO TO READ;                                                003200
         END;                                                             003210
 INRBL:                                                                   003220
         IF SUBSTR(INREC,1,71) = '// '                                    003230
         THEN DO;                                                         003240
               LINE_CARD = INREC;                                         003250
               LINE_MESS = 'NULL CARD';                                   003260
                                        /* ALLOW NULL CARD TO DELIMIT*/   003270
                                        /* .. & ENSURE IT STAYS LAST */   003280
               REXIT = INRBL2;          /* SET RETURN ADDRESS        */   003290
               GO TO ENDDD;             /* TERMINATE DD STATEMENT    */   003300
 INRBL2:       REXIT = INRBL1;          /* SET RETURN ADDRESS        */   003310
               GO TO ENDEXEC;           /* TERMINATE LAST STEP       */   003320
 INRBL1:       WRITE FILE(ERRLIST) FROM(LINE_AREA);                       003330
               WRITE FILE(PROCOUT) FROM(INREC);                           003340
               WRITE FILE(INTRDR) FROM(INREC);                            003350
               GO TO READ;                                                003360
         END;                                                             003370
1/*      PROCESS COMMENTS CARDS                                      */   003380
                                                                          003390
         IF SUBSTR(INREC,1,3) = '//*'                                     003400
         THEN DO;                                                         003410
               WRITE FILE(PROCOUT) FROM(INREC);                           003420
               WRITE FILE(INTRDR) FROM(INREC);                            003430
               GO TO READ;                                                003440
         END;                                                             003450
0                                                                         003460
0                                                                         003470
0/*      PROCESS DATA DELIMITERS                                     */   003480
                                                                          003490
         IF SUBSTR(INREC,1,2) = '/*'                                      003500
         THEN DO;                                                         003510
               WRITE FILE(PROCOUT) FROM(INREC);                           003520
               WRITE FILE(INTRDR) FROM(INREC);                            003530
               LINE_STEP = ' ';                                           003540
               LINE_CARD = INREC;                                         003550
               LINE_MESS = 'UNEXPECTED DELIMITTER';                       003560
               WRITE FILE(ERRLIST) FROM(LINE_AREA);                       003570
               GO TO READ;                                                003580
         END;                                                             003590
0                                                                         003600
0                                                                         003610
0/*      PROCESS JOB CARDS                                           */   003620
                                                                          003630
         IF FLDJOB                      /* TEST IF JOB CARD          */   003640
         THEN DO;                                                         003650
               LINE_CARD = INREC;                                         003660
               LINE_MESS = 'UNEXPECTED JOB CARD';                         003670
               WRITE FILE(ERRLIST) FROM(LINE_AREA);                       003680
               WRITE FILE(PROCOUT) FROM(INREC);                           003690
               GO TO READ;                                                003700
         END;                                                             003710
1/*      PROCESS S INIT COMMAND CARDS                                */   003720
                                                                          003730
         IF FLDS                        /* IF S INIT.P0              */   003740
         THEN DO;                       /* ... THEN ...              */   003750
               REXIT = SINIT1;          /* SET RETURN ADDRESS        */   003760
               GO TO ENDDD;             /* TERMINTAE LAST DD STAT    */   003770
 SINIT1:       REXIT = SINIT2;          /* SET RETURN ADDRESS        */   003780
               GO TO ENDEXEC;           /* TERMINATE LAS STEP        */   003790
 SINIT2:       WRITE FILE(PROCOUT) FROM(INREC); /* WRITE S INIT      */   003800
               GO TO READ;              /* GET NEXT RECORD           */   003810
         END;                           /* END OF S INIT LOOP        */   003820
0                                                                         003830
0                                                                         003840
0/*      PROCESS SUPERFLUOUS PROC STATEMENTS                         */   003850
                                                                          003860
         IF FLDPROC                     /* TEST FOR PROC STATEMENT   */   003870
         THEN DO;                       /* ... THEN ...              */   003880
               LINE_CARD = INREC;       /* MOVE CARD TO LINE         */   003890
               LINE_MESS = 'SUPERFLUOUS PROC CARD - DELETD';              003900
               WRITE FILE(ERRLIST) FROM(LINE_AREA); /* TELL OF ERROR */   003910
               GO TO READ;              /* GO GET NEXT CARD          */   003920
         END;                           /* END OF PROC ERROR ROUTINE */   003930
1/*      PROCESS EXEC CARDS                                          */   003940
-                                                                         003950
-/*      FIRST ENSURE THAT IT IS AN EXEC CARD.  IF IT IS, THEN            003960
         TERMINATE THE LAST DD STATEMENT.                            */   003970
         I = INDEX(INREC,' EXEC ');                                       003980
         IF I = 0                                                         003990
         THEN GO TO CNTEX;                                                004000
         REXIT = EXEC01;                                                  004010
         GO TO ENDDD;                                                     004020
 EXEC01: REXIT = EXEC02;                                                  004030
         GO TO ENDEXEC;                                                   004040
-                                                                         004050
-/*      TERMINATE THE PREVIOUS STEP, IF ANY, BY :-                       004060
               ADDING SYSUT6 IF MONPROGM FORCED                           004070
               ADDING SYSUDUMP IF NONE IN STEP                            004080
         NOTE THAT SYSUDUMP IS NOT FORCED FOR IBM PROCEDURES.        */   004090
                                                                          004100
 ENDEXEC:                                                                 004110
         IF ^SWEXEC                     /* IF NO EXEC YET FND        */   004120
         THEN GO TO REXIT;              /* THEN BYPASS ROUTINE       */   004130
         IF ^SWEX                       /* IF NO CURRENT STEP        */   004140
         THEN GO TO REXIT;              /* THEN BYPASS TERMINATION   */   004150
         SWEX = '0'B;                   /* ENSURE DONT REPROCESS     */   004160
         IF SWADD6                      /* IF MONPROGM FORCED ..     */   004170
         THEN WRITE FILE(INTRDR) FROM(CARD_SYSUT6); /* ... +DD SYSUT6*/   004180
         IF ^SWUDMP THEN                /* IF NO SYSUDUMP FOUND ..   */   004190
         WRITE FILE(INTRDR) FROM(CARD_UDUMP); /* .. ADD SYSUDUMP     */   004200
         IF SWADD6                                                        004210
         THEN WRITE FILE(PROCOUT) FROM(CARD_SYSUT6);                      004220
         IF SWIBM THEN GO TO NODUMP;         /* IF IBM PGM, SKIP DUMP*/   004230
         IF ^SWUDMP & ^IEFPROC          /* IF NOT IBM & NO DUMP      */   004240
         THEN WRITE FILE(PROCOUT) FROM(CARD_UDUMP);                       004250
 NODUMP: SWIBM = '0'B;                                                    004260
         SWADD6 = '0'B;                                                   004270
         SWUDMP = '0'B;                                                   004280
         SWDD1  = '0'B;                                                   004290
         SWDD   = '0'B;                                                   004300
         LINE_STEP=' ';                                                   004310
         GO TO REXIT;                                                     004320
1/*      PROCESS EXEC CARD - CONT'D                                  */   004330
-                                                                         004340
-/*      NOW PROCESS THE CURRENT EXEC CARD BY :-                          004350
               REPLACING IEHPROGM BY MONPROGM                             004360
               REMOVING PARM=CORE FORM SORTS                         */   004370
                                                                          004380
 EXEC02: J = INDEX(INREC,' ');          /* SEARCH FOR 1ST BLANK      */   004390
         IF J ^= 3                      /* IF COL 3 NOT BLANK        */   004400
         THEN LINE_STEP = SUBSTR(INREC,3,J-3); /* MOVE STEP NAME     */   004410
         J = INDEX(INREC,'IEHPROGM');                                     004420
         IF J ^= 0                                                        004430
         THEN SWADD6 = '1'B;                                              004440
         SWEX = '1'B;                   /* SHOW STEP EXISTS          */   004450
         IF SWADD6                                                        004460
         THEN SUBSTR(INREC,J,8) = 'MONPROGM'; /* REPLACE WITH MONPROG*/   004470
         SWEXEC = '1'B;                 /* SHOW 1ST EXEC FOUND       */   004480
         SW467 = '0'B;                  /* ASSUME NOT UT467          */   004490
         I = INDEX(INREC,'PGM=');       /* LOCATE PGM=               */   004500
         IF I = 0                       /*NIF NO PGM =               */   004510
         THEN DO;                       /* ... IT IS AN ERROR SO ... */   004520
               LINE_MESS = 'PROC INVOKES PROC'; /* SET ERROR MESSAGE */   004530
               LINE_CARD = INREC;       /* ADD CARD IMAGE            */   004540
               WRITE FILE(ERRLIST) FROM(LINE_AREA); /* WRITE MESSAGE */   004550
               CALL PLIRETC(8);        /* SET COND CODE             */    004560
               GO TO READ;              /* GT NXT RECORD             */   004570
         END;                           /* END OF ERROR ROUTINE      */   004580
         IF SUBSTR(INREC,I,6) = 'PGM=UT' /* TEST FOR A UTILITY       */   004590
         THEN SW467 = '1'B;             /* SET SW IF YES             */   004600
         I = I + 4;                          /* JUMP OVER PGM= */         004610
         IF SUBSTR(INREC,I,2) = 'IE'         /* TEST FOR IBM PGM     */   004620
             THEN SWIBM = '1'B;              /* SET SWITCH IF FOUND  */   004630
         IF SUBSTR(INREC,I,2) = 'IF'         /* TEST FOR IBM PGM     */   004640
             THEN SWIBM = '1'B;              /* SET SWITCH IF FOUND  */   004650
         IF SUBSTR(INREC,I,2) = 'IM'         /* TEST FOR IBM PGM     */   004660
             THEN SWIBM = '1'B;              /* SET SWITCH IF FOUND  */   004670
         IF SUBSTR(INREC,I,7) = 'LIBRARY'    /* TEST FOR IBM PGM     */   004680
             THEN SWIBM = '1'B;              /* SET SWITCH IF FOUND  */   004690
         IF SUBSTR(INREC,I,8) = 'SHARDISK'   /* TEST FOR IBM PGM     */   004700
             THEN SWIBM = '1'B;              /* SET SWITCH IF FOUND  */   004710
         J = INDEX(INREC,'IERRCO00');                                     004720
         IF J = 0                                                         004730
         THEN GO TO EXEC03;                                               004740
                                        /* AN ERROR IN AN EARLY PGM  */   004750
                                        /* CREATED ',PARM=' '        */   004760
         I = INDEX(INREC,',PARM='' ');  /* SEARCH FOR ERROR          */   004770
         IF I ^= 0                      /* IF ERROR FOUND THEN       */   004780
         THEN SUBSTR(INREC,I,7) = ' ';  /* DELETE BAD PARM           */   004790
         J = INDEX(INREC,'CORE=');                                        004800
         IF J = 0                                                         004810
         THEN GO TO EXEC03;                                               004820
         LAREA = SUBSTR(INREC,J,81-J);  /* PRESERVE 'CORE ' ONWARDS  */   004830
         I = INDEX(LAREA,',');          /* SEARCH FOR 1ST ','        */   004840
         K = INDEX(LAREA,'''');         /* SEARCH FOR 1ST '          */   004850
         IF I ^= 0 & K ^= 0                                               004860
         THEN J2 = MIN(I,K);            /* SET J2 TO 1ST             */   004870
         ELSE IF I ^= 0 THEN J2 = I;                                      004880
                        ELSE J2 = K;                                      004890
         J2 = J + J2 - 1;               /* POINT J2 AT 1ST ',' OR '  */   004900
         /* J POINTS AT 'C' OF CORE */                                    004910
         /* J2 POINTS AT , OR ' FOLLOWING VALUE */                        004920
         SUBSTR(INREC,J,71-J) = SUBSTR(INREC,J2,71-J); /* SLIDE ALONG*/   004930
         /* WE NOW HAVE PARM='' */                                        004940
         /*          OR PARM='XX' */                                      004950
         I = INDEX(INREC,'PARM=');                                        004960
         IF SUBSTR(INREC,I,7) = 'PARM='''''                               004970
         THEN SUBSTR(INREC,I-1,64-I) = SUBSTR(INREC,I+7,64-I);            004980
 EXEC03: WRITE FILE(PROCOUT) FROM(INREC);                                 004990
 WRITE FILE(INTRDR) FROM(INREC);                                          005000
         GO TO READ;                                                      005010
 CNTEX:  I = INDEX(INREC,' DD ');                                         005020
         IF I ^= 0 THEN GO TO DDSTRT;                                     005030
         IF SWDD1 THEN GO TO DDCONT;                                      005040
         /* MUST BE CONTINUED EXEC STATEMENT */                           005050
         WRITE FILE(PROCOUT) FROM(INREC);                                 005060
         WRITE FILE(INTRDR) FROM(INREC);                                  005070
         GO TO READ;                                                      005080
 DDSTRT: REXIT = DDST01;                                                  005090
         SUBSTR(INREC,72,1) = ' ';      /* REMOVE ANY CONTINUATION   */   005100
         GO TO ENDDD;                                                     005110
 DDST01: SWDD1 = '1'B;                                                    005120
         SWDD  = '1'B;                                                    005130
         POOL1 = ' ';                                                     005140
         POOL2 = ' ';                                                     005150
         P = ADDR(POOL1);                                                 005160
         I = INDEX(INREC,' DD ');                                         005170
         DO J = 1 TO 66;                                                  005180
               IF SUBSTR(INREC,I+3+J,1) ^= ' '                            005190
               THEN GO TO DDST02;                                         005200
         END;                                                             005210
 DDST02: I = I + 3 + J;  /* I POINTS AT START OF OPERAND */               005220
         LAREA = SUBSTR(INREC,I,81-I);  /* PRESERVE REST OF CARD     */   005230
         J = INDEX(LAREA,' ');          /* FIND 1ST BLANK            */   005240
         J = I + J - 2;                 /* POINT AT LAST NON-BLANK   */   005250
         WAREA = SUBSTR(INREC,1,J);     /* PRESERVE NON-BL DD STAT'T */   005260
         L = LENGTH(WAREA);                                               005270
         GO TO READ;                                                      005280
 DDCONT: SUBSTR(INREC,72,1) = ' ';      /* REMOVE ANY CONTINAUTION   */   005290
         DO J = 1 TO 69;                /* FIND START OF FIELD       */   005300
               IF SUBSTR(INREC,2+J,1) ^= ' '                              005310
               THEN GO TO DDCT01;                                         005320
         END;                                                             005330
 DDCT01: I = J + 2;     /* I POINTS AT 1ST NON BLANK */                   005340
         LAREA = SUBSTR(INREC,I,81-I);  /* PRESERVE REST OF CARD     */   005350
         J = INDEX(LAREA,' ');          /* FIND 1ST BLANK            */   005360
         J = J - 1;                     /* POINT AT LAST NONBLANK    */   005370
         WAREA = WAREA || SUBSTR(INREC,I,J);                              005380
         L = LENGTH(WAREA);                                               005390
         GO TO READ;                                                      005400
1/*                                                                       005410
         THIS SECTION OF CODING ANALYSES, ALTERS, AND REFORMATS           005420
         THE CONCATENATED DD STATEMENT.  EXHAUSTIVE CHECKS ARE            005430
         PERFROMED, AND STANDARDS ARE FORCED.                             005440
         IT IS EXECUTED WHEN THE END OF A DD STATAEMENT IS                005450
         RECOGNISED, BY THE PRESECE OF ANY OF THE FOLLOWING -             005460
               NULL CARD                                                  005470
               DD CARD                                                    005480
               EXEC CARD                                                  005490
               END OF PROC                                                005500
               COMMAND CARD                                          */   005510
                                                                          005520
 ENDDD:                                                                   005530
         IF ^SWDD                                                         005540
         THEN GO TO REXIT;    /* EXIT IF NO DD STATEMENT   */             005550
         POOL1 = ' ';                   /* EMPTY POOL1               */   005560
         POOL2 = ' ';                   /* EMPTY POOL2               */   005570
         SUBSTR(POOL1,1,L) = WAREA;     /* MOVE CONCATENATED STAT    */   005580
         A = 3;                         /* POINT AT SRART OF DDN     */   005590
         IF SUBSTR(POOL1,3,1) = ' '     /* TEST IF DDNAME            */   005600
         THEN GO TO ENDDD02;            /* BYPASS IF CONCATENATED    */   005610
         QEXIT = ENDDD01;               /* SET RETURN ADDRESS        */   005620
         GO TO GETLEN;                  /* DETERMINE LENGTH          */   005630
 ENDDD01: DDNAME=SUBSTR(POOL1,3,C);     /* PRESERVE DDNAME           */   005640
 ENDDD02:                               /* END OF DDN PRESERVATIOM   */   005650
         SWDD = '0'B;         /* SET OFF SO DON'T REPROCES */             005660
                              /* SET POINTERS & SWITCHES   */             005670
                              /* FIRST SET SWITCHES OFF    */             005680
         LINE_CARD = SUBSTR(POOL1,1,80);                                  005690
1/*      SET ALL DD STATEMENT SWITCHES OFF                          */    005700
                                                                          005710
         SWUNIT = '0'B;                                                   005720
         SWVOL  = '0'B;                                                   005730
         SWSER  = '0'B;                                                   005740
         SWREF  = '0'B;                                                   005750
         SWDCBZ = '0'B;                                                   005760
         SWLIB  = '0'B;                                                   005770
         SWSPCE = '0'B;                                                   005780
         SWDSN  = '0'B;                                                   005790
         SWLABL = '0'B;                                                   005800
         SWDCB  = '0'B;                                                   005810
         SWDUMY = '0'B;                                                   005820
         SWSYSO = '0'B;                                                   005830
         SWCONT = '0'B;                                                   005840
         SWDISP = '0'B;                                                   005850
         SWISAM = '0'B;                                                   005860
         SWGDG  = '0'B;                                                   005870
         SWSYSD = '0'B;                                                   005880
         SWSEP  = '0'B;                                                   005890
         SWTEMP = '0'B;                                                   005900
         SWTAPE = '0'B;                                                   005910
         SWPDS  = '0'B;                                                   005920
         SWRLSE = '0'B;                                                   005930
         SWNEW  = '0'B;                                                   005940
         SWRETP = '0'B;                                                   005950
         SWSRT = '0'B;                                                    005960
         SWDDN = '0'B;                                                    005970
         SWINTR = '0'B;                                                   005980
         SWNOBR = '0'B;                                                   005990
         SWUSYM = '0'B;                                                   006000
         UCHAR = ' ';                                                     006010
         SW00E = '0'B;                                                    006020
         DSN = ' ';                                                       006030
         SWRIGM = '0'B;                                                   006040
         J1 = 0;                                                          006050
         J2 = 0;                                                          006060
         J3 = 0;                                                          006070
         J4 = 0;                                                          006080
         J5 = 0;                                                          006090
1/*      INITIALISE POINTERS AND SET SWITCHES                       */    006100
                                                                          006110
         IF SUBSTR(POOL1,3,8) = 'STEPLIB ' /* IF STEPLIB CARD ..     */   006120
         THEN SWLIB = '1'B;             /* ... SET SWITCH            */   006130
         IF SUBSTR(POOL1,3,8) = 'SORTLIB ' /* IF SORTLIB CARD ...    */   006140
         THEN SWLIB = '1'B;             /* ... SET SWITCH            */   006150
         I = INDEX(POOL1,' DDNAME=');   IF I ^= 0 THEN SWDDN = '1'B;      006160
         I1 = INDEX(POOL1,'UNIT=');     IF I1 ^= 0 THEN SWUNIT = '1'B;    006170
         I2 = INDEX(POOL1,'VOL=');      IF I2 ^= 0 THEN SWVOL  = '1'B;    006180
         IF I2 = 0 THEN                                                   006190
         I2 = INDEX(POOL1,'VOLUME=');   IF I2 ^= 0 THEN SWVOL = '1'B;     006200
         I3 = INDEX(POOL1,'SER=');      IF I3 ^= 0 THEN SWSER  = '1'B;    006210
         I4 = INDEX(POOL1,'REF=');      IF I4 ^= 0 THEN SWREF  = '1'B;    006220
         I5 = INDEX(POOL1,'SPACE=');    IF I5 ^= 0 THEN SWSPCE = '1'B;    006230
         I6 = INDEX(POOL1,'DSN=');                                        006240
         IF I6= 0 THEN                                                    006250
         I6 = INDEX(POOL1,'DSNAME=');   IF I6 ^= 0 THEN SWDSN  = '1'B;    006260
         I7 = INDEX(POOL1,'LABEL=');    IF I7 ^= 0 THEN SWLABL = '1'B;    006270
         I8 = INDEX(POOL1,'DCB=');      IF I8 ^= 0 THEN SWDCB  = '1'B;    006280
         I9 = INDEX(POOL1,' DUMMY');    IF I9 ^= 0 THEN SWDUMY = '1'B;    006290
         IA = INDEX(POOL1,'SYSOUT=');   IF IA ^= 0 THEN SWSYSO = '1'B;    006300
         IB = INDEX(POOL1,',,CONTIG)'); IF IB ^= 0 THEN SWCONT = '1'B;    006310
         IC = INDEX(POOL1,'DISP=');     IF IC ^= 0 THEN SWDISP = '1'B;    006320
         ID = INDEX(POOL1,'RETPD=');    IF ID ^= 0 THEN SWRETP = '1'B;    006330
         IF ID = 0 THEN                                                   006340
         ID = INDEX(POOL1,'EXPDT=');    IF ID ^= 0 THEN SWRETP = '1'B;    006350
         IE = INDEX(POOL1,'SEP=');      IF IE ^= 0 THEN SWSEP  = '1'B;    006360
         IG = INDEX(POOL1,',RLSE');     IF IG ^= 0 THEN SWRLSE = '1'B;    006370
         IF IG = 0 THEN                                                   006380
         IG = INDEX(POOL1,',&RLSE');    IF IG ^= 0 THEN SWRLSE = '1'B;    006390
         I = INDEX(POOL1,'INTRDR');     IF I ^= 0 THEN SWINTR = '1'B;     006400
         IF SWVOL                       /* IF VOL SPECIFIED          */   006410
         THEN DO;                       /* ... THEN ...              */   006420
               IF SUBSTR(POOL1,I2,7) = 'VOLUME='  /* TEST FOR VOLUME */   006430
               THEN DO;                 /* THEN ...                  */   006440
                    SUBSTR(POOL1,I2,7) = '   VOL='; /* ALTER VOLUME T*/   006450
                    I2 = I2 + 3;        /* ADJUST POINTER            */   006460
               END;                     /* END SUBROUTINE            */   006470
         END;                           /* END MAIN ROUTINE          */   006480
         IF ^SWDSN & ^SWSPCE            /* IF NO DSN OR SPACE        */   006490
         THEN GO TO NODSN;              /*  .. THEN BYPASS           */   006500
         IF ^SWDSN                      /* IF NO DSN BUT SPCAE       */   006510
         THEN GO TO DSN03S;             /* GO TEST FOR PDS           */   006520
         I = INDEX(POOL1,'DSORG=IS');   /* TEST FOR IS D/S           */   006530
         IF I ^= 0 THEN SWISAM = '1'B;  /* SHOW IS IF IS             */   006540
         IF SUBSTR(POOL1,I6,4) = 'DSN=' /* TEST IF DSN= OR DSNAME=   */   006550
         THEN J1 = I6 + 4;              /* POINT J1 AT 1ST CHAR OF . */   006560
         ELSE J1 = I6 + 7;              /* . DSNAME REGARDLESS       */   006570
         IF SUBSTR(POOL1,I6,7) = 'DSNAME=' /* IF DSNAME ...          */   006580
         THEN SUBSTR(POOL1,I6,7) = 'DSN=   '; /* ... ALTER TO DSN    */   006590
         A = J1;                        /* POINT AT 1ST CHAR OF DSN  */   006600
         QEXIT = DSN01;                 /* SET RETURN ADDRESS        */   006610
         GO TO GETLEN;                  /* GET LENGTH OF DSN         */   006620
 DSN01:  J2 = J1 + C;                   /* J2 POINTS AT DELIMITTER   */   006630
         IF SUBSTR(POOL1,J2-1,1) = ')'  /* IF ENDS IN ) ...          */   006640
         THEN DO;                       /* ... THEN ...              */   006650
         LAREA = SUBSTR(POOL1,I6,J2+1-I6); /* MOVE DSN TO AREA       */   006660
         I = INDEX(LAREA,'(');          /* FIND EQUIVALENT '('       */   006670
         J5 = I6 + I - 1;               /* POINT J5 AT '('           */   006680
         J2 = J5 - 1;                   /* POINT J2 AT LAST CHAR     */   006690
         END;                                                             006700
         ELSE J2 = J2 - 1;              /* POINT J2 AT LAST CHAR     */   006710
         DSN = SUBSTR(POOL1,J1,J2-J1+1); /* PRESERVE DSN             */   006720
         IF J5 = 0                      /* IF NO '(' ...             */   006730
         THEN GO TO DSN03;              /* THEN BYPASS               */   006740
         IF SUBSTR(POOL1,J5+1,6) = 'PRIME)'  /* IF IT IS (PRIME)     */   006750
         THEN GO TO DSN02;                   /* FLAG'AS ISAM         */   006760
         IF SUBSTR(POOL1,J5+1,6) = 'INDEX)'  /* IS IT (INDEX)        */   006770
         THEN GO TO DSN02;                   /*  FLAG AS ISAM        */   006780
         IF SUBSTR(POOL1,J5+1,7) = 'OVFLOW)' /* IF IT IS (OVFLOW)    */   006790
         THEN GO TO DSN02;                   /*  FLAG AS ISAM        */   006800
         IF SUBSTR(POOL1,J5+1,1) = '+'       /* IF IT IS +GDG        */   006810
         THEN GO TO DSN03;                   /*  BYPASS IF YES       */   006820
         IF SUBSTR(POOL1,J5+1,1) = '-'       /* IF IT IS -GDG        */   006830
         THEN GO TO DSN03;                   /*  BYPASS IF YES       */   006840
         IF SUBSTR(POOL1,J5+1,1) = '0'       /* IF IT IS 0-GDG       */   006850
         THEN GO TO DSN03;                   /*  BYPASS IF YES       */   006860
         SWPDS = '1'B;                       /* ASSUME IT IS PDS     */   006870
         GO TO DSN03;                        /* JUMP FLAGGING AS IS  */   006880
 DSN02:  SWISAM = '1'B;                      /* FLAG AS ISAM D/S     */   006890
 DSN03:  IF SUBSTR(POOL1,3,8) = 'IAMRIGAM'   /* IF IT'S RIGAM ...    */   006900
         THEN SWRIGM = '1'B;                 /* SET ON FLAG          */   006910
         IF SUBSTR(POOL1,3,6) = 'RIGAM '     /* IF IT'S RIGAM ...    */   006920
         THEN SWRIGM = '1'B;                 /*  SET ON FLAG         */   006930
         IF SWISAM | SWRIGM | SWPDS          /* IF D/S TYPE KNOWN .. */   006940
         THEN GO TO ISTSTX;             /* ... THEN BYPASS TESTS     */   006950
 DSN03S:                                /* TEST SPACE FOR PDS        */   006960
         IF ^SWSPCE                     /* IF NO SPACE ...           */   006970
         THEN GO TO ISTST;              /* .. THEN GO TEST IF ISAM   */   006980
         A = I5 + 7;                    /* POINT AT CYL/TRK/BLOCK    */   006990
         QEXIT = DSN04;                 /* SET RETURN ADDRESS        */   007000
         GO TO GETLEN;                  /* GET LENGTH OF SUBFIELD    */   007010
 DSN04:  A = A + C + 1;                 /* POINT AT 2ND SUBFIELD     */   007020
         QEXIT = DSN05;                 /* SET RETURN ADDRESS        */   007030
         IF SUBSTR(POOL1,A,1) ^= '('    /* IS 2ND SUB-SUB-FIELDS     */   007040
         THEN GO TO ISTST;              /* TEST FOR IS IF NOT        */   007050
         A = A + 1;                     /* POINT AT 1ST SUB-SUB      */   007060
         GO TO GETLEN;                  /* GET LENGTH OF 1ST SUBSUB  */   007070
 DSN05:  IF SUBSTR(POOL1,A+C,1) = ')'   /* TEST FOR (NN)             */   007080
         THEN GO TO ISTST;              /* TEST FOR ISAM IF YES      */   007090
         A = A + C + 1;                 /* POINT AT 2ND SUB-SUB      */   007100
         QEXIT = DSN06;                 /* SET RETURN ADDRESS        */   007110
         GO TO GETLEN;                  /* GET LENGTH OF 2ND SUB-SUB */   007120
 DSN06:  IF SUBSTR(POOL1,A+C,1) = ')'   /* TEST FOR (NN,NN)          */   007130
         THEN GO TO ISTST;              /* TEST FOR ISAM IF YES      */   007140
                                        /* ASSUME (NN,NN,NN)         */   007150
                                        /* ASSUME DIRECTORY FOR PDS  */   007160
         SWPDS = '1'B;                  /* SHOW D/S IS PDS           */   007170
         GO TO ISTSTX;                  /* BYPASS ISAM TEST          */   007180
 ISTST:  GO TO ISTSTX;  /* TABLE SEARCH FOR IS DATASETS DELETED.          007190
                           NO LONGER POSSIBLE TO KEEP UP TO DATE */       007200
 ISTSTX:                                /* END OF ISAM SEARCH        */   007210
         IF SUBSTR(POOL1,J5+1,1) = '+'  /* IS IT '(+'                */   007220
         THEN SWGDG = '1'B;             /* IF YES SHOW GDG           */   007230
 NODSN:  IF SUBSTR(POOL1,I1,10) = 'UNIT=SYSDA' /* TEST FOR SYSDA     */   007240
         |  SUBSTR(POOL1,I1,10) = 'UNIT=SYSSQ' /* TEST FOR SYSSQ     */   007250
         THEN SWSYSD = '1'B;            /* SET SW IF SYSDA/SYSSQ     */   007260
         IF SUBSTR(POOL1,I1,11) = 'UNIT=(SYSDA' /* TEST FOR SYSDA    */   007270
         |  SUBSTR(POOL1,I1,11) = 'UNIT=(SYSSQ' /* TEST FOR SYSSQ    */   007280
         THEN SWSYSD = '1'B;            /* SET SW IF (SYSDA/(SYSSQ   */   007290
         IF SUBSTR(POOL1,IC,7) = 'DISP=(,' /* TEST IF NEW IMPLIED    */   007300
         THEN SWNEW =  '1'B;            /* SET SW IF YES             */   007310
         IF SUBSTR(POOL1,IC,9)  = 'DISP=(NEW' /* ? NEW SPECIFIED     */   007320
         THEN SWNEW  = '1'B;            /* SET SW IF YES             */   007330
         IF ^SWDISP & ^SWSYSO & ^SWDUMY /* IF NOT SYSOUT OR DUMMY .. */   007340
         THEN SWNEW  = '1'B;            /* .. & NO DISP THEN NEW     */   007350
         IF SUBSTR(DSN,1,1) = '&'       /* TEST FO TEMPORARY DSN     */   007360
         THEN SWTEMP = '1'B;            /* SET SW IF TEMP D/S NAME   */   007370
         IF SWUNIT                      /* IF UNIT PRESENT ....      */   007380
         THEN DO;                                                         007390
               IF SUBSTR(POOL1,I1,9) = 'UNIT=TAPE'   THEN SWTAPE='1'B;    007400
               IF SUBSTR(POOL1,I1,9) = 'UNIT=2400'   THEN SWTAPE='1'B;    007410
               IF SUBSTR(POOL1,I1,9) = 'UNIT=3420'   THEN SWTAPE='1'B;    007420
               IF SUBSTR(POOL1,I1,9) = 'UNIT=2401'  THEN SWTAPE = '1'B;   007430
               IF SUBSTR(POOL1,I1,9) = 'UNIT=3400'  THEN SWTAPE = '1'B;   007440
               IF SUBSTR(POOL1,I1,10) = 'UNIT=(2401' THEN SWTAPE = '1'B;  007450
               IF SUBSTR(POOL1,I1,10) = 'UNIT=(3400' THEN SWTAPE = '1'B;  007460
               IF SUBSTR(POOL1,I1,10) = 'UNIT=(TAPE' THEN SWTAPE='1'B;    007470
               IF SUBSTR(POOL1,I1,10) = 'UNIT=(2400' THEN SWTAPE='1'B;    007480
               IF SUBSTR(POOL1,I1,10) = 'UNIT=(3420' THEN SWTAPE='1'B;    007490
         IF SUBSTR(POOL1,I1,6) = 'UNIT=&' THEN SWUSYM = '1'B;             007500
         IF SUBSTR(POOL1,I1,7) = 'UNIT=(&' THEN SWUSYM = '1'B;            007510
         IF SUBSTR(POOL1,I1,6) = 'UNIT=(' /* TEST FOR COMPLEX UNIT   */   007520
         THEN UCHAR = SUBSTR(POOL1,I1+6,1); /* THEN GET 1ST CHAR     */   007530
         ELSE UCHAR = SUBSTR(POOL1,I1+5,1); /* THEN GET 1ST CHAR     */   007540
         IF UCHAR = '0'                 /* TEST FOR ABSOLUTE SPECIFIC*/   007550
         THEN SW00E = '1'B;             /* SET SW IF ABSOLUTE        */   007560
         END;                                                             007570
1/*      ALTER SYSABAND TO SYSUDUMP                                 */    007580
                                                                          007590
         IF SUBSTR(POOL1,3,8) = 'SYSABEND'   /* SYSABEND TO SYSUDUMP */   007600
         THEN DO;                            /* IF SYSABEND THEN ... */   007610
               SUBSTR(POOL1,3,8) = 'SYSUDUMP'; /* .. SET TO SYSUDUMP */   007620
               SWUDMP = '1'B;                /* SHOW SYSUDUMP PRESET */   007630
         END;                                /* END OF SYSABEND      */   007640
         IF SUBSTR(POOL1,3,8) = 'SYSUDUMP'   /* FORCE SYSUDUMP ...   */   007650
         THEN SWUDMP = '1'B;                 /* ... FOR EVERY STEP   */   007660
1/*      DELETE 'CONTIG' FROM SORTWKNN ( THANKS TO SYNCSORT )       */    007670
                                                                          007680
         IF SUBSTR(POOL1,3,6) = 'SORTWK'     /* CONTIG FROM SORTWKXX */   007690
         THEN DO;                            /* IF SORTWKXX ...      */   007700
               IF SWCONT THEN                /* & IF CONTIG ...      */   007710
               SUBSTR(POOL1,IB,9) = ')        ';  SWCONT = '0'B;          007720
         SWSRT = '1'B;                                                    007730
         END;                                /* BLANK OUT CONTIG     */   007740
1/*      ALTER DISP=OLD TO SHR FOR LIBRARIES AND INPUT DATA SETS    */    007750
                                                                          007760
         IF SUBSTR(POOL1,3,8) = 'IAMRIGAM' /* TEST FOR IAMRIGAM      */   007770
         |  SUBSTR(POOL1,3,8) = 'STEPLIB ' /* TEST FOR STEPLIB       */   007780
         |  SUBSTR(POOL1,3,8) = 'SORTLIB ' /*  ... OR FOR SORTLIB    */   007790
         THEN GO TO OLDSHR;                  /* IF IAMRIGAM, STEPLIB */   007800
         IF SUBSTR(DDNAME,1,7) = 'SYSUT1'  /* TEST FOR INPUT D/S     */   007810
         THEN GO TO OLDSHR;             /* THEN GO FORCE SHR         */   007820
         IF SUBSTR(DDNAME,1,6) = 'SORTIN' /* TEST FOR INPUT D/S      */   007830
         THEN GO TO OLDSHR;             /* THEN ALTER OLD TO SHR     */   007840
         IF SUBSTR(POOL1,3,6) = 'SYSIN '     /* SORTLIB OR SYSIN ... */   007850
         THEN DO;                            /* OLD TO SHR FOR INPUT */   007860
 OLDSHR:       IF ^SWDISP                    /* IF NO DISP ...       */   007870
               THEN GO TO OLDSHRX;           /* ... THEN BYPASS      */   007880
               IF SUBSTR(POOL1,IC,8) = 'DISP=OLD' /* ALTER OLD ...   */   007890
               THEN SUBSTR(POOL1,IC,8) = 'DISP=SHR'; /* ... TO SHR   */   007900
               IF   SUBSTR(POOL1,IC,9) = 'DISP=(OLD'  /* ALTER (OLD  */   007910
               THEN SUBSTR(POOL1,IC,9) = 'DISP=(SHR'; /* TO (SHR     */   007920
 OLDSHRX: END;                          /* END OF OLD TO SHR         */   007930
1/*      FORCE SPACE FOR OLD OR MOD SEQUENTIAL DATE SETS             */   007940
                                                                          007950
 /*      OUR MODIFIED SOFTWARE ALWAYS RELEASES TO THE TRACK LEVEL         007960
         AND REMOVES THE SECONDARY ALLOCATION.  IN ORDER TO PREVENT       007970
         B37 AND D37 ABENDS, IT IS NECESSARY TO RECODE THE SPACE          007980
         ATTRIBUTES WHEN WRITING TO AN OLD DASD DATA SET.  TO DO THIS     007990
         THE PROGRAM MAKES THE FOLLOWING ARBITRARY BUT HARMLESS           008000
         ASSUMPTIONS ABOUT THE OLD/MOD DATA SETS :-                       008010
               1. IT IS OUTPUT ( IF IT IS NOT, THE SPACE WILL             008020
                    BE IGNORED )                                          008030
               2. IT IS ON DISK. ( IF IT IS NOT, THE SPACE WILL           008040
                    BE IGNORED )                                          008050
               3. 50 TRACKS IS A REASONABLE DEFAULT SECONDARY EXTENT      008060
                                                                     */   008070
                                                                          008080
         IF ^SWDISP                     /* IF NO DISP PARAM ...      */   008090
         THEN GO TO FLABEL;             /* ... THEN DONT FORCE SPACE */   008100
         IF SUBSTR(POOL1,IC,8) = 'DISP=OLD' /* TEST FOR DISP=OLD     */   008110
         | SUBSTR(POOL1,IC,8) = 'DISP=MOD' /* .. OR FOR DISP=MOD     */   008120
         THEN GO TO FSPACE;             /* ..IF MOD/OLD THEN FSPACE  */   008130
         IF SUBSTR(POOL1,IC,9) = 'DISP=(OLD' /* TEST FOR DISP=OLD    */   008140
         |  SUBSTR(POOL1,IC,9) = 'DISP=(MOD' /* .. OR DISP=(MOD      */   008150
         THEN GO TO FSPACE;             /* IF OLD OR MOD THEN FORCE  */   008160
         ELSE GO TO FLABEL;             /* ..SPACE, ELSE BYPASS      */   008170
 FSPACE: IF SWSPCE                           /* ADD SPACE FOR MOD/OLD*/   008180
         THEN GO TO FLABEL;             /* BYPASS IF SPACE PRESENT   */   008190
         IF SWUNIT & SWVOL & SWSER & ^SWDSN /* IF UNIT,VOL,DISP ONLY */   008200
         THEN GO TO FSPCEX;             /* THEN BYPASS ROUTINE       */   008210
         IF SWVOL & SWREF & ^SWDSN      /* IF VOL=REF & DISP ONLY    */   008220
         THEN GO TO FSPCEX;             /* THEN DONT FORCE SPACE     */   008230
         IF SWISAM                      /* IF ISAM FILE THEN ...     */   008240
         THEN GO TO FLABEL;             /* .. DON'T FORCE SPACE      */   008250
         IF SWRIGM                      /* IF RIGAM FILE THEN ...    */   008260
         THEN GO TO FLABEL;             /* ... DON'T FORCE SPACE     */   008270
         IF SWPDS                       /* IF PDS THEN NO SPACE      */   008280
         THEN GO TO FSPCEX;                                               008290
         IF DDNAME = 'SYSLMOD'          /* IF AN OLD PDS THEN ...    */   008300
         THEN GO TO FSPCEX;             /* ... DON'T FOR E SPACE     */   008310
         IF SUBSTR(POOL1,IC,12) = 'DISP=(OLD,DE' /* IF (OLD,DELETE)  */   008320
         THEN GO TO FSPCEX;             /* THEN DO NOT FORCE SPACE   */   008330
         IF SWIBM THEN GO TO FSPCEX;         /* NO SPACE IF IBM PGM  */   008340
         I5 = L + 2;                    /* POINT I5 AT NEW POSN      */   008350
         SWSPCE = '1'B;                 /* SHOW SPACE PRESENT        */   008360
                                 SWRLSE = '1'B; /* SHOW RLSE PRESENT */   008370
         SAREA = SPACE;                 /* SET ADDITIONAL FLD        */   008380
         QEXIT = FSPCEX;                /* SET RETURN ADDRESS        */   008390
         GO TO ADDFLD;                  /* GO ADD SPACE PARAM        */   008400
 FSPCEX:                                /* END OF FORCED SPACE       */   008410
1/*      FORCE RETENTION PERIOD FOR NEW DATA STES                    */   008420
                                                                          008430
 /*      OUR MODIFIED SOFTWARE ALTERS A RETENTION PERIOD TO AN            008440
         EXPIRATION DATE.  AS SOON AS                                     008450
               IPL_DATE > CREATION_DATE + EXPIRY_DATE                     008460
         THE DATA SET IS SCRATCHED.  TO ENSURE THAT WE DON'T LODE         008470
         VITAL DATA SETS, THIS ROUTINE FORCES AN ARBITRARY                008480
         RETENTION PERIOD OF 25 FOR ALL NEW PARMANENT DATA STES.     */   008490
                                                                          008500
 FLABEL: IF ^SWNEW THEN GO TO FLABLX;   /* BYPASS IN NOT NEW D/S     */   008510
         IF SWTEMP THEN GO TO FLABLX;   /* BYPASS IF TEMP D/S       */    008520
         IF SWDDN THEN GO TO FLABLX;    /* BYPASS IF DDNAME          */   008530
         IF SWDUMY THEN GO TO FLABLX;   /* BYPASS IF DUMMY D/S       */   008540
         IF SWSYSO THEN GO TO FLABLX;   /* BYPASS IF SYSOUT D/S      */   008550
         IF SWINTR THEN GO TO FLABLX;   /* BYPASS IF INTERNAL READER */   008560
         IF ^SWDSN THEN GO TO FLABLX;   /* BYPASS IF NO DSN          */   008570
         IF ^SWRETP THEN GO TO FLABL0;  /* IF NO RETPD BYPASS        */   008580
         IF SUBSTR(POOL1,ID,5) = 'EXPDT' /* TEST FOR EXPDT           */   008590
         THEN GO TO FLABLX;             /* BYPASS IF EXPDT           */   008600
         A = ID + 6;                    /* POINT AT START OF PERIOD  */   008610
         QEXIT = CRETP1;                /* SET REURN ADDRESS         */   008620
         GO TO GETLEN;                  /* GET LENGTH OF RETPD       */   008630
 CRETP1: IF C ^> 2                      /* IF LENGTH > 2             */   008640
         THEN GO TO FLABLX;             /* CONTINUE, ELSE BYPASS     */   008650
         E = A + C;                     /* SET TO REPLACE RETPD      */   008660
         A = I7;                        /* PONT AT START OF LABEL    */   008670
         QEXIT = CRETP2;                /* SET RETURN ADDRESS        */   008680
         GO TO GETLEN;                  /* GET LENGTH OF LABEL       */   008690
 CRETP2: B = ID;                        /* START REPLACING AT RETPD  */   008700
         SAREA = 'EXPDT=11000';         /* SET REPLACEMENT STRING    */   008710
         I7 = L + 2;                    /* POINT AT NEW LABEL        */   008720
         QEXIT = CRETP3;                /* SET RETURN ADDERSS        */   008730
         GO TO MOVEFLD;                 /* GO REPLACE RETPD          */   008740
 CRETP3: ID = INDEX(POOL1,'EXPDT');     /* RESET EXPDT POINTER       */   008750
         GO TO FLABLX;                  /* GO TO END OF ROUTINE      */   008760
 FLABL0:                                /* END OF RETPD REPLACEMENT  */   008770
         IF ^SWSYSD & SWNEW & ^SWLABL   /* IF NOT NEW PERM D/S & NO L*/   008780
         THEN GO TO FLABL1;             /* IF^SYSDA & NEW & NO LABEL */   008790
         ELSE GO TO FLABL2;             /* ELSE GO TEST FURTHER      */   008800
 FLABL1: I7 = L + 2;                    /* POINT I7 AT NEW LABEL     */   008810
         SWLABL = '1'B;                 /* SHOW LABEL ...            */   008820
         SWRETP = '1'B;                 /* .. & RETPD PRESENT        */   008830
         SAREA = LABEL;                 /* ESTABLISH NEW FIELD       */   008840
         IF SWGDG                       /* IF GDC CREATION ...       */   008850
         THEN SUBSTR(SAREA,13,1) = '7'; /* ... SET RETPD = 75        */   008860
         ID = I7 + 6;                   /* POINT ID AT NEW RETPD     */   008870
         QEXIT = FLABLX;                /* SET RETURN ADDRESS        */   008880
         GO TO ADDFLD;                  /* GO ADD LABEL PARAM        */   008890
 FLABL2: IF ^SWSYSD & SWNEW & SWLABL & ^SWRETP /* IF NEW & LAB ^ RET */   008900
         THEN GO TO FLABL6;             /* THEN ADD RETPD TO LABEL   */   008910
         ELSE GO TO FLABLX;             /* ELSE BYPASS PROCESISNG    */   008920
1/*      FORCE RETENTION PERIOD  CONT'D                             */    008930
 FLABL6: A = I7;                        /* POINT A AT LABEL PARM     */   008940
         IF SUBSTR(POOL1,I7,7) ^= 'LABEL=(' /* IF SINGLE NUMBER      */   008950
         THEN GO TO FLABL7;             /* THEN GO PROCESS           */   008960
         QEXIT = FLABL5;                /* SET RETURN ADDRESS        */   008970
         GO TO GETLEN;                  /* GET LENGTH OF PARM        */   008980
 FLABL5: B = A + C - 1;                 /* SET TO INSERT AT END      */   008990
         E = B;                         /* SET NOT TO OMIT INFO      */   009000
         QEXIT = FLABL4;                /* SET RETURN ADDRESS        */   009010
         SAREA =',' || SUBSTR(LABEL,7,8); /* MV RETPD=NN TO SAREA    */   009020
         IF SWGDG                       /* IF THIS IS A GDG ...      */   009030
         THEN SUBSTR(SAREA,8,1) = '7';  /* ... ALTER 'NN' TO '75'    */   009040
         SWRETP = '1'B;                 /* SHOW RETPD PRESENT        */   009050
         GO TO MOVEFLD;                 /* ADD RETPD TO LABEL        */   009060
 FLABL4: I7 = D + 2;                    /* POINT I7 AT NEW 'LABEL'   */   009070
         ID = I7 + B - A + 1;           /* POINT ID AT NEW 'RETPD'   */   009080
         GO TO FLABLX;                  /* LEAVE ROUTINE             */   009090
 FLABL7: A = I7;                        /* POINT A AT START OF LAB   */   009100
         QEXIT = FLABL8;                /* SET RETURN ADDRESS        */   009110
         GO TO GETLEN;                  /* DETERMINE PARM LENGTH     */   009120
 FLABL8: B = A + 6;                     /* SET TO INSERT AFTER '='   */   009130
         E = A + 6;                     /* KEEP ALL INFO             */   009140
         SAREA = '(';                   /* SET TO INSERT '('         */   009150
         QEXIT = FLABL9;                /* EST RETRUN ADDRESS        */   009160
         I7 = L + 2;                    /* POINT AT NEW LABL POSN    */   009170
         GO TO MOVEFLD;                 /* GO INSERT '('             */   009180
 FLABL9: SAREA= SUBSTR(LABEL,7,8) || ')'; /* SET ADDITION            */   009190
         QEXIT = FLABLA;                /* SET RETURN ADDRESS        */   009200
         GO TO ADDFLD;                  /* GO ADD RETPD              */   009210
 FLABLA: IF SWGDG                       /* TEST FOR NEW GDG          */   009220
         THEN SUBSTR(POOL1,I7+C+8,1) = '7';                               009230
                                        /* ALTER 25 TO 75            */   009240
 FLABLX:                                /* END OF LABEL PROCESSING   */   009250
1/*      DELETE CHANNEL SEPARARION                                  */    009260
                                                                          009270
 CHANSEP: IF ^SWSEP                     /* REMOVE CHANNEL SEPARATION */   009280
          THEN GO TO CHANSPX;           /* BYPASS IF NO 'SEP'        */   009290
         IF SUBSTR(POOL1,IE-1,1) = ' '  /* TEST FOR PRECEDING BL     */   009300
         |  SUBSTR(POOL1,IE-1,1) = ','  /* TEST FOR PRECEDING ','    */   009310
          THEN GO TO CHNSP2;            /* VERIFY THIS IS A SEP PARM */   009320
         ELSE GO TO CHANSPX;            /* BYPASS ROUTINE IF NOT     */   009330
 CHNSP2:  A = I1;                       /* POINT 'A' AT STRT OF 'UNT'*/   009340
          QEXIT = CHNSP21;              /* SET RETURN ADDRESS        */   009350
          GO TO GETLEN;                 /* GET LENGTH OF UNIT        */   009360
 CHNSP21: IF IE > A & IE < A + C        /* TEST IF SEP WITHIN UNIT   */   009370
         THEN GO TO CHANSPX;            /* IF YESY BYPASS ROUTINE    */   009380
 CHNSP4:  A = IE;                       /* POINT AT START OF SEP     */   009390
          QEXIT = CHNSP5;               /* SET RETURN ADDRESS        */   009400
          GO TO GETLEN;                 /* GET LENGTH OF SEP         */   009410
 CHNSP5:  SUBSTR(POOL1,IE,C+1) = ' ';   /* BLANK OUT SEP             */   009420
         SWSEP = '0'B;                  /* SHOW NO MORE SEP          */   009430
 CHANSPX:                               /* END OF CHANNEL SEPARATION */   009440
1/*      DETECT & FLAG PERMANENT DATA SETS ON SYSDA                 */    009450
                                                                          009460
         IF SWSYSD & ^SWDSN             /* IF SYSDA & NO DSN, THEN   */   009470
         THEN GO TO SYSERX;             /* TEMP D/S SO IGNORE        */   009480
         IF SWSYSD & SWTEMP             /* IF SYSDA AND && THEN      */   009490
         THEN GO TO SYSERX;             /* TEMP D/S SO IGNORE        */   009500
         IF ^SWSYSD                     /* IF NOT SYSDA              */   009510
         THEN GO TO SYSERX;             /* ... THEN IGNORE           */   009520
         LINE_MESS = 'PERMANENT D/S ON SYSDA'; /* ERROR MESSAGE IN ..*/   009530
         WRITE FILE(ERRLIST) FROM(LINE_AREA);  /* .. & TELL OF ERROR */   009540
         CALL PLIRETC(8);              /* SET COND CODE             */    009550
 SYSERX:                                                                  009560
1/*      FORCE TEMP D/S TO SYSDA IF NOT ON TAPE                     */    009570
0        IF SWTEMP & ^SWSYSD & ^SWTAPE  /* IF && NOT ON SYSDA OR TPE*/    009580
         THEN GO TO FSYSDA;             /* THEN GO FORCE TO SYDA,    */   009590
         ELSE GO TO FSYSDX;             /* ELSE BYPASS ROUTINE       */   009600
 FSYSDA: IF SWUSYM                      /* IF UNIT IS SYMBOLIC PARM  */   009610
         THEN GO TO FSYSDX;             /* .. THEN DO NOT ALTER      */   009620
         IF SUBSTR(POOL1,I1,9) = 'UNIT=AFF=' /* IF UNIT AFF ...     */    009630
         THEN DO;                       /* ... THEN ...             */    009640
               LINE_MESS = 'TEMP D/S WITH UNIT AFFINITY'; /* SET ERR*/    009650
               WRITE FILE(ERRLIST) FROM(LINE_AREA); /* .. PRINT MES */    009660
               GO TO FSYSDX;            /* ... BUT ASSUME VALID & LET*/   009670
         END;                                                             009680
         IF SWUNIT                      /* IF UNIT EXISTS(IT SHOULD) */   009690
         THEN GO TO FSYSD1;             /* .. THEN GO MODIFY IT      */   009700
         ELSE GO TO FSYSDX;             /* OTHERWISE BRANCH          */   009710
         SAREA = 'UNIT=SYSDA';          /* SET TO ADD UNIT           */   009720
         SWUNIT = '1'B;                 /* SHOW UNIT NOW PRESENT     */   009730
         I1 = L + 2;                    /* POINT I1 AT NEW UNIT      */   009740
         SWSYSD = '1'B;                 /* SHOW SYSDA NOW PRESENT    */   009750
         QEXIT = FSYSDX;                /* SET RETURN ADDRESS        */   009760
         GO TO ADDFLD;                  /* GO ADD UNIT=SYSDA         */   009770
 FSYSD1: IF SUBSTR(POOL1,I1,6) = 'UNIT=(' /* IF LARGE PARM THEN ...  */   009780
         THEN GO TO FSYSDS;             /* .. GO HANDLE DIFFERENTLY  */   009790
         A = I1;                        /* POINT A AT START OF FIELD */   009800
         QEXIT = FSYSD2;                /* SET RETURN ADDRESS        */   009810
         GO TO GETLEN;                  /* GET LENGTH OF UNIT        */   009820
 FSYSD2: B = A;                         /* START INSERTION AT START  */   009830
         E = A + C;                     /* SET TO DELETE ORIGINAL    */   009840
         SAREA = 'UNIT=SYSDA';          /* SET NEW UNIT PARAMETER    */   009850
         I1 = L + 2;                    /* POINT I1 AT NEW UNIT      */   009860
         SWSYSD = '1'B;                 /* SHOW SYSDA PRESENT        */   009870
         QEXIT = FSYSDX;                /* SET RETURN ADDRESS        */   009880
         GO TO MOVEFLD;                 /* GO REPLACE UNIT FIELD     */   009890
 FSYSDS: A = I1 + 6;                    /* POINT AT 1ST CHAR AFTER ( */   009900
         QEXIT = FSYSD3;                /* SET RETURN ADDRESS        */   009910
         GO TO GETLEN;                  /* GET LENGTH OF SUBPARM     */   009920
 FSYSD3: B = I1 + 6;                    /* B POINTS AT START OF SPRM */   009930
         E = B + C;                     /* E POINTS AT END OF SUBPRM */   009940
         A = I1;                        /* A POINTS AT START OF UNIT */   009950
         I1 = L + 2;                    /* I1 POINTS AT NEW UNIT POS */   009960
         SWSYSD = '1'B;                 /* SHOW SYSDA NOW PRESENT    */   009970
         QEXIT = FSYSD4;                /* SET RETURN ADDRESS        */   009980
         GO TO GETLEN;                  /* GET LENGTH OF UNIT        */   009990
 FSYSD4: QEXIT = FSYSDX;                /* SET RETURN ADDRESS        */   010000
         SAREA = 'SYSDA';               /* SET TO INSERT SYSDA       */   010010
         GO TO MOVEFLD;                 /* MOVE & MODIFY UNIT        */   010020
 FSYSDX:                                /* END OF FORCED SYSDA FOR & */   010030
1/*      DELETE 'VOL=' IF SYSDA DATA SET                            */    010040
                                                                          010050
         IF SWSYSD & SWVOL              /* IF SYSDA & VOL, ....      */   010060
         THEN GO TO DELVOL;             /* ... THEN GO DELETE VOL    */   010070
         ELSE GO TO DELVOLX;            /* ... OTHERWISE BYPASS      */   010080
 DELVOL: A = I2;                        /* POINT A AT START          */   010090
         QEXIT = DELVL1;                /* SET RETURN ADDRESS        */   010100
         GO TO GETLEN;                  /* GET LENGTH OF VOL PARM    */   010110
 DELVL1: SUBSTR(POOL1,A,C+1) = ' ';     /* BLANK OUT VOL             */   010120
         SWVOL = '0'B;                  /* SHOW VOL NOT PRESENT      */   010130
         SWSER = '0'B;                  /* SHOW SER NOT PRESENT      */   010140
 DELVOLX:                               /* END OF VOL DELETION       */   010150
         IF SUBSTR(POOL1,I1,12) ^= 'UNIT=(SYSDA,' /* TEST FOR BIG SYS*/   010160
         THEN GO TO DSYSDX;             /* LEAVE ROUTINE IF NOT      */   010170
                                        /*MUST BE VOLUME COUNT, DEFER*/   010180
                                        /* OR SEP.  DELETE IT        */   010190
         A = I1;                        /* POINT A AT START          */   010200
         QEXIT = DSYSD1;                /* SET RETURN ADDRESS        */   010210
         GO TO GETLEN;                  /* GET LENGTH                */   010220
 DSYSD1: SAREA = 'UNIT=SYSDA';          /* SET SUBSTITUTION STRING   */   010230
         B = A;                         /* STERT REPLACING AT START  */   010240
         E = A + C;                     /* REPLACE ENTIRE ENTRY      */   010250
         QEXIT = DSYSDX;                /* SET RETURN ADDRESS        */   010260
         GO TO MOVEFLD;                 /* GO REPLACE UNIT           */   010270
 DSYSDX:                                /* END OF SYSDA REPL         */   010280
         IF SWUNIT &  ^SWTAPE           /* IF UNIT AND NOT TAPE ...  */   010290
         & ^SWSYSD & SWSER &SWVOL       /* ... AND NOT SYSDA & SER   */   010300
         THEN GO TO SEREF;              /* ... THEN GO ALTER TO REF  */   010310
         ELSE GO TO SEREFX;             /* ... ELSE BYPASS PROCESSIG */   010320
 SEREF:  IF SUBSTR(POOL1,I3,5) = 'SER=(' /* TEST FOR MULTIPLE VOLSER */   010330
         THEN DO;                       /* ERROR IF YES              */   010340
               LINE_MESS = 'MULTIPLE VOLUMES SPECIFIED';                  010350
               WRITE FILE(ERRLIST) FROM(LINE_AREA);                       010360
               CALL PLIRETC(8);        /* SET COND CODE             */    010370
               GO TO SEREFX;            /* BYPASS FURTHER PROCESSING */   010380
         END;                                                             010390
         A = I2;                        /* POINT A AT START OF VOL   */   010400
         QEXIT = SEREF1;                /* SET RETURN ADDRESS        */   010410
         GO TO GETLEN;                  /* GET LENGTH OF VOL         */   010420
 SEREF1: B = I3;                        /* START REPLACEMENT AT 'SE' */   010430
         E = B+4;                       /* END REPLACEMENT AT 'R='   */   010440
         SAREA = 'REF=DISK.';           /* SET REPLACEMENT STRING    */   010450
         SWREF = '1'B;                  /* SHOW REF NOW PRESENT      */   010460
         QEXIT = SEREFX;                /* SET RETURN ADDRESS        */   010470
         SWSER = '0'B;                  /* SHOW NO SER               */   010480
         GO TO MOVEFLD;                 /* ALTER SER TO REF=DISK.    */   010490
 SEREFX:                                /* END OF SER TO REF         */   010500
1/*      DELETE UNIT SPECIFICATIONS FOR DASD DATA SETS               */   010510
                                                                          010520
 /*      OUR STANDARDS DICTATE THAT JCL SHOULD BE DEVICE-TYPE AND         010530
         VOLUME SERIAL INDEPENDENT.  OLD DATA SETS SHOULD BE RETRIEVED    010540
         VIA THE CATALOGUE, AND NEW DATA STES SHOULD BE ALLOCATED         010550
         VIA VOLUME REFERENCE POINTERS ( WHICH IMPLY UNIT )9  THUS        010560
         UNIT NEED NEVER BE SPECIFIED FOR PERMANENT DASD DATA SETS.  */   010570
                                                                          010580
         IF SWTAPE & SWSER              /* IF TAPE & VOLSER ...      */   010590
         THEN DO;                       /* ... THEN TELL OF ERROR    */   010600
               LINE_MESS = 'TAPE SERIAL NUMBER SPECIFIED';                010610
               CALL PLIRETC(8);        /* SET COND CODE             */    010620
               WRITE FILE(ERRLIST) FROM(LINE_AREA);                       010630
         END;                           /* END OF TAPE VOLSER        */   010640
         IF SWUNIT & ^SWSYSD & ^SWTAPE  /* IF UNIT BUT NOT TAPE/SYSD */   010650
         THEN GO TO DELUNT;             /* THEN DELETE UNIT          */   010660
         ELSE GO TO DELUNITX;           /* ELSE BYPASS               */   010670
 DELUNT: IF SUBSTR(POOL1,I1,9) = 'UNIT=AFF='  /* IFF UNIT AFFINITY . */   010680
         THEN GO TO DELUNITX;           /* .. THEN IGNORE            */   010690
         IF SUBSTR(POOL1,I1,6) = 'UNIT=&' /* TEST FOR SYMBOLIC PRM   */   010700
         THEN GO TO DELUNITX;           /* BYPASS DELETION IF YES    */   010710
         IF SWINTR THEN GO TO DELUNITX; /* BYPASS IF INTERNAL READER */   010720
         IF SUBSTR(POOL1,I1,9) = 'UNIT=SEP='  /* IF UNIT SEPARATION  */   010730
         THEN GO TO DELUNITX;           /* .. THEN IGNORE.           */   010740
         IF SW00E                       /* IF ABSOLUTE UNIT SPEC     */   010750
         THEN GO TO DELUNITX;           /* ... THEN IGNORE           */   010760
         IF SUBSTR(POOL1,I1,6) = 'UNIT=('  /* IF SUB-PARAMETERS ...  */   010770
         THEN GO TO DELUNS;             /* ... THEN TREAT DIFFERENT  */   010780
         A = I1;                        /* POINT A AT START OF UNIT  */   010790
         QEXIT = DELUN1;                /* SET RETURN ADDRESS        */   010800
         GO TO GETLEN;                  /* GO GET LENGTH OF UNIT     */   010810
 DELUN1: SUBSTR(POOL1,A,C+1) = ' ';     /* BLANK OUT UNIT            */   010820
         SWUNIT = '0'B;                 /* SHOW UNIT DELETED         */   010830
         GO TO DELUNITX;                /* GO TO END OF ROUTINE      */   010840
 DELUNS: A = I1;                        /* POINT A AT START OF UNIT  */   010850
         QEXIT = DELUNC;                /* SET RETURN ADDRESS        */   010860
         GO TO GETLEN;                  /* GET LENGTH OF UNIT        */   010870
 DELUNC: IF SUBSTR(POOL1,A+C-3,3) = ',P)' /* IS IT PARALLEL MOUNTING */   010880
         THEN GO TO DELUN2;             /* GO ALTER IF YES           */   010890
         ELSE GO TO DELUN3;             /* GO PROCESS IF NO          */   010900
 DELUN2: SAREA = 'UNIT=(,P)';           /* SET NEW UNIT PARM         */   010910
         I1 =  L + 2;                   /* POINT I1 AT NEW POSITION  */   010920
         B = A;                         /* START REPLACEMENT AT 'UN' */   010930
         E = A + C;                     /* END REPLACEMENT AT ',P)'  */   010940
         QEXIT = DELUNITX;              /* SET RETURN ADDRESS        */   010950
         GO TO MOVEFLD;                 /* REPLACE UNIT PARM         */   010960
 DELUN3: A = I1 + 6;                    /* POINT AT 1ST SUBPARM      */   010970
                                        /* ASSUME IT'S DEVTYPE       */   010980
         QEXIT = DELUN4;                /* SET RETURN ADDRESS        */   010990
         GO TO GETLEN;                  /* GET LENGTH OF SUB-PARM    */   011000
 DELUN4: IF C ^= 0                      /* IF SUBPARM EXISTS ...     */   011010
         THEN SUBSTR(POOL1,A,C) = ' ';  /* ... THEN BLANK IT OUT     */   011020
 DELUNITX:                              /* END OF DELETE UNIT        */   011030
1/*      ENSURE THAT RLSE IS SPECIFIED IN SPACE REQUESTS             */   011040
                                                                          011050
 /*      HOWEVER, RLSE IS NOT FORCED IN THE FOLLOWING CASES -             011060
               RIGAM D/S                                                  011070
               ISAM D/S                                                   011080
               PDS                                                        011090
               SORT WORK D/S                                              011100
                                                                     */   011110
         IF SWSRT THEN GO TO FRLSEX;    /* DONT FORCE RLSE FOR SORTWK*/   011120
         IF SWSPCE & SWRLSE             /* IF SPACE & RELEASE ...    */   011130
         THEN GO TO FRLSEX;             /* ... THEN BYPASS           */   011140
         IF ^SWSPCE                     /* IF NO SPACE PARAM ...     */   011150
         THEN GO TO FRLSEX;             /* BYPASS IF ISAM D/S        */   011160
         IF SWISAM THEN GO TO FRLSEX;   /* BYPASS IF ISAM FILE       */   011170
         IF SWPDS  THEN GO TO FRLSEX;   /* BYPASS IF PDS   FILE      */   011180
         IF SWRIGM THEN GO TO FRLSEX;   /* BYPASS IF RIGAM FILE      */   011190
         IF SWIBM THEN GO TO FRLSEX;    /* BYPASS IF IBM PROGRAM     */   011200
         SWRLSE = '1'B;                 /* SHOW RLSE ADDED           */   011210
         A = I5 + 7;                    /* POINT AT CYL/TRK/BLOCKS   */   011220
         QEXIT = FRLSE1;                /* SET RETURN ADDRESS        */   011230
         GO TO GETLEN;                  /* GET LENGTH OF 1ST PARAM   */   011240
 FRLSE1: A = A + C + 1;                 /* POINT AT START OF 2ND     */   011250
         QEXIT = FRLSE2;                /* SET RETURN ADDRESS        */   011260
         GO TO GETLEN;                  /* GET LENGTH OF 2ND PARAM   */   011270
 FRLSE2: B = A + C;                     /* POINT B AT INSERTION POIN */   011280
         IF SUBSTR(POOL1,B,1) = ')'     /* IF SPACE=(XX,(YY)) ...    */   011290
         THEN E = B;                    /* THEN LEAVE THE ')' ...    */   011300
         ELSE E = B + 1;                /* ELSE OMIT THE ','         */   011310
         SAREA = ',RLSE';               /* ESTABLISH INSERTION STRNG */   011320
         QEXIT = FRLSE3;                /* SET RETURN ADDRESS        */   011330
         A  = I5;                       /* POINT AT START OF SPACE   */   011340
         I5 = L + 2;                    /* POINT AT NEW POSN OF SPCE */   011350
         GO TO GETLEN;                  /* GET LENGTH OF SPACE       */   011360
 FRLSE3: QEXIT = FRLSEX;                /* SET RETURN ADDRESS        */   011370
         GO TO MOVEFLD;                 /* ADD RLSE TP SPACE         */   011380
 FRLSEX:                                /* END OF FORCING RLSE       */   011390
1/*      REMOVE RLSE FROM SPACE REQUESTS FOR PDS                     */   011400
                                                                          011410
         IF ^SWPDS  THEN GO TO RRLSEX;  /* IGNORE IF NOT PDS         */   011420
         IF ^SWSPCE THEN GO TO RRLSEX;  /* IGNORE IF NO SPACE        */   011430
         IF ^SWRLSE THEN GO TO RRLSEX;  /* IGNORE IF NO RLSE         */   011440
         SWRLSE = '0'B;                 /* SET OFF RLSE SWITCH       */   011450
         IF SUBSTR(POOL1,IG,6) = ',RLSE)' /* TEST IF RLSE LAST PARM  */   011460
         THEN SUBSTR(POOL1,IG,6) = ')'; /* BLANK OUT ',RLSE' IF YES  */   011470
         ELSE SUBSTR(POOL1,IG+1,4) = ' '; /* BLANK OUT 'RLSE' IF NO  */   011480
 RRLSEX:                                /* END OF RLSE REMOVAL       */   011490
0                                                                         011500
0                                                                         011510
 /*      DETECT ANY ATTEMPT TO RE-ALLOCATE AN IS D/S                 */   011520
                                                                          011530
 /*      NOTE THAT AN IS D/S NEED ONLY BE RE-ALLOCATED IF IT IS           011540
         EBING EXTENDED - OTHERWISE IR MAY BE RECREATED                   011550
         OVER ITSELF.                                                */   011560
                                                                          011570
         IF ^SWISAM THEN GO TO ISDSAX;  /* BR IF NOT ISAM D/S        */   011580
         IF ^SWNEW  THEN GO TO ISDSAX;  /* BR IF NOT NEW DATA SET    */   011590
         LINE_MESS = 'UNNECESSARY ALLOCATION OF ISAM';                    011600
         WRITE FILE(ERRLIST) FROM(LINE_AREA); /* TELL OF ERROR       */   011610
         CALL PLIRETC(4);              /* SET COND CODE             */    011620
 ISDSAX:                                /* END OF ERROR ROUTINE      */   011630
0                                                                         011640
0                                                                         011650
1/*      REMOVE DCB FOR DDNAME SYSOUT WITH UT467                     */   011660
0/*      AT ONE TIME, IN  A FIT OF MASOCHISTIC FURY, I ADDED A ROUTINE    011670
          THAT ASSUMED A DDNAME OF SYSOUT MUST BE IN A COBOL PROGRAM,     011680
          AND HENCE REQUIRED DCB INFORMATION.  IN A VAIN ATTEMPT TO       011690
          PREVENT 013 ABENDS, I FORCED LRECL & BLKSIZE OF 120.  THIS      011700
          COMPLETELY OVERLOOKED THE FACT THAT SYSOUT IS USED IN MANY      011710
          OF MY UTILITIES WITH AN LRECL OF 133.  THUS I PREVENTED A       011720
          FEW 013S IN COBOL AND CREATED DOZENS IN BAL.  THIS ROUTINE      011730
          DETECTS UTILITIES AND REMOVES THE DCB FROM SYSOUT IF ANY.  */   011740
                                                                          011750
         IF SUBSTR(POOL1,3,7) ^= 'SYSOUT ' /* TEST FOR SYSOUT DDNAME */   011760
         THEN GO TO SDCBX;              /* BR IF NOT                 */   011770
         IF SW467 THEN GO TO SDCB1;     /* IF UTILITY THEN PROCESS   */   011780
         GO TO SDCBX;                   /* BYPASS ROUTINE            */   011790
 SDCB1:  IF ^SWDCB                      /* IF NO DCB                 */   011800
         THEN GO TO SDCBX;              /* ... THEN BUPASS           */   011810
         A = I8;                        /* PONT AT START OF DCB      */   011820
         QEXIT = SDCB2;                 /* SET ERTURN ADDRESS        */   011830
         GO TO GETLEN;                  /* GET LENGTH OF DCB         */   011840
 SDCB2:  SWDCB = '0'B;                  /* SET OFF DCB SWICH         */   011850
         SUBSTR(POOL1,A-1,C+1) = ' ';   /* BLANK OUT DCB             */   011860
 SDCBX:                                 /* END OF SYSOUT SPECIAL     */   011870
1/*      ENSURE THAT VOL=REF SPECIFIES QUALIFIED POINTER             */   011880
                                                                          011890
 /*      ALL VOLUME REFERENCE POINTERS SHOULD BE OF THE FORM -            011900
               VOL=REF=AAA.BBB                                       */   011910
                                                                          011920
         IF ^SWREF                      /* IF ND REF PRESENT ...     */   011930
         THEN GO TO AREFX;              /* .. THEN BYPASS ALTERING   */   011940
         A = I4 + 4;                    /* POINT A AT START OF REFIC */   011950
         IF SUBSTR(POOL1,A,1) = '*'     /* IF THIS IS A REFERBACK .. */   011960
         THEN GO TO AREFX;              /* .. THEN BYPASS            */   011970
         QEXIT = AREF1;                 /* SET RETURN ADDRESS        */   011980
         GO TO GETLEN;                  /* GET LENGTH OF REF NAME    */   011990
 AREF1:  IF C > 8                       /* IF > 8 MUST BE QUALIFIED. */   012000
         THEN GO TO AREFX;              /* .. SO EXIT                */   012010
         DO I = 1 TO C;                 /* CHECK FOR QUALIFIER...    */   012020
               IF SUBSTR(POOL1,A+I,1) = '.' /* ... IN SHORT QUAL NME */   012030
               THEN GO TO AREFX;        /* EXIT IF QUALIFIED         */   012040
         END;                           /*                           */   012050
         LINE_MESS = 'INVALID VOLUME REFERENCE'; /*SINGLE LEVEL NAMES     012060
                                                   ARE INVALID */         012070
         WRITE FILE(ERRLIST) FROM(LINE_AREA); /* DISPLAY ERROR MESSAGE*/  012080
         /* REFERENCE SEARCH DELETED. NO NEEDED AFTER 3330 CONVERSION*/   012090
 AREFX:                                 /* END OF REF REPLACEMENT    */   012100
1/*      ALTER SPACE REQUIREMENTS FROM 2314 TO 3330                  */   012110
0/*      CYL AND TRK APACE REQUESTS ARE DDCREASED ACCORDING TO            012120
         THE FOLLOWING ALGORITHMS :-                                      012130
               T3330 = T2314 * 3 / 5                                      012140
               C3330 = C2314 * 3 / 5 * 19 / 20                       */   012150
                                                                          012160
         IF ^SWPARM THEN GO TO ASPCEX;  /* BYPASS UNLESS REQUESTED   */   012170
         IF ^SWSPCE THEN GO TO ASPCEX;  /* BYPASS IF NO SPACE        */   012180
         SWSC = '0'B;                   /* ASSUME TRACK ALLOCATION   */   012190
         SWSB = '0'B;                   /* ASSUME NO SUBLIST         */   012200
         SWSA = '0'B;                   /* ASSUME NO CYL-TRK CONV    */   012210
         IF SUBSTR(POOL1,I5+7,4) = 'CYL,' /* TETS IF CYL REQUETS     */   012220
         THEN GO TO ASPCE1;             /* PROCESS IF YES            */   012230
         IF SUBSTR(POOL1,I5+7,4) = 'TRK,' /* TEST IF TRK REQUEST     */   012240
         THEN GO TO ASPCE2;             /* GO PROCESS IF YESY        */   012250
                                        /* MUST BE ABSTR OR BLKSIZE  */   012260
         GO TO ASPCEX;                  /* ... SO IGNORE             */   012270
0/*      FIRST ALTER THE PRINARY ALLOCATION                          */   012280
                                                                          012290
 ASPCE1: SWSC = '1'B;                   /* SHOW ALLOC IS IN CYLS     */   012300
 ASPCE2: IF SUBSTR(POOL1,I5+11,1) = '(' /* TEST FOR SUBLIST          */   012310
         THEN SWSB = '1'B;              /* SET SW IF SUBLIST         */   012320
         NINES = 0;                     /* ZEROISE ....              */   012330
         PACKD = 0;                     /* ... WORK RAEAS            */   012340
         A = I5 + 11;                   /* POINT AT START OF PROMARY */   012350
         IF SWSB                        /* IF SUBLIST PRESENT ...    */   012360
         THEN A = A + 1;                /* .. ADJUST POINTER         */   012370
         IF SUBSTR(POOL1,A,1) = '&'     /* IF SYMBOLIC PARM          */   012380
         THEN GO TO ASPCEY;             /* THEN GO TELL OF IT        */   012390
         QEXIT = ASPCE3;                /* SET RETURN ADDRESS        */   012400
         GO TO GETLEN;                  /* GET LENGTH OF PRIMARY     */   012410
 ASPCE3: SUBSTR(NONES,08-C,C) = SUBSTR(POOL1,A,C); /* EXTRACT PRIMARY*/   012420
         IF VERIFY(NINES,NUMERIC)       /* TEST FRO NUMERIC          */   012430
         THEN GO TO ASPCEV;             /* BR IF NON-NUMERIC         */   012440
         PACKD = NINES;                 /* PACK PRIMARY ALLOCATION   */   012450
         PACKD = PACKD * F3 / F5;       /* PERFORM COMMON CONVERSION */   012460
         IF SWSC THEN                   /* IF ALLOC IN CYLS ...      */   012470
         PACKD = PACKD * F19 / F20;     /* ... THEN CONVERT FURTHER  */   012480
         IF ^SWSC | PACKD > 3           /* IF REQUEST NOT LESS 3 CYL */   012490
         THEN GO TO ASPCE4;             /* ... THEN BYPASS           */   012500
         SWSA = '1'B;                   /* SHOW CYL-TRK CONVERSION   */   012510
         SUBSTR(POOL1,I5+7,3) = 'TRK';  /* ALTER CYL TO TRK          */   012520
         PACKD = PACKD * F19;           /* CONVERT TO TRKS           */   012530
 ASPCE4: IF PACKD < 1                   /* ONLY ROUND UP ......      */   012540
         THEN PACKD = PACKD + 1;        /* ... IF AMOUNT LESSS THAN 1*/   012550
         NINES = PACKD;                 /* UNPACK NEW ALLOCATION     */   012560
         B = A;                         /* POINT AT REPLACEMENT POINT*/   012570
         E = B + C;                     /* PRESERVE TENTATIVE END    */   012580
         DO I = 1 TO 7;                 /* SEARCH FOR 1ST NUMERIC    */   012590
               IF SUBSTR(NINES,I,1) ^= '0' /* LOOK FOR NONZERO       */   012600
               THEN GO TO ASPCE5;       /* BR IF NONZERO FOUND       */   012610
         END;                           /* END OF NONZERO SEARCH     */   012620
 ASPCE5: SAREA = SUBSTR(NINES,I,8-I);   /* ADD ALLOC TO REPL STRING  */   012630
1/*      ALTER SPACE FOR 3330'S ( CONT'D )                           */   012640
0/*      ALTER SECONDARY QUANTITY ( IF ANY )                         */   012650
                                                                          012660
         IF ^SWSB                       /* TEST FOR SUBLIST          */   012670
         THEN GO TO ASPCER;             /* BR IF NO SUBLIST          */   012680
         IF SUBSTR(POOL1,A+C,1) = ')'   /* TEST FOR (NN)             */   012690
         THEN GO TO ASPCER;             /* GO TO REPLACE IF YER      */   012700
         IF SUBSTR(POOL1,A+C,2) = ',,'  /* TEST FOR (NN,,NN)         */   012710
         THEN GO TO ASPCER;             /* BR TO REPLACE IF YES      */   012720
         IF SUBSTR(POOL1,A+C,1) = '&'   /* TEST FOR SYMBOLIC SECONDAR*/   012730
         THEN GO TO ASPCEY;             /* BR IF SYNBOLIC            */   012740
         IF SUBSTR(POOL1,A+C,2) = ',&'  /* TEST FOR SYMBOLIC SECONDRY*/   012750
         THEN GO TO ASPCEY;             /* BR IF SYNBOLIC            */   012760
 ASPCE6: A = A + C + 1;                 /* POINT AT START OF SEC     */   012770
         QEXIT = ASPCE7;                /* SET RETURN ADDERSS        */   012780
         GO TO GETLEN;                  /* GET LENGTH OF SECONDARY   */   012790
 ASPCE7: NINES = 0;                     /* SEROISE ....              */   012800
         PACKD = 0;                     /* ... WORH AREAS            */   012810
         SUBSTR(NONES,08-C,C) = SUBSTR(POOL1,A,C); /* EXTRACT SEC AMO*/   012820
         IF VERIFY(NINES,NUMERIC)       /* TEST FOR NUMERIC          */   012830
         THEN GO TO ASPCEV;             /* BR IN NON-NUMERIC         */   012840
         PACKD = NINES;                 /* PACK SECONDARY QUANT      */   012850
         PACKD = PACKD * F3 / F5;       /* PERFORM COMMON CONVERSION */   012860
         IF SWSC THEN                   /* IF CYL ALLOCATION         */   012870
         PACKD = PACKD * F19 / F20;     /* PERFORM EXTRA CONVERSION  */   012880
         IF SWSA THEN                   /* ALETR CYL TO TRK ?        */   012890
         PACKD = PACKD * F19;           /* CONVERT TO TRKS IF YES    */   012900
         IF PACKD < 1                   /* ONLY ROUND UP IF ...      */   012910
         THEN PACKD = PACKD + 1;        /* .. AMOUNT LESS THAN U     */   012920
         NINES = PACKD;                 /* UNPACK SECONDARY          */   012930
         E = E + C + 1;                 /* POINT AT END OF REPL      */   012940
         DO I = 1 TO 7;                 /* SEARCJ FOR DATA           */   012950
               IF SUBSTR(NINES,I,1) ^= '0' /* TEST FOR NONZERO       */   012960
               THEN GO TO ASPCE8;       /* BR IF NONZERO FOUND       */   012970
         END;                           /* END OF SEARCH             */   012980
 ASPCE8: SAREA = SAREA || ','           /* ADD ',' TO PRIMARY        */   012990
               || SUBSTR(NINES,I,8-I);  /* ADD SECONDARY             */   013000
0                                                                         013010
0/*      NOW REPLACE THE NEW AMOUNTS IN THE SPACE PARAMETER          */   013020
                                                                          013030
 ASPCER: A = I5;                        /* POINT AT START OF PACE    */   013040
         I5 = L + 2;                    /* POINT AT NE WSPACE        */   013050
         QEXIT = ASPCE9;                /* SET RETURN ADDRESS        */   013060
         GO TO GETLEN;                  /* GET LENFTH OF SPCE        */   013070
 ASPCE9: QEXIT = ASPCEX;                /* SET RETURN ADDRESS        */   013080
         GO TO MOVEFLD;                 /* GO REPLACE SPACE QUANTS   */   013090
 ASPCEV: LINE_MESS = 'SPACE PARAMETER NONNUMERIC'; GO TO ASPCEW;          013100
 ASPCEY: LINE_MESS = 'SYMBOLIC PARM IN SPACE'; /* SET ERROR MESSAGE  */   013110
 ASPCEW: WRITE FILE(ERRLIST) FROM(LINE_AREA); /* WRITE ERROR MESS    */   013120
 ASPCEX:                                /* ENS OF SPACE ALTERATION   */   013130
1/*      ALTER CYLS TO TRKS FOR SMALL DATA SETS                      */   013140
0/*      ALLOCATIONS OF 3 CYLINDERS OR LESS ARE ALTERED TO TRKS TO        013150
          MINIMISE FREE SPACE FRAGMENTATION.                         */   013160
                                                                          013170
         IF SWPARM THEN GO TO CSPCEX;   /* PYPASS IF PARM = SPAXE    */   013180
         IF ^SWSPCE THEN GO TO CSPCEX;  /* BYPASS IF NO SPACE        */   013190
         IF SWISAM THEN GO TO CSPCEX;   /* IS MUST BE ALLOCATED IN CY*/   013200
         SWSC = '0'B;                   /* ASSUME TRACK ALLOCATION   */   013210
         SWSB = '0'B;                   /* ASSUME NO SUBLIST         */   013220
         SWSA = '0'B;                   /* ASSUME NO CYL-TRK CONV    */   013230
         IF SUBSTR(POOL1,I5+7,4) = 'CYL,' /* TETS IF CYL REQUETS     */   013240
         THEN GO TO CSPCE1;             /* PROCESS IF YES            */   013250
         IF SUBSTR(POOL1,I5+7,4) = 'TRK,' /* TEST IF TRK REQUEST     */   013260
         THEN GO TO CSPCEX;             /* IGNORE IF ALREADY TRACKS  */   013270
                                        /* MUST BE ABSTR OR BLKSIZE  */   013280
         GO TO CSPCEX;                  /* ... SO IGNORE             */   013290
 CSPCE1: SWSC = '1'B;                   /* SHOW ALLOC IS IN CYLS     */   013300
 CSPCE2: IF SUBSTR(POOL1,I5+11,1) = '(' /* TEST FOR SUBLIST          */   013310
         THEN SWSB = '1'B;              /* SET SW IF SUBLIST         */   013320
         NINES = 0;                     /* ZEROISE ....              */   013330
         PACKD = 0;                     /* ... WORK RAEAS            */   013340
         A = I5 + 11;                   /* POINT AT START OF PROMARY */   013350
         IF SWSB                        /* IF SUBLIST PRESENT ...    */   013360
         THEN A = A + 1;                /* .. ADJUST POINTER         */   013370
         IF SUBSTR(POOL1,A,1) = '&'     /* IF SYMBOLIC PARM          */   013380
         THEN GO TO CSPCEY;             /* THEN GO TELL OF IT        */   013390
         QEXIT = CSPCE3;                /* SET RETURN ADDRESS        */   013400
         GO TO GETLEN;                  /* GET LENGTH OF PRIMARY     */   013410
 CSPCE3: SUBSTR(NONES,08-C,C) = SUBSTR(POOL1,A,C); /* EXTRACT PRIMARY*/   013420
         IF VERIFY(NINES,NUMERIC)       /* TEST FRO NUMERIC          */   013430
         THEN GO TO CSPCEV;             /* BR IF NON-NUMERIC         */   013440
         PACKD = NINES;                 /* PACK PRIMARY ALLOCATION   */   013450
         IF ^SWSC | PACKD > 3           /* IF REQUEST NOT LESS 3 CYL */   013460
         THEN GO TO CSPCEX;             /* .. THEN BYPASS ROUTINE    */   013470
         SWSA = '1'B;                   /* SHOW CYL-TRK CONVERSION   */   013480
         SUBSTR(POOL1,I5+7,3) = 'TRK';  /* ALTER CYL TO TRK          */   013490
         PACKD = PACKD * F19;           /* CONVERT TO TRKS           */   013500
 CSPCE4: NINES = PACKD;                 /* UNPACK NEW ALLOCATION     */   013510
         B = A;                         /* POINT AT REPLACEMENT POINT*/   013520
         E = B + C;                     /* PRESERVE TENTATIVE END    */   013530
         DO I = 1 TO 7;                 /* SEARCH FOR 1ST NUMERIC    */   013540
               IF SUBSTR(NINES,I,1) ^= '0' /* LOOK FOR NONZERO       */   013550
               THEN GO TO CSPCE5;       /* BR IF NONZERO FOUND       */   013560
         END;                           /* END OF NONZERO SEARCH     */   013570
 CSPCE5: SAREA = SUBSTR(NINES,I,8-I);   /* ADD ALLOC TO REPL STRING  */   013580
1/*      ALTER SPACE FOR 3330'S ( CONT'D )                           */   013590
0/*      ALTER SECONDARY QUANTITY ( IF ANY )                         */   013600
                                                                          013610
         IF ^SWSB                       /* TEST FOR SUBLIST          */   013620
         THEN GO TO CSPCER;             /* BR IF NO SUBLIST          */   013630
         IF SUBSTR(POOL1,A+C,1) = ')'   /* TEST FOR (NN)             */   013640
         THEN GO TO CSPCER;             /* GO TO REPLACE IF YER      */   013650
         IF SUBSTR(POOL1,A+C,2) = ',,'  /* TEST FOR (NN,,NN)         */   013660
         THEN GO TO CSPCER;             /* GO TO REPLACE IF YER      */   013670
         IF SUBSTR(POOL1,A+C,1) = '&'   /* TEST FOR SYMBOLIC SECONDAR*/   013680
         THEN GO TO CSPCEY;             /* BR IF SYNBOLIC            */   013690
         IF SUBSTR(POOL1,A+C,2) = ',&'  /* TEST FOR SYMBOLIC SECONDRY*/   013700
         THEN GO TO CSPCEY;             /* BR IF SYNBOLIC            */   013710
 CSPCE6: A = A + C + 1;                 /* POINT AT START OF SEC     */   013720
         QEXIT = CSPCE7;                /* SET RETURN ADDRESS        */   013730
         GO TO GETLEN;                  /* GET LENGTH OF SECONDARY   */   013740
 CSPCE7: NINES = 0;                     /* ZEROISE ....              */   013750
         PACKD = 0;                     /* ... WORH AREAS            */   013760
         SUBSTR(NONES,08-C,C) = SUBSTR(POOL1,A,C); /* EXTRACT SEC AMO*/   013770
         IF VERIFY(NINES,NUMERIC)       /* TEST FOR NUMERIC          */   013780
         THEN GO TO CSPCEV;             /* BR IN NON-NUMERIC         */   013790
         PACKD = NINES;                 /* PACK SECONDARY QUANT      */   013800
         IF SWSA THEN                   /* ALETR CYL TO TRK ?        */   013810
         PACKD = PACKD * F19;           /* CONVERT TO TRKS IF YES    */   013820
         NINES = PACKD;                 /* UNPACK SECONDARY          */   013830
         E = E + C + 1;                 /* POINT AT END OF REPL      */   013840
         DO I = 1 TO 7;                 /* SEARCJ FOR DATA           */   013850
               IF SUBSTR(NINES,I,1) ^= '0' /* TEST FOR NONZERO       */   013860
               THEN GO TO CSPCE8;       /* BR IF NONZERO FOUND       */   013870
         END;                           /* END OF SEARCH             */   013880
 CSPCE8: SAREA = SAREA || ','           /* ADD ',' TO PRIMARY        */   013890
               || SUBSTR(NINES,I,8-I);  /* ADD SECONDARY             */   013900
0                                                                         013910
0/*      NOW REPLACE THE NEW AMOUNTS IN THE SPACE PARAMETER          */   013920
                                                                          013930
 CSPCER: A = I5;                        /* POINT AT START OF PACE    */   013940
         IF ^SWSA                       /* CHECK IF CYL-TRK CONVERSIO*/   013950
         THEN GO TO CSPCEX;             /* BYPASS IF NO              */   013960
         I5 = L + 2;                    /* POINT AT NE WSPACE        */   013970
         QEXIT = CSPCE9;                /* SET RETURN ADDRESS        */   013980
         GO TO GETLEN;                  /* GET LENFTH OF SPCE        */   013990
 CSPCE9: QEXIT = CSPCEX;                /* SET RETURN ADDERSS        */   014000
         GO TO MOVEFLD;                 /* GO REPLACE SPACE QUANTS   */   014010
 CSPCEV: LINE_MESS = 'SPACE PARAMETER NONNUMERIC'; GO TO CSPCEW;          014020
 CSPCEY: LINE_MESS = 'SYMBOLIC PARM IN SPACE'; /* SET ERROR MESSAGE  */   014030
 CSPCEW: WRITE FILE(ERRLIST) FROM(LINE_AREA); /* WRITE ERROR MESS    */   014040
 CSPCEX:                                /* END OF SPACE ALTERATION   */   014050
1/*      ADD DCB TO GDG(+1)                                          */   014060
0/*      IT IS AN INSTALLATION STANDARD THAT THE DCB ATTRIBUTES OF A */   014070
 /*      NEW MEMBER OF A GDG BE SUPPLIED BY A DCB PARM OF THE FORM -      014080
               DCB=(DSCB,... OVER-RIDING SUBPARMS ...)               */   014090
                                                                          014100
 /*      FIRST CHECK IF THE DAMN FOOL HA  SUPPLIED A DCB PARM             014110
         WITHOUT A PATTERN DCSB SPECIFIED.  IF HE HAS, INSERT 'DSCB,'*/   014120
                                                                          014130
         IF SWGDG & SWNEW & ^SWDCB      /* IF NEW GDG WITHOUT DCB    */   014140
         THEN GO TO GDGDCB;             /* THEN PREPARE TO ADD DCB   */   014150
         IF SWGDG & SWNEW & SWDCB       /* IF NEW GDG WITH DCB       */   014160
         THEN GO TO CDCB;               /* .. THEN GO TEST DCB       */   014170
         ELSE GO TO GDGDCX;             /* .. ELSE BRANCH OUT        */   014180
 CDCB:   IF SUBSTR(POOL1,I8+4,1) ^= '(' /* IF NOT MULTIPLE DCB       */   014190
         THEN GO TO CDCBN;              /* ... THEN GO HANDLE DIFFERE*/   014200
         A = I8 + 5;                    /* POINT AT START OF 1ST     */   014210
         QEXIT = CDCB1;                 /* SET RETURN ADDRESS        */   014220
         GO TO GETLEN;                  /* GET LENGTH OF 1ST PARM    */   014230
 CDCB1:  DO I = 1 TO C;                 /* SEARCH FOR '=' ISGN       */   014240
               IF SUBSTR(POOL1,I8+4+I,1) = '=' /* TEST FOR '='       */   014250
               THEN GO TO CDCB2;        /* BRANCH IF FOUND           */   014260
         END;                           /* END OF '=' SEARCH         */   014270
         GO TO GDGDCX;                  /* NO '=' SIGN FOUND, SO ..  */   014280
                                        /* .. ASSUMS IS PATTERN DSCB */   014290
 CDCB2:  B = I8 + 5;                    /* PIINT AFTER '('           */   014300
         E = B;                         /* OMIT NO NIFORMATION       */   014310
         A = I8;                        /* POINT AT START OF DCB     */   014320
         I8 = L + 2;                    /* POINT AT NEW DCB          */   014330
         SAREA = 'DSCB,';               /* SET INSERTION STRING      */   014340
         QEXIT =  CDCB3;                /* SET RETURB ADDRESS        */   014350
         GO TO GETLEN;                  /* GET LENGTH OF DCB         */   014360
 CDCB3:  QEXIT = GDGDCX;                /* SET RETURN ADDRESS        */   014370
         GO TO MOVEFLD;                 /* INSERT 'DSCB,'            */   014380
 CDCBN:                                 /* DCB HAS ONLY 1 SUBFIELD   */   014390
         A = I8 + 4;                    /* POINT AT SUBPARM          */   014400
         QEXIT = CDCBN1;                /* SET RETURN ADDRESS        */   014410
         GO TO GETLEN;                  /* GET LENGTH OF SUBFIELD    */   014420
 CDCBN1: DO I = 1 TO C;                 /* SEARCH FOR '=' SIGM       */   014430
               IF SUBSTR(POOL1,I8+3+I,1) = '=' /* TEST FOR '='       */   014440
               THEN GO TO CDCBN2;       /* BRANCH IF '=' FOUND       */   014450
         END;                           /* END OF '=' SEARCH         */   014460
         GO TO GDGDCX;                  /* MUST BE DSCB SO LEAVE     */   014470
 CDCBN2: B = I8 + 4;                    /* INSERT AFTER '=' SIGN     */   014480
         E = B;                         /* OMIT NO INFORMATION       */   014490
         SAREA = '(DSCB,';              /* SET INSERTION STRING      */   014500
         A = I8;                        /* OIINT AT TSRAT OF DCB     */   014510
         I8 = L + 2;                    /* POINT AT NEW DCB          */   014520
         QEXIT = CDCBN3;                /* SET RETURN ADDRESS        */   014530
         GO TO GETLEN;                  /* GET LENGTH OF DCB         */   014540
 CDCBN3: QEXIT = CDCBN4;                /* SET RETURN ADDRESS        */   014550
         GO TO MOVEFLD;                 /* INSERT '(DSCB,'           */   014560
 CDCBN4: WAREA = WAREA || ')';          /* ADD TRAILING ')'          */   014570
         L = L + 1;                     /* ADJUST LENGTH             */   014580
         GO TO GDGDCX;                  /* GO TO END OF ROUTINE      */   014590
1/*      GDG(+1) DCB CONT'D                                          */   014600
0/*      THIS SECTION OF CODING USES A SUBROUTINE TH DETERMINE THE        014610
         GDG'S DCB ATTRIBUTES FROM THE PATTERN DSCB AND ADDS THEM         014620
         TO THE DD STATEMENT.                                        */   014630
                                                                          014640
 GDGDCB: IF SWPARM                      /* TEST IF PARM ON           */   014650
         THEN SAREA = 'DCB=(DSCB,OPTCD=Z,'; /* SET OPTCD = Z IF ON   */   014660
         ELSE SAREA = 'DCB=(DSCB,';     /* OTHERWISE NO OPTCD        */   014670
         I8 = L + 2;                    /* POINT AT NEW DCB POSN     */   014680
         SWDCB = '1'B;                  /* SHOW DCB NOW PRESENT      */   014690
         SWDCBZ = '1'B;                 /* SHOW OPTCD = Z PRESENT    */   014700
         POOL2 = ' ';                   /* PREPARE TO RECEIVE DCB    */   014710
         CALL DYNAMO(PARM4,PARM1,PARM2,PARM3);                            014720
         IF RETCD = '2'                 /* IF PATTERN DSCB NOT FOUND */   014730
         THEN DO;                       /* ... THEN ...              */   014740
               LINE_MESS = 'MISSING PATTERN DSCB'; /* ERROR MESSAGE  */   014750
               WRITE FILE(ERRLIST) FROM(LINE_AREA); /* PRINT MESSAGE */   014760
               CALL PLIRETC(8);        /* SET COND CODE             */    014770
         END;                                                             014780
         DO I = 1 TO 50;                /* CONCATENATE DCB FIELDS    */   014790
               IF SUBSTR(POOL2,I,1) = ' ' /* IF REACHED END ...      */   014800
               THEN GO TO GDGDC1;       /* THEN BRANCH               */   014810
               SAREA = SAREA || SUBSTR(POOL2,I,1); /* ADD BYTE TODCB */   014820
         END;                           /* END CONCATENATION         */   014830
 GDGDC1: QEXIT = GDGDCX;                /* SET RETURN ADDRESS        */   014840
         GO TO ADDFLD;                  /* ADD DCB TO BB STATEMENT   */   014850
 GDGDCX:                                /* END OF GDG DCB            */   014860
1/*      OPTCD = Z FOR SEQUENTIAL DASD D/S                           */   014870
0/*      SPECIFYING OPTCD=Z CAUSES A SEQRCH DIRECT CHANNEL PROGRAM        014880
         TO BE CREATED INSTEAD OF A SEARCH PREVIOUS.  THE FORMER          014890
         IS MORE EFFICIENT, SO WE FORCE IT.                          */   014900
                                                                          014910
         GO TO DCBZX;                   /* BYPASS UNTIL Z WORKS      */   014920
         IF SWTAPE THEN GO TO DCBZX;    /* NO OPTCD=Z FOR TAPE       */   014930
         IF SWPDS  THEN GO TO DCBZX;    /* NO OPTCD=Z IF PDS         */   014940
         IF SWRIGM THEN GO TO DCBZX;    /* NO OPTCD=Z IF RIGAM       */   014950
         IF SWISAM THEN GO TO DCBZX;    /* NO OPTCD=Z IF ISAM        */   014960
         IF SWDCBZ THEN GO TO DCBZX;    /* NO OPTCD=Z IF EXISTS NOW  */   014970
         IF SWDUMY THEN GO TO DCBZX;    /* NO OPTCD=Z IF DUMMY D/S   */   014980
         IF SWSYSO THEN GO TO DCBZX;    /* NO OPTCD=Z IF SYSOUT D/S  */   014990
         IF SWLIB  THEN GO TO DCBZX;    /* NO OPTCD=Z IF STEP/SORTLB */   015000
         IF SWDDN THEN GO TO DCBZX;     /* NO OPTCD=Z IF DDNAME      */   015010
         IF SWSRT THEN GOTO DCBZX;      /* NO OPTCD=Z FOR SORTWK     */   015020
         IF SWVOL & SWDISP & ^SWDSN     /* IF DISP & VOL ONLY        */   015030
         THEN GO TO DCBZX;              /* .. THEN BYPASS OPTCD=Z    */   015040
         IF SWDCB  THEN GO TO DCBZ1;   /* IF DCB THEN GO MODIFY     */    015050
         SWDCB = '1'B;                  /* SHOW CB NOW PRESENT       */   015060
         SWDCBZ = '1'B;                 /* SHOW OPTCD=Z PRESENT NOW  */   015070
         SAREA = 'DCB=OPTCD=Z';         /* ESTABLISH NEW PARAMETER   */   015080
         I8 = L + 2;                    /* POINT I8 AT NEW DCB POSN  */   015090
         QEXIT = DCBZX;                 /* SET RETURN ADDRESS        */   015100
         GO TO ADDFLD;                  /* GO ADD DCB PARAMETER      */   015110
 DCBZ1: I = INDEX(POOL1,'OPTCD=');     /* SEE IF OPTCD ALREADY      */    015120
         IF I ^= 0                      /* IF OPTCD ALREADY EXISTS,  */   015130
         THEN GO TO DCBZ6;             /* .. THEN BRANCH             */   015140
         SAREA = ',OPTCD=Z';            /* SET INSERTION STRING      */   015150
         IF SUBSTR(POOL1,I8,5) ^= 'DCB=(' /* TEST IF MULTI-PARMS     */   015160
         THEN GO TO DCBZ3;             /* BRANCH IF NOT TO FORCE     */   015170
         A = I8;                        /* POINT A AT START OF DCB   */   015180
         QEXIT = DCBZ2;                /* SET RETURN ADDRESS         */   015190
         GO TO GETLEN;                  /* GET LENGTH OF DCB         */   015200
 DCBZ2: B = A + C - 1;                 /* START INSERTION AT ')'     */   015210
         E = B;                         /* PRESERVE ')'              */   015220
         I8 = L + 2;                    /* POINT I8 AT NEW DCB       */   015230
         QEXIT = DCBZX;                /* SET RETURN ADDRESS         */   015240
         SWDCBZ = '1'B;                 /* SHOW DCBZ PRESENT         */   015250
         GO TO MOVEFLD;                 /* ADD OPTCD TO DCB=(....)   */   015260
 DCBZ3: SAREA = '(OPTCD=Z,';           /* SET INSERTION STRING       */   015270
         A = I8;                        /* POINT AT START OF DCB     */   015280
         QEXIT = DCBZ4;                /* SET RETURN ADDRESS         */   015290
         GO TO GETLEN;                  /* GET LENGTH OF DCB         */   015300
 DCBZ4: B = A + 4;                     /* START INSERTING AFTER '=' */    015310
         E = A + 4;                     /* PRESERVE EXISTING PARM    */   015320
         I8 = L + 2;                    /* POINT IB AT NEW DCB       */   015330
         SWDCBZ = '1'B;                 /* SHOW OPTCD = Z PRESENT    */   015340
         QEXIT = DCBZ5;                /* SET RETURN ADDRESS        */    015350
         GO TO MOVEFLD;                 /* INSERT '(OPTCD=Z,'        */   015360
 DCBZ5:  L = L + 1;                     /* POINT PAST END OF PARAM   */   015370
         SUBSTR(POOL1,L,1) = ')';       /* ADD TRAILING ')'          */   015380
         GO TO DCBZX;                  /* GO TO END OF ROUTINE      */    015390
1/*      OPTCD = Z  CONT'D                                          */    015400
                                                                          015410
 DCBZ6:                                /* OPTCD PRESENT: TEST FOR Z */    015420
         A = I + 6;                     /* POINT AFTER =             */   015430
         QEXIT = DCBZ8;                 /* SET RETURN ADDRESS        */   015440
         GO TO GETLEN;                  /* GET LENGTH                */   015450
 DCBZ8: DO I = 1 TO C;                  /* SEARCH OPTCD FOR Z        */   015460
               IF SUBSTR(POOL1,A-1+I,1) = 'Z' /* IF Z FOUND          */   015470
               THEN GO TO DCBZX;       /* THEN EXIT FROM ROUTINE    */    015480
         END;                           /* END OF Z-SEARCH ROUTINE   */   015490
         B = A;                         /* INSERT Z AFTER '='        */   015500
         E = B;                         /* OMIT NO INFORMATION       */   015510
         SAREA = 'Z';                   /* SET TO INSERT Z           */   015520
         SWDCBZ = '1'B;                 /* SHOW OPTCD=Z PRESENT      */   015530
         A = I8;                        /* POINT  A AT START OF DCB  */   015540
         I8 = L + 2;                    /* POINT I8 AT NEW DCB       */   015550
         QEXIT = DCBZ7;                /* SET RETURN ADDRESS        */    015560
         GO TO GETLEN;                  /* GET LENGTH OF DCB         */   015570
 DCBZ7: QEXIT = DCBZX;                /* SET RETURN ADDRESS        */     015580
         GO TO MOVEFLD;                 /* INSERT 'Z' AFTER 'OPTCD=' */   015590
 DCBZX:                                /* END OF FORCING OPTCD=Z    */    015600
                                        /* PREPARE TO OUTPUT DD STAT */   015610
1/*      PREPARE TO OUTPUT DD STATEMENT                             */    015620
                                                                          015630
         POOL2 = ' ';                   /* BLANK OUT POOL2           */   015640
         OUTREC = ' ';                  /* BLANK OUT OUTREC          */   015650
         I = INDEX(POOL1,' ');          /* FIND 1ST BLANK            */   015660
         SUBSTR(OUTREC,1,I) =           /* MOVE '//' OR '//DDN' TO   */   015670
          SUBSTR(POOL1,1,I);            /* .. OUTPUT RECORD          */   015680
         I = INDEX(POOL1,' DD ');       /* FIND ' DD ' CONSTANT      */   015690
         SUBSTR(POOL1,1,I+3) = ' ';     /* BLANK OUT START OF STAT   */   015700
         SUBSTR(OUTREC,16,2) = 'DD';    /* ADD 'DD' TO OUTPUT REC    */   015710
         WAREA = '';                    /* NULLIFY WORK AREA         */   015720
         CNTBR = 0;                     /* ZEROISE COUNT OF ()       */   015730
         DO I = 1 TO 500;               /* LOOP THRU POOLU ...       */   015740
          IF SUBSTR(POOL1,I,1) = '('    /* IF ENTERING (             */   015750
          THEN CNTBR = CNTBR + 1;       /* THEN INCREASE COUNT       */   015760
          IF SUBSTR(POOL1,I,1) = ')'    /* IF LEAVING )              */   015770
          THEN CNTBR = CNTBR - 1;       /* THEN DECREASE COUNT       */   015780
          IF SUBSTR(POOL1,I,1) = ','    /* IF THIS BYTE ,            */   015790
          & SUBSTR(WAREA,L,1) = ','     /* AND LAST WAS ,            */   015800
          & CNTBR = 0                   /* AND NOT WITHIN BRACKETS   */   015810
          THEN SUBSTR(POOL1,I,1) = ' '; /* THEN BLANK OUT EXTRA ,    */   015820
          IF SUBSTR(POOL1,I,1) ^= ' '   /* .. IGNORING BLANKS ...    */   015830
          THEN WAREA = WAREA ||         /* .. AND SAVING CHARACTERS  */   015840
               SUBSTR(POOL1,I,1);       /* .. FOR NEW DD STATEMENT   */   015850
          L = LENGTH(WAREA);            /* GET NEW LENGTH            */   015860
         END;                           /* END DATA SEARCH           */   015870
         L = LENGTH(WAREA);             /* GET LENGTH OF NEW DATA    */   015880
         POOL1 = ' ';                   /* BLANK OUT POOL1           */   015890
         SUBSTR(POOL1,1,L) = WAREA;     /* PRESERVE NEW DATA         */   015900
         IF SUBSTR(POOL1,L,1) = ','     /* IF RTAILING COMMA         */   015910
         THEN DO;                       /* ... THEN ...              */   015920
               SUBSTR(POOL1,L,1) = ' '; /* BLANK COMMA OUT           */   015930
               L = L - 1;               /* DECREMENT LENGTH          */   015940
         END;                           /* END OF ROUTINE            */   015950
         IF L < 52                      /* IF LESS THAN 1 CRAD ...   */   015960
         THEN GO TO ENDDD1;             /* ... THEN GO WRITE         */   015970
         ELSE GO TO ENDDD2;             /* ELSE GO BE CLEVER         */   015980
 ENDDD1: SUBSTR(OUTREC,21,L) = WAREA;   /* ADD DATA TO CARD          */   015990
         WRITE FILE(PROCOUT) FROM(OUTREC); /* WRITE TO NEW PROC      */   016000
         WRITE FILE(INTRDR) FROM(OUTREC); /* WRITE TO TEST JOBSTRM   */   016010
         GO TO ENDDDX;                  /* GO TO END OF ROUTINE      */   016020
1/*      SEPARATE DATE INTO MORE THAN 1 OUTPUT CARD                 */    016030
                                                                          016040
 ENDDD2:                                /* THERE IS MORE THAN 1 CARD */   016050
                                        /* OF DATA SO IT MUST BE     */   016060
                                        /* SEPARATED.  THE FOLLOWING */   016070
                                        /* FIELDS ARE USED -         */   016080
                                        /*  A - START OF CURRENT FLD */   016090
                                        /*  B - START OF CURRENT CRD */   016100
                                        /*  C - LGTH OF CURRENT FLD  */   016110
                                        /*  J1- LGTH OF CURRENT CRD  */   016120
                                        /*  J2- BYTES0CARD (51/56)   */   016130
                                        /*  J3- TOTAL LENGTH USED    */   016140
                                        /*  J4- START POSN IN CARD   */   016150
                                        /*  L - LENGTH OD DATA       */   016160
         A = 1;                         /* POINT A AT START OF POOL1 */   016170
         B = A;                         /* POINT B AT START OF POOL1 */   016180
         J1 = 0;                        /* ZEROISE CARD LENGTH       */   016190
         J2 = 51;                       /* SET MEX DATA0CARD TO 51   */   016200
         J3 = 0;                        /* ZEROISE TOTAL LENGTH      */   016210
         J4 = 21;                       /* SET START POSN OF OUTPUT  */   016220
         QEXIT = ENDDD3;                /* ESTABLISH LOOP ADDRESS    */   016230
         GO TO GETLEN;                  /* GET LENGTH OF FIELD       */   016240
 ENDDD3: J1 = J1 + C + 1;               /* ADD FIELD TO CARD         */   016250
         IF J1 > J2                     /* IF LENGTH EXCEEDS CARD    */   016260
         THEN GO TO ENDDD4;             /* THEN GO WRITE CARD        */   016270
         J3 = J3 + C + 1;               /* INCREMENT TOTAL LENGTH    */   016280
         IF J3 > L                      /* TEST IF DATA EXHAUSTED    */   016290
         THEN GO TO ENDDD5;             /* GO WRITE CARD IF YES      */   016300
         A = J3 + 1;                    /* POINT AT START OF NEXT FLD*/   016310
         GO TO GETLEN;                  /* GET LENGTH & LOOP BACK    */   016320
 ENDDD4: J1 = J1 - C - 1;               /* RESET TO END OF LAST FLD  */   016330
 ENDDD5: SUBSTR(OUTREC,J4,J1) =         /* TO OUTPUT RECORD MOVE ... */   016340
          SUBSTR(POOL1,B,J1);           /* ... FIELDS THAT FIT       */   016350
         IF C > J2 & J1 = 0             /* IF FIELD LARGER THANCARD  */   016360
         THEN DO;                       /* ... THEN ...*             */   016370
               SWNOBR = '1'B;           /* SET TO IGNORE '('         */   016380
               GO TO GETLEN;            /* GO BACK & GET LENGTH      */   016390
         END;                           /* END OF ROUTINE            */   016400
         WRITE FILE(PROCOUT) FROM(OUTREC); /* WRITE TO NEW PROC      */   016410
         WRITE FILE(INTRDR) FROM(OUTREC); /* WRITE TO TEST JOBSTRM   */   016420
         SWNOBR = '0'B;                 /* INDICATE WHOLE PARMS WANTD*/   016430
         B = J3 + 1;                   /* POINT B AT START OF NEW C  */   016440
         J1 = 0;                        /* RESET CARD LENGTH         */   016450
         A = B;                         /* POINT AT 1ST NEW FLD      */   016460
         J2 = 56;                       /* SET TO 56 BYTES MAX0CARD  */   016470
         J4 = 16;                       /* SET TO STRAT IN COL 16    */   016480
         SUBSTR(OUTREC,3,78) = ' ';     /* BLANK OUT OUTPUT          */   016490
         IF J3 > L                      /* TEST IF DATA EXHAUSTED    */   016500
         THEN GO TO ENDDDX;             /* EXIT IF EXHAUSTED         */   016510
         ELSE  GO TO GETLEN;            /* LOOP BACK                 */   016520
 ENDDDX:                                /* END /F DD ROUTINE         */   016530
         GO TO REXIT;                                                     016540
1/*      EXTARCT PARAMETER FROM DD STATEMENT AND ADD TO END         */    016550
                                                                          016560
 MOVEFLD:                /* THIS ROUTINE EXTRACTS A PARAMETER FROM   */   016570
                         /* THE DD STATEMENT, AND ADDS IT TO THE END */   016580
                         /* OF THE STRING WHILE INSERTING OR ALTERING*/   016590
                         /* SUB-PARAMETERS.  OPERATION IS CONTROLLED */   016600
                         /* BY THE FOLLOWING 5 POINTERS -            */   016610
                         /*   A - START OF PARAMETER TO BE EXTRACTED */   016620
                         /*   B - START OF INSERTION OR ALTERATION   */   016630
                         /*   C - LENGTH OF PARAMETER INITIALLY      */   016640
                         /*   D - LENGTH OF DD STATEMENT (FROM L)    */   016650
                         /*   E - RECOMMENCMENT POINT IN PARAMETER   */   016660
         D = L;                         /* SET D TO DD LENGTH        */   016670
         WAREA = SUBSTR(POOL1,1,D) || ',' || /* DD STAT + ','        */   016680
                 SUBSTR(POOL1,A,B-A) || SAREA || /* + PARM + INSERT  */   016690
                 SUBSTR(POOL1,E,A+C-E);          /* + END OF PARM    */   016700
         SUBSTR(WAREA,A,C+1) = ' ';     /* BLANK OUT ORIGINAL FIELD  */   016710
         L = LENGTH(WAREA);             /* SET L TO FIELD LENGTH     */   016720
         SUBSTR(POOL1,1,L) = WAREA;     /* MOVE NEW STAT'T TO POOL1  */   016730
         GO TO QEXIT;                   /* RETURN TO CALLER          */   016740
1/*      ADD PARAMETER TO END OF CONCATENATED DD STAEMENT           */    016750
                                                                          016760
 ADDFLD:                 /* THIS ROUTINE ADDS A PARAMETER TO THE END */   016770
                         /* OF THE DD STATEMENT.                     */   016780
         WAREA = SUBSTR(POOL1,1,L) || ',' || SAREA; /* ADD NEW TO OLD*/   016790
         L = LENGTH(WAREA);                  /* GET LENGTH OF NEW ST */   016800
         SUBSTR(POOL1,1,L) = WAREA;          /* MOVE NEW DD TO POOL1 */   016810
         GO TO QEXIT;                        /* RETURN TO CALLER     */   016820
1/*      DETERMINE THE LENGTH OF A PARAMETER                        */    016830
                                                                          016840
 GETLEN:                 /* THIS ROUTINE DETERMINES THE LENGTH OF A  */   016850
                         /* PARAMETER OR SUBPARAMETER.               */   016860
                         /* ON ENTRY, A POINTS AT THE START OF THE   */   016870
                         /* FIELD, AND C IS SET TO THE LENGTH.       */   016880
         CNTBR = 0;      /* ZEROISE COUNT OF PARENTHESES             */   016890
         C = A;          /* POINT AT START OF FIELD                  */   016900
 GETLN1: IF C > L                       /* END OF STAT'T DELIMITS    */   016910
         THEN GO TO GETLNX;                                               016920
         IF SUBSTR(POOL1,C,1) = '('     /* KEEP CNT OF '(' ENTERED   */   016930
         THEN CNTBR = CNTBR + 1;                                          016940
         IF SUBSTR(POOL1,C,1) = ')'     /* KEEP CNT OF ')' LEFT      */   016950
         THEN CNTBR = CNTBR - 1;                                          016960
         IF CNTBR < 0                   /* LEAVING MORE ')' THAN ... */   016970
         THEN GO TO GETLNX;             /* ... ENTERED DELIMITS      */   016980
         IF SUBSTR(POOL1,C,1) = ',' & CNTBR = 0 /* ',' NOT IN '()'   */   016990
         THEN GO TO  GETLNX;            /* DELIMITS THE FIELD        */   017000
         IF SUBSTR(POOL1,C,1) = ',' & SWNOBR /* IF ',' & ')' NOT WANT*/   017010
         THEN GO TO GETLNX;             /* THEN DELIMITS             */   017020
         C = C + 1;                     /* POINT AT NEXT BYTE        */   017030
         GO TO GETLN1;                  /* LOOP BACK                 */   017040
 GETLNX: C = C - A;                     /* SET C TO LENGTH           */   017050
         GO TO QEXIT;                   /* RETURN TO CALLER          */   017060
1/*      JOB TERMINATION ROUTINE                                    */    017070
                                                                          017080
 END:    REXIT = END1;                                                    017090
         GO TO ENDDD;                                                     017100
 END1:   REXIT = END2;                                                    017110
         GO TO ENDEXEC;                                                   017120
 END2:   CLOSE FILE(PROCIN);                                              017130
         CLOSE FILE(PROCOUT);                                             017140
         CLOSE FILE(ERRLIST);                                             017150
         WRITE FILE(INTRDR) FROM(CARD_PEND);                              017160
         WRITE FILE(INTRDR) FROM(CARD_EXECPR);                            017170
         WRITE FILE(INTRDR) FROM(CARD_ABCDEF);                            017180
         WRITE FILE(INTRDR) FROM(CARD_ROUTE); /* ADD ROUTING         */   017190
         WRITE FILE(INTRDR) FROM(CARD_EOF);                               017200
         CLOSE FILE(INTRDR);                                              017210
         END;                                                             017220
