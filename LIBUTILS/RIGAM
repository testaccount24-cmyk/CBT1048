         TITLE 'RIGAM - RANDOM INDEXED GENERIC ACCESS METHOD'
RIGAM    START 0
         SPACE 3
***********************************************************************
*        REGISTERS EQUATES AND USAGE                                  *
***********************************************************************
         SPACE 1
R0       EQU   0    SVC COMMUNICATIONS AND WORK REGISTER
R1       EQU   1    SVC COMMUNICATIONS AND WORK REGISTER
R2       EQU   2    WORK REGISTER
R3       EQU   3    WORK REGISTER
R4       EQU   4    BAL RETURN ADDRESS
R5       EQU   5    WORK REGISTER
R6       EQU   6    WORK REGISTER
R7       EQU   7    WORK REGISTER
R8       EQU   8    WORK REGISTER
R9       EQU   9    WORK REGISTER
R10      EQU   10   BASE REGISTER 4
R11      EQU   11   BASE REGISTER 3
R12      EQU   12   BASE REGISTER 2
R13      EQU   13   SAVE AREA POINTER / BASE REGISTER 1
R14      EQU   14   BALR RETURN ADDRESS
R15      EQU   15   BALR ROUTINE ADDRESS
         EJECT
***********************************************************************
*        HOUSEKEEPING                                                 *
***********************************************************************
         SPACE 1
         PGMIN EQUATES=NO,USING=(R13,R12,R11,R10),SAVEFLD=SAVEAREA
         SPACE 1
         PRINT NOGEN
         EJECT
***********************************************************************
*        RESOLVE USER PARAMETERS                                      *
***********************************************************************
         SPACE 1
FIRST    L     2,0(1)              GET LIST POINTER
         ST    2,ULIST             SAVE ADDRESS OF LIST
         L     3,4(1)              GET AREA POINTER
         ST    3,UAREA             SAVE ADDRESS OF AREA
         L     4,8(1)              GET ERROR LIST                  BXL
         ST    4,UERLIST           STORE POINTER TO USER ERROR HANDBXL.
         MVC   NOOFILE1(54),0(2)   MOVE IN LIST PARAMETERS
         XC    INDICTOR(1),INDICTOR                              BXL
         BAL   4,FINDFILE          GO TO FILE I.D. TABLE LOOK-UP RTN.
         CLI   INDICATO,I01        TEST THE INDICATOR
         BNE   RETOCALL            LEAVE IF IT IS AN EXCEPTION
         SPACE 3
***********************************************************************
*        TEST FOR FILE TYPE 1 OR 2 OPERATION CODE .                   *
***********************************************************************
         SPACE 1
         CLC   UOPCODE+2(1),=C'G'  TYPE 1 FILE OP-CODE?
         BE    SW3OPI              YES.
         CLC   UOPCODE+2(1),=C'A'  TYPE 2 FILE OP-CODE?
         BE    SW4OPI              YES.
         CLC   UOPCODE,=C'OPI'     INITIAL OP-CODE?
         BNE   SW2OPI              NO
         SPACE 3
***********************************************************************
*        OPEN DATA SET, INITIAL TEST.                                 *
***********************************************************************
         SPACE 1
SW1OPI   BC    0,ER2               SWITCH OFF,FIRST TIME THRU.
         MVI   SW1OPI+1,X'F0'      TURN OPI SWITCH1 OFF.
         MVI   SW2OPI+1,X'00'      TURN OPI SWITCH2 ON.
         MVI   SW3OPI+1,X'00'      TURN OPI SWITCH3 ON.
         MVI   SW4OPI+1,X'00'      TURN OPI SWITCH4 ON.
         B     OPI                 GO TO OPI ROUTINE.
         EJECT
***********************************************************************
*        DATA SET AND FILE ORGANIZATION TEST.                         *
***********************************************************************
         SPACE 1
SW2OPI   BC    15,ER1              IF ON NO OPI ISSUED BY USER.
         CLC   UOPCODE,=C'CDS'     CLOSE DATA SET?
         BE    CDS                  YES.
         CLC   UOPCODE,=C'OPF'     OPEN FILE?
         BE    OPF                  YES.
         CLC   UOPCODE,=C'GAF'     REMOVE IF NOT IN TEST
         BE    GAF                 REMOVE IF NOT IN TEST
         CLC   UOPCODE,=C'REF'     RESERVE FILE?
         BE    REF                  YES.
         BAL   4,GFP               GET THE FILE PARAMETERS.
         CLI   INDICATO,I01        TEST INDICATOR.
         BNE   RETOCALL            NOT VALID,LEAVE.
         CLC   UOPCODE,=C'FRF'     FREE FILE?
         BE    FRF                  YES.
         CLC   UOPCODE,=C'CLF'     CLOSE FILE?
         BE    CLF                  YES.
         B     ER3                 INVALID OP-CODE ERROR.
         SPACE 3
***********************************************************************
*        TYPE 1 FILE ORGANIZATION TEST.                               *
***********************************************************************
         SPACE 1
SW3OPI   BC    15,ER1              IF ON OPI NOT ISSUED BY USER.
         BAL   4,GFP               GET THE FILE PARAMETER TABLE.
         CLI   INDICATO,I01        TEST INDICATOR.
         BNE   RETOCALL            NOT VALID LEAVE.
         MVC   UIDEN,FILEID        INITIALIZE FOR KEY TEST.        BXL
         CLC   UOPCODE,=C'RRG'     READ RANDOM GENERIC
         BE    RRG                  YES.
         CLC   UOPCODE,=C'SSG'     SET SEQUENTIAL GENERIC?
         BE    SSG                  YES.
         CLC   UOPCODE,=C'RSG'     READ SEQUENTIAL GENERIC?
         BE    RSG                  YES.
         CLC   UOPCODE,=C'WDG'     WRITE DELETE GENERIC?
         BE    WDG                  YES
         CLC   UOPCODE,=C'WUG'     WRITE UPDATE GENERIC?
         BE    WUG                  YES.
         CLC   UOPCODE,=C'WAG'     WRITE ADD GENERIC?
         BE    WAG                  YES.
         B     ER3                 INVALID OP-CODE.
         EJECT
***********************************************************************
*        TYPE 2 FILE ORGANIZATION TEST.                               *
***********************************************************************
         SPACE 1
SW4OPI   BC    15,ER1              ON IF OPI NOT ISSUED BY USER.
         BAL   4,GFP               GET THE FILE PARAMETER TABLE.
         CLI   INDICATO,I01        TEST INDICATOR.
         BNE   RETOCALL            NOT VALID,LEAVE.
         CLC   UOPCODE,=C'RRA'     READ RANDOM ACTUAL?
         BE    RRA                  YES.
         CLC   UOPCODE,=C'SSA'     SET SEQUENTIAL ACTUAL?
         BE    SSA                  YES.
         CLC   UOPCODE,=C'RSA'     READ SEQUENTIAL ACTUAL?
         BE    RSA                  YES.
         CLC   UOPCODE,=C'WUA'     WRITE UPDATE ACTUAL?
         BE    WUA                  YES.
         CLC   UOPCODE,=C'WAA'     WRITE ADD ACTUAL?
         BE    WAA                  YES.
         CLC   UOPCODE,=C'SQA'     SET QUEUE ACTUAL?
         BE    SQA                  YES.
         B     ER3                 INVALID OP-CODE.
         SPACE 3
***********************************************************************
*        ERROR AND RETURN PROCEDURES.                                 *
***********************************************************************
         SPACE 1
ER1      MVI   INDICATO,I04         OPI NOT FIRST OP-CODE ISSUED.
         B     RETOCALL            RETURN
ER2      MVI   INDICATO,I26        MORE THAN ONE OPI ISSUED.
         B     RETOCALL            RETURN
ER3      MVI   INDICATO,I05        INVALID OP-CODE ISSUED.
         SPACE 1
RETOCALL L     2,ULIST             LOAD ADDRESS OF USERS LIST
         MVC   UIDEN,UFILE         RESTORE FILE NUMBER.            BXL
         MVC   0(54,2),NOOFILE1    MOVE INFORMATION BACK TO USER
         LR    8,13
         USING SAVEAREA,8
         DROP  13
         L     13,SAVEAREA+4
         L     14,12(13)
         BAL   4,TESTIND           RESOLVE USERS RETURN AREA       BXL
         LM    0,12,20(13)
         SR    15,15
         BR    14
         USING SAVEAREA,13
         DROP  8
         EJECT
***********************************************************************
*        I/O WORK AREA FOR USER PARAMETERS                            *
***********************************************************************
         SPACE 1
         DS    0F
NOOFILE1 DS    H'0'                                 NO.OF TYPE 1 FILES.
NOOFILE2 DS    H'0'                                 NO.OF TYPE 2 FILES.
URECNO   DS    F'0'                                 RECORD NUMBER.
INDICTOR DS    H'0'                                 INDICATOR.
         ORG   *-1
INDICATO DS    X
UOPCODE  DS    CL3                 USER PARAMETERS= OP-CODE
FILETYPE DS    CL1                                  FILE TYPE.
UIDEN    DS    CL3                 USER IDENTIFICATION CODE FOR FILE.
UKEY     DS    CL35                                 KEY (OR ARGUEMENT)
MULTIO1  DS    CL1                 TYPE 1 FILE MULTI-I/O AREA INDICATOR
MULTIO2  DS    CL1                 TYPE 2 FILE MULTI-I/O AREA INDICATOR
UFILE    DS    CL3                 FILE NUMBER OF USER IDENTIFICATION.
ULIST    DC    A(0)                ADDRESS OF USERS LIST.
UAREA    DC    A(0)                ADDRESS OF USERS WORK AREA.
FEEDBACK DC    A(URECNO)           ADDRESS OF RECORD NUMBER.
UERLIST  DC    A(0)                USER ERROR LIST POINTER.
         TITLE 'RIGAM - FILE DETERMINIZATION'
***********************************************************************
*        THIS ROUTINE WILL DO A TABLE LOOK-UP BY THE USER SPECIFIED   *
*         FILE IDENTIFICATION CODE. A FOUND CONDITION WILL PLACE THE  *
*         FILE NUMBER IN THE *RIGAM CALCULATION FIELD CALLED UFILE.   *
***********************************************************************
         SPACE 1
FINDFILE STM   2,9,REGSAVEL        SAVE THE REGISTARS.
         XR    2,2                 CLEAR REGISTAR 2.
         MVC   UFILE,UIDEN         FILE ID SUPPLIED IS FILE NO.    BXL
         CLC   UOPCODE,=C'OPI'     IS IT FIRST TIME
         BE    FF5                 IF YES, LEAVE.
         CLC   UOPCODE,=C'CDS'     IS IT LAST TIME
         BE    FF5                 IF YES, LEAVE.
         B     FF5                 BYPASS FILE DETERMINATION.      BXL
         LA    3,FILETABL          POINT TO TABLE OF I.D. AND FILE NO.
FF1      CLC   0(3,3),UIDEN        IS TABLE I.D. SAME AS USER I.D.?
         BE    FF3                 YES. GO LOAD FILE NO.ENTRY.
         LA    3,6(3)              NO. POINT TO NEXT FILE I.D.
         CLC   0(3,3),=X'404040'   IS IT END OF TABLE ?
         BE    FF2                 YES. GO SET INDICATOR.
         B     FF1                 NO. GO LOOK SOME MORE.
FF3      LA    3,3(3)              POINT TO FILE NUMBER.
         MVC   UFILE(3),0(3)       MOVE FILE NO. TO UFILE.
FF5      MVI   INDICATO,I01        SET INDICATOR TO VALID RETURN.
FF4      LM    2,9,REGSAVEL        RESTORE THE REGISTARS.
         BR    4                   RETURN.
FILETABL DC    40CL6'      '
         SPACE 1
******** TEST FOR OPF OR REF OPCODE FROM USER. ***
         SPACE 1
FF2      CLC   UOPCODE,=C'OPF'     IS USER OPCODE AN OPF?
         BE    FF6                 YES. READY READ.
         CLC   UOPCODE,=C'REF'     IS USER OPCODE AN REF?
         BE    FF6                 YES. READY READ
         CLC   UOPCODE,=C'GAF'     IS IT A GAF?
         BE    FF6                 YES. GET THE FILE.
         MVI   INDICATO,I18        NEITHER. SET INDICATOR.
         B     FF4                 LEAVE.
         EJECT
***********************************************************************
*        FILE DETERMINIZATION ROUTINE  ( CONT'D )                     *
***********************************************************************
         SPACE 1
******** READY FOR READ. ***
         SPACE 1
FF6      MVC   UFILE,=C'001'       PLACE *RIGAM I.D.FILE NUMBER IN CALL
         MVC   FREP+1(1),FILETYPE
         MVI   FILETYPE,X'F1'
         BAL   4,GFP               GET *RIGAM I.D.FILE PARAMETERS.
FREP     MVI   FILETYPE,X'00'
         CLI   INDICATO,I01        GET FILE O.K?
         BNE   FF4                 NO. LEAVE.
         MVC   FFHOLD(3),UKEY
         MVC   UKEY(3),UIDEN       MOVE USER I.D.TO KEY.
         BAL   4,GIR               SEARCH FILE.
         MVC   UKEY(3),FFHOLD
         CLI   INDICATO,I01        SEARCH O.K.?
         BE    FF7                 YES.CONTINUE
         CLI   INDICATO,I03        REC NOT FOUND
         BNE   FF4                 NO.LEAVE.
         MVI   INDICATO,I34        YES.FILE ISN'T THERE.SET INDICATOR.
         B     FF4                 LEAVE.
         SPACE 1
******** POINT TO INTERNAL *RIGAM WORK AREA FOR NEW FILE. ***
         SPACE 1
FF7      LA    8,FFHOLD            GET ADDRESS OF *RIGAM WORK AREA AND
         ST    8,UAREA                 STORE IT FOR INTERNAL MOVE
         BAL   4,READBLK           GO READ RECORD.
         CLI   INDICATO,I01        READ O.K?
         BNE   FF4                 NO. LEAVE
         MVI   BDIND,X'01'         SET BLOCK/DEBLOCK TO MOVE TO
         BAL   4,BDR                 INTERNAL WORK AREA,AND GO TO MOVE.
         SPACE 1
******** PLACE FILE NUMBER IN I.D. TABLE. ***
         SPACE 1
         LA    3,FILETABL          POINT TO FILE TABLE.
FF8      CLC   0(3,3),=X'404040'   IS IT BLANK?
         BE    FF9                 YES. GO TO MOVE
         LA    3,6(3)              NO. INCREMENT TO NEXT ENTRY.
         B     FF8                      AND CONTINUE SEARCH.
FF9      MVC   0(6,3),FFHOLD+3     MOVE I.D.AND FILE NUMBER TO TABLE
         MVC   UFILE,FFHOLD+6      PLACE FILE NUMBER IN FOR USER.
         B     FF5                 GO SET VALID INDICATOR.
FFHOLD   DC    CL9' '              INTERNAL *RIGAM WORK AREA.
REGSAVEL DS    8F                  REGISTAR STORAGE AREA.
         TITLE 'RIGAM - ''OPI'' - OPEN INITIAL'
***********************************************************************
*        OPEN RIGAM DATA SET AND USES GETMAINS TO RESERVE CORE        *
*         FOR TABLES (NO-TYPE1 - NO-TYPE2).                           *
***********************************************************************
         SPACE 1
OPI      STM   R2,R9,RIGAMSA       SAVE REGISTERS
         BAL   4,TSTYPDEV          GO TEST DEVICE TYPE
         OPEN  (IAMRIGAM,INOUT)     OPEN THE *RIGAM DATA SET.
         XC    PARMWK1,PARMWK1     CLEAR PARAMETER WORK AREA.
         LH    2,NOOFILE1          GET NUMBER OF TYPE 1
         LH    3,NOOFILE2               AND TYPE 2 FILES ON LINE.
         AH    2,=H'1'             OPEN AT LEAST ONE TYPE 1 FILE.
TST2     CH    3,=H'0'             ARE THERE ANY TYPE 2 FILES?
         BH    TSTOK               YES
         AH    3,=H'1'             OPEN AT LEAST ONE TYPE 2 FILE.
TSTOK    STH   2,LTB1              STORE NUMBER OF TYPE 1
         STH   3,LTB2                   AND TYPE 2 FILES TO OPEN.
         MH    2,=H'229'           RESOLVE NUMBER OF BYTES FOR EACH
         MH    3,=H'28'                 TYPE 1 AND TYPE 2 FILE
         STM   2,3,SAV23           SAVE NUMBERS FOR FREEMAIN
         LR    0,2                 USE RO AS BYTE DEFINITION FOR TYPE1
         GETMAIN R,LV=(0)          ISSUE GETMAIN FOR TABLE1.
         ST    1,TABLE1            SAVE ADDRESS OF TABLE1 START.
         LH    5,LTB1              NUMBER OF FILES-T1.
         LH    6,=H'228'           LENGTH(-1)OF EACH T1 FILE.
         BAL   4,CLEARIT           GO CLEAR CORE.
         LR    0,3                 USE RO AS BYTE DEFINITION FOR TYPE 2
         GETMAIN R,LV=(0)          ISSUE GETMAIN FOR TABLE2.
         ST    1,TABLE2            SAVE ADDRESS OF TABLE2 START.
         LH    5,LTB2              NUMBER OF FILES-T2.
         LH    6,=H'27'            LENGTH(-1)OF EACH T2 FILE.
         BAL   4,CLEARIT           GO CLEAR CORE.
         L     2,TABLE2            POINT TO TYPE 2 AREA.
         LH    3,LTB2              GET NUMBER OF TYPE 2 FILES.
INITFIL2 MVC   0(3,2),=X'FFFFFF'   MOVE IN F'S.
         LA    2,28(2)             INCREMENT TO NEXT FILE SPACE.
         BCT   3,INITFIL2          TEST FOR MORE FILES
         LH    3,LTB1              GET NUMBER OF TYPE 1 FILES
         L     2,TABLE1            INITIALIZE TABLE1.
INITFIL1 MVC   0(3,2),=X'FFFFFF'   MOVE IN F'S.
         LA    2,229(2)            INCREMENT TO NEXT FILE SPACE.
         BCT   3,INITFIL1          TEST FOR MORE FILES.
         MVI   INDICATO,I01        SET INDICATOR TO 1.
         B     BFDRC1              BYPASS FDR CODING.              BXL
         MVC   UFILE,=C'001'       MOVE *RIGAM FILE TO USER FILE.
         LH    5,=H'40'
         LA    6,FILETABL          POINT TO FILETABL.
         EJECT
***********************************************************************
*        'OPI'   ( CONT'D )                                           *
***********************************************************************
         SPACE 1
OPICLEAR MVC   0(6,6),=X'404040404040'  CLEAR TABLE.
         LA    6,6(6)
         BCT   5,OPICLEAR
BFDRC1   EQU   *                                                   BXL
         RDJFCB (JFCB)              READ JFCB               BXL 3.3.74
         MVC   RRNAME+3(44),JFCBDSNM    MOVE DATA SET NAME       BXL
         LM    R2,R9,RIGAMSA       RESTORE REGISTERS
         B     RETOCALL            CHANG TO OPF IF FDR INCLUDED    BXL
         SPACE 1
CLEARIT  EX    6,ERASEIT           CLEAR CORE AREA.
         LA    1,1(6,1)            POINT TO NEXT CORE AREA.
         BCT   5,CLEARIT           AGAIN OR...
         BR    4                     ...RETURN.
ERASEIT  XC    0(0,1),0(1)         CLEAR INST.
         SPACE 1
SAV23    DS    2F                  GETMAIN STORAGE LENGTH SAVE AREA.
SAV3     EQU   *-4                 POINTER TO LENGTH OF TABLE 2.
REGSAVE  DS    8F                  REGISTAR SAVE AREA.
         TITLE 'RIGAM - ''OPF'' - OPEN FILE'
***********************************************************************
*        OPEN RIGAM FILE SUB-ROUTINE, CHECKS FOR FILE IN TABLE OR     *
*         PARAMETER AREA. IT GETS PARAMETERS FROM DISK TO REPLACE     *
*         THIS INFORMATION IF FILE IS CURRENTLY IN WORK AREA IT IS    *
*         DELETED. INDICATOR -1 FOR NO ROOM IN TABLE. CONVERT         *
*         FILE XXX (CL3) TO TTR FOR READ A BLOCK                      *
***********************************************************************
         SPACE 1
OPF      STM   R2,R9,RIGAMSA       SAVE REGISTERS
         L     2,=F'0'             TEST ONLY.
         BAL   4,OPCOUNT           TEST ONLY.
         XC    OPFCVTAR,OPFCVTAR        CLEAR CVB AREA
         PACK  OPFCVTAR+6(2),UFILE      PACK FILE
         CVB   3,OPFCVTAR               FILE TO BINARY
         XR    2,2                      REG 2 TO ZERO
         D     2,BLKNOF            R Q - DIVIDE FILE BY MAX-R-TRK   BXL
         LTR   2,2                 IS REGISTAR 2= TO ZERO?
         BC    6,OPFB              NO.BRANCH TO STORE TTR.
         S     3,=F'1'             DECREMENT TT OF TTR.
         L     2,BLKNOF            SET R OF TTR                     BXL
OPFB     ST    3,OPFCVTAR          STORE TT.
         MVC   RTTR(2),OPFCVTAR+2       MOVE  TT TO RTTR
         STC   2,RTTR+2                 R TO RTTR
         BAL   4,JDAREAD                 READ FILE PARAMETER BLOCK.
         CLC   UFILE,=C'001'
         BE    REFENTRY
         CLC   FILETYPE,BLOCK+6    FILETYPE EQUAL IN LIST AND PARAMS?
         BE    REFENTRY
         MVI   INDICATO,I06
         B     OPFRTN1
         SPACE 1
******** FIRST  PART  OF  FILE PARAMETER ON DISK IS IMAGE OF FILE PWA *
******** CHECK  FOR TYPE OF FILE ***
         SPACE 1
REFENTRY CLI   BLOCK+6,X'F2'       CHECK FOR TYPE 2 FILE.
         BE    OPF2                     GO TO OPEN TYPE 2
         SPACE 1
******** CHECK  FOR FILE IN PARAMETER WORK AREA ***
         SPACE 1
         CLC   FILENO,UFILE
         BNE   OPFS1
         MVC   FILENO,=X'FFFFFF'        DELETE WORK AREA
         MVI   FILETYP,X'00'  ZERO FILETYPE USED AS SWITCH IN GFP RTN
OPFS1    L     5,TABLE1                 POINT 5 TO TABLE 1
         LH    3,LTB1                   3 CONTAINS ENTRIES IN TABLE 1
         EJECT
***********************************************************************
*        'OPF'  ( CONT'D )                                            *
***********************************************************************
         SPACE 1
OPFLOOP1 CLC   0(003,5),UFILE           CHECK FILE PRESENT
         BE    OPFM1                    MOVE INFO TO TABLE
         LA    5,229(5)                 INCREMENT TO NEXT ENTRY
         BCT   3,OPFLOOP1               COMPARE NEXT ENTRY
         L     5,TABLE1                 POINT 5 TO TABLE 1
         LH    3,LTB1                   3 CONTAINS ENTRIES IN TABLE 1
OPFLOOP2 CLC   0(3,5),=X'FFFFFF'        CHECK FOR OPENING
         BE    OPFM1                    EQUAL GO TO MOVE
         LA    5,229(5)                 INCREMENT
         BCT   3,OPFLOOP2               CHECK END
         B     OPFSCM1                  CODE = -1 TABLE FULL
OPFM1    MVC   0(24,5),BLOCK       MOVE IN PARAMETER        BXL-28.2.74
         MVC   28(201,5),BLOCK+28  EXCEPT NSR               BXL-28.2.74
         XC    190(39,5),190(5)  CLEAR OUT LARG,LBR*LAST DATA RCD READ*
         MVI   8(5),X'01'               SET FT SWITCH
REFSW1   BC    0,OPFRTN            WILL NOT DO NEXT INST.IF ON FROM REF
         MVI   7(5),X'00'          MOVE '00' TO RESERVE CODE.
         B     OPFRTN                   RETURN
OPF2     CLC   FILENO,UFILE             FILE IN PWA
         BNE   OPFS2                    NO
         MVC   FILENO,=X'FFFFFF'        YES DELETE
         MVI   FILETYP,X'00'  ZERO FILETYPE USED AS SWITCH IN GFP RTN
OPFS2    L     5,TABLE2                 POINT 5 TO TABLE 2
         LH    3,LTB2                   3 CONTAINS ENTRIES IN TABLE 2
OPFLOOP3 CLC   0(03,5),UFILE            CHECK FILE IN TABLE
         BE    OPFM2                    YES MOVE INTO CURRENT SLOT
         B     OPFA                     AROUND CONSTANT
OPFCVTAR DS    D          XXXXXXXX      CONVERT TO BINARY AREA
OPFA     LA    5,28(5)                  INCREMENT TO NEXT SLOT
         BCT   3,OPFLOOP3               LOOP
         L     5,TABLE2                 POINT 5 TO TABLE 2
         LH    3,LTB2                   3 CONTAINS ENTRIES IN TABLE 2
OPFLOOP4 CLC   0(3,5),=X'FFFFFF'        CHECK OPEN SLOT
         BE    OPFM2                    GO TO MOVE
         LA    5,28(5)                  INCREMENT
         BCT   3,OPFLOOP4               LOOP
OPFSCM1  MVI   INDICATO,I07        TABLE FULL,SET INDICATOR TO -7.
REFSW3   BC    15,OPFRTN1          SWITCH OFF IF ENTRY FROM REF RTN. TO
         MVI   REFSW3+1,X'F0'      DEQ/RELEASE CONTROL OVER FILE AS
         BAL   4,DOADEQ            INDICATOR >1 IS SET.
         B     OPFRTN1             LEAVE.
         EJECT
***********************************************************************
*        'OPF'  ( CONT'D )                                            *
***********************************************************************
         SPACE 1
OPFM2    MVC   0(28,5),BLOCK            MOVE IN FILE PARAMETERS
         MVI   8(5),X'01'               SET FIRST TIME INDICATOR
REFSW2   BC    0,OPFRTN            WILL NOT DO NEXT INST.IF ON FROM REF
         MVI   7(5),X'00'          MOVE'00'TO RESERVE CODE.
OPFRTN   MVI   INDICATO,I01        SET INDICATOR TO 1.
         CLC   UFILE,=C'001'       IS IT RIGAM PRIVATE FILE ?
         NOP   OPFCNG              CHANGE TO BE  IF FDR INCLUDED   BXL
         MVC   TTRHLD(4),BLOCK+19       GET LAST DATA RECORD USED.
         BAL   4,FDBKCALC               GO CONVERT IT TO DECIMAL.
         L     6,URECNO                 SAVE IT.
         MVC   TTRHLD(3),BLOCK+14       GET TTR OF UPPER DATA EXTENT.
         MVC   TTRHLD+3(1),BLOCK+23     GET NO.DATA REC.PER BLOCK.
         BAL   4,FDBKCALC               GO CONVERT IT TO DECIMAL
         L     7,URECNO                 READY FOR DIFFERENCE.
         SR    7,6                      SUB.TO DETERMINE REC.SPACE LEFT
         ST    7,URECNO                 GIVE NUMBER TO USER.
OPFRTN1  EQU   *
         MVI   REFSW1+1,X'00'           TURN OFF REF SWITCH'S SET
         MVI   REFSW2+1,X'00'          IN THE REF ROUTINE.
         LM    R2,R9,RIGAMSA       RESTORE REGISTERS
         B     RETOCALL            RETURN TO CALLER
OPFCNG   L     4,TABLE1            GET ADDRESS OF TYPE 1 TABLE.
         ST    4,NOOFILE1          STORE IT IN PARMLIST.
         LA    4,FILETABL          GET ADDRESS OF CROSS REFERENCE LIST.
         ST    4,URECNO            STORE IT IN PARMLIST.
         B     OPFRTN1             RETURN
         TITLE 'RIGAM - ''SSG'' - SET SEQUANTIAL GENERIC'
***********************************************************************
*        SET SEQUENTIAL GENERIC ROUTINE.                              *
***********************************************************************
         SPACE 1
SSG      STM   R2,R9,RIGAMSA       SAVE REGISTERS
         L     2,=F'6'             TEST ONLY.
         BAL   4,OPCOUNT           TEST ONLY.
         CLI   FILETYP,X'F1'       IS IT A TYPE 1 FILE?
         BE    SSGOK               YES.
         MVI   INDICATO,I13        NO. SET INDICATOR TO -13 AND RETURN
         B     RETOCALL              TO THE MAINLINE ROUTINE.
SSG27    MVI   INDICATO,I27        NEXT SEQUENTIAL. SET INDICATOR.
         B     SSGSET              CONTINUE PROCESSING.
SSGOK    BAL   4,GIR               GET INDICES ROUTINE.
         LH    2,=H'1'
         LH    3,INDICTOR               INDICATOR
         C     3,=F'3'             IS IT NEXT SEQUENTIAL?
         BE    SSG27               YES.
         CR    3,2                      INDICATOR < 0
         BH    SSG1                YES
SSGSET   L     5,FOUNDADD          POINTER TO ARGUEMENT.
         SR    4,4                      CLEAR 4
         IC    4,ARGL                   ARGUMENT LENGTH
         AR    5,4                      POINT TO DELETE CODE
         LA    5,1(5)                   POINT TO TTRN OF RECORD
         MVC   BRNSR,0(5)          MOVE FOR TTRN OF NSR.
SSG1     LM    R2,R9,RIGAMSA       RESTORE REGISTERS
         B     RETOCALL            RETURN TO CALLER
         TITLE 'RIGAM - ''RSG'' - READ SEQUENTIAL GENERIC'
***********************************************************************
*        READ SEQUENTIAL GENERIC ROUTINE                              *
***********************************************************************
         SPACE 1
RSG      STM   R2,R9,RIGAMSA       SAVE REGISTERS
         L     2,=F'7'             TEST ONLY.
         BAL   4,OPCOUNT           TEST ONLY.
         CLI   FILETYP,X'F1'       IS IT A TYPE 1 FILE?
         BE    RSGTTR              YES. CONTINUE PROCESSING.
         MVI   INDICATO,I14        NO.SET INDICATOR TO -14.
         B     RSG1A                 AND RETURN.
RSGTTR   MVC   RTTR(3),BRNSR       TTR OF NEXT SEQUENTIAL RECORD.
         MVC   BDN(1),BRNSR+3           RECORD POSITION OF NSR
         SPACE 1
******** CHECK END OF FILE  ***
         SPACE 1
RSG2     CLC   BRNSR,BREOF              END OF FILE COMPARE
         BE    RSG1                     YES
         BAL   4,READBLK                READ DATA BLOCK
         LH    2,=H'1'                  COMPARE TO 1
         LH    3,INDICTOR               LOAD INDICATOR
         CR    3,2                      INDICATOR < 1
         BH    RSG1A                    YES
         MVI   BDIND,X'01'              SET BLOCK INDICATOR TO 1
         BAL   4,BDR                    DEBLOCK
         L     5,RECORDFD               RECORD
         S     5,=F'4'                  POINT TO TTRN OF NSR
         MVC   BRNSR,0(5)               SAVE NSR IN FP TABLE
         S     5,=F'1'                  POINT TO DELETE CODE
         CLI   0(5),X'FF'               CHECK FOR DELETE
         BE    RSGTTR                   GO TO NSR
         A     5,=F'8'                  POINT TO KEY OF RECORD
         SR    4,4                      CLEAR 4
         IC    4,ARGL                   ARGUMENT LENGTH
         S     4,=F'1'                  MOVE LENGTH FOR ARGUMENT
         EX    4,RSGMOVE                MOVE ARG FOUND TO FP TABLE
         MVC   TTRHLD(3),RTTR      SAVE READ ADDRESS BLOCK.
         MVC   TTRHLD+3(1),BDN     SAVE READ ADDRESS RECORD NUMBER.
         MVI   INDICATO,I01        SET INDICATOR TO 1.
         BAL   4,FDBKCALC          GET USER A RECORD NUMBER.
RSG1A    LM    R2,R9,RIGAMSA       RESTORE REGISTERS
         B     RETOCALL            RETURN TO CALLER
         SPACE 1
RSGMOVE  MVC   LARG(0),0(5)        ARGUMENT MOVE
RSG1     MVI   INDICATO,I29             END OF FILE INDICATOR
         B     RSG1A                    GO TO 1A
         TITLE 'RIGAM - ''RRG'' - READ RANDOM GENERIC'
***********************************************************************
*        READ RANDOM GENERIC ROUTINE                                  *
***********************************************************************
         SPACE 1
RRG      STM   R2,R9,RIGAMSA       SAVE REGISTERS
         L     2,=F'5'             TEST ONLY.
         BAL   4,OPCOUNT           TEST ONLY.
         CLI   FILETYP,X'F1'       IS PARM FILE TYPE = TO 1 ?
         BE    RRGBAL              YES. CONTINUE.
         MVI   INDICATO,I11        NO. SET INDICATOR TO -11.
         B     RRG1                  AND RETURN TO USER.
RRGBAL   BAL   4,GIR               GET INDICIES.
         LH    3,=H'1'                  1
         LH    2,INDICTOR               INDICATOR
         CR    2,3                      INDICATOR< 1
         BH    RRG1                     YES
         BAL   4,READBLK                READ DATA BLOCK
         LH    2,INDICTOR               INDICATOR
         CR    2,3                      INDICATOR< 1
         BH    RRG1                     YES
         MVC   TTRHLD(3),RTTR      SAVE READ ADDRESS BLOCK.
         MVC   TTRHLD+3(1),BDN     SAVE READ ADDRESS RECORD NUMBER.
         MVI   BDIND,X'01'              DEBLOCK
         BAL   4,BDR                    BLOCK DEBLOCK ROUTINE
         BAL   4,FDBKCALC          GET USER A RECORD NUMBER.
RRG1     LM    R2,R9,RIGAMSA       RESTORE REGISTERS
         B     RETOCALL            RETURN TO CALLER
         TITLE 'RIGAM - FEEDBACK CALCULATION'
***********************************************************************
*        FEEDBACK CALCULATION ROUTINE                                 *
***********************************************************************
         SPACE 1
FDBKCALC STM   2,9,REGSAVEC        STORE THE REGISTARS.
         XC    CONVTTRN,CONVTTRN   CLEAR TTRN AREA IN CONVERT ROUTINE.
         MVC   CONVTTRN(3),LOWBLK  MOVE DATA START TTR FOR RELETIVE TO
         BAL   4,CONVTON             ZERO ALIGNMENT AND CONVERT IT.
         L     7,CONVNNNN          CONVERTED DATA TTR FOR RELETIVE NO.
         MVC   CONVTTRN,TTRHLD     TTRN OF DATA JUST FOUND.
         BAL   4,CONVTON           CONVERT IT TO A NUMBER.
         L     6,CONVNNNN          STORE RESULTANT NUMBER.
         SR    6,7                 CALCULATE RECORD NUMBER.
         L     7,FEEDBACK          GET ADDRESS OF USERS REC.NO.AREA.
         ST    6,0(0,7)            PLACE REC.NO.IN USER RETURN
         LM    2,9,REGSAVEC        RESTORE THE REGISTARS.
         BR    4                   RETURN.
TTRHLD   DC    F'0'                HOLD AREA FOR CALCULATION.
REGSAVEC DS    10F                 REGISTAR STORAGE SAVE AREA.
         TITLE 'RIGAM - ''WAA'' - ADD AN ACTUAL RECORD'
***********************************************************************
*        THIS ROUTINE ADDS A NEW RECORD TO THE FILE.                  *
***********************************************************************
         SPACE 1
WAA      STM   2,9,WAASAVE         STORE REGISTARS.
         L     2,=F'17'            TEST ONLY.
         BAL   4,OPCOUNT           TEST ONLY.
         CLC   FILETYPE,=C'2'      CHECK FILETYPE TO BE EQUAL TO 2.
         BNE   WAAMIN1             IT IS NOT. GO SET INDICATOR TO -1.
         SR    2,2                 CLEAR REGISTARS 2,
         SR    4,4                             AND 4,
         SR    5,5                             AND 5,
         SR    6,6                             AND 6.
         IC    2,NODRPB            INSERT MAXIMUM N.
         MVC   RHD,LDRU            GET LAST DATA RECORD USED
         IC    4,RHD+3             INSERT CURRENT N,
         IC    5,RHD+2                    CURRENT R,
         LH    6,RHD                  AND CURRENT TT.
         BAL   9,WAATEST           ADD NEW RECORD - OVERWRITING FFSBXL
         LA    9,WAAEXIT           RESET BRANCH RETURN ADDRESS.    BXL
         L     3,UAREA             GET ADDR OF DATA AREA IN REG3.  BXL
         MVI   3(3),X'FF'          MOVE FFFFS RECORD TO            BXL
         MVC   4(34,3),3(3)        LAST RECORD POSITION.           BXL
         A     4,=F'1'             INCREMENT N BY 1.
         CR    4,2                 COMPARE AGAINST MAXIMUM N.
         BH    UP4                 TOO HIGH. GO INCREASE R.
         B     WAATEST              O.K. GO TEST FOR FILE LIMIT.
UP4      A     5,=F'1'             INCREMENT R.
         SR    4,4                 ZERO N.
         L     4,=F'1'             SET N=1
         C     5,BLKNOF            COMPARE AGAINST MAXIMUN R.       BXL
         BH    UP5                 R EXCEED. GO INCREASE TT.
         B     WAATEST             O.K. GO TEST FOR FILE LIMIT.
UP5      A     6,=F'1'             INCREMENT TT.
         SR    5,5                 ZERO R.
         L     5,=F'1'             SET R=1.
WAATEST  STC   4,BDN               STORE N FOR BLOCK/DEBLOCK ROUTINE.
         ST    4,WAASAVE+36        SAVE R4 FOR LATER RECD INCREMENTBXL
         STC   4,LDRU+3            STORE N FOR NEXT ADDITION.
         STC   5,LDRU+2            STORE R FOR NEXT ADDITION.
         STC   5,RTTR+2            STORE R FOR READ DATA ROUTINE.
         SR    7,7                 ZERO REGISTAR 7 TO
         ST    7,WTTR                CLEAR WTTR IN WRITE ROUTINE.
         STC   5,WTTR+2            STORE R FOR WRITE DATA ROUTINE.
         ST    6,RHD               MOVE TT FOR ALIGNMENT.
         EJECT
***********************************************************************
*        'WAA'   ( CONT'D )                                           *
***********************************************************************
         SPACE 1
         MVC   WTTR(2),RHD+2       COMPLETE TTR FOR WRITE ROUTINE AND
         MVC   RTTR(2),RHD+2             READ ROUTINE
         MVC   TTRHLD(3),RTTR      COMPLETE TTR FOR WRITE ROUTINE AND
         MVC   TTRHLD+3(1),BDN           READ ROUTINE.
         MVC   LDRU,TTRHLD         UPDATE LAST DATA RECORD USED
         MVC   RHD+1(3),HGHBLK     GET FILE UPPER LIMIT ALIGNED AND
         L     7,RHD                 STORE IT IN REGISTAR 7.
         MVC   RHD+1(3),LDRU       GET NEXT BLOCK ALIGNED AND
         L     8,RHD                 STORE IT IN REGISTAR 8.
         CR    8,7                 DETERMINE IF FILE LIMIS ARE EXCEEDED
         BH    WAAEQUO             YES. GO SET END OF FILE CONDITION.
         BAL   4,READBLK           NO. GO READ A DATA BLOCK.
         CLI   INDICATO,I01        ANY ERROR CONDITIONS?
         BH    WAAEXIT               YES. LEAVE ROUTINE.
         MVI   BDIND,X'02'         NO.SET BLK/DBLK TO GET REC.TO USER.
         BAL   4,BDR               GO PLACE NEW RECORD IN BLOCK
         BAL   4,WRITEBLK          GO WRITE NEW RECORD.
         CLI   INDICATO,I01        ANY ERROR CONDITIONS?
         BH    WAAEXIT               YES. LEAVE ROUTINE.
         BAL   4,FDBKCALC          GET USER A RECORD NUMBER.
         L     4,WAASAVE+36        RESTORE R4 FOR RECD NO INCREMENTBXL
         BR    9                   RETURN TO WAA00190 OR WAA00630. BXL
         B     WAAEXIT             PREPARE FOR EXIT.
WAAMIN1  MVI   INDICATO,I25        SET INDICATOR ERROR = -25.
         B     WAAEXIT               LEAVE ROUTINE.
WAAEQUO  MVI   INDICATO,I28        END OF FILE ERROR CONDITION.
WAAEXIT  BAL   4,PARMRYT           GO WRITE PARAMETERS IF GOOD WAA.
         LM    2,9,WAASAVE         RESTORE REGISTARS.
         B     RETOCALL            RETURN TO MAIN ROUTINE.
WAASAVE  DS    10F                 REGISTAR SAVE AREA.
         TITLE 'RIGAM - ''WUA'' - WRITE AN UPDATED ACTUAL RECORD'
***********************************************************************
*        THIS ROUTINE WRITES AN UPDATED ACTUAL RECORD.                *
***********************************************************************
         SPACE 1
WUA      STM   R2,R9,RIGAMSA       SAVE REGISTERS
         L     2,=F'16'            TEST ONLY.
         BAL   4,OPCOUNT           TEST ONLY.
         CLC   FILETYPE,=C'2'      CHECK FILETYPE FOR TYPE 2 ONLY.
         BNE   WUAMIN1               IT IS NOT. SET INDICATOR TO -1.
         BAL   4,BLKCALC             IT IS. GO CALCULATE TTR AND N.
         BAL   4,READBLK           READ BLOCK SPECIFIED BY TTR.
         CLI   INDICATO,I01        INSURE PROPER READ.
         BH    WUAEXIT               IT WAS NOT. LEAVE ROUTINE.
         MVI   BDIND,X'02'         IT WAS.SET BLK/DBLK TO MOVE IN NEW
         BAL   4,BDR                 RECORD THEN GO TO BLK/DBLK ROUTINE
         SR    2,2                 CLEAR REGISTAR 2 TO
         ST    2,WTTR                ZERO WRITE TTR AREA.
         MVC   WTTR(3),RTTR        MOVE READ TTR TO WRITE TTR.
         BAL   4,WRITEBLK          GO TO WRITE ROUTINE AND UPDATE.
         B     WUAEXIT             GO TO EXIT.
WUAMIN1  MVI   INDICATO,I24        SET INDICATOR ERROR = -24.
WUAEXIT  LM    R2,R9,RIGAMSA       RESTORE REGISTERS
         B     RETOCALL            RETURN TO CALLER
         TITLE 'RIGAM - ''RSA'' - READ SEQUENTIAL ACTUAL'
***********************************************************************
*        READ SEQUENTIAL ACTUAL ROUTINE                               *
***********************************************************************
         SPACE 1
RSA      STM   R2,R9,RIGAMSA       SAVE REGISTERS
         L     2,=F'14'            TEST ONLY.
         BAL   4,OPCOUNT           TEST ONLY.
         CLC   FILETYPE,=C'2'      CHECK FILETYPE FOR TYPE 2 ONLY.
         BNE   RSAMIN1               IT IS NOT. SET INDICATOR TO -1.
         MVC   RHD,BRNSR           ALIGN FOR EVEN WORD BOUNDRY.
         L     5,RHD                 IT IS. SECURE N FOR BLOCK/DEBLOCK
         STC   5,BDN                  IN THAT ROUTINE THEN SET THE
         MVI   BDIND,X'01'         SET BLK/DBLK TO MOVE TO USER.
         SRA    5,8(0)               DROP N TO DETERMINE
         MVC   RHD,HGHBLK          (ALIGN FOR EVEN WORD BOUNDRY)
         L     6,RHD                 IF THE FILE LIMIT HAS
         SRA   6,8(0)              SHIFT N OUT.
         CR    5,6                   BEEN EXCEEDED. IF SO,
         BH    RSAEQU0               SET INDICATOR TO ZERO.
         MVC   RTTR(3),BRNSR       MOVE IN TTR OF NSR.
         BAL   4,READBLK             THEN BRANCH TO THE READ DATA RTN.
         CLI   INDICATO,I01        TEST INDICATOR FOR GOOD READ.
         BH    RSAEXIT             IF IT WAS NOT,LEAVE THIS ROUTINE.
         MVC   TTRHLD(3),RTTR      SAVE READ ADDRESS BLOCK.
         MVC   TTRHLD+3(1),BDN     SAVE READ ADDRESS RECORD NUMBER.
         MVI   BDIND,X'01'
         BAL   4,BDR               IF IT WAS,GO TO BLOCK/DEBLOCK TRN.
         BAL   4,FDBKCALC          GET USER A RECORD NUMBER.
         SR    2,2                 CLEAR REGISTAR 2,
         SR    4,4                             AND 4,
         SR    5,5                             AND 5,
         SR    6,6                             AND 6,
         IC    2,NODRPB            INSERT  MAXIMUM N,
         IC    4,BDN                       CURRENT N,
         MVC   RHD,BRNSR           GET PREVIOUS RECORD TO INCREMENT.
         IC    5,RHD+2                     CURRENT R,
         LH    6,RHD                   AND CURRENT TT.
         A     4,=F'1'             INCREMENT N BY 1.
         CR    4,2                 COMPARE AGAINST MAXIMUM N.
         BH    INC4                  OVER. GO INCREMENT R.
         B     INSERT                O.K. GO TO PLACE BACK IN F/P TABLE
         EJECT
***********************************************************************
*        'RSA'  ( CONT'D)                                             *
***********************************************************************
         SPACE 1
INC4     A     5,=F'1'             INCREMENT R BY 1.
         SR    4,4                 ZERO N.
         L     4,=F'1'             SET N=1.
         C     5,BLKNOF            COMPARE AGAINST MAXIMUN R.       BXL
         BH    INC5                  OVER. GO INCREMENT TT.
         B     INSERT                O.K. GO TO PLACE BACK IN F/P TABLE
INC5     A     6,=F'1'             INCREMENT TT BY 1.
         SR    5,5                 ZERO R.
         L     5,=F'1'             SET R=1.
INSERT   STC   4,BRNSR+3           INSERT NEXT
         STC   5,BRNSR+2                       TTRN
         ST    6,RHD                                IN
         MVC   BRNSR(2),RHD+2                          FILE-PARAM.TABLE
         B     RSAEXIT             GO TO EXIT.
RSAMIN1  MVI   INDICATO,I23        SET INDICATOR ERROR = -23.
         B     RSAEXIT             GO TO EXIT.
RSAEQU0  MVI   INDICATO,I29        SET INDICATOR TO 0 FOR END-OF-FILE.
RSAEXIT  LM    R2,R9,RIGAMSA       RESTORE REGISTERS
         B     RETOCALL            RETURN TO CALLER
         TITLE 'RIGAM - ''SSA'' - SET SEQUENTIAL ACTUAL'
***********************************************************************
*        SET SEQUENTIAL ACTUAL ROUTINE                                *
***********************************************************************
         SPACE 1
SSA      STM   R2,R9,RIGAMSA       SAVE REGISTERS
         L     2,=F'13'            TEST ONLY.
         BAL   4,OPCOUNT           TEST ONLY.
         CLC   FILETYPE,=C'2'      CHECK FOR FILE TYPE 2.
         BNE   SETMIN1             NOT A 2. GO SET INDICATOR TO -1.
         BAL   4,BLKCALC           IS A 2. CALCULATE BLOCK.
         MVC   BRNSR(3),RTTR       MOVE TTR FROM RTTR TO TTR OF TTRN
         MVC   BRNSR+3(1),BDN        AND N FROM BDN TO N OF TTRN.
         MVI   INDICATO,I01        SET INDICATOR TO GOOD COMPLETION.
         B     SSAEXIT             BRANCH AROUND NEXT INSTRUCTION.
SETMIN1  MVI   INDICATO,I22        SET INDICATOR ERROR = -22.
SSAEXIT  LM    R2,R9,RIGAMSA       RESTORE REGISTERS
         B     RETOCALL            RETURN TO CALLER
         TITLE 'RIGAM - ''RRA'' - READ RANDOM ACTUAL'
***********************************************************************
*        READ RANDOM ACTUAL ROUTINE                                   *
***********************************************************************
         SPACE 1
RRA      STM   R2,R9,RIGAMSA       SAVE REGISTERS
         L     2,=F'12'            TEST ONLY.
         BAL   4,OPCOUNT           TEST ONLY.
         BAL   4,BLKCALC           BRANCH TO CALCULATE ACTUAL BLOCK
         BAL   4,READBLK           BRANCH TO READ ACTUAL BLOCK
         CLI   INDICATO,I01        TEST INDICATOR FOR ERRORS.
         BH    RRAEXIT             ERROR EXISTS, LEAVE ROUTINE.
         MVI   BDIND,X'01'         NO. SET BLK/DBLK TO MOVE TO USER.
         BAL   4,BDR               BRANCH TO BLOCK/DEBLOCK ROUTINE.
         L     7,RECORDFD          POINT TO RECORD IN BLOCK.
         LA    8,5                 SUBTRACT 5 TO POINT
         SR    7,8                      TO DELETE BYTE.
         CLI   0(7),X'FF'          HAS RECORD BEEN DELETED ?
         BNE   RRAEXIT             NO. NORMAL RETURN.
         MVI   INDICATO,I03        YES. FLAG USER INDICATOR.
RRAEXIT  LM    R2,R9,RIGAMSA       RESTORE REGISTERS
         B     RETOCALL            RETURN TO CALLER
         TITLE 'DEVELOP TTR FROM APP.PGM.RECORD NUMBER.BLKCALC.'
***********************************************************************
*        CALCULATE ACTUAL BLOCK FROM USERS RECORD NUMBER.             *
***********************************************************************
         SPACE 1
BLKCALC  STM   2,9,BCALCSAV        STORE THE REGISTARS.
         SR    2,2                 CLEAR REG.S 2
         SR    5,5                       AND 5.
         ST    5,RHD               CLEAR HOLD AREA.
         L     3,FEEDBACK          GET ADDRESS OF USERS RECORD NUMBER.
         L     3,0(3)              GET USERS RECORD NUMBER.
         IC    5,NODRPB            INSERT NUMBER OF RECORDS PER BLOCK.
         DR    2,5                 DIV.REC.NO.BY NO.OF REC.PER BLK.
         LR    4,3                 PLACE R IN R4. (R2 CONTAINS N).
         SR    3,3                 CLEAR R3.
         MVC   RHD(3),LOWBLK       GET LOW DATA BLOCK EXTENT.
         IC    3,RHD+2             INSERT LOW BLOCK R.
         AR    4,3                 ADD LOW BLK R TO R DEVELOPED ABOVE.
         LH    3,RHD               LOAD TT OF LOW DATA BLOCK EXTENT.
BLK1     CL    4,BLKNOF            TOTAL R CANNOT BE > MAX-R-TRK    BXL
         BC    12,BLK2             LOW OR EQUAL.
         S     4,BLKNOF            DECREMENT R BY MAX-R-TRK         BXL
         A     3,=F'1'             ENCREMENT TT BY 1.
         B     BLK1                GO TEST R AGAIN.
BLK2     CL    2,=F'0'             IF R2=0,N=NO.DATA REC.PER BLK.
         BNE   BLK3                R2 GREATER THAN 3,ALGORITHM FINISHED
         LR    2,5                 N=NO.OF DATA REC.PER BLOCK.
         S     4,=F'1'             TT=TT-1
         CL    4,=F'0'
         BNE   BLK3
         LH    4,BLKNOH                                             BXL
         S     3,=F'1'
BLK3     STH   3,RTTR              STORE TT.
         STC   4,RTTR+2            STORE R.
         STC   2,BDN               STORE N.
         LM    2,9,BCALCSAV        RESTORE THE REGISTARS.
         BR    4                   RETURN
RHD      DC    F'0'                ALIGNMENT HOLD AREA.
BCALCSAV DS    8F                  REGISTAR SAVE AREA.
         SPACE 1
**** ABOVE ALGORITHM IS A THREE STEP FORMULA, SUCH... *****************
*                                                                     *
*            1.)    REC.NO. / REC.PER BLK.= R.N                       *
*                        (WHERE R IS THE TRUNCATED WHOLE NUMBER,      *
*                           AND N IS THE REMAINDER)                   *
*                                                                     *
*            2.)    R > 4  THAN TT=TT+1 AND R=R-4                     *
*                        (CONTINUE TILL R =< 4 .)                     *
*                                                                     *
*            3.)    N = 0 THEN TT=TT-1 , N=REC.PER BLK., AND R=4.     *
*                             (ONE TEST)                              *
*                                                                     *
*** WHEN COMPLETED, ALGORITHM DEVELOPS TTRN FOR TYPE 2 FILE. **********
         TITLE 'GET FILE PARAMETERS RIGAM'
         SPACE 1
******** FILE TABLE AREA ****
         SPACE 1
TABLE1   DC    A(0)                     LOCATION OF TABLE 1
TABLE2   DC    A(0)                     LOCATION OF TABLE 2
LTB1     DC    H'0'                 MAX NO OF ENTRIES TABLE 1
LTB2     DC    H'0'                 MAX NO OF ENTRIES TABLE 2
         SPACE 2
GFP      STM   2,9,REGSAVE         STORE THE REGISTARTS.
         CLI   FILETYP,X'00'       IS IT FIRST TIME?(PARMWK WILL BE 00)
         BE    GFP7                YES. GO TEST FILE TYPE.
         CLC   UFILE,FILENO        NO.ARE FILE PARAMS IN WORK AREA?
         BE    GFP16               YES.SET INDICATOR AND LEAVE.
         CLI   FILETYP,X'F1'       DOES WORK AREA CONTAIN A TYPE 1 FILE
         BE    GFP1                YES. GO STORE IT.
         CLI   FILETYP,X'F2'       DOES WORK AREA CONTAIN A TYPE 2 FILE
         BE    GFP4                YES. GO STORE IT.
         B     GFP14               NEITHER.GO SET INDICATOR AND LEAVE.
         SPACE 1
******** SEARCH TABLE 1 TO STORE WORK AREA OF TYPE 1 FILE. ***
         SPACE 1
GFP1     L     2,TABLE1            POINT TO TABLE 1 START.
         LH    3,LTB1              GET ENTRIES IN TABLE 1.
GFP2     CLC   0(3,2),FILENO       COMPARE WORK FILE TO TABLE.
         BE    GFP3                IF = GO STORE WORK IN TABLE.
         LA    2,229(2)           IF ^= PREPARE TO LOOK AGAIN.
         BCT   3,GFP2              HAS NUMBER OF ENTRIES BEEN EXCEEDED?
         B     GFP15               YES.GO SET INDICATOR AND LEAVE.
         SPACE 1
******** MOVE WORK FILE BACK TO PARAMETER TABLE FOR TYPE 1 FILES. ***
         SPACE 1
GFP3     MVC   0(229,2),PARMWK1    WORK STORAGE MOVE.
         B     GFP7                GO TEST NEW USER FILE TYPE.
         SPACE 1
******** SEARCH TABLE 2 TO STORE WORK AREA OF TYPE 2 FILE. ***
         SPACE 1
GFP4     L     2,TABLE2            POINT TO TABLE 2 START.
         LH    3,LTB2              GET ENTRIES IN TABLE 2.
GFP5     CLC   0(3,2),FILENO       COMPARE WORK FILE TO TABLE.
         BE    GFP6                IF = GO STORE WORK IN TABLE.
         LA     2,28(2)           IF ^= PREPARE TO LOOK AGAIN.
         BCT   3,GFP5              HAS NUMBER OF ENTRIES BEEN EXCEEDED?
         B     GFP15               YES.GO SET INDICATOR AND LEAVE.
         SPACE 1
******** MOVE WORK FILE BACK TO PARAMETER TABLE FOR TYPE 2 FILES. ***
         SPACE 1
GFP6     MVC   0(28,2),PARMWK2     WORK STORAGE MOVE.
         SPACE 1
******** TEST USERS REQUESTED FILE TYPE. ***
         SPACE 1
GFP7     CLI   FILETYPE,X'F1'      IS USER FILE TYPE A 1?
         BE    GFP8                YES. GO PREPARE SEARCH.
         CLI   FILETYPE,X'F2'      IS USER FILE TYPE A 2?
         BE    GFP11               YES. GO PREPARE SEARCH
         B     GFP14               NO.GO SET INDICATOR AND LEAVE
         SPACE 1
******** SEARCH TABLE 1 TO MOVE USER REQUESTED PARAMETER FILE TO THE
********  WORK AREA ***
         SPACE 1
GFP8     L     2,TABLE1            POINT TO TABLE 1 START.
         LH    3,LTB1              GET ENTRIES IN TABLE 1.
GFP9     CLC   0(3,2),UFILE        COMPARE USER FILE TO TABLE 1.
         BE    GFP10               IF = GO MOVE PARAMS TO WORK AREA.
         LA    2,229(2)           IF ^= PREPARE SEARCH AGAIN.
         BCT   3,GFP9              HAS NUMBER OF ENTRIES BEEN EXCEEDED?
         B     GFP15               YES.GO SET INDICATOR AND LEAVE.
         SPACE 1
******** MOVE TABLE PARAMETER OF USERS FILE TO WORK AREA.  ***
         SPACE 1
GFP10    MVC   PARMWK1(229),0(2)   MOVE PARAMETERS.(TYPE 1)
         B     GFP16               GO SET INDICATOR.
         SPACE 1
******** SEARCH TABLE 2 TO MOVE USER REQUESTED PARAMETER FILE TO THE
********  WORK AREA ***
         SPACE 1
GFP11    L     2,TABLE2            POINT TO TABLE 2 START.
         LH    3,LTB2              GET ENTRIES IN TABLE 2.
GFP12    CLC   0(3,2),UFILE        COMPARE USER FILE TO TABLE 2.
         BE    GFP13               IF = GO MOVE PARAMS TO WORK AREA.
         LA    2,28(2)            IF ^= PREPARE SEARCH AGAIN.
         BCT   3,GFP12             HAS NUMBER OF ENTRIES BEEN EXCEEDED?
         B     GFP15               YES.GO SET INDICATOR AND LEAVE.
         SPACE 1
******** MOVE TABLE PARAMETER OF USERS FILE TO WORK AREA.  ***
         SPACE 1
GFP13    MVC   PARMWK2(28),0(2)    MOVE PARAMETERS.(TYPE 2)
         B     GFP16               GO SET INDICATOR.
         SPACE 1
******** INDICATOR SETTINGS AND EXIT. ***
         SPACE 1
GFP14    MVI   INDICATO,I06        NOT EQUAL SPECIFICATIONS SET.
         B     GFP17               LEAVE
GFP15    MVI   INDICATO,I09        FILE NOT OPENED SET.
         B     GFP17               LEAVE
GFP16    MVI   INDICATO,I01        FUNCTION COMPLETED SET
GFP17    LM    2,9,REGSAVE         RESTORE THE REGISTARTS.
         BR    4                   LEAVE.
         TITLE 'GET INDICIES ROUTINE RIGAM'
GIR      STM   2,9,REGSAVE1        SAVE THE REGISTARS.
         TM    FTSWTCH,X'02'            FIRST TIME
         BO    GIR1                     NO
         MVI   FTSWTCH,X'02'            YES RESET SWITCH
         B     GIR2A                    GO TO 2A
GIR1     LA    3,UKEY                   USER ARGUMENT - KEY
         SR    4,4                      CLEAR 4
         IC    4,ARGL                   ARGUMENT LENGTH
         B     GIR2                     BRANCH AROUND COMPARE
GIRCOMP  CLC   0(0,3),0(2)              COMPARE
GIR2     S     4,=F'1'                  LENGTH-1
GIR3     LA    2,HA1                    POINTER TO HIGH ARG LEVEL 1
         EX    4,GIRCOMP                COMPARE
         BC    12,GIR4                  LT EQ BR
GIR5     LA    2,HA2                    POINTER TO HIGH ARG LEVEL 2
         EX    4,GIRCOMP                COMPARE
         BC    12,GIR6                  LT EQ BR
         B     GIR2A                    GO TO  2A
GIR4     LA    2,LA1                    POINTER TO LOW ARG LEVEL 1
         EX    4,GIRCOMP                COMPARE
         BL    GIR5                     LOWER
         MVC   RTTR(3),BN1         BLOCK NO. TO LEVEL 1 BLK NO.
         MVI   LEVEL,X'01'              LEVEL NO = 1
         B     GIR2B                    GO TO 2B
GIR6     LA    2,LA2                    POINTER TO  LOW ARG LEVEL 2
         EX    4,GIRCOMP                COMPARE
         BL    GIR2A                    GO TO 2A
         MVC   RTTR(3),BN2         BLOCK NO. OF LEVEL 2 BLK NO.
         MVI    LEVEL,X'02'             LEVEL NO = 2
         B     GIR2B                    GO TO 2B
GIR2A    MVC   RTTR(3),ILBN        STARTING INDEX BLOCK.
         MVC   LEVEL,NOINDL             NO OF LEVELS
GIR2B    BAL   4,JDAREAD           READ AN INDEX BLOCK.
         CLI   INDICATO,I01        TEST INDICATOR.
         BH    GIR3C               BAD NOISE IF LOW, SO LEAVE.
         MVC   LBR(3),RTTR              TTR OF LAST REC TO FP TABLE
         MVC   LBR+3(1),BDN             N   OF LAST REC TO FP TABLE
         BAL   4,SEARCH                 SEARCH INDEX  BLOCK AND CHAIN
         CLI   LEVEL,X'02'              CURRENT LEVEL = 2
         BE    GIR7                     GO TO SAVE LEVEL 2
         CLI   LEVEL,X'01'              CURRENT LEVEL = 1
         BE    GIR8                     GO TO SAVE LEVEL 1
GIR9     SR    2,2                      CLEAR REG 2
         IC    2,LEVEL                  LEVEL
         S     2,=F'1'                  REDUCE LEVEL BY ONE
         STC   2,LEVEL                  STORE LEVEL
         B     GIR2B                    GO TO 2B
         SPACE 1
******** STORE CONTENTS OF CURRENT LEVEL 2 IN PARM WORK ***
         SPACE 1
GIR7     SR    4,4                      CLEAR 4
         IC    4,ARGL                   ARG LENGTH
         S     4,=F'1'                  LENGTH FOR MOVE
         LA    2,LA2                    LOW ARGUMENT LEVEL2
         LA    3,BLOCK+12               LOW ARGUMENT BLOCK
         B     GIR10                    BR AROUND MOVE
GIRMOVE  MVC   0(0,2),0(3)              EXECUTED MOVE
GIR10    EX    4,GIRMOVE                MOVE  LOW ARGUMENT LEVEL 2
         LA    2,HA2                    POINTER HIGH ARG  LEVEL2
         LR    8,4                      ARGUMENT LENGTH - 1
         LA    8,6(8)                   INDEX LENGTH
         SR    6,6                      CLEAR  6
         SR    7,7                      CLEAR  7
         IC    7,BLOCK+3                NUMBER OF INDICIES PER BLOCK
         S     7,=F'1'                  SUBTRACT 1
         MR    6,8                      LENGTH TO LAST INDEX
         AR    3,7                      POINT TO HIGH BLOCK
         EX    4,GIRMOVE                MOVE HIGH ARGUMENT  LEVEL 2
         MVC   BN2(3),BLOCK        MOVE LEVEL 2 BLOCK NO.
         B     GIR9                     GO TO REDUCE LEVEL
GIR8     SR    4,4                      CLEAR 4
         IC    4,ARGL                   ARG LENGTH
         S     4,=F'1'                  LENGTH FOR MOVE
         LA    2,LA1                    LOW ARG LEVEL 1
         LA    3,BLOCK+12               LOW ARG BLOCK
         EX    4,GIRMOVE                MOVE LOW LEVEL ARG
         LA    2,HA1                    POINT TO PARM AREA HIGH ARG
         LR    8,4                      ARG LENGTH-1
         LA    8,6(8)                   INDEX LENGTH
         SR    6,6                      CLEAR 6
         SR    7,7                      CLEAR 7
         IC    7,BLOCK+3                NO OF INDICIES
         S     7,=F'1'                  SUB 1
         MR    6,8                      LENGTH TO LAST INDEX
         AR    3,7                      POINT TO LAST INDEX
         EX    4,GIRMOVE                MOVE TO PARM AREA H L BLOCK 1
         MVC   BN1(3),BLOCK        MOVE LEVEL 1 BLOCK POINTER.
GIR3C    LM    2,9,REGSAVE1        RESTORE THE REGISTARS
         BR    4                        RETURN
REGSAVE1 DS    10F                 REGISTAR STORAGE AREA.
LEVEL    DS    C                        LEVEL COUNTER
         TITLE 'SEARCH   RIGAM'
***********************************************************************
*        SEARCH ROUTINE    ENTRY BAL  4,SEARCH                        *
***********************************************************************
         SPACE 1
SEARCH   STM   2,9,REGSAVE2        SAVE THE REGISTARS(CRIED THE C.P.U.)
S7       SR     8,8                     COUNTER REG = 0
         SR    9,9                      CLEAR 9
         IC    9,BLOCK+3                NO OF INDICES
         LA    3,BLOCK+12               POINTER TO FIRST INDEX
         SR    4,4                      CLEAR 4
         IC    4,ARGL                   ARGUMENT LENGTH
         S     4,=F'1'                  DECREMENT LENGTH
         LA    8,1(8)                   COUNTER = 1
         LA    2,UKEY                   KEY POINTER
         B     S1                       BR AROUND
SCOMP    CLC   0(0,2),0(3)              COMPARE
S1       EX    4,SCOMP                  KEY = INDEX ARGUMENT
         BE    S2                       TEST DELETE CODE
         BL    S10                 TEST BLOCK INDICE LOCATION.
         CR    8,9                      COUNTER = NO INDICIES PER BLOCK
         BE    S4                       GO TO CHAIN
         BH    SCPROB              CANNOT EXCEED INDICES IN BLOCK.
         LA    8,1(8)                   INCREMENT COUNTER
         STC   8,INDNUMB           SAVE INDEX POS.FOR FKG ROUTINE.
         LA    3,6(3)                   INCREMENT INDEX
         AR   3,4                       INCREMENT INDEX
         B     S1                       GO TO COMPARE
S4       CLC   INDPB(1),BLOCK+3    IS BLOCK FULL
         BH    S4A                 NO.
         CLI   BLOCK+10,X'FF'      YES.IS IT CHAINED?
         BE    S6                  YES. GO GET CHAINED BLOCK.
         MVI   ADDINDIC,X'02'      NO. SET UP FOR CHAINING.
         B     S4B                 SET INDICATOR
S4A      MVI   ADDINDIC,X'01'      SET X TO X+1
S4B      MVI   INDICATO,I03        RECORD NOT FOUND CONDITION
         B     S5                  EXIT
S9       SR    3,4                 RESTORE POINTER TO EQUAL INDEX
         S     3,=F'1'                FOUND ADDRESS FOR STORING POINTER
S3       MVI   ADDINDIC,X'00'      SET ADD IND. TO INDEX+0 CONDITION.
         MVI   INDICATO,I03        SET INDICATOR TO ZERO.
         LR    7,3                 SEARCH
SHIL01   S     7,=F'5'               FOR
         CLI   0(7),X'FF'              LOWEST
         BNE   SHIL02                      SEQUENTIAL
         SR    7,4                           KEY
         S     7,=F'1'                              THEN
         MVC   INDSVE,INDICTOR     SAVE INDICATOR
         BAL   8,SRSUP1
         B     SHIL01                             THEN
SHIL02   MVC   SRLOWAG,1(7)        SEARCH FOR       STORE IT
         LR    7,3                     HIGHEST
SHIL03   AR    7,4                        SEQUENTIAL
         CLI   1(7),X'FF'                    KEY
         BNE   SHIL04                        INDEX
         A     7,=F'6'                                 STORE
         MVC   INDSVE,INDICTOR     SAVE INDICATOR
         BAL   8,SRSUP2
         B     SHIL03                              STORE
SHIL04   MVC   SRHIWAG,2(7)                             IT.
         B     S5                  LEAVE.
S6       MVC   RTTR(3),BLOCK+7     GET CHAIN POINTER
         ST    4,FOUNDADD
         BAL   4,JDAREAD           GET NEXT CHAINED BLOCK.
         L     4,FOUNDADD
         B     S7                       GO BACK
S2       AR    3,4                      INCREMENT TO
         LA    3,1(3)                   GET DELETE POINTER
         CLI   0(3),X'FF'               DELETE
         BE    S9                  SET INDICATORS.
         MVI   INDICATO,I01        SET INDICATOR TO 1.
         SR    6,6                 CLEAR REGISTAR 6 FOR DATA RECORD
         IC    6,ARGL                LENGTH ADJUSTMENT FACTOR.
         B     S8                  GET NEXT LEVEL TTRN.
S5       SR    6,6                 ADJUST
         IC    6,ARGL                TO
         AR    3,6                     BLOCK
S8       LA    3,1(3)                       TTR.
         MVC   RTTR(3),0(3)        MOVE TTR TO READ
         MVC   BDN,3(3)                 MOVE N TO BLOCK DEBLOCK
         S     3,=F'1'             ADJUST BACK TO
         SR    3,6                   KEY ADDRESS.
         ST    3,FOUNDADD               POINTER TO FOUND INDEX
         LM    2,9,REGSAVE2        RESTORE THE REGISTARS
         BR    4                        RETURN
S10      CLI   LEVEL,X'01'
         BNE   S3
         LA    5,BLOCK+12          POINT TO FIRST INDICE IN. BLOCK.
         CR    3,5                 SAME AS POINTER TO HIGH INDICE ??
         BNE   S3                  NO. CONTINUE MAINLINE.
         XR    6,6                 YES.FIRST OF BLOCK. CLEAR R6.
         IC    6,ARGL              INSERT ARGUEMENT LENGTH
S11      AR    5,6                 ADD ARG.LENGTH TO POINTER FOR DELETE
         CLI   0(5),X'FF'          IS IT DELETED?
         BNE   S12                 NO.
         LA    5,5(5)              YES. POINT TO NEXT INDEX
         B     S11                  AND GO COMPARE FOR DELETE AGAIN.
S12      MVC   SRHIWAG,1(5)        STORE HI TTRN FOR WAG ROUTINE.
         MVC   PREVTTR(3),BLOCK    SAVE THIS BLOCK TTR.
         CLC   BLOCK+4(3),=X'000000'    IS PREVIOUS NEXT LEVEL ?
         BE    S14                      YES. GO MAKE LO=HI.
         MVC   RTTR(3),BLOCK+4     GET PREVIOUS BLOCK TTR FOR READ.
         BAL   4,JDAREAD           GO TO READ ROUTINE.
         XR    5,5                 CLEAR REGISTAR 5.
         IC    5,BLOCK+11          GET INDICE LEVEL OF THIS BLOCK
         N     5,FOXMASK           MASK OUT TOTAL INDICES
         CH    5,=H'1'             IS THIS BLOCK A LEVEL 1 ??
         BNE   S14                 NO. GO SET LOWAG AND READ.
         XR    5,5                 YES.CLEAR REG.5
         IC    5,BLOCK+3           INSERT TOTAL INDICES THIS BLOCK.
         STC   5,INDNUMB           STORE IT FOR CALCULATION ROUTINE.
         BAL   4,INDCALC           GO TO CALCULATION ROUTINE.
         L     5,INDADDR           GET ADDRESS OF LAST INDEX KEY.
S13      AR    5,6                 ADD KEY LENGTH TO ADDRESS OF KEY
         CLI   0(5),X'FF'          IS THIS RECORD DELETED ?
         BNE   S15                 NO. GO TO STORE TTRN.
         SR    5,6                 YES. SUBTRACT KEY LENGTH AND
         S     5,=F'5'                  5 FOR TTRN AND DELETE THEN
         SR    5,6                      ADJUST TO NEXT KEY.
         B     S13                 GO COMPARE AGAIN.
*S14     MVC   SRLOWAG,SRHIWAG     REMOVED   2/9/71                 DAM
S14      MVC   SRLOWAG,LOWBLK      SUBSTITUTED   2/9/71             DAM
         MVI   SRLOWAG+3,X'01'     ADDED         2/9/71             DAM
         B     S16                 GO TO READ.
S15      MVC   SRLOWAG,1(5)        STORE LO TTRN FOR WAG ROUTINE.
S16      MVC   RTTR(3),PREVTTR     POINT TO NEXT BLOCK SAVED.
         BAL   4,JDAREAD           GO TO READ ROUTINE.
         MVI   ADDINDIC,X'00'      SET WAG INDICATOR AND
         MVI   INDICATO,I03          EXCEPTION INDICATOR.
         B     S5                  GO TO CALCULATE ADJUSTMENT ADDRESS
REGSAVE2 DS    8F                  REGISTAR STORAGE AREA.
FOUNDADD DS    F
PREVTTR  DC    F'0'                PREVIOUS INDEX BLOCK TTR HOLD.
FOXMASK  DC    XL4'0000000F'       MASK FOR LEVEL CHECK
SCPROB   MVI   INDICATO,I35        INDICES DON'T EXIST.
         LM    2,9,REGSAVE2        RESTORE
         BR    4                   LEASE
         TITLE 'SUPPORT TO FIND LO TTRN POINTER.'
***********************************************************************
*    THIS ROUTINE DETERMINES IF THE LOW ADDRESS OF AN INDEX BLOCK IN  *
* CORE HAS BEEN EXCEED. IT WILL READ BACKWARD THROUGH THE INDICES TILL*
* A NONE DELETED INDEX IS FOUND OR FIRST RECORD MUST BE INSERTED.     *
***********************************************************************
         SPACE 1
SRSUP1   STM   2,9,SRSAVREG        SAVE REG'S.
         LA    2,BLOCK+12          POINT TO FIRST INDEX.
         CR    7,2                 IS ADDRESS OF CURRENT > THAN FIRST?
         BC    12,SRS1             NO, GO DETERMINE PREVIOUS BLOCK.
         LM    2,9,SRSAVREG        YES. RETURN FOR
         BR    8                        FURTHER SEARCH.
         SPACE 2
SRS1     BC    0,SRS2              FIRST TIME THRU SWITCH IS OFF.
         MVI   SRS1+1,X'F0'        TURN ABOVE SWITCH ON.
         MVC   SRCTTRIN(3),BLOCK   SAVE THIS INDEX BLOCK TTR.
SRS2     CLC   BLOCK+4(3),=X'000000'    IS PREVIOUS TTR ZERO ?
         BE    SRS6                     YES. GO MOVE START TTRN IN.
         MVC   RTTR(3),BLOCK+4     PREPARE READ WITH PREVIOUS TTR.
         BAL   4,JDAREAD           EXECUTE READ ROUTINE.
         SPACE 1
********                    EXECUTE FORMULA
******** ((ARGL*NO.INX.USED)+(5*(NO.INX.USED-1)))+A(BLOCK+12) ***
         SPACE 1
         XR    5,5
         XR    6,6
         XR    7,7
         XR    8,8
         IC    7,BLOCK+3
         IC    5,ARGL
         MR    6,5
         LR    8,7
         XR    7,7
         IC    7,BLOCK+3
         SH    7,=H'1'
         XR    5,5
         LA    5,5(5)
         MR    6,5
         AR    8,7
         LA    7,BLOCK+12
         AR    7,8            R7 POINTS TO LAST INDEX DELETE BYTE.
         SPACE 1
SRS3     CLI   0(7),X'FF'     IS INDEX DELETED?
         BNE   SRS4           NO. GO STORE IT IN LOWAG.
         XR    8,8            YES, SUBTRACT
         IC    8,ARGL              KEY (ARGUMENT)
         SR    7,8                 LENGTH.
         S     7,=F'5'        SUBTRACT RIGAM DISPLACEMENT.
         BAL   8,SRSUP1       GO DETERMINE ADDRESSABILITY THIS BLOCK.
         B     SRS3           COMPARE NEXT INDEX DELETE.
         SPACE 1
SRS4     MVC   SRLOWAG,1(7)   MOVE IN LOW POINTER FOR WAG.
SRS5     MVC   RTTR(3),SRCTTRIN    RESTORE CURRENT BLOCK TTR.
         BAL   4,JDAREAD           EXECUTE READ ROUTINE.
         MVI   SRS1+1,X'00'   TURN FIRST SWITCH (SRS1) OFF.
         LM    2,9,SRSAVREG   RESTORE REGS.
         XR    4,4                    AND
         IC    4,ARGL                 ARGL
         S     4,=F'1'                AND
         LR    7,3                    POINTER TO INDEX.
         MVC   INDICTOR,INDSVE     RESTORE INDICATOR
         B     SHIL03         GO SEARCH FOR HIWAG.
         SPACE 1
SRS6     MVC   SRLOWAG(3),LOWBLK   GET START TTR AND N
         MVI   SRLOWAG+3,X'01'          FOR LOW POINTER FOR WAG.
         B     SRS5                GO RESTORE BLOCK.
         SPACE 2
***********************************************************************
*    THIS ROUTINE DETERMINES IF THE HIGH ADDRESS OF AN INDEX BLOCK IN *
* CORE HAS BEEN EXCEED. IT WILL READ FORWARD THROUGH THE INDICES TILL *
* A NONE DELETE INDEX IS FOUND OR EOF IS TO BE INSERTED.              *
***********************************************************************
         SPACE 1
SRSUP2   STM   2,9,SRSAVREG        STORE REG'S.
         SPACE 1
********                    EXECUTE FORMULA
******** ((ARGL+5)*NO.INX.USED)+A(BLOCK+12) ***
         SPACE 1
         XR    4,4
         XR    5,5
         XR    6,6
         IC    5,ARGL
         LA    5,5(5)
         IC    6,BLOCK+3
         MR    4,6
         LA    6,BLOCK+12
         AR    5,6            R5 CONTAINS ADDRESS OF HIGH INDEX + 1.
         CR    7,5            IS ADDRESS OF CURRENT < THAN LAST ?
         BC    10,SRS2A       NO. GO DETERMINE NEXT BLOCK.
         LM    2,9,SRSAVREG   YES. RESTORE REG'S.
         BR    8              RETURN FOR SEARCH
         SPACE 1
SRS2A    BC    0,SRS2B        FIRST TIME THRU SWITCH IS OFF.
         MVI   SRS2A+1,X'F0'  TURN ABOVE SWITCH ON.
         MVC   SRCTTRIN(3),BLOCK   SAVE THIS BLOCK TTR.
*
SRS2B    CLC   BLOCK+7(3),=X'000000'    IS NEXT TTR ZERO ?
         BE    SRS2H                    YES. SET HIWAG AT EOF TTRN.
         CLI   BLOCK+10,X'FF'      IS BLOCK CHAINED ?
         BE    SRS2C               YES. GO CHECK HIGH INDEX.
         CLC   BLOCK+7(3),ILBU     NEXT INDEX > LAST BLOCK ?
         BH    SRS2H               YES. SET HIWAG AT EOF TTR.
         B     SRS2D               GO AROUND NEXT COMPARE.
         SPACE 1
SRS2C    CLC   BLOCK+7(3),IHBN     NEXT INDEX > UPPER EXTENT ?
         BH    SRS2H               YES. SET HIWAG AT EOF TTR.
         SPACE 1
SRS2D    MVC   RTTR(3),BLOCK+7     READY READ WITH NEXT BLOCK TTR.
         BAL   4,JDAREAD           EXECUTE READ ROUTINE.
         LA    7,BLOCK+12          POINT TO FIRST INDEX.
SRS2E    XR    8,8                 DISPLACE TO
         IC    8,ARGL                 DELETE BYTE.
         AR    7,8                 ADD ARGUMENT LENGTH
         CLI   0(7),X'FF'          IS INDEX DELETED ?
         BNE   SRS2F               NO. GO SAVE TTRN IN HI WAG.
         LA    7,5(7)              INCREMENT POINTER BY RIGAM BYTES.
         BAL   8,SRSUP2       GO DETERMINE ADDRESSABILITY THIS BLOCK.
         B     SRS2E          COMPARE FOR NEXT INDEX DELETE.
         SPACE 1
SRS2F    MVC   SRHIWAG,1(7)   STORE TTRN IN HIGH POINTER FOR WAG.
SRS2G    MVC   RTTR(3),SRCTTRIN    RESTORE CURRENT BLOCK TTR.
         BAL   4,JDAREAD           EXECUTE READ ROUTINE.
         MVI   SRS2A+1,X'00'       TURN FIRST SWITCH (SRS2A) OFF.
         LM    2,9,SRSAVREG        RESTORE REGS.
         MVC   INDICTOR,INDSVE     RESTORE INDICATOR
         B     S5                  GO SET POINTER FOR CURRENT.
         SPACE 1
SRS2H    MVC   SRHIWAG,BREOF       SET HIWAG POINTER AT EOF FOR WAG.
         B     SRS2G
         SPACE 1
SRSAVREG DS    8F                  REGISTER SAVE AREA
SRCTTRIN DC    F'0'                TTR SAVE.
INDSVE   DC    H'0'                SAVE INDICATOR
         TITLE  'BLOCK BEBLOCK ROUTINE GENERIC RIGAM'
***********************************************************************
*        ROUTINE TO INSERT A RECORD OR RETRIEVE A RECORD              *
***********************************************************************
         SPACE 1
BDN      DS    C                        POSITION OF RECORD IN BLOCK
BDIND    DS    C                01 OR 02IND=1 OR 2  =1 TO USER
*  ENTRY  BAL  4,BDR
BDR      STM   2,9,REGSAVE4        SAVE THE REGISTARS
         LA    2,BLOCK+3                POINTER TO FIRST ENTRY
         SR     3,3                     CLEAR 3
         IC    3,BDN                    NO OF BLOCK TO 3
         S     3,=F'1'                 SET FOR MULTIPLY
         SR    7,7                      CLEAR 6
         IC    7,DLGN                   FIRST BYTE OF DATA LENGTH+
         SLA    7,8(0)                 SHIFT LENGTH
         IC    7,DLGN+1                 REMAINDER OF LENGTH
         LR    8,7                 SAVE THE DATA LENGTH.
         SR    6,6                      CLEAR6
         MR    6,3
         AR    2,7                      POINTER TO DATA
         SR    6,6                 CLEAR REGISTAR 6.
         SR    7,7                 CLEAR REGISTAR 7.
         LA    7,5(7)              PLACE A 5 IN REGISTAR 7.
         A     3,=F'1'             ADD 1 TO RECORD NUMBER.
         MR    6,3                 MULTIPLY NO.OF REC.S AND CONSTANT 5.
         AR    2,7                 ADD PRODUCT TO REG.2 FOR ALIGNMENT.
         ST    2,RECORDFD               SAVE DATA POINTER
         L     3,UAREA                  AREA IN CALLING PROG
         LR    6,8           RESTORE DATA LENGTH
         S     6,=F'1'                  LENGTH FOR MOVE
         L     8,=F'255'                LOAD MOVE CONSTANT
BDRCOMP  CR    6,8                      COMPARE < 256
         BC    12,MOVEL256         GO TO 256 CHAR.OR LESS MOVE.
         B     MOVEG256                 > 256 CHAR MOVE
MOVEL256 CLI   BDIND,X'01'              DATA TO USER
         BE    MOVETO                   GO TO MOVE TO USER
         EX    6,BDRMOVEF               EXECUTE MOVE FROM USER
         B     BDRRTN                   RETURN
MOVETO   EX     6,BDRMOVET              EXECUTE MOVE TO USER
         B     BDRRTN                   RETURN
MOVEG256 S     6,=F'256'                DECREMENT
         CLI   BDIND,X'01'              CHECK FOR MOVE TO USER
         BE    MVTO                     MOVE TO
         EX    8,BDRMOVEF              EXECUTE MOVE FROM
         B     ADJUST                   ADJUST REGISTERS
MVTO     EX    8,BDRMOVET               MOVE TO
         B     ADJUST                   ADJUST
BDRMOVET MVC   0(0,3),0(2)              COMPUTED MOVE  TO   USER
BDRMOVEF MVC   0(0,2),0(3)              COMPUTED MOVE  FROM USER
ADJUST   A     2,=F'256'                ADJUST POINTERS
         A     3,=F'256'                ADJUST POINTERS
         B     BDRCOMP                  GO BACK TO COMPARE
BDRRTN   LM    2,9,REGSAVE4        RESTORE THE REGISTARS.
         BR    4                        RETURN
RECORDFD DC    A(0)                     LOCATION OF DATA BLOCK
REGSAVE4 DS    10F                 REGISTAR SAVE AREA.
         TITLE 'RIGAM - READ A BLOCK'
***********************************************************************
*                                                                     *
*        THIS ROUTINE CONVERT THE RELATIVE TRACK ADDRESS (TTR) TO     *
*         ACTUAL ADDRESS FOR READ A DATA BLOCK WITH 'XDAP' MACRO.     *
*                                                                     *
***********************************************************************
         SPACE 1
READBLK  STM   R2,R9,RDRBLKSA      SAVE R2 TO R9
         CLC   RTTR(3),HGHBLK           CHECK HIGH FILE EXTENT
         BH    RDR1                     EXTENT VIOLATION
         CLC   RTTR(3),LOWBLK           CHECK LOW  FILE EXTENT
         BL    RDR1                     EXTENT VIOLATION
         CLC   BLOCK(3),RTTR            CHECK FOR BLOCK IN CORE
         BE    RDR2                     EQUAL SKIP READ
JDAREAD  STM   R2,R9,RDRBLKSA      SAVE R2 TO R9
         L     R0,RTTR             LOAD TTRN INTO R0
         L     R1,IAMRIGAM+44       LOAD ADDRESS OF DATA EXTENT BLOCK
         LA    R2,MBBCCHHR         LOAD ADDRESS OF MBBCCHHR WORK AREA
         L     R15,16              LOAD ADDRESS OF COMM. VECTOR TABLE
         L     R15,28(R15)         LOAD ENTRY POINT ADDRESS OF IECPCNVT
         STM   R9,R13,XDAPSA1      PRESERVE REGISTERS R9 TO R13
         CNOP  2,4
         BALR  R14,R15             GO CONVERT RELATIVE TRACK ADDRESS
*                                   TO ACTUAL ADDRESS
         BAL   R14,24(R14)         BRANCH AND LINK AROUND SAVE AREA REG
XDAPSA1  DS    5F                  SAVE AREA FOR REGS R9 TO R13
         LM    R9,R13,0(R14)       RESTORE REGISTERS R9 TO R13
         XDAP  XDAPECB1,RI,IAMRIGAM,BLOCK,1693,,MBBCCHHR
         WAIT  ECB=XDAPECB1
         CLI   XDAPECB1,X'7F'      TEST IF SUCCESSFUL ?
         BNE   XDAPERR             BRANCH IF NO
RDR2     MVI   INDICATO,I01        SET INDICATOR TO 1
         B     *+8                 SKIP NEXT INSTRUCTION
RDR1     MVI   INDICATO,I12        SET INDICATOR TO 12
         LM    R2,R9,RDRBLKSA      RESTORE R2 TO R9
         BR    R4                  RETURN TO CALLER
         TITLE 'RIGAM - WRITE A BLOCK'
***********************************************************************
*                                                                     *
*        THIS ROUTINE CONVERT THE RELATIVE TRACK ADDRESS (TTR) TO     *
*         ACTUAL ADDRESS FOR WRITE A BLOCK WITH 'XDAP' MACRO          *
*                                                                     *
***********************************************************************
         SPACE 1
WTRBLOCK STM   R2,R9,WRTBLKSA      SAVE REGISTERS
         L     R1,IAMRIGAM+44      LOAD ADDRESS OF DATA EXTENT BLOCK
         LA    R2,MBBCCHHR         LOAD ADDRESS OF MBBCCHHR WORK AREA
         L     R15,16              LOAD ADDRESS OF COMM. VECTOR TABLE
         L     R15,28(R15)         LOAD ENTRY POINT ADDRESS OF IECPCNVT
         STM   R9,R13,XDAPSA2      PRESERVE REGISTERS R9 TO R13
         CNOP  2,4
         BALR  R14,R15             GO CONVERT RELATIVE TRACK ADDRESS
*                                   TO ACTUAL ADDRESS
         BAL   R14,24(R14)         BRANCH AND LINK AROUND SAVE AREA REG
XDAPSA2  DS    5F                  SAVE AREA FOR REGS
         LM    R9,R13,0(R14)       RESTORE REGISTERS R9 TO R13
         XDAP  XDAPECB2,WI,IAMRIGAM,BLOCK,1693,,MBBCCHHR
         WAIT  ECB=XDAPECB2
         CLI   XDAPECB2,X'7F'      TEST IF SUCCESSFUL ?
         BNE   XDAPERR             BRANCH IF NO
         LM    R2,R9,WRTBLKSA      RESTORE REGISTERS
         BR    R4                  RETURN TO CALLER
         TITLE 'RIGAM - ''WUG'' - WRITE UPDATE GENERIC'
***********************************************************************
*        WRITE UPDATE GENERIC ROUTINE                                 *
***********************************************************************
         SPACE 1
WUG      STM   R2,R9,RIGAMSA       SAVE REGISTERS
         L     2,=F'9'             TEST ONLY.
         BAL   4,OPCOUNT           TEST ONLY.
         CLI   FILETYPE,X'F1'      FILE TYPE = 1
         BNE   WUG1                NO GO TO SET IND=-1
         B     WUGKEY              GO COMPARE KEYS FOR EQUALS.
WUGOK    BAL   4,GIR               GET INDICES ROUTINE.
         LH    2,INDICTOR          LOAD INDICATOR
         CH    2,=H'1'             IND=1
         BNE   WUG1A               NO GO TO 1A
         B     WUG2                BRANCH AROUND
WUG1     MVI   INDICATO,I15        SET THE INDICATOR TO -15.
         B     WUG1A               GO TO EXIT
WUG2     BAL   4,READBLK           READ DATA ROUTINE
         LH    2,INDICTOR          LOAD INDICATOR
         CH    2,=H'1'             IND <1
         BH    WUG1A               YES GO TO EXIT
         MVI   BDIND,X'02'         SET BLOCKING INDICATOR = 02
         BAL   4,BDR               BLOCK DEBLOCK ROUTINE
         MVC   WTTR(3),BLOCK       SET WRITE TTR
         BAL   4,WRITEBLK          WRITE BLOCK
WUG1A    LM    R2,R9,RIGAMSA       RESTORE REGISTERS
         B     RETOCALL            RETURN TO CALLER
         SPACE 1
******** TEST KEY IN LIST AGAINST KEY IN WORK AREA. ***
         SPACE 1
WUGKEY   L     5,UAREA             POINT TO USERS WORK AREA.
         XR    6,6                 CLEAR R6.
         IC    6,ARGL              GET ARGUEMENT (KEY) LENGTH.
         AH    6,=H'2'             ADJUST FOR COMPARE.
         EX    6,WUGCOMP           EXECUTE COMPARE.
         BE    WUGOK               GOOD. CONTINUE UPDATE
         MVI   INDICATO,I36        BAD. SET INDICATOR TO 36.
         B     WUG1A               RETURN
WUGCOMP  CLC   UIDEN(0),0(5)       COMPARE KEY LIST AND WORK AREA.
         TITLE 'WRITE DATA AND INDEX WRD WRI  RIGAM'
***********************************************************************
*        SUBROUTINE TO WRITE DATA OR INDEX BLOCKS                     *
*        DIFFERENCE  IN CHECKING FILE EXTENTS                         *
***********************************************************************
         SPACE 1
WTTR     DC    F'0'           TTR FOR BLOCK TO BE WRITTEN
ANWORD   DC    F'0'         ANOTHER FULL WORD, HOW ABOUT THAT
HIGHEXT  DC    F'0'           UPPER EXTENT FOR CHECK
LOWEXT   DC    F'0'           LOWER EXTENT FOR CHECK
WRITEINX STM   2,9,REGSAVEX   SAVE REGISTERS
         MVC   HIGHEXT(3),IHBN     HIGH INDEX BLOCK EXTENT
         MVC   LOWEXT(3),ILBN      LOW  INDEX BLOCK EXTENT
         B     WDI3                GO TO COMPARES.
WRITEBLK STM   2,9,REGSAVEX   SAVE REGISTERS
          MVC  HIGHEXT(3),HGHBLK   HIGH DATA BLOCK EXTENT
         MVC   LOWEXT(3),LOWBLK    LOW  DATA BLOCK EXTENT
WDI3     CLI   RESERVCD,X'00'      IS FILE RESERVED   00=NO  FF=YES
         BNE   WDI2                NOT EQUAL BRANCH
         MVI   INDICATO,I31        SET INDICATOR TO 31(NOT RESERVED)
         B     WDIEXIT             GO TO RETURN
         SPACE 1
******** CHECK FILE EXTENTS FOR VIOLATION ***
         SPACE 1
WDI2     CLC   WTTR(3),HIGHEXT     HIGH EXTENT VIOLATION
         BH    WDI4                YES
         CLC   WTTR(3),LOWEXT      LOW  EXTENT VIOLATION
         BL    WDI4                YES
         SPACE 1
******** ALL TESTS ARE CORRECT WRITE ***
         SPACE 1
         L     R0,WTTR             LOAD TTRN INTO R0
         BAL   R4,WTRBLOCK         GO WRITE A BLOCK
         MVI   INDICATO,I01        SET INDICATOR TO 1
         B     WDIEXIT             GO TO EXIT
WDI4     CLC   HIGHEXT(3),IHBN     INDEX OR DATA EXTENT ERROR?
         BE    WDI6                INDEX YES.
         MVI   INDICATO,I16        SET DATA EXTENT ERROR = -16.
         B     WDIEXIT             LEAVE.
WDI6     MVI   INDICATO,I17        SET INDEX EXTENT ERROR = -17.
WDIEXIT  LM    2,9,REGSAVEX        RESTORE REGISTERS
         BR    4                   RETURN
         TITLE 'RIGAM - ''WAG'' - WRITE ADD GENERIC'
***********************************************************************
*        WRITE ADD GENERIC ROUTINE                                    *
***********************************************************************
         SPACE 2
SPIND1   DC    PL1'00'        SPECIAL ADD INDICATOR 1   * CONSTANTS 1 *
SPIND2   DC    PL1'00'        SPECIAL ADD INDICATOR 2   * TOGETHER  2 *
SPIND3   DC    XL1'00'             UNUSED SPECIAL INDICATOR?    12-6-72
SPIND4   DC    XL1'00'                                          12-6-72
WAG      STM   2,9,REGSAVEF        SAVE THE REGISTARS.
         L     2,=F'11'            TEST ONLY.
         BAL   4,OPCOUNT           TEST ONLY.
         CLI   FILETYP,X'F1'  IS THIS A TYPE 1 FILE
         BE    WAGOK          YES GO TO OK
         MVI   INDICATO,I19        NO. SET INDICATOR TO -19.
         B     WAG5B              GO TO 5B
WAGOK    MVC   SPIND1(4),=XL4'00000000' SET INS. TO ZERO        12-6-72
         BAL   4,TSTWAGKY          GO TEST LIST AND WKAREA KEY.
         BAL   4,GIR               GO TO GET INDICIES ROUTINE
         SPACE 1
******** RETURN INDICATOR SHOULD BE A THREE FOR ARGUMENT NOT FOUND. ***
         SPACE 1
         CLI   INDICATO,I03        COMPARE INDICATOR TO 3
         BE    WAGOK2              BRANCH EQUAL TO OK2
         BH    WAG5B               LEAVE IF LESS THAN ZERO.
WAGDUP   MVI   INDICATO,I20        SAME KEY. SET INDICATOR = 20.
         B     WAG5B               GO TO 5B
         SPACE 1
******** CHECK DELETE CODE ***
         SPACE 1
WAGOK2   L     2,FOUNDADD          LOAD POINTER TO INDEX(X)
***                                X=REL POS FOUND BY GET INDICIES
***      N=REL POS OF LAST INDEX USED IN INDEX BLOCK
         XR    3,3                 CLEAR REG 3
         IC    3,ARGL              LENGTH OF ARGUMENT TO REG 3
         AR    2,3                 POINT TO DELETE CODE
         CLI   0(2),X'FF'          DELETE CODE OF INDEX ON
         BE    WAG7A               YES GO TO 7A
         SPACE 1
******** IS REC NO OF LAST DATA REC USED(FP TABLE)=NO OF DATA RECS/BLOC
********  (FD TABLE) ***
         SPACE 1
WAGLDRUP CLC   LDRU+3(1),NODRPB    LAST DATA REC. USED?         12-6-72
         BE    WAG1                YES  GO TO CHECK END OF EXTENT
         XR    4,4                 CLEAR REG 4
         IC    4,LDRU+3            N OF LAST DATA RECORD USED
         A     4,=F'1'             N=N+1
         STC   4,LDRU+3            STORE N IN FP TABLE
         B     WAG2A               GO TO 2A
         SPACE 1
******** BLOCK NO OF LAST DR USED = HIGH BLOCK NO OF DATA FILE
********  EXTENT(FPT) ***
         SPACE 1
WAG1     CLC   LDRU(3),HGHBLK      END OF EXTENT
         BNE   WAG2                NO GO TO ADD 1 TO BLOCK
         MVI   INDICATO,I28        SET INDICATOR = -3
         B     WAG5B               GO TO 5B
         SPACE 1
******** ADD 1 TO BLOCK NO OF LAST DR USED  SET RECORD NO OF SAME = 1
         SPACE 1
WAG2     XR    4,4                 CLEAR REG 4
         IC    4,LDRU+2            INSERT BLOCK NO
         C     4,BLKNOF                                             BXL
         BE    WAG3                YES GO TO INCREMENT TT
         A     4,=F'1'             NO ADD 1 TO R
         STC   4,LDRU+2            STORE INCREMENTED R
         B     WAG4                GO TO SET N=1
WAG3     XR    4,4                 CLEAR 4
         IC    4,LDRU              TT OF
         SLA   4,8(0)                   LAST
         IC    4,LDRU+1                    DATA BLOCK
         A     4,=F'1'             INCREMENT BY 1
         STC   4,LDRU+1            STORE TT OF
         SRA   4,8(0)                         LAST
         STC   4,LDRU                            DATA BLOCK
         MVI   LDRU+2,X'01'        SET R=1
WAG4     MVI   LDRU+3,X'01'        SET N=1
         B     WAG2A               GO TO 2A
         SPACE 1
***********************************************************************
* IF ADD INDICATOR = 0 THEN REL POS = POS WHERE NEW INDEX IS TO BE    *
* INSERTED                                                            *
* IF ADD INDICATOR = 1 NEW INDEX SHOULD BE BUILT AT REL POS + 1 INDEX *
***********************************************************************
         SPACE 1
ADDINDIC DC    X'00'               ADD INDICATOR SET BY GET INDICIES
WAG2A    CLI   ADDINDIC,X'01'      ADD INDICATOR = 1
         BE    WAG5                YES GO TO INCREMENT X
         CLI   ADDINDIC,X'02'      SHOULD OVERFLOW BE SET UP?
         BE    WAG6A               YES.
         SPACE 1
***********************************************************************
**  SHIFT INDICIES       INDEX(N) TO INDEX(N+1)                       *
**                         ...         ...                            *
**                       INDEX(X) TO INDEX(X+1)                       *
**   BLOCK     1963      BLOCK                                        *
**   SHIFTARG    40      IF BLOCK IS FULL THIS CONTAINS SHIFTED ARGUME*
**   SAVEARG     40      FRONT ARG                                    *
**       IS INDEX BLOCK FULL IF SO SHIFT INDEX(N) TO SHIFTARG         *
***********************************************************************
         SPACE 1
         XR    2,2                 CLEAR REGISTER 2
         IC    2,BLOCK+3           NO OF INDEXES USED
         XR    3,3                 CLEAR REGISTER 3
         IC    3,INDPB             NO OF INDEXES MAXIMUM PER BLOCK
         CR    2,3                 ROOM FOR ADDITIONAL INDEX
         BL    REGSHIFT            YES GO TO REGULAR SHIFT
         SPACE 1
******** NOT A REGULAR SHIFT SET UP FOR A REGULAR SHIFT ***
******** CALCULATE INDEX LENGTH ***
         SPACE 1
         XR    4,4                 CLEAR REGISTER 4
         IC    4,ARGL              ARGUMENT LENGTH
         LA    4,5(4)              INDEX LENGTH
         SPACE 1
******** FOUNDADD CONTAINS LOCATION OF FOUND INDEX ***
******** CALCULATE END INDEX ***
         SPACE 1
         LR    7,2                 NO INDICIES USED
         XR    6,6                 CLEAR 6
         MR    6,4                 NO INDICIES X INDEX LENGTH
         LR    6,4                 INDEX LENGTH
         S     6,=F'1'             INDEX MOVE LENGTH
         LA    9,BLOCK+12          POINTER TO FIRST INDEX
         AR    9,7                 POINTER TO LAST ARGUMENT
         EX    6,WAGMOVE1          MOVE LAST INDEX TO SHIFTARG
         B     WAG6                BRANCH AROUND MOVE
WAGMOVE1 MVC   SHIFTARG(0),0(9)    MOVE FULL INDEX TO SHIFTARG
WAG6     S     2,=F'1'             DECREMENT NO OF INDICIES USED
         SPACE 1
******** REGULAR SHIFT ***
         SPACE 1
REGSHIFT XR    4,4                 CLEAR REGISTER 4
         IC    4,ARGL              ARGUMENT LENGTH
         LA    4,5(4)              INDEX LENGTH
         SPACE 1
******** CALCULATE NUMBER OF RECORD TO BE INSERTED  ***
         SPACE 1
         L     7,FOUNDADD          ADDRESS OF INDEX FOUND.
         LA    6,BLOCK+12          ADDRESS OF 1ST INDEX IN BLOCK.
         SR    7,6                 CALCULATE LENGTH OF INDICIES
         XR    6,6                 CLEAR EVEN DIVIDE REGISTER
         DR    6,4                 CALCULATE FOUND INDEX NUMBER
         SPACE 1
***********************************************************************
*  REGISTER 7 CONTAINS THE NO OF THE INDEX TO BE INSERTED             *
*  DIVIDE  REMAINDER EVEN QUOTIENT ODD                                *
*        GO TO                                                        *
*        SHIFT                                                        *
*        ROUTINE                                                      *
***********************************************************************
         SPACE 1
         ST    7,SHFTLOC           INDEX TO BE SHIFTED
         ST    4,SHFTLNG           LENGTH OF INDEX
         ST    3,SHFTNOUS          LAST INDEX LOCATION
         BAL   4,SHIFT             GO TO SHIFT INDICIES ROUTINE
         B     SET                 GO TO SET
         SPACE 1
******** SET X=X+1 SET ADD IND=0  SET SP IND2=2 *****
         SPACE 1
WAG5     L     6,FOUNDADD          POINT TO X
         XR    4,4                 CLEAR REGISTER 4
         IC    4,ARGL              ARGUMENT LENGTH
         LA    4,5(4)              INDEX LENGTH
         AR    6,4                 X=X+1
         ST    6,FOUNDADD          STORE X+1
         MVI   ADDINDIC,X'00'      SET ADD IND = 0   00
         MVI   SPIND2,X'02'        SET SP IND2 = 2    02
         SPACE 1
******** INSERT  NEW  INDEX  ARG(X)=KEY ****
         SPACE 1
SET      L     6,FOUNDADD          LOAD ADDRESS OF X
         XR    4,4                 CLEAR REGISTER 4
         IC    4,ARGL              ARGUMENT LENGTH
         S     4,=F'1'             ARGUMENT MOVE LENGTH
         EX    4,ARGMOVEX          MOVE USER ARGUMENT
         B     WAG7                BRANCH AROUND MOVE
ARGMOVEX MVC   0(0,6),UKEY         EXECUTED MOVE      ARG(X)=KEY
WAG7     AR    6,4                 ADD MOVE LENGTH
         A     6,=F'1'             POINT TO DELETE CODE
         MVI   0(6),X'00'          SET DELETE CODE OFF  DELETE CODE(X)0
         LA    6,1(6)              POINT TO TTRN OF DATA RECORD
         MVC   0(4,6),LDRU         DATA BLOCKNO AND REC NO (X)= LAST
*                                  BLOCK NO AND REC NO USED
         SPACE 1
******** NO OF INDICIES USED = NO OF INDICIES / BLOCK (FP TABLE) ***
         SPACE 1
WAG2B    CLC   INDPB(1),BLOCK+3
         BE    WAG6A               GO CHECK CHAIN INDICATOR.
WAG3A    XR    4,4               CLEAR REGISTER 4
         IC    4,BLOCK+3         NO OF INDICIES USED
         A     4,=F'1'           INCREMENT NO OF INDICIES USED
         STC   4,BLOCK+3         STORE NO OF INDICIES USED
         SPACE 1
******** SETUP TO WRITE INDEX BLOCK  ***
         SPACE 1
         MVC   WTTR(3),BLOCK       THIS TTR TO WRITE ROUTINE
WAG3B    BAL   4,WRITEINX          WRITE INDEX BLOCK
         LH    4,INDICTOR          LOAD INDICATOR
         CH    4,=H'1'             COMPARE INDICATOR TO 1
         BH    WAG5B               BRANCH LESS THAN 1
         SPACE 1
******** CHECK SP IND1 = 1 ?
******** SET BLOCK NO AND REC NO = DATA BN AND RN SAVED FROM INDEX(X-1)
         SPACE 1
         MVC   RTTR(3),SRLOWAG     TTR FROM INDEX(X-1)
         BAL   4,JDAREAD           READ INDEX BLOCK
         LH    4,INDICTOR          LOAD INDICATOR
         CH    4,=H'1'             INDICATOR < 1
         BH    WAG5B               YES  GO TO 5B
         B     WAG4A               NO   GO TO 4A
         SPACE 1
******** CONSTANTS USED FOR SAVE AND SET OF TTRN  ***
         SPACE 1
SBNTTRN  DC    F'0'                FOR SET BLOCK NO AND REC NO
WAGLDBST DS    CL3                 LOW DATA BLOCK EXTENT.
WAGHDBST DS    CL3                 HIGH DATA BLOCK EXTENT.
SVTTRN   DC    F'0'                FOR SAVE OF BN AND RN OF NSR SHOWN
         SPACE 1
WAG4A    NOP   *        CALCULATE POINTER
*                       TO DATA RECORD 5 BYTE RIGAM FIELDS
         SPACE 1
******** CALCULATE THE POINTER TO THE RECORD NO INVOLVED   ***
******** CALCULATE DISPLACEMENT          FIRST RECORD = REC NO 1 ***
         SPACE 1
         XR    7,7                 CLEAR REL.7
         IC    7,DLGN              * *  LOAD            * *
         SLA   7,8(0)              * *      DATA        * *
         IC    7,DLGN+1            * *          LENGTH  * *
         LR    8,7                 SAVE DATA LENGTH
         XR    4,4                 CLEAR REG.4.
         IC    4,LDRU+3            LOAD POSITION OF NEW RECORD
         LR    5,4                 SAVE NUMBER
         XR    6,6                 CLEAR REG.6.
         S     4,=F'1'             * * * RECORD ADD.ALGORITHM * * * * *
         MR    6,4                 *                                  *
         XR    6,6                 * ((((REC.LEN. X  ((LDRU+3)-1))  + *
         LA    6,5(6)              *                                  *
         XR    4,4                 *     (5  X  (LDRU+3)))  +         *
         MR    4,6                 *                                  *
         SR    5,6                 *       A(BLOCK+3)))  -  5  =      *
         AR    7,5                 *                                  *
         LA    6,BLOCK+3           *   POINTER TO NEW RECORD ADDRESS. *
         AR    6,7                 * * * * * * * * * ?? * * * * * * * *
         SPACE 1
******** NOW TEST  INDICATOR     REG 6 CONTAINS POINTER TO RECORD  ***
         SPACE 1
         CLI   SPIND2,X'03'
         BE    WAG4A1
          CLI  SPIND2,X'02'        SP IND 2 = 2
         BE    WAG12               EQUAL SAVE
         CLC   BLOCK(3),LDRU       DATA INSERTS IN RESIDENT BLOCK?
         BNE   WAGNEW              NO.
         MVI   0(6),X'00'          TURN OFF DELETE BYTES.
         LA    6,1(6)              POINT TO TTRN.
         MVC   0(4,6),SRHIWAG      MOVE IN NEW TTRN.
         L     7,UAREA             GET ADDRESS OF NEW RECORD.
         S     8,=F'1'             ADJUST LENGTH ATTRIBUTE.
         MVC   BDN(1),LDRU+3       POINT TO NEW RECORD INSERT POINT
         MVI   BDIND,X'02'         SET TO MOVE FROM USER AREA.
         BAL   4,BDR               GO MOVE.
WAG4A1   CLC   BLOCK(3),SRLOWAG    IS PREVIOUS REC.IN SAME BLOCK?
         BNE   PREPOINT                 NO.
         MVC   POINN,SRLOWAG+3     YES.
         BAL   4,POINT             GO POINT TO PREVIOUS RECORD.
         L     4,POINADDR          GET POINTER.
         CLI   SPIND2,X'03'
         BE    SAMETTRN
         MVC   1(4,4),LDRU         MOVE IN NEW N ADDRESS.
         B     WAGOUT              GO WRITE IT.
SAMETTRN MVC   1(4,4),SBNTTRN
         B     WAGOUT
PREPOINT MVC   WTTR(3),BLOCK            WRITE
         BAL   4,WRITEBLK               NEW
         LH    4,INDICTOR               RECORD.
         CH    4,=H'1'                  TEST
         BH    WAG5B                    LEAVE IF INDICATOR >1.
         MVC   RTTR(3),SRLOWAG          GET BLOCK WITH
         BAL   4,READBLK                PREVIOUS
         LH    4,INDICTOR               RECORD
         CH    4,=H'1'                  TEST
         BH    WAG5B                    LEAVE IF <1.
         MVC   POINN,SRLOWAG+3          MOVE IN PREV.REC.POSITION.
         BAL   4,POINT             RESOLVE ADDRESS,
         L     4,POINADDR          THEN
         CLI   SPIND2,X'03'
         BE    SAMETTRN
         MVC   1(4,4),LDRU         POINTER TO NEW RECORD.
WAGOUT   MVC   WTTR(3),BLOCK       WRITE DATA
         BAL   4,WRITEBLK          BLOCK
         B     WAG5B               THEN LEAVE.
WAG12    MVC   SVTTRN,1(6)         SAVE BN&RN OF NSR SHOWN FOR REC.NO.
WAG13    MVC   WTTR(3),BLOCK       TTR OF BLOCK TO WRITE
         BAL   4,WRITEBLK          WRITE DATA ROUTINE
         LH    8,INDICTOR          LOAD INDICATOR
         CH    8,=H'1'             INDICATOR < 1
         BH    WAG5B               YES GO TO 5B
WAG4C    MVC   SBNTTRN,LDRU     SET BNO&RECNO=LAST BN&RN USED(FP TABLE)
WAG4B    MVC   RTTR(3),SBNTTRN     SET UP FOR READ
         BAL   4,JDAREAD           READ A BLOCK
         LH    8,INDICTOR          LOAD INDICATOR
         CH    8,=H'1'             IND < 1
         BH    WAG5B               YES GO TO 5B
         SPACE 1
WAG5A    MVI   BDIND,X'02'         INDICATOR SET TO BLOCK
         MVC   BDN,SBNTTRN+3       RECORD NO
         BAL   4,BDR               GO TO BLOCK/DEBLOCK ROUTINE
         SPACE 1
******** POINT TO RIGAM FIELDS OF RECORD JUST INSERTED ***
         SPACE 1
         MVC   POINN,SBNTTRN+3     MOVE RECORD NUMBER
         BAL   4,POINT             GO TO LOCATE RIGAM FIELDS
         SPACE 1
******** CHECK SPECIAL INDICATORS   ***
         SPACE 1
         L     6,POINADDR          POINT TO RIGAM FIELDS OF RECORD.
         CLI   SPIND2,X'01'        SP IND 2 = 1 ?
         BE    WAG14               YES
         CLI   SPIND2,X'02'        SP IND 2 = 2 ?
         BE    WAG15               YES
         SPACE 1
******** SET BLOCK NO AND REC NO OF NSR FOR REC = DATA BLOCK AND RN ***
******** OF LAST INDEX FOUND                                        ***
         SPACE 1
         MVC   1(4,6),SRHIWAG      FROM FP TABLE
         B     WAG14
         SPACE 1
******** SET BN AND RN OF NSR FOR REC = SAVED BN AND RN FOR NSR ***
         SPACE 1
WAG15    MVC   1(4,6),SVTTRN       FROM SAVED TTRN
WAG14    MVI   0(6),X'00'          SET DELETE CODE = OFF
         CLI   SPIND2,X'03'        SP IND 2 = 3 ?
         BE    WAG4A
         SPACE 1
******** WRITE DATA  ROUTINE ***
         SPACE 1
         MVC   WTTR(3),BLOCK       MOVE TTR TO WRITE ROUTINE
         BAL   4,WRITEBLK          WRITE BLOCK
WAG5B    BAL   4,PARMRYT           GO WRITE PARAMETERS IF GOOD WAG.
         CLI   INDICATO,I01        GOOD WAG ?
         BH    WAGLRTN             NO. EXIT.
         CLI   SPIND2,X'03'        IMBEDDED ADDITION ?
         BNE   MLDRU               NO.
         MVC   TTRHLD,SBNTTRN      YES. MOVE OLD TTRN.
         B     AFDBK               GO CALCULATE.
MLDRU    MVC   TTRHLD,LDRU         MOVE NEW TTRN.
AFDBK    BAL   4,FDBKCALC          GO CALCULATE USER RECORD.
WAGLRTN  LM    2,9,REGSAVEF        RESET REGISTERS
         SPACE 1
******** EXIT ***
         SPACE 1
         B     RETOCALL            EXIT
REGSAVEF DS    10F                 REGISTAR STORAGE SAVE AREA.
         SPACE 1
******** INDEX BLOCK IN CORE ***
         SPACE 1
WAG6A    CLI   BLOCK+10,X'FF'      CHAIN IND = 1   1=FF=ON
         BE    WAG16A                   YES.
         SPACE 1
******** ADD 1 TO LAST INDEX BLOCK USED(FP TABLE)  ***
         SPACE 1
         B     WAG17               GO AROUND CONSTANT.
INCTTRIX DC    F'0'                WORKAREA FOR INCREMENTING TTRZ
WAG17    MVC   INCTTRIX,ILBU       MOVE LAST INDEX BLOCK USED
         XR    4,4                 CLEAR REGISTER 4
         IC    4,INCTTRIX+2        INSERT R OF LAST INDEX BLOCK USED
         C     4,BLKNOF                                             BXL
         BE    WAG18               YES GO TO INCREMENT
         A     4,=F'1'             ADD 1 TO R
         STC   4,INCTTRIX+2        STORE R
         B     WAG19               RESUME
WAG18    LH    4,INCTTRIX          LOAD TT
         AH    4,=H'1'             ADD 1 TO TT
         STH   4,INCTTRIX          STORE TT
         MVI   INCTTRIX+2,X'01'    RESET R
WAG19    MVC   ILBU(3),INCTTRIX    MOVE INCREMENTED TTR
******** COMPARE FOR EXTENT VIOLATION ***
         SPACE 1
         CLC   ILBU,IHBN           LAST USED > HIGH
         BH    WAG20               YES  GO TO SET CODE
          B    WAG21
WAG20    MVI   INDICATO,I17        SET INDICATOR TO 17.
         B     WAG5B               GO TO 5B
WAG21    MVI   BLOCK+10,X'FF'      SET CHAIN IND=1
         MVC   NSIB(3),BLOCK+7     SAVE NEXT SEQUENTIAL IND.BLK.POINTER
         MVC   BLOCK+7(3),ILBU     SET CHAIN BLOCK NO = L INDX BLK USED
         SPACE 1
******** WRITE DATA  ROUTINE ***
         SPACE 1
         MVC   WTTR(3),BLOCK       SET BLOCK TO WRITE INDEX
         BAL   4,WRITEINX          GO TO WRITE INDEX
         LH    4,INDICTOR          LOAD INDICATOR
         CH    4,=H'1'             IND < 1
         BH    WAG5B               YES GO TO 5B
         SPACE 1
******** SET UP A NEW INDEX BLOCK ***
         SPACE 1
         MVC   BLOCK+4(3),BLOCK    PREV BN = BLOCK NO
         MVC   BLOCK(3),ILBU       BLOCK NO = LAST INDEX BLOCK USED
         MVI   BLOCK+3,X'01'       NO OF INDICIES = 1
         MVI   BLOCK+10,X'00'      CHAIN IND = 0
         MVC   BLOCK+7(3),NSIB     POINT TO NEXT SEQUENTIAL IND.BLK.
         SPACE 1
******** INDEX AT END OF I/O SHIFTARG = INDEX(1) ***
         SPACE 1
         XR    4,4                 CLEAR REGISTER 4
         IC    4,ARGL              INSERT ARGUMENT LENGTH
         A     4,(4)               ALIGN FOR TTRN & DELETE.
         EX    4,ARGMOVE           MOVE INDEX
         CLI   SPIND4,X'01'        IS SPECIAL IND4 = 1          12-6-72
         BE    WAG16               YES. BRANCH                  12-6-72
         LA    4,BLOCK+12          POINT
         XR    5,5                  TO
         IC    5,ARGL              DELETE
         AR    4,5                  BYTE.
         MVI   0(4),X'00'          TURN IT OFF.
         B     WAG16               GO WRITE NEW INDEX BLOCK.
NSIB     DC    F'0'                NEXT SEQUENTIAL INDEX BLOCK POINTER.
ARGMOVE  MVC   BLOCK+12(0),SHIFTARG     MOVE NEW INDEX IN.
WAG16B   MVC   WTTR(3),BLOCK       TTR TO WROTE.
         BAL   4,WRITEINX          GO TO WRITE INDEX
         LH    4,INDICTOR          LOAD INDICATOR
         CH    4,=H'1'             INDICATOR . 1
         BH    WAG5B               YES GO TO 5B
         SPACE 1
******** SET BLOCK NO = BN OF NEXT CHAINED INDEX BLOCK ***
         SPACE 1
         MVC   RTTR(3),BLOCK+7     CHAINED BLOCK
         BAL   4,JDAREAD           GO READ NEXT INDEX BLOCK.
         MVC   BLOCK+4(3),ILBU     POINT NSIB TO NEW INDEX BLOCK.
         MVC   WTTR(3),BLOCK       MOVE TTR TO WRITE MACRO.   1ST.
         BAL   4,WRITEINX          GO WRITE PREVIOUS WITH NSIB POINTER.
         LH    4,INDICTOR          TEST FOR WRITE OK.
         CH    4,=H'1'             IS INDICATOR A 1 ?
         BH    WAG5B               NO. LEAVE WAG ROUTINE.
         MVI   SPIND2,X'03'        SET SP IND 2 = 3 .
         B     WAG4C               GO WRITE DATA.
         SPACE 1
******** MOVE INDEX AT NO OF INDICIES/BLOCK +1 TO INDEX(0)
********  SAVEARG=INDEX(0) ***
         SPACE 1
WAG16A   MVC   WTTR(3),BLOCK      *  WRITE THIS BLOCK  *
         BAL   4,WRITEINX          *                   *
         LH    4,INDICTOR          *  AND TEST FOR A   *
         CH    4,=H'1'             *                   *
         BH    WAG5B               *  GOOD INDICATOR.  *
         MVC   RTTR(3),BLOCK+7     READ THE
         BAL   4,JDAREAD             CHAINED BLOCK.
         XR    4,4                 CLEAR 4
         IC    4,ARGL              INSERT ARGUMENT LENGTH
         A     4,=F'4'             CALCULATE MOVE LENGTH
         EX    4,SWITCH            EXECUTE MOVE
         B     WAG22               BRANCH AROUND MOVE
SWITCH   MVC   SAVEARG(0),SHIFTARG  MOVE INST. TO BE EXECUTED
WAG22    NOP   *
         SPACE 1
***********************************************************************
*  SAVEARG CONTAINS THE INDEX TO BE INSERTED. IF THE NO OF INDICIES   *
*  PER BLOCK = MAX NO  SHIFTARG WILL CONTAIN THE INDEX SHIFTED        *
*  OFF THE BLOCK                                                      *
*  CASE 1  BLOCK FULL   INDEX>LAST INDEX OR INDEX.LAST  INDEX         *
*  COMPUTE INDEX LENGTH      CASE Z  INDEX/BLOCK . MAX                *
***********************************************************************
         SPACE 1
         XR    2,2                 CLEAR REGISTER 2
         IC    2,ARGL              ARGUMENT LENGTH REGISTER 2
         LR    3,2
         S     3,=F'1'             ARGUMENT MOVE LENGTH REG 3
         LR    4,2
         LA    4,5(4)              INDEX LENGTH REG 4
         LR    5,4
         S     5,=F'1'             INDEX MOVE LENGTH REG.5
         XR    6,6                 CLEAR REGISTER 6
         IC    6,BLOCK+3           NO INDICIES PER BLOCK
         XR    7,7                 CLEAR REGISTER 7
         IC    7,INDPB             MAX NO INDICIES PER BLOCK
         LA    8,BLOCK+12          POINT TO FIRST INDEX
         XR    9,9                 COUNTER REGISTER
         SPACE 1
******** LOOP THRU TO FIND INDEX TO BE SHIFTED ***
         SPACE 1
WAGLOOP  A     9,=F'1'             FIRST INDEX
         EX    3,WAGCOMP           COMPARE  INDEX(0) TO INDEX ON BLOCK
         BL    WAG23               FOUND
         BE    WAGDUP              KEY IS EQUAL
         CR    9,6                 COUNT TO NO INDX PER BLOCK
         BE    WAG24               LAST INDEX NOT LOW
         AR    8,4                 INCREMENT TO NEXT INDEX.
         B     WAGLOOP             GO TO LOOK FOR NEXT INDEX
WAGCOMP  CLC   SAVEARG(0),0(8)     EXECUTED COMPARE
         SPACE 1
******** INDEX(0)>ANY INDEX ON BLOCK ***
         SPACE 1
WAG24    MVC   SHIFTARG,SAVEARG    INDEX(0) GOES TO INDEX(N+1)
         B     WAG2B               GO TO 2B
         SPACE 1
******** INDEX(0).COUNTER INDEX  ***
******** IS COUNTER POINTING TO LAST INDEX ON BLOCK ***
         SPACE 1
WAG23    CR    9,6                 COUNT TO NO INDX PER BLOCK
         BE    WAG25               YES
         CR    6,7                 BLOCK FULL
         BE    WAG28A              YES
         SPACE 1
******** BLOCK IS NOT FULL SHIFT AND INSERT ***
         SPACE 1
WAG26    ST    9,SHFTLOC           POINTER TO INDEX FOR SHIFT ROUTINE
         ST    6,SHFTNOUS          LAST INDEX ON BLOCK
         ST    4,SHFTLNG           INDEX LENGTH
         BAL   4,SHIFT             SHIFT INDICIES
         SPACE 1
******** MOVE  IN INDEX(0)  TO PROPER PLACE ***
         SPACE 1
         EX    5,IX0MOVE           MOVE TO INSERT INDEX
         B     WAG27               BRANCH AROUND CONSTANT
IX0MOVE  MVC   0(0,8),SAVEARG      INSERT INDEX
WAG27    B     WAG2B               GO TO 2B
         SPACE 1
******** LAST  INDEX ON  BLOCK ***
         SPACE 1
WAG25    CR    6,7                 BLOCK FULL
         BE    WAG28A              YES
         LR    2,8                 POINT
         AR    2,5                   TO
         LA    2,1(2)                 INDEX(X+1)
         EX    5,MINSHIFT          SHIFT
         B     WAG28               BRANCH AROUND MOVE
MINSHIFT MVC   0(0,2),0(8)         LAST  INDEX  MOVE
WAG28    EX    5,IX0MOVE           INSERT INDEX
         B     WAG2B               GO TO 2B
         SPACE 1
******* BLOCK FULL  SHIFT LAST INDEX OFF   ***
         SPACE 1
WAG28A   STC   7,POINX             SET UP INDEX POINT
         BAL   4,POINTX            POINT TO LAST INDEX
         L     4,POINTADX          POINT TO LAST INDEX
         EX    5,OVFINDX           SHIFT INDEX TO SHIFTARG
         B     WAG29               BRANCH AROUND MOVE
OVFINDX  MVC   SHIFTARG(0),0(4)    MOVE LAST INDEX TO SHIFT ARG
WAG29    ST    9,SHFTLOC           STORE SHIFT LOCATION
         S     6,=F'1'             DECREMENT NO IND/BLOCK BY1
         ST    6,SHFTNOUS          STORE NO.OF IND ON BLOCK
         A     5,=F'1'             CALCULATE INDEX LENGTH
         ST    5,SHFTLNG           STORE INDEX LENGTH
         S     5,=F'1'             CALCULATE MOVE LENGTH
         BAL   4,SHIFT             SHIFT
         EX    5,IX0MOVE           MOVE IN INDEX
         B     WAG2B               GO TO 2B
         SPACE 1
WAG7A    L     5,FOUNDADD          INDEX(X)                     12-6-72
         XR    2,2                 CLEAR 2                      12-6-72
         IC    2,ARGL              INSERT ARGUMENT LENGTH       12-6-72
         BCTR  2,0                                              12-6-72
         EX    2,ARGCOMP                                        12-6-72
         BNE   SET4SP                                           12-6-72
         MVI   SPIND2,X'03'        SET SPECIAL IND2 = 3         12-6-72
         EX    2,ARGXMOV           SET ARG(X) = KEY             12-6-72
         B     WAG30               BRANCH AROUND NOVE           12-6-72
ARGCOMP  CLC   0(0,5),UKEY                                      12-6-72
SET4SP   MVI   SPIND4,X'01'        SET SPECIAL IND4 = 1         12-6-72
         B     WAGLDRUP                                         12-6-72
ARGXMOV  MVC   0(0,5),UKEY         MOVE FOR ARG(X)=KEY
WAG30    AR    5,2                 POINT TO END OF ARG(X)
         MVI   1(5),X'00'          SET DELETE CODE=0
         MVC   LBR,2(5)            SAVE LAST BLOCK FOUND IN PARAM.TABLE
         MVC   WTTR(3),BLOCK       SET TTR FOR WRITE
         BAL   4,WRITEINX          WRITE INDEX
         LH    3,INDICTOR          LOAD INDICATOR
         CH    3,=H'1'             IND . 1
         BH    WAG5B               YES GO TO 5B
         SPACE 1
******** SET BLOCK NO AND REC NO = DATA BN AND RN FOR LAST INDEX
********  FOUND (FP TABLE) ***
         SPACE 1
         MVC   SBNTTRN,LBR
         B     WAG4B
SRLOWAG  DC    F'0'                LOW WAG INDEX.
SRHIWAG  DC    F'0'                HIGH WAG INDEX.
WAGMVCEX MVC   4(0,6),0(7)         MOVE DATA INTO BLOCK.
WAGNEW   CLC   SRHIWAG,SRLOWAG     IS IT LOWER THAN LOWEST KEY.
         BE    READNEW             YES. DO NOT CHANGE NSR POINTER.
         MVC   POINN,SRLOWAG+3     MOVE REC.NO.OF PREV.REC.TO DETERMINE
         BAL   4,POINT              ADDRESS OF POINTER.
         L     4,POINADDR          LOAD ADDRESS OF PREVIOUS RECORD.
         MVC   1(4,4),LDRU         MOVE IN NSR ADDRESS.
         MVC   WTTR(3),BLOCK       GIVE DATA BLOCK ADDRESS TO AND GO
         BAL   4,WRITEBLK           EXECUTE WRITE.
         LH    4,INDICTOR          TEST FOR
         CH    4,=H'1'               GOOD WRITE.
         BH    WAG5B                NO.LEAVE.
READNEW  MVC   RTTR(3),LDRU        GOOD. GET NEW DATA ADDRESS FOR NEW
         BAL   4,READBLK            DATA BLOCK AND GO EXECUTE READ.
         LH    4,INDICTOR          TEST FOR
         CH    4,=H'1'               GOOD READ.
         BH    WAG5B               NO,LEAVE.
         MVI   0(6),X'00'          GOOD.TURN OF DELETE BYTES.
         LA    6,1(6)              INCREMENT TO TTRN OF NSR.
         MVC   0(4,6),SRHIWAG      MOVE IN TTRN OF NSR.
         MVC   BDN,LDRU+3          POSITION OF NEW RECORD.
         MVI   BDIND,X'02'         SET TO MOVE FROM USER AREA.
         BAL   4,BDR               GO TO BLOCK/DEBLOCK ROUTINE.
         B     WAGOUT              GO WRITE AND EXIT.
WAG16    CLC   BLOCK(3),BLOCK+7    IS NEXT BLOCK THIS BLOCK ?
         BNE   WAG16B              NO. GO TO WAG16B.
         XR    4,4                 OTHERWISE
         IC    4,BLOCK+9                CHECK
         C     4,BLKNOF            R FOR MAX.                       BXL
         BE    INCTTOF7                 IT IS.GO INCREMENT TT.
         A     4,=F'1'             INCREMENT R.
         STC   4,BLOCK+9                AND STORE IT.
         B     WAG16B              RETURN TO 16B
INCTTOF7 XR    4,4                 GET
         IC    4,BLOCK+7           TT
         SLA   4,8(0)              AND
         IC    4,BLOCK+8           INCREMENT
         A     4,=F'1'             BY
         STC   4,BLOCK+8           1.
         SRA   4,8(0)              STORE
         STC   4,BLOCK+7           IT.
         MVI   BLOCK+9,X'01'       SET R = 1.
         B     WAG16B              GO TO 16B
TSTWAGKY XR    5,5                 CLEAR R5
         XR    6,6                   AND R6.
         L     5,UAREA             POINT TO USER WKAREA.
         IC    6,ARGL              GET KEY LENGTH AND
         AH    6,=H'2'               ID. ADJUST FOR LENGTH.
         EX    6,WUGCOMP           EXECUTE SAME COMPARE AS IN WUG.
         BNE   IND44               BAD. GO AROUND RETURN.
         BR    4                   GOOD.RETURN TO CONTINUE WAG.
IND44    MVI   INDICATO,I44        SET INDICATOR TO 44.
         B     WAG5B               RETURN TO USER.
         TITLE 'RIGAM - ''WDG'' - WRITE DELETE GENERIC'
***********************************************************************
*        WRITE DELETE GENERIC ROUTINE                                 *
***********************************************************************
         SPACE 1
WDG      STM   R2,R9,RIGAMSA       SAVE REGISTERS
         L     2,=F'10'            TEST ONLY.
         BAL   4,OPCOUNT           TEST ONLY.
         CLI   FILETYP,X'F1'       IS PARM FILE TYPE = TO 1 ?
         BNE   WDG1                NO BRANCH
         BAL   4,GIR               YES  GET INDICIES ROUTINE
         B     WDG2                BRANCH AROUND
WDG1     MVI   INDICATO,I21        SET INDICATOR TO -21.
         B     WDG1A               GO TO 1A
WDG2     LH    4,INDICTOR          LOAD INDICATOR
         CH    4,=H'1'             IND=1
         BH    WDG1A               NO. GO TO 1A
         SPACE 1
******** FOUNDADD POINTS TO INDEX ***
         SPACE 1
         XR    2,2                 CLEAR REGISTER 2
         IC    2,ARGL              INSERT ARGUMENT LENGTH
         L     3,FOUNDADD          INDEX(X)
         AR    3,2                 POINT TO DELETE CODE
         MVI   0(3),X'FF'          SET DELETE CODE FOR INDEX(X)=1
         A     3,=F'1'                  ADD 1 TO RESOLVE DATA BLOCK.
         MVC   RTTR(3),0(3)        STORE TTR TO READ DATA BLOCK.
         A     3,=F'3'             ADJUST FOR RECORD NUMBER.
         MVC   POINN,0(3)          PLACE REC.NO.IN POINT POSITION.
         MVC   WTTR(3),BLOCK       INITIALIZE WRITE TTR
         BAL   4,WRITEINX          WRITE INDEX BLOCK
         LH    2,INDICTOR          LOAD INDICATOR
         CH    2,=H'1'             IND  <  1
         BH    WDG1A               YES  GO TO 1A
         SPACE 1
******** SET  BLOCK NO & RNO = DBN & RN FOR LAST INDEX FOUND (FP TABLE)
         SPACE 1
         BAL   4,READBLK           READ BLOCK
         LH    2,INDICTOR          LOAD INDICATOR
         CH    2,=H'1'             IND < 1
         BH    WDG1A               YES GO TO 1A
         SPACE 1
*  USE POINT DATA ROUTINE TO GET ADDRESS OF DATA REC                  *
         SPACE 1
         BAL   4,POINT             GET DATA LOCATION.
         L     5,POINADDR          ADDRESS OF DATA RECORD
         MVI   0(5),X'FF'          SET DELETE CODE ON
         MVC   WTTR(3),BLOCK       READY DATA WRITE TTR.
         BAL   4,WRITEBLK          WRITE DATA
WDG1A    LM    R2,R9,RIGAMSA       RESTORE REGISTERS
         B     RETOCALL            RETURN TO CALLER
         TITLE 'SHIFT ROUTINE USED WITH WAG  RIGAM'
***********************************************************************
*        THIS  ROUTINE SHIFTS INDICIES TO MAKE ROOM FOR AN INSERT     *
***********************************************************************
         SPACE 1
SHFTNOUS DC    F'0'                LAST INDEX ON BLOCK NUMBER
SHFTLOC  DC    F'0'                INDEX NUMBER TO BE SHIFTED
SHFTLNG  DC    F'0'                LENGTH OF INDEX
SHIFT    STM   2,9,REGSAVEG        SAVE REG.S.
         L     2,SHFTLNG           LENGTH OF INDEX REG 2
         LR    3,2                 LENGTH OF INDEX FOR MOVE REG 3
         S     3,=F'1'             LENGTH FOR MOVE
         SPACE 1
******** CALCULATE MOVE TO AND FROM ADDRESS AND NUMBER OF MOVES  ***
         SPACE 1
         LA    8,BLOCK+12          START ADDRESS OF
         LR    6,8                   INDEX AREA.
         A     8,=F'1681'          LENGTH OF INDEX AREA.
         L     5,SHFTLOC           ENTRIES TO DATE.
         XR    4,4                 **CL%AR FOR CALC. OF
         MR    4,2                 DISPLACEMENT TO LAST INDEX
         AR    6,5                 REG.6 CONTAINS ADDRESS OF LAST INDEX
         SR    8,6                 **DETERMINE DISPALCEMENT LENGTH IN
         SRDA  8,32(0)             RELATION TO KEY FOR NO.OF MOVES
         DR    8,2                 TO BE MADE .
         LR    7,9                 NUMBER OF SHIFTS STORED.
         XR    8,8                 ** ROUND FOR LAST ADDRESS INCREMENT
         MR    8,2                 IN DISPLACEMENTS PER KEY LENGTH
         SR    9,2                 SUBT, LENTGH AND ADD
         AR    9,6                    DISPLACEMENT
         LR    6,9                 SHIFT TO ADDRESS STORED.
         SR    9,2                    DISPLACE ADDRESS.
         MVC   SHIFTARG,0(6)       STORE LAST INDEX INS HIFT SAVE ARG
         LR    8,9                 SHIFT FROM ADDRESS STORED
SHIFTLOP EX    3,SHFMOVE           EXECUTE MOVE LOOP
         SR    8,2                 DECREMENT FROM ADDR BY INDEX LENGTH
         SR    6,2                 DECREMENT TO ADDR BY INDEX LENGTH
         BCT   7,SHIFTLOP          PERFORM SHIFT BY NUMBER REQUIRED
         LM    2,9,REGSAVEG        RESTORE THE RECOS
         BR    4                   RETURN
SHFMOVE  MVC   0(0,6),0(8)         MOVE TO SHIFT
REGSAVEG DS    8F                  REINSTATE STORAGE SAVE AREA
         TITLE 'POINT TO INDEX     RIGAM'
POINX    DC    XL1'00'             INDEX NUMBER
POINTADX DC    F'0'                ADDRESS OF INDEX
POINTX   STM   2,9,REGSAVEX
         XR    2,2                 CLEAR REGISTER 2
         IC    2,ARGL              ARGUMENT LENGTH
         LA    2,5(2)              INDEX LENGTH
         SRDA  2,32(0)             SHIFT FOR MULTIPLY
         XR    4,4                 CLEAR 4
         IC    4,POINX             INDEX NO
         S     4,=F'1'             INDEX NO-1
         MR    2,4                 DISPLACEMENT
         LA    5,BLOCK+12          POINTER TO FIRST INDEX
         AR    5,3                 POINTER TO NUMBERED INDEX
         ST    5,POINTADX          STORE POINTER
         LM    2,9,REGSAVEX        RESTORE REGISTERS
         BR    4                   RETURN
         TITLE 'RIGAM - ''FRF'' - FREE FILE'
***********************************************************************
*        FREE FILE ROUTINE                                            *
***********************************************************************
         SPACE 1
FRF      STM   R2,R9,RIGAMSA       SAVE REGISTERS
         L     2,=F'2'             TEST ONLY.
         BAL   4,OPCOUNT           TEST ONLY.
         B     TSTDQFL             GO TEST DEQ-ABILITY STATUS OF FILE
FRF1     MVI   INDICATO,I08        SET THE INDICATOR TO -8.
         B     FRFEXIT             GO  TO EXIT
FRF2     MVI   RESERVCD,X'00'      TURN OFF RESERVE CODE
FRFTSTL  BAL   4,DOADEQ            GO RELEASE EXCLUSIVE FILE CONTROL
         CLI   FILETYP,X'F1'       IS IT A TYPE 1 FILE ?
         BNE   FRFL2               NO.
         L     2,TABLE1            POINT TO TYPE 1 TABLE.
         LH    3,LTB1              GET ENTRIES IN TABLE.
FRFTBL1  CLC   FILENO,0(2)         COMPARE TABLE 1 TO WORK AREA.
         BE    FRF1OK              IF EQUAL GO TO MOVE,
         LA    2,229(2)            OTHERWISE POINT TO NEXT ENTRY.
         BCT   3,FRFTBL1           TEST FOR MORE ENTRIES.YES,GO LOOK.
         MVI   INDICATO,I09        NO. SET INDICATOR AND
         B     FRFEXIT                  LEAVE.
FRF1OK   MVC   0(229,2),PARMWK1    MOVE WORK TO TABLE THEN
         MVI   INDICATO,I01        SET THE INDICATOR
         B     FRFEXIT             AND LEAVE.
FRFL2    L     2,TABLE2            POINT TO TYPE 2 TABLE.
         LH    3,LTB2              GET ENTRIES IN TABLE.
FRFTBL2  CLC   FILENO,0(2)         COMPARE TABLE 2 TO WORK AREA.
         BE    FRF2OK              IF EQUAL GO TO MOVE,
         LA    2,28(2)             OTHERWISE POINT TO NEXT ENTRY.
         BCT   3,FRFTBL2           TEST FOR MORE ENTRIES.YES,GO LOOK.
         MVI   INDICATO,I09        NO. SET INDICATOR AND
         B     FRFEXIT                  LEAVE.
FRF2OK   MVC   0(28,2),PARMWK2     MOVE WORK TO TABLE THEN
         MVI   INDICATO,I01        SET INDICATOR AND
FRFEXIT  LM    R2,R9,RIGAMSA       RESTORE REGISTERS
         B     RETOCALL            RETURN TO CALLER
         SPACE 1
******** TEST IF FILE HAS PREVIOUSLY BEEN ENQ'D BY THIS TASK. ***
         SPACE 1
TSTDQFL  EQU   *
         MVC   RRNAME(3),UIDEN     SET ENQ FOR FILE TEST.
         BAL   4,ENQTEST           GO TEST STATUS OF FILE.
         CLI   INDICATO,I01        NOT ALLOCATED ?
         BE    FRF1              1)NO.GO TELL PROGRAMMER CAN'T FREE A..
*                                  ...FILE THAT ISN'T RESERVED.
         CLI   INDICATO,I04      2)SAME COMMENTS AS # 1 ABOVE.
         BE    FRF1
         B     FRF2                GO FREE FILE.
         TITLE 'RIGAM - ''CLF'' - CLOSE FILE'
***********************************************************************
*        CLOSE FILE ROUTINE                                           *
***********************************************************************
         SPACE 1
CLF      STM   R2,R9,RIGAMSA       SAVE REGISTERS
         L     2,=F'3'             TEST ONLY.
         BAL   4,OPCOUNT           TEST ONLY.
         CLC   UFILE,FILENO        PARAMETER TABLE CONTAINS FILE
         BNE   CLF1                NOT EQUAL
         CLC   FILETYPE,FILETYP    EQUAL FILETYPE EQUAL
         BNE   CLF2                NOT EQUAL SET CODE = -1
         B     CLF3                BRANCH AROUND
CLF2     MVI   INDICATO,I18        SET INDICATOR TO -18.
         B     CLFEXIT             EXIT
CLF3     CLI   RESERVCD,X'FF'      RESERVE CODE = ON
         BE    CLF9                GO SET CODE
         MVC   FILENO,=X'FFFFFF'   DELETE FILE
         MVI   FILETYP,X'00'       SET GFP FIRST TIME SWITCH.
         SPACE 1
******** GO TO TABLE  FOR FILE TYPE ***
         SPACE 1
CLF1     CLI   FILETYPE,X'F1'      TYPE 1 FILE  ?
         BNE   CLFTYP2             GO TO TYPE 2
         SPACE 1
******** TYPE 1 FILE ***
         SPACE 1
         L     2,TABLE1            ADDRESS OF TABLE 1
         LH    3,LTB1              ENTRIES   TABLE 1
CLF5     CLC   0(3,2),UFILE        COMPARE FOR EQUAL FILENO
         BE    CLF4                EQUAL
         LA    2,229(2)            INCREMENT TO NEXT
         BCT   3,CLF5              GO TO NEXT PARAMETER
         B     CLF2                GO TO SET IND = -1
CLF4     CLI   6(2),X'F1'          FILE TYPE = 1
         BNE   CLF2                NO  IND = -1
CLF8     CLI   7(2),X'00'          RESERVE CODE = OFF
         BNE   CLF9                NO. GO SET INDICATOR.
         MVC   0(3,2),=X'FFFFFF'   DELETE FILE
         MVI   INDICATO,I01        SET  IND = 1
         B     CLFEXIT             GO TO EXIT
         SPACE 1
******** TYPE 2 FILE ***
         SPACE 1
CLFTYP2  L     2,TABLE2            ADDRESS OF TABLE 2
         LH    3,LTB2              NO ENTRIES TABLE 2
CLF6     CLC   0(3,2),UFILE        FILE NO EQUAL
         BE    CLF7                YES
         LA    2,28(2)             NO INCREMENT
         BCT   3,CLF6              COMPARE NEXT ENTRY
         B     CLF2                SET IND = -1
CLF7     CLI   6(2),X'F2'          FILE TYPE = 2
         BNE   CLF2                NO  IND = -1
         B     CLF8                GO TO  8
CLF9     MVI   INDICATO,I10        SET INDICATOR TO -10.
CLFEXIT  BAL   4,CLEAR             DETERMINE CLEAR PARMWK1.
         LM    R2,R9,RIGAMSA       RESTORE REGISTERS
         B     RETOCALL            RETURN TO CALLER
         TITLE 'CLOSE DATA SET  CDS  RIGAM'
***********************************************************************
*        CLOSE DATA SET                                               *
***********************************************************************
         SPACE 1
CDS      STM   2,9,REGSAVEX        SAVE REGISTERS
         SPACE 1
******** CLOSE  FILE IN PARAMETER AREA ***
         SPACE 1
         LA    2,FILENO            STORE PARAMETER WORK AREA ADDRESS...
         ST    2,RESPT               IN CASE OF A BRANCH.
         CLI   RESERVCD,X'FF'      CURRENT FILE RESERVED
         BNE   CDS1                NO
         MVC   FILCNCL,FILENO      YES FILENO TO CANCEL
         BAL   4,RESC              CANCEL RESERVATION
CDS1     MVC   FILENO,=X'FFFFFF'   DELETE FILE
         SPACE 1
******** DELETE TYPE 1 FILE ***
         SPACE 1
         L     2,TABLE1            ADDRESS OF TABLE 1
         LH    3,LTB1              NO ENTRIES TABLE 1
CDS3     CLI   7(2),X'FF'          RESERVE CODE ON
         BE    CDS2                YES
CDS5     MVC   0(3,2),=X'FFFFFF'   NO DELETE  FILE
         LA    2,229(2)            INCREMENT TO NEXT PARAMETER
         BCT   3,CDS3              LOOP
         B     CDS4                GO TO TYPE 2
CDS2     MVC   FILCNCL,0(2)        SET UP CANCEL
         ST    2,RESPT             POINT TO  PARAMETER
         BAL   4,RESC              CANCEL
         B     CDS5                DELETE
         SPACE 1
******** DELETE TYPE 2 FILE ***
         SPACE 1
CDS4     L     2,TABLE2            POINT TO TYPE 2
         LH    3,LTB2              NO TYPE 2 ENTRIES
CDS6     CLI   7(2),X'FF'          RESERVE CODE ON
         BE    CDS7                YES  CANCEL
CDS8     MVC   0(3,2),=X'FFFFFF'   DELETE FILE
         LA    2,28(2)             INCREMENT TO NEXT PARAMETER
         BCT   3,CDS6              LOOP
         B     CDSEXIT             GO TO EXIT
CDS7     MVC   FILCNCL,0(2)        SET CANCEL
         ST    2,RESPT             POINT TO PARAMETER
         BAL   4,RESC              CANCEL
         B     CDS8                GO TO DELETE
CDSEXIT  LH    3,LTB1              LOAD ENTRIES FOR TABLE 1.
         CH    3,=H'1'             ARE THERE ANY?
         BL    TRY2                NO. GO TRY TYPE 2.
         SPACE 1
********  FREEMAIN FOR TABLE 1.  ***
         SPACE 1
         L     0,SAV23             LOAD LENGTH OF TABLE 1 INTO REG.'0'.
         L     1,TABLE1            LOAD ADD. OF TABLE1 INTO REG. '1'.
         FREEMAIN R,LV=(0),A=(1)             ISSUE FREEMAIN.
TRY2     LH    3,LTB2              LOAD ENTRIES FOR TABLE 2.
         CH    3,=H'1'             ARE THERE ANY?
         BL    CDSLEAVE            NO. LEAVE.
         SPACE 1
********  FREEMAIN FOR TABLE 2.  ***
         SPACE 1
         L     0,SAV3              LOAD LENGTH OF TABLE2 INTO REG.'0'.
         L     1,TABLE2            LOAD ADD.OF TABLE2 INTO REG. '1'.
         FREEMAIN R,LV=(0),A=(1)             ISSUE FREEMAIN.
CDSLEAVE LM    2,9,REGSAVEX        RESTORE THE REGISTARS.
         CLOSE (IAMRIGAM)           CLOSE THE DATA SET.
         MVI   INDICATO,I01        SET INDICATOR.
         B     RETOCALL            RETURN TO THE USER.
REGSAVEX DS    10F                 REGISTAR SAVE AREA
         TITLE 'TTRN-NNNNNN TWO WAY CONVERSION RIGAM'
***********************************************************************
*        SUBROUTINE TO CONVERT TTRN TO NNNNNN                         *
***********************************************************************
         SPACE 1
CONVTTRN DC    F'0'                TTRN TO BE CONVERTED
CONVNNNN DC    F'0'                 NNNNNN TO BE CONVERTED
         SPACE 1
******** USER MUST SET UP ABOVE TWO FIELDS ***
         SPACE 1
******** CONVERT FROM TTRN TO NNNNNN  ***
         SPACE 1
CONVTON  STM   2,9,REGSAVEX             SAVE REGISTERS
         XR    2,2                      CLEAR REGISTER 2
         IC    2,NODRPB                 INSERT NO OF DATA RECORDS/BLOCK
         LH    5,CONVTTRN               LOAD TT OF TTRN
         MH    5,BLKNOH            TT X MAX-R-TRK                   BXL
         XR    3,3                      CLEAR REGISTER 3
         IC    3,CONVTTRN+2             R INSERTED
         AR    5,3                      TTX4+R
         XR    4,4                      CLEAR REGISTER 4
         MR    4,2                      BLOCKSXNO DATA RECORDS/BLOCK
         XR    4,4                      CLEAR REGISTER 4
         IC    4,CONVTTRN+3             N OF CURRENT RECORD
         AR    5,4                      NNNNNN OF RECORD
         ST    5,CONVNNNN               STORE NNNNNN OF TTRN
         LM    2,9,REGSAVEX             RESTORE PRIOR REGISTERS
         BR    4                        RETURN
         SPACE 1
******** CONVERT FROM NNNNNN TO TTRN  ***
         SPACE 1
CONVFRT  STM   2,9,REGSAVEX             SAVE REGISTERS
         L     2,CONVNNNN               LOAD NNNNNN
         SRDA  2,32(0)                  PLACE DIVIDEND
         XR    4,4                      CLEAR REGISTER 4
         IC    4,NODRPB                 NO OF DATA RECORDS PER BLOCK
         DR    2,4                      NNNNNN DIVIDED BY DATA R/BLOCK
         STC   2,CONVTTRN+3             STORE N
         XR    2,2                      CLEAR REGISTER 2
         D     2,BLKNOF            CALCULATE TT AND R               BXL
         A     2,=F'1'                  INCREMENT BY 1
         STC   2,CONVTTRN+2             STORE R
         STH   3,CONVTTRN               STORE TT
         LM    2,9,REGSAVEX             RESTORE REGISTERS
         BR    4                        RETURN
         SPACE 1
******** ROUTINE SHOULD BE USED FOR TYPE 1 AND 2 FILES       ***
         SPACE 1
         TITLE 'POINT TO RECORD    RIGAM'
POINN    DC    XL1'00'             RECORD NUMBER
POINADDR DC    F'0'                POINTER TO RECORD RIGAM FIELD
POINT    STM   2,9,REGSAVEX        SAVE REGISTERS
         XR    2,2                 CLEAR REGISTER 2
         IC    2,DLGN              HIGH ORDER BYTE OF DATA LENGTH
         SLA   2,8(0)              SHIFT HIGH ORDER BYTE
         IC    2,DLGN+1            LOW ORDER BYTE OF DATA LENGTH
         SPACE 1
******** DATA LENGTH FOR TYPE 1 FILES INCLUDES ***
******** FILE ID  KEY AND DATA                 ***
         SPACE 1
         LR    6,2                 LOAD 6 WITH DATA LENGTH
         SPACE 1
******** DATA LENGTH FOR TYPE 2 FILES INCLUDES ***
******** FILE ID AND DATA                      ***
         SPACE 1
         XR    8,8                 CLEAR REGISTER 8
         IC    8,POINN             INSERT RECORD NUMBER
         S     8,=F'1'             SUBTRACT FOR RELATIVE RECORD POINTER
         LR    7,6                 SET UP FOR
         XR    6,6                 MULTIPLY  REL RECORD X  REC LENGTH
         MR    6,8                 FOR DISPLACEMENT
         A     8,=F'1'             TRUE RECORD POSITION.
         L     5,=F'5'             SET UP FOR MULTIPLY.
         XR    4,4                 CLEAR REGISTAR 4.
         MR    4,8                 RESOLVE DISPLACEMENT OF INDICITIVE
         AR    7,5                  INFORMATION AND ADD TO DATA DISP.
         S     7,=F'5'             SUBTRACT KEY FIELD LENGTH.
         LA    6,BLOCK+3           POINT TO FIRST BLOCK
         AR    6,7                 POINT TO THIS  BLOCK
         ST    6,POINADDR          STORE POINTER
         LM    2,9,REGSAVEX        RESTORE REGISTERS
         BR    4                   RETURN
         TITLE 'RESERVE FILE   REF  RIGAM'
***********************************************************************
*        RESERVE FILE                                                 *
***********************************************************************
         SPACE 1
REF      STM   2,9,REGSAVE9        SAVE THE REGISTARS.
         L     2,=F'1'             TEST ONLY.
         BAL   4,OPCOUNT           TEST ONLY.
         XC    OPFCVTAR,OPFCVTAR   CLEAR THE PACKING AREA.
         PACK  OPFCVTAR+6(2),UFILE           PACK FILE I.D.
         CVB   3,OPFCVTAR          CONVERT FILE I.D. TO PACKED.
         XR    2,2                 CLEAR REGISTAR 2.
         D     2,BLKNOF            DIV FILE-ID BY MAX-R-TRK         BXL
         LTR   2,2                 IS REGISTAR 2 = ZERO ?
         BC    6,REFB              NO. BREANCH TO STORE TTR.
         S     3,=F'1'             DECREMENT TT OF TTR.
         L     2,BLKNOF            SET R OF TTR                     BXL
REFB     ST    3,OPFCVTAR          STORE TT.
         MVC   RTTR(2),OPFCVTAR+2  MOVE TT TO READ TTR.
         STC   2,RTTR+2            R TO READ TTR.
         MVC   WTTR,RTTR           HOLD TTR FOR WRITE FUNCTION.
         BAL   4,TSTFAVAL          GO TEST FILE AVAILABILITY.
REFENQ   BAL   4,DOANENQ           GO ENQ FILE FOR EXCLUSIVE CONTROL.
         SPACE 1
******** READ  EXCLUSIVE  PARAMETER BLOCK ***
         SPACE 1
         BAL   4,JDAREAD           GO READ PARAMETER BLOCK INTO CORE.
         CLC   FILETYPE,BLOCK+6    FILETYPE EQUAL IN LIST AND PARAMS?
         BNE   MOVE6               NO.GO SET INDICAROR TO A 6.
         B     REF2                     NO BRANCH AROUND
REF1     MVI   INDICATO,I02             SET INDICATOR = -2
REFREL   LM    2,9,REGSAVE9        RESTORE THE REG'S.
         B     RETOCALL            RETURN TO USER.
REF2     CLC   UFILE,BLOCK         IS FILE EQUAL TO USER SPEC.S ???????
         BE    REF3                YES
         BAL   4,DOADEQ            FREE FILE EXCLUSIVE CONTROL
         MVI   INDICATO,I26        TELL PROGRAMMER OF PROBLEM
         B     REFREL              ..IN FILE CROSS-REFERENCE
MOVE6    BAL   4,DOADEQ            FREE FILE EXCLUSIVE CONTROL.
         MVI   INDICATO,I06        TELL PROGRAMMER FILE TYPES UNEQUAL.
         B     REFREL              RELEASE AND EXIT
REF3     MVI   BLOCK+7,X'FF'       SET RESERVE SWITH ON.
         SPACE 1
******** CHECK FOR SPACE REMAINING ***
         SPACE 1
         CLC   LDRU(3),HGHBLK      ROOM FOR WRITE ADD
         BH    REF4                NO
         B     REFEXIT             YES
REF4     MVI   INDICATO,I28        SET INDICATOR TO FILE FULL.
         MVI   BLOCK+7,X'00'       RESET RESERVE CODE  REL AND EXIT
         BAL   4,DOADEQ            FREE FILE EXCLUSIVE CONTROL.
         B     REFREL              GO TO RELEASE
REFEXIT  LM    2,9,REGSAVE9        RESTORE THE REGISTARS.
         MVI   REFSW3+1,X'00'      DEQ IF NO ROOM IN TABLE IN OPF RIN.
         MVI   REFSW1+1,X'F0'      TURN ON REF SWITCH'S TO STOP
         MVI   REFSW2+1,X'F0'        RESERVE CODE FROM REVERSING.
         B     REFENTRY            SET UP FILE USING OPF ROUTINE.
REGSAVE9 DS    10F                 REGISTAR STORAGE SAVE AREA.
         SPACE 1
******** TEST FILE AVAILABILITY FOR RESERVE STATUS WITH EXCLUSIVE CTRL.
         SPACE 1
TSTFAVAL EQU   *
         MVC   RRNAME(3),UIDEN     SET ENQ FOR CURRENT FILE.
         BAL   4,ENQTEST           GO TEST FILE STATUS
         CLI   INDICATO,I01        CONTROL ALREADY ESTABLISHED?
         BE    REFENQ              NO. GO GET IT.
         CLI   INDICATO,I04        IS CONTROL SOMEPLACE ELSE?
         BE    REF1                YES.GO SET INDICATOR FOR PROGRAM.
         MVI   INDICATO,I25        OTHERWISE TELL PROGRAMMER OF A...
         B     REFREL              ...PROBABLE LOGIC ERROR.
         TITLE 'ENQ AGAINST A FILE FOR TESTING AVAILABILITY.'
***********************************************************************
*                                                                     *
*   THIS ROUTINE WILL ISSUE AN ENQ AGAINST A GIVEN FILE IDENTIFICATION*
* FOR THE PURPOSE OF TESTING ITS AVAILABILITY.THROUGH-OUT THE SYSTEM  *
* ENVIRONMENT. A RETURN OF ZERO IN REG.15 MEANS IT IS AVAILABLE. IF   *
* REG.15 CONTAINS AN ADDRESS IT WILL BE TO THE RETURN CODE. (ADDRESS  *
* PLUS 3). A RETURN CODE OF 4 MEANS IT IS NOT AVAILABLE. A RETURN CODE*
* OF 8 MEANS THIS TASK ALREADY HAS CONTROL OVER THE FILE.             *
*                                                                     *
***********************************************************************
         SPACE 1
ENQTEST  STM   1,4,DENQSV          SAVE REGS.
         ENQ   (RGNAME,RRNAME,E,47,SYSTEM),RET=TEST
         XC    INDICTOR(2),INDICTOR     CLEAR INDICATOR
         LTR   15,15                    IS R15 ZERO ?
         BZ    ENQTST1                  YES,EXIT.
         MVC   INDICTOR+1(1),3(15)      NO.SET INDICATOR WITH RET.CODE.
         B     ENQTST2                  GO EXIT.
ENQTST1  MVI   INDICATO,I01             SET INDICATOR TO 1.
ENQTST2  LM    1,4,DENQSV          RESET REGS.
         BR    4                   EXIT.
DENQSV   DC    4F'0'               REGISTER SAVE AREA.
RGNAME   DC    CL8'DSNRIGAM'       ENQ/DEQ GNAME FOR MACRO.
RRNAME   DC    CL47' '             ENQ/DEQ RNAME FIELD FOR MACRO.
         TITLE 'ENQ FOR EXCLUSIVE CONTROL OF A FILE.'
***********************************************************************
*                                                                     *
*  THIS ROUTINE WILL ISSUE.AN ENQ FOR EXCLUSIVE CONTROL OVER A FILE TO*
* BE RESERVED. THE ENQTEST ROUTINE SHOULD BE EXECUTED PRIOR TO ENTRY S*
* THE PARTITION WILL NOT BE PERMANENTLY PLACED IN A WAIT STATE SHOULD *
* AN ON-LINE ENVIRONMENT FAILED TO DEQ THE FILE.                      *
*                                                                     *
***********************************************************************
         SPACE 1
DOANENQ  STM   1,4,DENQSV          SAVE REGS.
         ENQ   (RGNAME,RRNAME,E,47,SYSTEM)
         LM    1,4,DENQSV          RESET REGS.
         BR    4                   RETURN.
         TITLE 'DEQ/RELEASE EXCLUSIVE CONTROL OF A FILE.'
***********************************************************************
*                                                                     *
*   THIS ROUTINE WILL ISSUE A DEQ RELEASING EXCLUSIVE CONTROL OVER A  *
* FILE TO BE FREED. THE ENQTEST ROUTINE SHOULD HAVE BEEN EXECUTED PRIO*
* TO ENTRY TO THIS ROUTINE TO INSURE THE PROGRAM RESERVED THE FILE.   *
*                                                                     *
***********************************************************************
         SPACE 1
DOADEQ   STM   1,4,DENQSV          SAVE REGISTERS.
         DEQ   (RGNAME,RRNAME,47,SYSTEM)
         LM    1,4,DENQSV          RESTORE REGISTERS.
         BR    4                   RETURN.
         TITLE 'TEST DEVICE TYPE'
***********************************************************************
*        THIS SUBROUTINE TEST THE DEVICE TYPE OF RIGAM D/S,           *
*         AND GIVE THE MAXIMUN NUMBER OF BLOCKS ON ONE TRACK.         *
*            2311=2, 2314=4, 3330=7,                                  *
*                    WRITTEN BY TSG MONSANTO BRUSSELS                 *
***********************************************************************
         SPACE 1
TSTYPDEV STM   R2,R4,TYPDEVSA      SAVE REGISTERS
         DEVTYPE IAMRIGAM+40,TYPDEVWA,DEVTAB,RPS
         LTR   4,15                RETURN CODE IS IT ZERO ?
         BNZ   DNOK                BRANCH IF NO
         LA    2,NETAD             ESTABLISH LOOP
         LA    3,TABDEV            POINT R2 AT FIRST TABLE ELEMENT
LTSTAD   CLC   TYPDEVWA(4),0(3)    TEST IF DEVICE T. IS IN RIGAM TABLE
         BE    DOK                 BRANCH IF YES
         LA    3,6(3)              INCREMENT POINTER
         BCT   2,LTSTAD            PROCESS NEXT TABLE ELEMENT
         B     DNOK                ERROR - DEVICE TYPE UNKNOWN
DOK      MVC   BLKNOH,4(3)         MOVE MAX. NO OF BLOCKS PER TRACK
         LM    R2,R4,TYPDEVSA      RESTORE REGISTERS
         BR    R4                  RETURN TO CALLER
         SPACE 2
TYPDEVSA DS    3F                  SAVE AREA
TYPDEVWA DC    6F'0'               WORK AREA FOR DEVTYPE MACRO
BLKNOF   DC    H'0'                MAXIMUN NUMBER OF
BLKNOH   DC    H'0'                   BLOCKS PER TRACK
TABDEV   DC    X'30002001',H'2'    2 BLOCKS FOR 2311
         DC    X'30C02008',H'4'    4 BLOCKS FOR 2314
         DC    X'30502009',H'7'    7 BLOCKS FOR 3330
         DC    X'3050200D',H'7'    7 BLOCKS FOR 3330-11
         DC    X'FFFFFFFF',H'0'    FREE
         DC    X'FFFFFFFF',H'0'    FREE
         DC    X'FFFFFFFF',H'0'    FREE
         DC    X'FFFFFFFF',H'0'    FREE
         DC    X'FFFFFFFF',H'0'    FREE
         DC    X'FFFFFFFF',H'0'    FREE
NETAD    EQU   10                  NUMBER OF TABLE ELEMENTS
         TITLE 'RESERVATION CANCEL  RIGAM'
***********************************************************************
*        RESERVATION  CANCEL                                          *
***********************************************************************
         SPACE 1
FILCNCL  DC    CL3' '              FILE TO BE RES CANC
RESC     STM   2,9,REGSAVEE        SAVE THE REGISTARS.
         L     5,RESPT             POINT TO PARAMETERS.
         MVC   RRNAME(3),3(5)      MOVE I.D.TO RNAME.
         BAL   4,ENQTEST           GO TEST STATUS.
         CLI   INDICATO,I08        IS IT HERE.?
         BNE   RESCRTRN            NO NOT RESERVED.EXIT.
         MVI   7(5),X'00'          TURN INTERNAL RESERVE CODE OFF.
         BAL   4,DOADEQ            DEQ/RELEASE THE FILE
RESCRTRN LM    2,9,REGSAVEE        RESET REGISTERS.
         BR    4                   RETURN
RESPT    DC    F'0'                POINTER TO PARAMETER
REGSAVEE DS    10F                 REGISTAR STORAGE SAVE AREA.
         TITLE 'RIGAM - FILE PARAMETER AND I/O WORK AREAS'
***********************************************************************
*        FILE PARAMETER WORK AREA                                     *
***********************************************************************
         SPACE 1
PARMWK2  DS    0CL28                   TYPE 2 FILES
PARMWK1  DS    0CL229                   TYPE 1 FILES
FILENO   DS    CL3                      FILE NO
FILEID   DS    CL3                      3 CHAR ID
FILETYP  DS    CL1               F1ORF2 FILE TYPE 1 OR 2
INDFILE  DS    0C                       FILE AND ACCESSING INDICATORS
RESERVCD DS    C                00 OR FF     RESERVATION CODE
FTSWTCH  DS    C          '02'=NFT'01'=FT    FIRST TIME 'GET INDICIES'
PCODE    DS    CL2                           ETC
*  DATA  FILE EXTENT
LOWBLK   DS    CL3                      TTR  LOW BLOCK NO
HGHBLK   DS    CL3                      TTR  HIGH BLOCK NO
*  DATA  RECORD LENGTH                  DATA LENGTH,ARG,ID,+5 BYTES
DLGN     DS    CL2                      LENGTH OF DATA    BINARY
LDRU     DS    CL4          NOT EOF T-1 TTRN OF LAST DATA RECORD USED.
NODRPB   DS    C                        NO OF DATA RECORDS PER BLOCK
BRNSR    DS    CL4                      TTRN OF NEXT SEQUENTIAL RECORD
*  ADDITIONAL PARAMETERS FOR TYPE 1 FILES
BREOF    DS    CL4                      TTRN OF END OF FILE RECORD
NOINDL   DS    C                        NO OF INDEX LEVELS
*  INDEX FILE  EXTENT
ILBN     DS    CL3                      LOW BLOCK NO   TTR
IHBN     DS    CL3                      HIGH BLOCK NO  TTR
ILBU     DS    CL3                      LAST INDEX BLOCK USED TTR
ARGL     DS    C                        ARGUMENT LENGTH
INDPB    DS    C                        NO INDICIES PER BLOCK
*   LAST LEVEL 2 INDEX BLOCK FOUND
LA2      DS    CL35                     LOW ARG
HA2      DS    CL35                     HIGH ARG
BN2      DS    CL3                      BLOCK NO
*   LAST LEVEL 1 INDEX BLOCK FOUND
LA1      DS    CL35                     LOW ARG
HA1      DS    CL35                     HIGH ARG
BN1      DS    CL3                      BLOCK NO
*   LAST  DATA RECORD FOUND
LARG     DS    CL35                     ARG
LBR      DS    CL4                      DATA BLOCK NO AND REC NO TTRN
         SPACE 3
***********************************************************************
*        I/O AREA                                                     *
***********************************************************************
         SPACE 1
BLOCK    DS    CL1693                   I/O AREA FOR DISK
SHIFTARG DS    CL40                     ARGUMENT+ID SHIFTED
SAVEARG  DS    CL40                     ARGUMENT+ID SAVED
         DC    CL20' '        DISPLACEMENT FOR GOOFY DCB ALLOTMENT.
         TITLE 'RIGAM - ABEND''S'
***********************************************************************
*        ABEND'S                                                      *
***********************************************************************
         SPACE 1
EOF      WTO   'RIGAM DISK EOF'
         ABEND 111,DUMP
         SPACE 1
ERR      WTO   'RIGAM DISK ERR'
         ABEND 222,DUMP
         SPACE 1
XDAPERR  WTO   'XDAP ERROR'
         ABEND 888,DUMP
         SPACE 1
DNOK     WTO   'DEVICE TYPE UNKNOWN'
         ABEND 999,DUMP
         TITLE 'SQA--SET QUEUE ACTUAL ROUTINE. RLG.'
***********************************************************************
*                                                                     *
* THIS ROUTINE RESETS THE LDRU OF A TYPE 2 FILE TO POINT TO THE FIRST *
*    RECORD OF THE FILE. RLG.                                         *
*                                                                     *
***********************************************************************
         SPACE 1
SQA      L     2,=F'15'            TEST ONLY.
         BAL   4,OPCOUNT           TEST ONLY.
         CLI   FILETYP,X'F2'       IS IT A TYPE 2 FILE ? MAKE SQA AFTER
         BNE   SQATYP1             NO.
         MVC   LDRU(3),LOWBLK      YES. MOVE IN LOW BLOCK EXTENT
         MVI   LDRU+3,X'00'           AND RECORD 1 POINTER.
         MVI   INDICATO,I01        SET INDICATOR OK.
         BAL   4,PARMRYT           WRITE PARAMETERS BACK WITH NEW LDRU.
         B     RETOCALL            LEAVE.
SQATYP1  MVI   INDICATO,I30        SET INDICATOR TO 30.
         B     RETOCALL            LEAVE.
         TITLE 'CALCULATE AN INDICE ADDRESS. INDCALC ROUTINE. RLG.'
***********************************************************************
*                                                                     *
* THIS ROUTINE CALCULATES A POINTER TO AN INDEX KEY. RLG.             *
*                                                                     *
***********************************************************************
         SPACE 1
REGSAVEI DS    8F                  REGISTAR STORAGE AREA.
INDNUMB  DC    XL1'00'             INDICE NUMBER FOR CALCULATION.
INDADDR  DC    F'0'                ADDRESS CALCULATED.
         SPACE 2
INDCALC  STM   2,9,REGSAVEI        STORE THE REGISTARS.
         XC    INDADDR,INDADDR     CLEAR THE ADDRESS AREA.
         XR    2,2                 CLEAR REGISTARS 2,
         XR    4,4                                 4,
         XR    5,5                                 5,
         XR    6,6                                 6.
         LA    2,BLOCK+12          POINT TO FIRST INDICE.
         IC    5,INDNUMB           GET INDICE NUMBER.
         IC    6,ARGL              GET THE KEY LENGTH.
         SH    5,=H'1'             DECREMENT INDICE BY 1.
         MR    4,6                 DETERMINE NO.OF KEY BYTES DISPLACED.
         AR    2,5                 ADD ABOVE TO START ADDRESS.
         XR    4,4                 CLEAR CALCULATION REGISTARS 4,
         XR    5,5                                             5,
         XR    6,6                                             6,
         IC    5,INDNUMB           GET INDICE NUMBER.
         LA    6,5(6)              CONSTANT 5 FOR TTRN AND DELETE CODE.
         SH    5,=H'1'             DECREMENT INDICE BY 1.
         MR    4,6                 DETERMINE CONSTANT BYTES DISPLACED.
         AR    2,5                 ADD ABOVE TO START ADDRESS.
         ST    2,INDADDR           PLACE POINTER IN HOLD FOR RETURN.
         LM    2,9,REGSAVEI        RESTORE THE REGISTARS.
         BR    4                   RETURN.
         SPACE 1
***********************************************************************
*                                                                     *
*  THE ABOVE ALGORITHM RESOLVES THE FOLLOWING FORMULA...              *
*                                                                     *
*       A(BLOCK+12)  +  ((KEY LENGTH  X (INDEX NO.-1))  +             *
*                                                                     *
*                   (5  X  (INDEX NO.-1)))  = INDEX ADDRESS OF KEY    *
*                                                                     *
***********************************************************************
         TITLE 'TEST OVERLAY END-OF-JOB FOR CLEARING PARMWK AREA.RLG.'
***********************************************************************
*                                                                     *
* THIS ROUTINE DETERMINES WHETHER ALL FILES HAVE BEEN CLOSED. IF NOT,A*
* RETURN TO CLF IS ISSUED. IF THEY HAVE THE PARAMETER WORK AREA IS    *
* CLEARED TO HEX'00'.                                                 *
* THIS IS ESSENTIAL IN OVERLAY STRUCTURE PROGRAMMING.                 *
*                                                                     *
***********************************************************************
         SPACE 1
CLEAR    STM   2,9,REGSAVEJ        STORE THE REGISTARS.
         L     2,TABLE1            POINT TO TABLE OF TYPE 1 FILES.
         LH    3,LTB1              GET NUMBER OF ENTRIES FOR TYPE 1.
         XR    4,4                 CLEAR REG.4 FOR COUNT.
CLR1     CLC   0(3,2),=X'FFFFFF'   COMPARE FOR FREE AREA.
         BNE   CLEARXIT            NOT EQUAL,LEAVE.                BXL
*        BNE   CLR3                NOT EQUAL,SEE IF IT'S *RIGAM.   BXL
CLR4     AH    4,=H'1'             COUNT TYPE 1 CLOSED TABLE AREAS.
         LA    2,229(2)            POINT TO NEXT ENTRY
         BCT   3,CLR1              TEST FOR MORE. YES,GO COMPARE.
         LH    3,LTB1              NO.GET NUMBER OF TYPE1 ENTRIES.
         CR    3,4                 IS COUNT THE SAME AS ENTRIES?
         BNE   CLEARXIT            NO. LEAVE.
         L     2,TABLE2            YES.POINT TO TABLE OF TYPE 2 FILES.
         LH    3,LTB2              GET NUMBER OF ENTRIES IN TABLE2.
         XR    4,4                 CLEAR REG.4 FOR COUNT.
CLR2     CLC   0(3,2),=X'FFFFFF'   COMPARE FOR FREE AREA.
         BNE   CLEARXIT            NOT EQUAL,LEAVE.
         AH    4,=H'1'             COUNT TYPE 2 CLOSED TABLE AREA.
         LA    2,28(2)             POINT TO NEXT ENTRY.
         BCT   3,CLR2              TEST FOR MORE. YES,GO COMPARE.
         LH    3,LTB2              NO.GET NUMBER OF TYPE 2 ENTRIES.
         CR    3,4                 IS COUNT THE SAME AS ENTRIES?
         BNE   CLEARXIT            NO.LEAVE.
         XC    PARMWK1,PARMWK1     YES. CLEAR PARAMETER WORK AREA.
CLEARXIT LM    2,9,REGSAVEJ        RESTORE THE REGISTARS.
         BR    4                   RETURN TO CLF.
REGSAVEJ DS    8F
CLR3     CLC   0(3,2),=X'F0F0F1'   IS IT *RIGAMS
         BE    CLR4                YES. GO ADD.
         B     CLEARXIT            NO. LEAVE.
         TITLE 'HOLD TASK'
***********************************************************************
*                                                                     *
*   THIS OPCODE WILL HOLD A TASK TILL A FILE UNDER EXCLUSIVE CONTROL I*
* FREED. THEN IT WILL PASS FUNCTIONAL GUIDANCE BACK TO THE PROGRAMMER.*
*                                                                     *
***********************************************************************
         SPACE 1
GAF      STM   1,4,REGSAVEK
         MVC   RRNAME(3),UIDEN     MOVE FILE NUMBER
         BAL   4,ENQTEST           IS IT AVAILABLE ?
         CLI   INDICATO,I01
         BE    GAFEND              YES, SKIP ENQ/DEQ
         MVC   GAFMSG0+18(44),JFCBDSNM
         MVC   GAFMSG1+44(3),UIDEN
GAFMSG0  WTO   'RIGAM DSN=                                            '
GAFMSG1  WTO   'RIGAM AWAITING AVAILABILITY OF FILE XXX.'
         BAL   4,DOANENQ
         MVC   GAFMSG2+28(3),UIDEN
GAFMSG2  WTO   'RIGAM ATTAINED FILE XXX CONTROL.'
         BAL   4,DOADEQ
         MVI   INDICATO,I01
GAFEND   LM    1,4,REGSAVEK
         B     RETOCALL
*
REGSAVEK DC    4F'0'
         TITLE 'OP-CODE USE COUNT AND USE INDICATOR ROUTINE. RLG.'
***********************************************************************
*                                                                     *
*    THIS ROUTINE WILL KEEP TRACK OF THE LAST EIGHT OP-CODES SPECIFIED*
* BY THE USER. IT WILL ALSO COUNT THE NUMBER OF TIMES EACH OP-CODE IS *
* SPECIFIED. R2 CONTAINS OP-CODE NUMBER. RLG.                         *
*                                                                     *
***********************************************************************
         SPACE 1
         NOP                       ENABLE BYPASS                   BXL
OPCOUNT  STM   2,9,OPSAVE          SAVE REG'S.
         LA    3,OPTAB             POINT TO TABLE.
         L     4,=F'18'            SET R4 FOR TOTAL OP-CODES.
         SPACE 1
OPCT1    XR    5,5                 CLEAR R5.
         IC    5,0(0,3)            PLACE USE BYTE IN R5.
         LTR   5,5                 TEST FOR ZERO'S.
         BZ    OPCT4               IF ZERO THEN BRANCH.
         SLA   5,1(0)              SHIFT USE 1 BIT.
OPCT2    STC   5,0(0,3)            PUT USE BYTE BACK.
OPCT3    LA    3,4(3)              POINT TO NEXT USE BYTE.
         BCT   4,OPCT1             COUNT NUMBER OF ENTRIES. NON-ZERO
         B     OPCT5                 CONTINUE. ZERO,LEAVE.
OPCT4    LR    6,4                 PLACE BCT COUNT IN R6.
         AR    6,2                 ADD OP-CODE NUMBER.
         L     7,=F'18'            PLACE AN 18 IN R7.
         CR    6,7                 IF R6=18 IT IS CORRECT OP-CODE.
         BNE   OPCT3               IF NOT CONTINUE SEARCH.
         AH    5,=H'1'             IF CORRECT ADD 1 TO USE COUNT.
         B     OPCT2                AND GO TO STORE IT.
         SPACE 1
OPCT5    MH    2,=H'4'             FIND DISPLACEMENT LENGTH
         LA    3,OPTAB             POINT TO TABLE BEGINING.
         AR    3,2                 INCREMENT TO OP-CODE USE COUNT.
         IC    5,0(0,3)            SAVE USE BYTE IN R5.
         L     4,0(0,3)            PLACE USE WORD IN R4.
         SLA   4,8(0)              SHIFT USE BYTE OUT OF R4.
         SRA   4,8(0)              SHIFT ALIGN USE COUNT.
         A     4,=F'1'             INCREMENT USE COUNT.
         ST    4,0(0,3)            STORE USE COUNT.
         STC   5,0(0,3)            STORE USE BYTE.
         LM    2,9,OPSAVE          RESTORE REG'S.
         BR    4                   RETURN
OPSAVE   DS    8F                  REG. SAVE AREA.
OPTAB    DC    F'0'                OPF COUNT      POINT IS 0
         DC    F'0'                REF COUNT      POINT IS 1
         DC    F'0'                FRF COUNT      POINT IS 2
         DC    F'0'                CLF COUNT      POINT IS 3
         DC    F'0'                GAF COUNT      POINT IS 4
         DC    F'0'                RRG COUNT      POINT IS 5
         DC    F'0'                SSG COUNT      POINT IS 6
         DC    F'0'                RSG COUNT      POINT IS 7
         DC    F'0'                FKG COUNT      POINT IS 8
         DC    F'0'                WUG COUNT      POINT IS 9
         DC    F'0'                WDG COUNT      POINT IS10
         DC    F'0'                WAG COUNT      POINT IS11
         DC    F'0'                RRA COUNT      POINT IS12
         DC    F'0'                SSA COUNT      POINT IS13
         DC    F'0'                RSA COUNT      POINT IS14
         DC    F'0'                SQA COUNT      POINT IS15
         DC    F'0'                WUA COUNT      POINT IS16
         DC    F'0'                WAA COUNT      POINT IS17
         TITLE 'WRITE PARAMETERS FOR SUCCESSFUL WAG OR WAA. RLG.'
***********************************************************************
*                                                                     *
* THIS ROUTINE WILL TEST FOR A VALID INDICATOR. IF VALID IT WILL WRITE*
* THE FILE PARAMETERS BECAUSE THE WAG OR WAA HAS CHANGED THE LDRU. THE*
* RESULT WILL SAVE SYSTEM RESTART PROCEDURES IN THE EVENT OF POWER OR *
* SYSTEM FAILURE.                                                     *
* IF THE INDICATOR IS INVALID A RETURN IS EXECUTED. RLG.              *
*                                                                     *
***********************************************************************
         SPACE 1
PARMRYT  EQU   *
         STM   2,9,PARMSV          STORE REGISTERS.
         CLI   INDICATO,I01        VALID INDICATOR ?
         BH    PARMOUT             NO. LEAVE.
         XC    OPFCVTAR,OPFCVTAR   CLEAR CONVERT AREA.
         PACK  OPFCVTAR+6(2),FILENO     PACK FILE NUMBER.
         CVB   3,OPFCVTAR               MAKE IT BINARY.
         XR    2,2                      R2 CLEAR.
         D     2,BLKNOF            DIV FILE-ID BY MAX-R-TRK         BXL
         LTR   2,2                      IS R2 = ZERO ?
         BC    6,PARM1             NO. GO STORE TTR.
         S     3,=F'1'             YES.DECREMENT TT OF TTR.
         L     2,BLKNOF            SET R OF TTR                     BXL
PARM1    ST    3,OPFCVTAR          ADJUST TT.
         MVC   PRTTR(2),OPFCVTAR+2      MOVE TT TO PARM WRITE TTR.
         STC   2,PRTTR+2                MOVE R TO PARM WRITE TTR.
         MVC   BLOCK(229),FILENO        MOVE PARAMETERS TO OUTPUT AREA.
         L     R0,PRTTR            LOAD TTRN INTO R0
         BAL   R4,WTRBLOCK         GO WRITE A BLOCK
PARMOUT  LM    2,9,PARMSV          RESTORE REGISTARS.
         BR    4                   EXIT.
         SPACE 1
PARMSV   DS    8F                  REGISTAR SAVE AREA.
PRTTR    DC    F'0'                PARAMETER WRITE TTR SAVE.
PRTTR1   DC    F'0'                 WORD ADJUSTMENT FOR TTR.
         TITLE 'TEST INDICATOR FOR ERROR RETURN ROUTINE...TESTIND' BXL
TESTIND  STM   2,9,TIRGSAV         STORE THE REGISTARS.            BXL
         NI    CGHALL1+2,X'8F'  INSERTED BY C.G.HALL - PLEASE NOTE THAT
         NI    CGHALL2+2,X'8F'     THESE ARE NOT IN GREENVILLE VERSION.
CGHALL1  CLI   INDICATO,I01        IS INDICATOR O.K?               BXL
         BE    TESTRTN             YES,RETURN TO USER CALL         BXL
CGHALL2  L     3,UERLIST           GET POINTER TO USER ERROR LIST. BXL
         L     5,4(13)  LOAD ADDRESS OF 'DYNAMO' SAVE AREA.        BXL
         ST    3,12(5)  ALTER STORED VALUE OF REGISTER 14.         BXL
TESTRTN  LM    2,9,TIRGSAV         RESTORE THE REGISTARS.          BXL
         BR    4                   RETURN TO MAINLINE.             BXL
TIRGSAV  DS    8F                  REGISTAR STORAGE SAVE AREA      BXL
         SPACE 1
***********************************************************************
*                                                                  BXL*
*   ALGORITHM FOR ERROR ADDRESS RETURN IS THE FOLLOWING FORMULA... BXL*
*                                                                  BXL*
*     RETURN ADDRESS = USER ERROR LIST ADDRESS + (4 *INDICATOR) -  BXL*
*                                                                  BXL*
***********************************************************************
         TITLE 'RIGAM - DCB''S'
***********************************************************************
*        DATA CONTROL BLOCKS                                          *
***********************************************************************
         SPACE 1
JFCB     DCB   DDNAME=IAMRIGAM,                                        *
               DSORG=DA,                                               *
               MACRF=(E),                                              *
               EXLST=STRJFCB
         SPACE 3
IAMRIGAM DCB   DDNAME=IAMRIGAM,                                        *
               DSORG=DA,                                               *
               MACRF=(E),                                              *
               RECFM=F,                                                *
               BLKSIZE=1693,                                           *
               BUFNO=1,                                                *
               EODAD=EOF,                                              *
               SYNAD=ERR
         TITLE 'RIGAM - JOB FILE CONTROL BLOCK'
***********************************************************************
*        JOB FILE CONTROL BLOCK                                       *
***********************************************************************
         SPACE 1
         DS    0D
STRJFCB  DC    X'87'
         DC    AL3(JFCBAREA)
         PRINT GEN
JFCBAREA IEFJFCBN
         PRINT NOGEN
         TITLE 'RIGAM - WORK AREAS, CONSTANTS, EQUATES AND LITERALS '
***********************************************************************
*        WORK AREAS                                                   *
***********************************************************************
         SPACE 1
RIGAMSA  DS    8F                  SAVE AREA FOR SUBRIN AND SUBROUT M.
RDRBLKSA DS    8F                  SAVE AREA FOR READ A BLOCK ROUTINE
WRTBLKSA DS    8F                  SAVE AREA FOR WRITE A BLOCK ROUTINE
MBBCCHHR DC    D'0'                WA FOR XDAP MACRO
RTTR     DC    F'0'                TTR FOR READ A BLOCK
         DC    F'0'                A FULL WORD FILLER FOR RTTR
         EJECT
***********************************************************************
*        EQUATES AND LITERALS POOL                                    *
***********************************************************************
     SPACE 1
**********************************
****  RIGAM RETURN INDICATORS ****
**********************************
         SPACE 1
I01      EQU   X'01'     OPERATION PERFORMED
I02      EQU   X'02'     FILE RESERVED
I03      EQU   X'03'     RECORD NOT FOUND
I04      EQU   X'04'     OPI NOT FIRST OP-CODE EXECUTED
I05      EQU   X'05'     INVALID OP-CODE
I06      EQU   X'06'     OPF, REF. FILE TYPE SPECIFIED NOT EQUAL TO
*                         FILE SPECIFICATIONS
I07      EQU   X'07'     OPF, REF. CAPACITY OF FILE TABLE EXCEEDED,
*                         NUMBER OF FILES SPECIFIED BY OPI INVALID
I08      EQU   X'08'     FRF ATTEMPTED WITHOUT FIRST RESERVING FILE
I09      EQU   X'09'     FILE NOT OPEN
I10      EQU   X'0A'     CLF ATTEMPTED ON FILE WHICH HAS NOT BEEN
*                        FREED (FRF)
I11      EQU   X'0B'     RRG ATTEMPTED ON TYPE 2 FILE
I12      EQU   X'0C'     ATTEMPTED TO READ DATA OUTSIDE OF FILE EXTENT
I13      EQU   X'0D'     SSG ATTEMPTED ON TYPE 2 FILE
I14      EQU   X'0E'     RSG ATTEMPTED ON TYPE 2 FILE
I15      EQU   X'0F'     WUG ATTEMPTED ON TYPE 2 FILE
I16      EQU   X'10'     ATTEMPTED TO WRITE DATA OUTSIDE OF FILE EXTENT
I17      EQU   X'11'     ATTEMPTED TO WRITE INDICES OUTSIDE OF FILE
*                         EXTENT
I18      EQU   X'12'     FILE ID.(APPLICATION'S PROGRAM DATA AREA) NOT
*                         EQUAL TO FILE SPECIFICATIONS
I19      EQU   X'13'     WAG ATTEMPTED ON TYPE 2 FILE
I20      EQU   X'14'     WAG ATTEMPTING TO ADD A RECORD WHOSE KEY
*                         DUPLICATES A KEY IN THE FILE
I21      EQU   X'15'     WDG ATTEMPTED ON TYPE 2 FILE
I22      EQU   X'16'     SSA ATTEMPTED ON TYPE 1 FILE
I23      EQU   X'17'     RSA ATTEMPTED ON TYPE 1 FILE
I24      EQU   X'18'     WUA ATTEMPTED ON TYPE 1 FILE
I25      EQU   X'19'     WAA ATTEMPTED ON TYPE 1 FILE
I26      EQU   X'1A'     MORE THAN ONE OPI
I27      EQU   X'1B'     SET SEQUENTIAL BEGINS WITH NEXT KEY
I28      EQU   X'1C'     FILE FULL
I29      EQU   X'1D'     END OF FILE
I30      EQU   X'1E'     SQA ATTEMTED ON TYPE 1 FILE
         EJECT
***********************************************************************
*        EQUATES AND LITERALS POOL    ( CONT'D )                      *
***********************************************************************
         SPACE 1
I31      EQU   X'1F'     ATTEMPTED WRITE ON UNRESERVED FILE
I32      EQU   X'20'     FKG EXCEEDED UPPER LIMIT OF FILE, R.NOT FOUND
I33      EQU   X'21'     FKG ATTEMPTED ON A TYPE 2 FILE
I34      EQU   X'22'     FKG RECORD DELETED FROM FILE
I35      EQU   X'23'     INDICES DON'T EXIST
I36      EQU   X'24'
I37      EQU   X'25'
I38      EQU   X'26'
I39      EQU   X'27'
I40      EQU   X'28'
I41      EQU   X'29'
I42      EQU   X'2A'
I43      EQU   X'2B'
I44      EQU   X'2C'
         SPACE 2
BLANK    EQU   X'40'
         SPACE 2
ENABLE   EQU   *                                                   BXL
         LTORG
         END
