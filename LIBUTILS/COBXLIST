HHH7     TITLE 'COBOL CROSS REFERENCE LISTING PROGRAM'
         ISEQ  73,80
         SPACE 20
*        COBOL CROSS-REFERENCE IN FORMAT OF ALP CROSS-REFERENCE
         SPACE 6
*        AUTHOR:  HOWARD H HUTCHISON
         SPACE 2
*        DATE:  MAY 22, 1967
         SPACE 2
*        DIRECT INQUIRIES TO:  HOWARD HUTCHISON
*                              IBM
*                              2830 VICTORY PARKWAY
*                              CINCINNATI, OHIO    45206
         SPACE
*                              (513) 751-6500
         EJECT
         SPACE 10
*      ***** TABLE OF CONTENTS *****
         SPACE
*      DOCUMENTATION REQUIRED (TYPE III)
*          CARD DECK KEY                     3
*          PROGRAM ABSTRACT                  4
*          USER INFORMATION
*              DETAILED PROGRAM DESCRIPTION
*                  PURPOSE                   5
*                  ADVANTAGES                5
*                  PROGRAM REQUIRMENTS       5
*                  SYSTEM CONFIGURATION      5
*                  TIMING                    5
*              PROGRAM MODIFICATION AIDS     5
*              INPUT-OUTPUT DESCRIPTION      6
*              SAMPLE PROBLEM                6
*          OPERATING INSTRUCTIONS            7
*          SYSTEM MATERIAL                   8
*      BASIC PROGRAM
*          PURPOSE                           9
*          USER FURNISHED PARAMETERS        10
*          ERROR MESSAGES                   11
*          INPUT/OUTPUT REQUIRMENTS         12
*          CURRENT LINITATIONS              13
*          RECOMMENDED CHANGES              13
*          EXECUTION TIME REQUIRMENTS       14
*          ASSEMBLY TIME REQUIRMENTS        15
*          PROGRAM STATEMENTS               15
*          SAMPLE PROGRAM OUTPUT           16
         EJECT
         SPACE 10
*      ***** CARD DECK KEY *****
         SPACE
*      1. ASSEMBLER SOURCE STATEMENTS;
*             SEQUENCE NUMBER IN CC 76-80
*                 (CC 76,78-80 NUMERIC)
*                 (CC 77 ALPHANUMERIC),
*             IDENTIFICATION OF 'HHH' IN CC 73-75,
*             1522 CARDS.
         SPACE
*      2. SAMPLE PROBLEM INPUT;
*             SEQUENCE NUMBER IN CC 77-80,
*             IDENTIFICATION OF 'HHH9' IN CC 73-76,
*             61 CARDS.
         SPACE
*      3. OBJECT DECK;
*             (FOR USER'S WHO DO NOT WISH TO RECOMPILE)
*             SEQUENCE NUMBER IN CC 77-80,
*             IDENTIFICATION OF 'HHH8' IN CC 73-76,
*             183 CARDS.
         SPACE 13
*                              PAGE 3
         EJECT
         SPACE 2
*      ***** PROGRAM ABSTRACT *****
         SPACE
*      THE COBOL LANGUAGE PROVIDES EXCELLENT DOCUMENTATION AND
* DEBUGGING AIDS EXCEPT FOR THE LACK OF A CROSS-REFERENCE LISTING.
* BECAUSE MANY PROGRAMMERS FOUND THE CROSS-REFERENCE A VALUABLE TOOL
* FOR DEBUGGING AND DOCUMENTING WHILE WORKING WITH OTHER LANGUAGES,
* THIS PROGRAM WAS WRITTEN TO FILL THAT NEED.
*
*      THIS PROGRAM FIRST LISTS THE INPUT SOURCE DECK AND ASSIGNS A
* SEQUENTIAL NUMBER.  THE STATEMENTS THAT COME FROM A PARTITIONED DATA
* SET AS THE RESULT OF A 'COPY' OR 'INCLUDE' ARE FLAGGED WITH AN
* ASTERISK.  ALSO, COBOL RESERVED WORDS USED BY PROGRAMMERS AS USER
* ASSIGNED NAMES ARE FLAGGED AS ERRORS.
*
*      THE SECOND PART OF THE OUTPUT IS AN ALPHABETICAL LISTING OF EACH
* USER NAME FOLLOWED BY:  1) HOW THE NAME WAS DEFINED, I.E., 'FD',
* '01', OR 'PN' (FOR PROCEDURE NAME);  2) THE SEQUENCE NUMBER OF THE
* SOURCE CARD THAT DEFINED THE NAME;  AND,  3) THE SEQUENCE NUMBER OF
* THE SOURCE CARDS IN WHICH THE NAME WAS USED.
         SPACE 2
*      THIS PROGRAM AND ITS DOCUMENTATION WERE WRITTED BY AN IBM
* EMPLOYEE.  THEY HAVE BEEN SUBMITTED TO THE PROGRAM INFORMATION
* DEPARTMENT FOR GENERAL DISTRIBUTION IN THE EXPECTATION THAT THEY
* MAY PROVE USEFUL TO OTHER MEMBERS OF THE DATA PROCESSING COMMUNITY.
* THE PROGRAM AND ITS DOCUMENTATION ARE, ESSENTIALLY, IN THE AUTHOR'S
* ORIGINAL FORM AND HAVE NOT BEEN SUBJECTED TO ANY FORMAL TESTING.
* IBM ONLY SERVES AS THE DISTRIBUTION AGENCY IN SUPPLYING THIS
* PROGRAM.  IT IS THE USER'S RESPONSIBILITY TO DETERMINE THE USEFULNESS
* AND TECHNICAL ACCURACY OF THE PROGRAM IN HIS OWN ENVIROMENT.  THIS
* PROGRAM IS NOT PART OF THE IBM PRODUCT LINE AS ARE PROGRAMMING
* SYSTEMS (TYPE I) AND APPLICATION PROGRAMS (TYPE II).
*
*      QUESTIONS CONCERNING THE USE OF THE PROGRAM SHOULD BE DIRECTED
* TO THE AUTHOR.  ANY CHANGES TO THE PROGRAM WILL BE REFLECTED IN THE
* APPROPRIATE CATALOG OF PROGRAMS; HOWEVER, THE CHANGES WILL NOT BE
* DISTRIBUTED AUTOMATICALLY TO USERS.
*
*      THE PROGRAM IS WRITTED IN ASSEMBLER LANGUAGE AND WAS DESIGNED TO
* RUN UNDER OS/360.
         SPACE 5
*                              PAGE 4
         EJECT
         SPACE 10
*      ***** USER INFORMATION *****
         SPACE 2
*      A. DETAILED PROGRAM DESCRIPTION.
         SPACE
*           1) PURPOSE:  THE PROGRAM WAS DESIGNED TO AID THE PROGRAMMER
*      WHEN DEBUGGING BY CROSS-REFERENCING ALL USER DEFINED NAMES.
         SPACE
*           2) ADVANTAGES:
*                A)  THIS TOOL IS NOT AVAILABLE WITH THE TYPE I COBOL
*                    COMPILER.
*                B)  COBOL-WORDS USED AS DATA-NAMES OR PROCEDURE-NAMES
*                    ARE FLAGGED AS ERRORS (THE COBOL E COMPILER DOES
*                    NOT DO THIS).
*                C)  THE METHOD AND LEVEL OF DEFINITION ARE LISTED
*                    (SUCH AS '01', '77', OR 'PN' (FOR PROCEDURE-NAME))
*                    AS WELL AS THE STATEMENT SEQUENCE NUMBER DEFINING
*                    THE NAME.
         SPACE
*           3) PROGRAM REQUIRMENTS:  THE SOURCE STATEMENTS MUST BE
*      ASSEMBLED WITH THE OS/360 ASSEMBLY LANGUAGE TRANSLATOR AND THE
*      PROGRAM MUST BE EXECUTED UNDER CONTROL OF OS/360.
         SPACE
*           4) SYSTEM CONFIGURATION:  MINIMUM SYSTEM TO SUPPORT OS/360.
         SPACE
*           5) TIMING:  THE TIME REQUIRED TO EXECUTE THIS PROGRAM WITH
*      AN INPUT OF 1008 COBOL SOURCE CARDS WAS 139 SECONDS.
         SPACE 2
*      B. PROGRAM MODIFICATIONS AIDS.
         SPACE
*      THIS PROGRAM WAS WRITTED TO FACILITATE CERTAIN CHANGES.  THE
* VARIOUS VALUES THAT THE AUTHOR FELT WERE LIKLY TO BE CHANGED FOR
* DIFFERENT INSTALLATIONS WERE GROUPED ON ONE PAGE AS 'EQU' STATEMENTS.
* SEE THE DISCUSSION TITLED 'USER FURNISHED PATAMETERS' ON PAGE 10 AND
* THE ASSEMBLER 'EQU' STATEMENTS ON PAGE 15.
         SPACE
*                              PAGE 5
         EJECT
*      C. INPUT-OUTPUT DESCRIPTION.
         SPACE 2
*           1) PRIMARY INPUT (REQUIRED):
*              DATA SET CONTENTS = COBOL SOURCE STATEMENTS;
*              DEVICE = CARDS, TAPE, OR DISK;
*              ORGANIZATION = SEQUENTIAL OR PARTITIONED;
*              BLOCKING FACTOR = 1.
         SPACE
*           2) SUPPLEMENTAL INPUT (OPTIONAL):
*              DATA SET CONTENTS = COBOL SOURCE STATEMENTS;
*              PURPOSE = FULLFILL THE REQUIRMENTS OF THE 'COPY' OR
*                        'INCLUDE' IF PRESENT IN PRIMARY INPUT COBOL
*                        SOURCE STATEMENTS;
*              DEVICE = DISK;
*              ORGANIZATION = PARTITIONED;
*              BLOCKING FACTOR = 1.
         SPACE
*           3) PRIMARY OUTPUT (REQUIRED):
*              DATA SET CONTENTS = (FIRST HALF) LISTING OF THE INPUT
*                                  WITH ASSIGNED SEQUENTIAL NUMBERS;
*                                = (SECOND HALF) CROSS REFERENCE
*                                  LISTING;
*              DEVICE = PRINTER, TAPE, OR DISK;
*              ORGANIZATION = SEQUENTIAL;
*              BLOCKING FACTOR = 1.
         SPACE
*           4) SECONDARY OUTPUT (OPTIONAL):
*              DATA SET CONTENTS = 80/80 COPY OF THE PRIMARY INPUT DATA
*                                  SET;
*              PURPOSE = TO PERMIT A CARD SOURCE STATEMENT USER TO
*                        FOLLOW THIS PROGRAM WITH A COMPILATION WITHOUT
*                        REQUIRING A SECOND PASS OF THE SOURCE CARDS;
*              DEVICE = TAPE OR DISK;
*              ORGANIZATION = SEQUENTIAL;
*              BLOCKING FACTOR = 1.
         SPACE 2
*      D. SAMPLE PROBLEM.
         SPACE
*          THE SAMPLE PROBLEM IS A COBOL SOURCE LANGUAGE DECK.  THIS
* COBOL PROGRAM IS ONLY TO SERVE AS SAMPLE INPUT TO THE CROSS-REFERENCE
* PROGRAM AND MAY NOT BE EXECUTABLE.  SEE PAGE 83 FOR THE SAMPLE
* PROBLEM OUTPUT (THE OUTPUT CONTAINS A LISTING OF THE INPUT SO NO
* SEPERATE INPUT LISTING WAS PROVIDED).
         SPACE 2
*                              PAGE 6
         EJECT
         SPACE 10
*      ***** OPERATING INSTRUCTIONS *****
         SPACE 2
*      THE OPERATING INSTRUCTIONS ARE BROKEN DOWN INTO TWO CATAGORIES;
* FIRST THE ASSEMBLY TIME REQUIRMENTS, AND SECOND THE EXECUTION TIME
* REQUIRMENTS.
         SPACE 2
*      ASSEMBLY TIME REQUIRMENTS:
         SPACE
*      THE PROGRAM MAY BE ASSEMBLED AND EXECUTED AS IT IS.  HOWEVER,
* TO TAKE ADVANTAGE OF DIFFERENT MACHINE CONFIGURATIONS (SUCH AS CORE
* SIZE GREATER THAN MODEL 'F' OR TAPES TO PERMIT GREATER BLOCKSIZE ON
* THE UTILITY DATA SETS), THE USER SHOULD READ THE SECTION TITLED
* 'PROGRAM MODIFICATIONS AIDS' (SEE PAGE 5)  AND STUDY THE ASSEMBLER
* 'EQU' STATEMENTS AND COMMENTS ON PAGE 15.
         SPACE 2
*      EXECUTION TIME REQUIRMENTS:
         SPACE
*      AN EXAMPLE OF JCL  REQUIRMENTS FOR EXECUTION ARE:
* //STEPNAME EXEC PGM=HHH70000 (OR USER'S ASSIGNED NAME)
* //SYSABEND DD SYSOUT=A
* //HHHPRINT DD SYSOUT=A
* //SYSLIB   DD DSNAME=(NAME OF USER'S PDS USED FOR 'COPY' & 'INCLUDE')
* //HHHUT1   DD UNIT=SYSSQ,SPACE=(CYL,(5,1))
* //HHHUT2   DD UNIT=SYSSQ,SPACE=(CYL,(5,1))
* //HHHUT3   DD DUMMY
* //SYSIN    DD *
* (COBOL SOURCE STATEMENTS)
* /*
         SPACE
*      THE SPECIFICS OF EACH OF THESE DATA SETS ARE DISCUSSED IN THE
* SECTION TITLED 'INPUT-OUTPUT DESCTIPTION' (SEE PAGE 6)  AND THE
* ASSEMBLER LISTING PAGE TITLED 'EXECUTION TIME REQUIRMENTS' (SEE PAGE
* 14).
         SPACE
*                              PAGE 7
         EJECT
         SPACE 10
*      ***** SYSTEMS MATERIAL *****
         SPACE
*      THIS PROGRAM IS DELIVERED AS ASSEMBLY LANGUAGE SOURCE STATEMENTS
* AND MUST BE ASSEMBLED PRIOR TO USE.  THIS DOCUMENT ITSELF IS THE
* PROGRAM LISTING AND (BECAUSE IT WAS A COMPILE, LOAD, AND GO), IS
* FOLLOWED BY THE LISTING OF THE SAMPLE PROBLED OUTPUT.  BECAUSE THE
* SAMPLE PROBLEM INPUT IS LISTED AS A NORMAL PART OF THE OUTPUT, NO
* SEPERATE LISTING OF THE SAMPLE PROBLEM INPUT IS FURNISHED.
         SPACE 29
*                              PAGE 8
         EJECT
         ISEQ  73,80
         SPACE
*        VERSION 1, MODIFICATION LEVEL 2         07/18/67
         SPACE
HHH70000 CSECT
         SPACE 10
* PURPOSE:     THIS PROGRAM WILL OUTPUT A DATA SET, SUITABLE FOR
*        PRINTING, WHICH IS A CROSS-REFERENCE LISTING OF A COBOL
*        PROGRAM.  THE OUTPUT IS SIMILAR IN FORMAT TO THE CROSS-
*        REFERENCE LISTING FURNISHED BY THE ALP ASSEMBLER.  THE OUTPUT
*        OF THIS PROGRAM IS:
*           FIRST - A LISTING (80/80) OF THE SOURCE STATEMENTS AND AN
*              ASSIGNED SEQUENTIAL NUMBER.  AN '*' IS PRINTED BETWEEN
*              THE SEQ NUMBER AND THE CARD IMAGE IF THE SOURCE
*              STATEMENT IS A RESULT OF A 'COPY' OR 'INCLUDE'.
*           SECOND - A LISTING OF:
*              1) THE COBOL NAME;
*              2) HOW IT WAS DEFINED, I.E.,'FD', '03', OR 'PN' FOR A
*                 PROCEDURE (SECTION OR PARAGRAPH) NAME, ETC;
*              3) THE SEQUENTIAL NUMBER OF THE CARD IN WHICH IT WAS
*                 DEFINED;
*              4) THE SEQUENTIAL NUMBER OF THE CARD IN WHICH THE NAME
*                 WAS USED.
         SPACE 15
*                              PAGE 9
         EJECT
         SPACE 10
* USER FURNISHED PARAMETERS:
*
*              SEVERAL PARAMETERS MAY BE CHANGED AT ASSEMBLY TIME.
*        THIS IS DONE BY USING 'EQU' STATEMENTS.  SEE 'USER FURNISHED
*        PARAMETERS' IN THE PROGRAM SECTION BELOW.  THESE VARIABLES
*        ARE:
*
*              1) 'MAXLINES'  THE USER FURNISHES THE NUMBER OF LINES
*                 TO BE PRINTED ON EACH PAGE OF OUTPUT.
*
*              2) 'MAXNAME'  THE USER FURNISHES THE THE MAXIMUM LENGTH
*                 OF HIS COBOL NAMES.  THIS VALUE CANNOT BE GREATER '
*                 THAN 30.  IF THE USER EXCERCISES THE OPTION TO EQUATE
*                 THIS TO LESS THAN 30, THIS PROGRAM MAY EXECUTE
*                 FASTER.
*
*              3) 'UTMAXBS'  THE USER FURNISHES THE DESIRED MAXIMUM
*                 BLOCK SIZE (IN BYTES) FOR THE UTILITY DATA SETS 1
*                 AND 2.
*
*              4) 'UT3MAXBS'  THE USER FURNISHES THE DESIRED MAXIMUM
*                 BLOCK SIZE (IN BYTES) FOR THE UTILITY 3 DATA SET.
*
*              5) 'ARRAYLGH'  THE USER FURNISHES THE DESIRED LENGTH FOR
*                 THE SEQUENCING ARRAY.
         SPACE 12
*                              PAGE 10
         EJECT
         SPACE 5
* ERROR MESSAGES:
*
*              SEVERAL CONDITIONS WILL CAUSE ERROR MESSAGES TO BE SENT
*        TO THE OUTPUT DATA SET (NORMALLY THE PRINTER).  THESE ERROR
*        MESSAGES WILL APPEAR IMMEDIATELY FOLLING THE CARD IMAGE WHICH
*        RAISED THE ERROR CONDITION.  THESE MESSAGES FLAG:
*
*              1) A NAME THAT EXCEEDS 30 CHARACTERS, THE MAXIMUM COBOL
*                 PERMITS.  WHEN THIS CONDITION IS FOUND, THE REST OF
*                 THE CARD IMAGE IS IGNORED.
*
*              2) A NAME THAT IS LONGER THAN THE USER SPECIFIED MAXIMUM
*                 NAME LENGTH.  WHEN THIS CONDITION IS FOUND THE NAME
*                 IS TRUNCATED TO THE LENGTH SPECIFIED BY THE USER AS
*                 THE MAXIMUM LENGTH.
*
*              3) A COBOL WORD USED AS A DATA-NAME OR PROCEDURE-NAME.
*
*              4) A MEMBER OF A PDS, NAMED FOLLOWING A 'COPY' OR
*                 'INCLUDE', COULD NOT BE FOUND IN THE DIRECTORY OF THE
*                 PDS NAMED IN THE DD CARD NAMED 'HHHSYSLB'.
*
*              5) AN I/O ERROR WAS DETECTED WHEN SEARCHING THE
*                 DIRECTORY OF THE PDS POINTED TO BY THE DD CARD
*                 NAMED 'HHHSYSLB'.
*
*              TWO ERROR CONDITIONS WILL BE FLAGGED IN THE CROSS-
*              REFERENCE LISTING.
*
*              1) IF A COBOL NAME IS USED BUT NOT DEFINED, 'UNDEFINED'
*                 WILL BE PRINTED IN THE FIELD NORMALLY CONTAINING THE
*                 DEFINING SEQUENCE NUMBER.
*
*              2) IF A COBOL NAME IS DEFINED TWICE, 'DUPLICATE' WILL BE
*                 PRINTED BESIDE THE SEQUENCE NUMBER OF WHERE IT WAS
*                 FIRST DEFINED.  BECAUSE IT IS LEGAL IN COBOL TO HAVE
*                 DUPLICATE NAMES (WHICH REQUIRES QUALIFICATION), THIS
*                 CONDITION WILL NOT ADD TO THE ERROR COUNTER
*
*
*              THIS PROGRAM DOES NOT CHECK FOR SYNTAX ERRORS.
         SPACE
*                              PAGE 11
         EJECT
         SPACE 10
* INPUT/OUTPUT REQUIREMENTS:
*
*              SIX DATA SETS ARE USED BY THIS PROGRAM.  THE CHARACTER-
*              ISTICS OF EACH OF THESE DATA SETS ARE:
*
*              1) PRIMARY INPUT - THE COBOL SOURCE STATEMENTS ARE
*                 ENTERED VIA THIS DATA SET.
*
*              2) SUPPLEMENTAL INPUT - THIS DATA SET IS USED TO
*                 FULLFILL THE REQUIRMENTS OF THE 'COPY' OR 'INCLUDE'
*                 IF PRESENT IN THE COBOL SOURCE STATEMENTS.
*
*              3) PRIMARY OUTPUT -  AN 80/80 LISTING OF THE SOURCE
*                 STATEMENTS WITH THE ASSIGNED SEQUENTAL NUMBER AND
*                 THE CROSS REFERENCE LISTING.
*
*              4) SECONDARY OUTPUT - AN 80/80 COPY OF THE PRIMARY
*                 INPUT DATA SET.  THIS DATA SET WAS INCLUDED FOR
*                 USERS WHOSE SOURCE PROGRAMS ARE IN CARDS.  THIS DATA
*                 SET CAN BE USED AS INPUT TO A COMPILATION FOLLOWING
*                 THIS PROGRAM, THEREBY, ELIMINATING THE NEED TO PASS
*                 THE SOURCE CARDS A SECOND TIME
*
*              5) A UTILITY DATA SET USED TO DUMP THE SEQUENCED NAME
*                 ARRAY IF THE LIMITS OF THE ARRAY ARE EXCEEDED.
*                 (NOTE: IF AVAILABLE, A DIRECT ACCESS DEVICE SHOULD
*                  BE USED)
*
*              6) A UTILITY DATA SET WHOSE FUNCTION IS THE SAME AS 5
*                 ABOVE
         SPACE 7
*                              PAGE 12
         EJECT
         SPACE 10
* CURRENT LIMITATIONS
*
*        1) ENVIRONMENT DIVISION - CONFIGURATION SECTION.  MNEMONIC-
* NAMES ASSIGNED IN THE SPECIAL-NAMES PARAGRAPH WILL BE FLAGGED AS
* UNDEFINED.
*
*        2) ENVIRONMENT DIVISION - INPUT-OUTPUT SECTION.  DATA-NAMES,
* SECTION-NAMES, SAVE-AREA-NAMES, AND FILE-NAMES USED IN THIS SECTION
* WILL NOT BE LISTED IN THE CROSS-REFERENCE LISTING.  THE OVERFLOW-
* NAME ASSIGNED IN THE OPTION 2 APPLY CLAUSE WILL BE FLAGGED AS
* UNDEFINED.
*
*        3) WHEN COPY (OR INCLUDE) IS USED, THE DATA-NAME (OR SECTION-
* OR PARAGRAPH-NAME) PRECEEDING THE COPY (OR INCLUDE) IS DEFINED AS
* WELL AS THE FIRST DATA-NAME (OR SECTION- OR PARAGRAPH-NAME) FOUND IN
* THE NAMED PDS MEMBER.  IF THE DATA-NAMES (OR SECTION- OR PARAGRAPH-
* NAMES) ARE IDENTICAL, THE FIRST WILL BE FLAGGED AS A DUPLICATE.
*
*        4) THE COBOL WORD 'OBJECT-COMPUTER' WILL NOT BE FLAGGED AS A
* COBOL WORD.  THIS WORD WAS REMOVED FROM THE LIST OF 256 COBOL WORDS
* TO PERMIT A BALANCED BINARY SEARCH.
         SPACE
*        5) THE DIVISION HEADINGS MUST START IN CARD COLUMN 8.
         SPACE 4
* RECOMMENDED CHANGES
*
* 1. ELIMINATE CURRENT RESTRICTIONS.
* 2. PROGRAM TO PERMIT ARRAY-LENGTH CHANGE VIA 'PARM' IN EXEC CARD.
* 3. PROGRAM TO PERMIT MAXIMUM-USER-NAME-LENGTH CHANGE VIA 'PARM' IN
*    EXEC CARD.
         SPACE 4
*                              PAGE 13
         EJECT
         SPACE 10
*        EXECUTION TIME REQIRMENTS <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
         SPACE
*              USER MUST FURNISH FOLLOWING JCL:
         SPACE
*        DDNAME=HHHINPUT     REQUIRED - PRIMARY INPUT (SEQ OR PARTITION
*        DDNAME=HHHSYSLB     OPTIONAL - FOR 'COPY' OR 'INCLUDE' (PDS)
*        DDNAME=HHHPRINT     REQUIRED - PRIMARY OUTPUT (PRINTER)
*        DDNAME=HHHUT1       REQUIRED - UTILITY (SEQ - FOR SORT)
*        DDNAME=HHHUT2       REQUIRED - UTILITY (SEQ - FOR SORT)
*        DDNAME=HHHUT3       REQUIRED - UTILITY (SEQ - 80/80 OF PRIMARY
*                                       INPUT, 'HHHINPUT', FOR USERS
*                                       WHOSE INPUT IS IN CARDS.  THIS
*                                       DATA SET IS BUILT TO PERMIT A
*                                       COMPILATION TO FOLLOW THIS RUN
*                                       WITHOUT REQUIRING A SECOND PASS
*                                       OF THE SOURCE CARDS.  THIS MAY
*                                       BE 'DUMMY')
*        SYSABEND DD SYSOUT=A IS RECOMMENDED
         SPACE 19
*                              PAGE 14
         EJECT
         SPACE 10
*        ASSEMBLY TIME REQUIRMENTS <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
         SPACE
*              USER MUST FURNISH FOLLOWING VALUES:
         SPACE
MAXLINES EQU   57       LINES TO BE PRINTED PER PAGE
         SPACE
MAXNAME  EQU   30       MAXIMUM LENGTH OF USER NAME
*                       (CANNOT BE GREATER THAN 30)
         SPACE
UTMAXBS  EQU   2198     MAXIMUM BLOCK SIZE FOR UTILITIES 1 AND 2
*                       (ASSUME 2311)
         SPACE
UT3MAXBS EQU   80       MAXIMUM BLOCK SIZE FOR UTILITY 3
*                       (CANNOT BE BLOCKED FOR INPUT TO COBOL E)
         SPACE
ARRAYLGH EQU   22400    LENGTH OF ARRAY FOR SEQUENCING NAMES
*              ENTRIES = (ARRAYLENGTH / (MAXNAME + 4)) - 2
*              NOTE: MAXIMUM ARRAY LENGTH VARIES AS A FUNCTION OF;
*                    1) CORE SIZE, 2) NUCULES SIZE, AND 3) PROGRAM
*                    SIZE.  OF COURSE, PROGRAM SIZE WILL VARY AS A
*                    FUNCTION OF; 1) PROGRAM LOGIC SIZE (LESS ARRAY IS
*                    = 24A6(16) = 9382(10))  AND 2) JCL REQUIRMENTS.
*                    IF ALL DATA SETS ARE USED, AN ARRAY LENGTH,
*                    'ARRAYLGH', OF 10,000 MAY BE TO LARGE FOR A
*                    MODEL 'F'.
         SPACE 12
*                              PAGE 15
         EJECT
LENGTH   EQU   MAXNAME+4
MVCLENGT EQU   LENGTH-1                LENGTH OF RECORDS FOR 'EX' MOVE
CLRECL   EQU   LENGTH                  ESTABLISH RECORD LENGTH
BLKFACT  EQU   UTMAXBS/LENGTH          ESTABLISH MAX BLOCKING FOR UTIL
CBLKSIZE EQU   LENGTH*BLKFACT          ESTABLISH BLOCK SIZE
UT3BLKF  EQU   UT3MAXBS/80             ESTABLISH BLOCKING FACTOR UT3
UT3BLKSZ EQU   80*UT3BLKF              ESTABLISH BLOCKSIZE FOR UT3
         EJECT
* REGISTER USAGE
R0       EQU   0
R1       EQU   1    BINARY SEARCH - COMPARE VALUE
R2       EQU   2                  - INCREMENT FOR BINARY SEARCH
R3       EQU   3                  - DEVELOPED TABLE ADDRESS
R4       EQU   4    ADDRESS OF READ ROUTINE
R5       EQU   5    ADDRESS OF LAST INPUT (NEEDED IF FRESH COPY REQUIRE
R6       EQU   6    WORKING REGISTER - CARD AREA - FOR CHARACTER MOVE
R7       EQU   7    WORKING REGISTER - WORK AREA - FOR CHARACTER MOVE
R8       EQU   8
R9       EQU   9
R10      EQU   10   PUT LOGIC BASE REG & ENTRY ADDRESS
R11      EQU   11   INTERNAL RETURN
R12      EQU   12   BASE
R13      EQU   13
R14      EQU   14
R15      EQU   15
         EJECT
         PRINT ON,NODATA,NOGEN
         USING *,15
         SAVE  (14,12)                 STORE REGS IN CALLING MODULE
         LA    12,SAVEREG              LOAD ADDR OF THIS MODULE SAVE
         ST    12,8(13)                STORE ADDR IN CALLING MODULE
         ST    13,4(12)                STORE CALLING SAVE IN THIS MODUL
         LR    13,12                   SET THIS MODULE TO CALL
         BALR  12,0                    ESTABLISH ADDRESSABILITY
         USING *,12                    AND TELL ASSEMBLER
         SPACE 2
         OPEN  (CARDDCB,,PDSDCB,,PRTDCB,(OUTPUT),UT3DCB,(OUTPUT))
         LA    R4,QSAMGET              INITIALIZE READ-REG
         LA    R2,PRTPUT               INITIALIZE PRINTER ROUTINE BY
         BALR  R11,R2                  DUMMY PUT AND
         LA    R2,PRTLN                SAVE ADDR OF I/O AREA
         ST    R1,0(R2)                IN PRINT ROUTINE
         LA    R10,PUT                 SET BASE REG FOR PUT RTN
         LA    R1,CDIMGPRT             LOAD ADDR OF AN (ANY) AREA
         L     R15,=A(HHH80000)        LOAD ENTRY/BASE REG FOR DATE
         BALR  R14,R15                 GET DATE AS 'MM/DD/YY.JJJ'
         MVC   HDRDATE+5(6),CDIMGPRT+6 MOVE JULIAN DATE
         MVC   HDRDATE+14(8),CDIMGPRT  MOVE GREGORIAN DATE
         ST    R0,HOLDTIME
*              TIME IS STILL IN REG 0
         SRDL  R0,32(0)                SHIFT REG 0 TO REG 1
         D     R0,=F'36'               DIVIDE - QUOTIENT IN REG 1
         CVD   R1,DBLWD                TO PK  FRMT=X'000000000HH.1234+'
         UNPK  CDIMGPRT(6),DBLWD       TO ZONED  FRMT=C'HH123D'
         MVC   HDRTIME+7(2),CDIMGPRT   MOVE HOURS
         MVC   HDRTIME+10(3),CDIMGPRT+2 MOVE DECIMALS
         EJECT
* IDENTIFICATION DIVISION LOGIC ***************************************
P1D1     BAL   R11,RDWT                DO READ-WRITE
         CLC   =C'ENVIRONMENT ',CARD
         BNE   P1D1
         SPACE 5
* ENVIRONMENT DIVISION LOGIC *****  ***********************************
P1A3     BAL   R11,MOVE                DO MOVE
P1B3     CLC   =C'DATA ',WORK
         BE    P2A1
         CLC   =C'SELECT ',WORK
         BE    P1C4
         CLC   =C'SPECIAL-NAMES ',WORK
         BE    P1E3
         CLC   =C'FILE-CONTROL ',WORK
         BE    P1E3
         CLC   =C'I-O-CONTROL ',WORK
         BNE   P1A3
P1E3     BAL   R11,MOVE                CHECK FOR COPY
         CLC   =C'COPY ',WORK
         BNE   P1B3
         BAL   R11,CPYLBINT            INITIALIZE SYSLIB PDS FOR 'COPY'
         B     P1A3
P1C4     BAL   R11,MOVE                BYPASS FILE-NAME
         B     P1E3
         EJECT
* DATD DIVISION LOGIC *************************************************
P2A1     BAL   R11,RDWT
         BAL   R11,CONVERT
         BAL   R11,MOVE
         CLC   =C'PROCEDURE ',CARD
         BE    P2A3
P2D1     MVC   DDFLAG,WORK             SAVE (IN CASE DEFINER)
         CLC   =C'FD ',WORK            TEST FOR 'FD'
         BE    P2G1
         CLC   =C'SD ',WORK            TEST FOR 'SD'
         BE    P2G1
         CLC   =C'SA ',WORK            TEST FOR 'SA'
         BE    P2G1
         TM    WORK,X'F0'              TEST FOR NUMERIC
         BC    14,P2A1                 NOT FOUND
         TM    WORK+1,X'F0'            TEST SECOND POSITION FOR NUMERIC
         BC    14,P2A1                 NOT FOUND
         CLI   WORK+2,C' '             TEST THIRD POSITION FOR BLANK
         BNE   P2A1
P2G1     BAL   R11,MOVE                MOVE DATA-NAME
         CLC   =C'FILLER ',WORK
         BE    P2C2
         CNOP  0,4                     FORCE WORD ALIGNMENT
         BAL   R11,COBWDTST
         DC    A(P2K1)                 WORD FOUND
         DC    A(P2A2)                 WORD NOT FOUND
P2K1     MVC   MSG(54),MSG2            MOVE IN ERROR MESSAGE
         AP    ERRCTR,=P'1'            ADD ONE TO ERROR COUNTER
         LA    R1,ERRMSG
         BAL   R11,PRINTIT             GO TO PRINT ROUTINE
         B     P2A1
P2A2     MVC   FLAG,DDFLAG             FLAG AS DEFINING (W/ DEFINER)
P2B2     BALR  R11,R10                 BRANCH TO PUT ROUTINE
P2C2     BAL   R11,MOVE                THIS MAY FORCE READ
         CLC   =C'COPY ',WORK
         BNE   P2A5
         BAL   R11,CPYLBINT            INITIALIZE SYSLIB PDS FOR 'COPY'
         B     P2A1
P2A5     CLC   =C'REDEFINES ',WORK
         BNE   P2D1
         BAL   R11,MOVE                DO MOVE
         MVC   FLAG,=C'99'             FLAG AS REFERENCING
         CNOP  0,4
         BAL   R11,COBWDTST            DO COBOL WORD TEST
         DC    A(P2K1)                 WORD FOUND EXIT ADDRESS
         DC    A(P2B2)                 WORD NOT FOUND EXIT ADDRESS
DDFLAG   DC    C'XX'
         EJECT
* PROCEDURE DIVISION ROUTINE ******************************************
P2A3     LA    R6,EOCARD               FORCE END OF CARD CONDITION
         B     P2C3
P2B3     BALR  R11,R10                 BRANCH TO PUT ROUTINE
P2C3     BAL   R11,MOVE
         TM    WORK,X'F0'              TEST FOR NUMERIC
         BO    P2C3
         CLI   WORK,C'-'               CHECK FOR STAND ALONE DASH WHICH
         BE    P2C3                    WILL BE FOUND IN COMPUTE STATEME
         CLC   =C'INCLUDE ',WORK
         BE    P2E4
         CNOP  0,4
         BAL   R11,COBWDTST
         DC    A(P2H3)                 FOUND EXIT ADDRESS
         DC    A(P2B3)                 NOT FOUND EXIT ADDRESS
P2H3     CLI   FLAG,C'9'               IS WORD DEFINING (SECTION OR
         BE    P2C3                    PARA NAME)?  BRANCH ON NO
         MVC   MSG(54),MSG2            MOVE ERROR MESSAGE
         AP    ERRCTR,=P'1'            ADD ONE TO ERROR COUNTER
         LA    R1,ERRMSG
         BAL   R11,PRINTIT             GO TO PRINT ROUTINE
         B     P2C3
P2E4     BAL   R11,CPYLBINT
         B     P2C3
         SPACE 2
* END OF PHASE I LOGIC
PHASIEOD CLOSE (CARDDCB,)
         CLOSE (PDSDCB,,UT3DCB,REREAD)
         MVC   CX3,CX4                 SET END TEST ADDR = LEFT-MOST
         L     R1,CX4                  LOAD LEFT-MOST POINTER
         MVI   0(R1),X'01'             SET TO SHOW ARRAY FULL
         MVC   CX2,=A(PRTXREF)         SET PHYSICAL PUT TO PRINTER
         B     FINALENT                GO TO DISPOSE FOR LAST TIME
ERRCTR   DC    P'000'
LNSPRNED DC    P'0000'
         EJECT
* MOVE LOGIC **********************************************************
*        PURPOSE:  MOVE CHARACTER STRING FROM 'CARD' TO 'WORD'
MOVE     ST    R11,MOVEST              SAVE RETURN ADDRESS
MOVEA1   LA    R7,WORK                 INITIALIZE 'WORK' REGISTER
         MVI   WORK,C' '               BLANK RECEIVING FIELD
         MVC   WORK+1(29),WORK
         MVC   PREFLAG,=C'99'          FLAG AS REFERENCING
         B     MOVEC1
MOVEB1   LA    R6,1(R6)                INCREMENT SENDING REG
MOVEC1   CLI   0(R6),X'FF'             CHECK FOR END OF CARD
         BNE   MOVEE1                  BYPASS GETTING CARD
MOVED1   BAL   R11,RDWT                DO READ-WRITE
         BAL   R11,CONVERT             DO CONVERT
MOVEE1   CLI   0(R6),C' '              TEST FOR BLANK
         BE    MOVEB1
MOVEF1   MVC   0(1,R7),0(R6)           MOVE ONE CHARACTER
         LA    R7,1(R7)                INCREMENT RECEIVING REG
         LA    R6,1(R6)                INCREMENT SENDING REG
         CLI   0(R6),C' '              TEST FOR BLANK
         BE    MOVEJ1
         CLI   0(R6),X'FF'             TEST FOR END OF CARD
         BE    MOVEJ1
         CLI   0(R7),X'FF'             SEE IF 'WORK' EXCEEDED
         BNE   MOVEF1                  MOVE ANOTHER CHARACTER
         B     MOVEG2                  TO ERROR ROUTINE
MOVEJ1   CLC   =C'NOTE ',WORK
         BE    MOVEA3
         MVC   FLAG,PREFLAG
         L     R11,MOVEST
         BR    R11
*
MOVEST   DS    F
CARD     DS    CL65                    IMAGE OF CC 8 THRU 72
EOCARD   DC    X'FF'
WORK     DS    CL30
         DC    X'FF'
PREFLAG  DS    CL2
FLAG     DS    CL2
ERRMSG   DC    X'09'                   WRITE, SPACE 1 AFTER PRINT
         DC    C'ERROR   '
MSG      DC    54C'X'
         DC    59C'*'
MSG1     DC   C' NAME EXCEEDS THIRTY CHARACTERS - REST OF CARD IGNORED'
MSG2     DC   C'COBOL WORD USED AS DATA-NAME OR SECTION/PARAGRAPH NAME'
MSG5     DC    C'- TRUNCATED TO = MAXNAME'
         EJECT
MOVEG2   MVC   MSG(54),MSG1
         AP    ERRCTR,=P'1'            ADD ONE TO ERROR COUNTER
         LA    R1,ERRMSG
         BAL   R11,PRINTIT             GO TO PRINT ROUTINE
         B     MOVEA1
*
MOVEA3   CLI   FLAG,C'9'               WAS PREVIOUS CHARACTER STRING
         BE    MOVEA4                  A PARAGRAPH NAME?  BRANCH ON NO
* DELIMIT BY SECTION/PARAGRAPH NAME
MOVEB3   BAL   R11,RDWT
         CLI   CARD,C' '               CHECK FOR SECTION/PARA NAME
         BE    MOVEB3
MOVED3   BAL   R11,CONVERT             DO CONVERT
         MVI   WORK,C' '               BLANK RECEIVING FIELD
         MVC   WORK+1(29),WORK
         LA    R7,WORK                 INITIALIZE RECEIVING REG
         B     MOVEE1
* DELIMIT BY PERIOD OR SECTION/PARAGRAPH NAME
MOVEA4   MVC   CARD,7(R5)              MOVE UNCONVERTED IMAGE OF CARD
         LA    0,EOCARD                ADDR OF END OF CARD
         B     MOVEC4
MOVEB4   LA    R6,1(R6)                INCREMENT 'CARD' REG
MOVEC4   CR    R0,R6                   TEST FOR END OF CARD
         BE    MOVED4
         CLI   0(R6),C'.'              TEST FOR DELIMITING PERIOD
         BNE   MOVEB4
         B     MOVED3
MOVED4   L     R3,=A(TRTTBL)           GET ADDREST OF TRT TABLE
         MVI   125(R3),X'00'           REMOVE QUOTE FROM TRT
         MVI   75(R3),X'FF'            PUT PERIOD IN TRT TABLE
MOVED4A  BAL   R11,RDWT
         CLI   CARD,C' '               CHECK FOR SECTION/PARAGRAPH NAME
         BNE   MOVEJ4
         TRT   CARD,0(R3)              CHECK FOR PERIOD
         BC    8,MOVED4A               BRANCH NOT FOUND
         LR    R6,R1                   ADDR OF PERIOD
MOVEJ4   MVI   125(R3),X'FF'           REPLACE QUOTE IN TRT TABLE
         MVI   75(R3),X'00'            REMOVE PERIOD FROM TRT TABLE
         B     MOVED3
         EJECT
* READ WRITE LOGIC ****************************************************
RDWT     ST    R11,RDWTST
         BALR  R11,R4                  GET NEXT LOGICAL RECORD
         LA    R2,CDIMGPRT             ADDRESS OF CD IMAGE IN PRINT ARE
         MVC   0(80,R2),0(R1)          MOVE CARD IMAGE TO PRINT LINE
         BAL   R11,TSTSEQ              TEST USER SEQUENCING
         MVC   CARD,7(R1)              CARD IMAGE (CC8-72) TO 'CARD'
         LR    R5,R1                   SAVE ADDRESS OF CARD IMAGE
         LA    R6,CARD                 INITIALIZE CARD AREA WORK REG
         CLI   CARD,C' '               TEST FOR PARAGRAPH NAME
         BNE   FLGDEFN
         MVC   PREFLAG,=C'99'          FLAG AS REFERENCING
RDWTRET  AP    SEQNOP,=P'1'            ADD 1 TO SEQ CTR
         LA    R2,SEQNOD               LOAD ADDR OF ZONED SEQ NUMBER
         UNPK  0(4,R2),SEQNOP          MOVE SEQ NO (PACKED) TO (ZONED)
         OI    3(R2),X'F0'             REMOVE STD SIGN
         CVB   R1,SEQNOP               SEQ NUMBER TO PUT RTN
         LA    R2,SEQNOB               ADDR OF BINARY SEQ NO
         STH   R1,0(R2)                SAVE BINARY SEQ NUMBER
         LA    R1,PRTLINE              ADDR OF DESIRED OUTPUT
         BAL   R11,PRINTIT             GO TO PRINT ROUTINE
         L     R11,RDWTST
         MVC   PRTLINE+109(10),PRTLINE+108  CLEAR (MAYBE) CORE COUNTER
         BR    R11
*
FLGDEFN  MVC   PREFLAG,=C'PN'          FLAG AS PROCEDURE(SEC/PARA) NAME
         B     RDWTRET
*
         DS    0D
SEQNOP   DC    P'000000000000000'      SEQUENCE COUNTER (PACKED)
SEQNOB   DS    H                       SEQUENCE NUMBER - BINARY
RDWTST   DS    F
         SPACE 3
*        PURPOSE   TEST SEQUENCE NUMBERING IN USERS SOURCE CODING.
TSTSEQ   EQU   *
         ST    R11,TSTSEQST            STORE RETURN REG
         CLI   CPYLBFLG,C'*'           IS IT A PDS ENTRY
         BE    TSTBYPS                 YES. BYPASS SEQUENCE TEST
         MVI   CPYLBFLG,C' '           CLEAR SEQUENCE ERROR FLAG
         CLC   TSTHOLD,0(R2)           COMPARE SEQUENCE
         BL    TSTOK                   OK IF PREVIOUS IS LOW
         MVI   CPYLBFLG,C'S'           NOTE BAD SEQUENCE
         AP    ERRCTR,=P'1'            ADD ONE TO ERROR COUNTER
TSTOK    EQU   *
         MVC   TSTHOLD,0(R2)           SAVE SEQNO FOR COMPARE TO NEXT
TSTBYPS  EQU   *
         L     R11,TSTSEQST            RESTORE RETURN REG
         BR    R11                     RETURN TO CALLER
TSTSEQST DS    F
TSTHOLD  DC    X'000000000000'
         ISEQ
         ISEQ  73,80
         EJECT
* PRIMARY INPUT LOGIC *************************************************
QSAMGET  L     R1,=A(CARDDCB)
         GET   (1)
         LR    R2,R1                   SAVE I/O ADDR
         L     R1,=A(UT3DCB)
         PUT   (1)
         MVC   0(80,R1),0(R2)          MOVE CARD IMAGE TO UTILITY 3
         LR    R1,R2                   PUT INPUT I/O ADDRESS IN REG 1
         BR    R11
         SPACE 2
* CONVERT LOGIC *******************************************************
CONVERT  L     1,=A(TRTTBL)
         TRT   CARD,0(R1)              TEST FOR QUOTE
         BC    8,TRANS                 NO QUOTE FOUND
         LA    0,CARD+65               LOAD END OF CARD ADDRESS
BLANKIT  MVI   0(1),C' '               MOVE BLANK TO FIRST QUOTE
         LA    1,1(1)                  INCREMENT REG 1
         CR    0,1                     TEST FOR END OF CARD
         BE    TRANS
         CLI   0(1),X'7D'              TEST FOR QUOTE
         BNE   BLANKIT                 LOOP AGAIN
         MVI   0(1),C' '
         B     CONVERT                 TEST FOR SECOND SET OF QUOTES
*
TRANS    L     1,=A(TRTBL)
         TR    CARD,0(R1)              ALL BUT A-Z, 0-9, & '-' TO X'40'
         BR    11
         EJECT
* COBOL WORD SEARCH - BINARY SEARCH ***********************************
*        UPON ENTRY, REG 11 MUST POINT TO ADCON LIST.  IF COBOL WORD
*        FOUND, CONTROL WILL BE PASSED TO ADDRESS POINTED TO BY REG 11.
*        IF COBOL WORD NOT FOUND, CONTROL WILL BE PASSED TO ADDRESS
*        POINTED TO BY REG 11 PLUS FOUR.
COBWDTST CLI   WORK+15,C' '            TEST FOR BLANK IN POS 16
         BNE   NOTCOBWD
         LM    0,2,INITIAL             REG 0 = 8
*                                      REG 1 = 2048
*                                      REG 2 = ADDRESS OF TABLE(MIDDLE)
EOL      CR    R0,R1                   TEST FOR END OF LOOP
         BE    NOTCOBWD
         SRA   1,1(0)                  SHIFT - DIVIDE BY TWO
         CLC   0(15,2),WORK            COMPARE TABLE AND ARGUMENT
         BE    YESCOBWD
         BH    TBLHI                   BRANCH IF TABLE HIGH
         AR    2,1                     ADD INCREMENT
         B     EOL
TBLHI    SR    2,1                     SUBTRACT INCREMENT
         B     EOL
*
YESCOBWD L     11,0(11)                FOUND EXIT
         BR    11
*
NOTCOBWD L     11,4(11)                NOT FOUND EXIT
         BR    11
*
INITIAL  DC    F'8'
         DC    F'2048'
         DC    A(COBWDS)
         EJECT
* SYSLIB (COPYLIB) ROUTINES *******************************************
CPYLBINT ST    R11,PDSST               SAVE RETURN ADDRESS
         MVC   CARD,7(R5)              GET FRESH COPY OF CARD IMAGE
         BAL   R11,MOVE                GET MEMBER NAME
         L     R1,=A(TRTBL)            REMOVE QUOTES
         TR    WORK,0(R1)
         LA    R6,EOCARD               FORCE END OF CARD CONDITION
         MVC   PDSIO(8),WORK+1         MOVE MEMBER NAME
         L     R1,=A(PDSDCB)           LOAD ADDR OF DCB
         FIND  (1),PDSIO,D             PG 189 CPS
         STC   R15,EXCOND              ISOLATE EXCEPTIONAL RETURN
         TM    EXCOND,X'0C'
         BC    7,CLIERR                BRANCH IF ONES OR MIXED
         LA    R4,CPYLBCK              LOAD READ-REG WITH ADDR OF CHECK
         MVI   CPYLBFLG,C'*'           FLAG COMING FM SYSLIB (COPYLIB)
         L     R11,PDSST
READPDS  READ  PDSDECB,                PG 165 CPS                      +
               SF,                                                     +
               PDSDCB,                                                 +
               PDSIO,                                                  +
               'S'
         LR    R1,R5                   LOAD REG 1 W/ ADDR OF IMAGE
         BR    R11
         EJECT
CPYLBCK  CHECK PDSDECB                 PG 169 CPS
         MVC   0(80,R5),PDSIO          SAVE CARD IMAGE INCASG FRESH
*                                      COPY NEEDED FOR 'NOTE'
         B     READPDS
*
CLIERR   TM    EXCOND,X'08'            TEST FOR I/O ERR IN DIRECTORY
         BO    PERERR
         MVC   MSG(54),MSG3            MOVE ERROR MESSAGE
CLIERR1  LA    R1,ERRMSG               LOAD ADDR OF LINE TO BE PRINTED
         AP    ERRCTR,=P'1'            ADD ONE TO ERROR COUNTER
         BAL   R11,PRINTIT             GO TO PRINT ROUTINE
         L     R11,PDSST
         BR    R11                     EXIT
*
PERERR   MVC   MSG(54),MSG4
         B     CLIERR1
*
PDSIO    DS    10D
PDSST    DS    F
EXCOND   DS    C
MSG3     DC   C'THE NAMED MEMBER WAS NOT FOUND IN THE HHHSYSLB PDS ***'
MSG4     DC   C'I/O ERROR WAS DETECTED WHEN SEARCHING THE DIRECTORY **'
*
PDSEOD   MVI   CPYLBFLG,C' '           REMOVE SYSLIB (COPYLIB) FLAG
         LA    R4,QSAMGET
         BR    R4
         EJECT
* PRINT LOGIC *********************************************************
*              USER MUST HAVE ADDR OF OUTPUT IN 1
PRINTIT  STM   1,11,PRTSTM             SAVE REGISTERS
         LM    2,5,PRTLN               LOAD REGS 2=PRTAREA
*                                                3=LINECTR
*                                                4=MAX LINE COUNT
*                                                5=ADCON-PRT HEADER
         CR    3,4
         BH    HDRRTN                  BRANCH IF LINECTR GREATER MAX
HDRRET   BAL   11,PRINTIO              PRINT RTN
         LA    3,1(0,3)                ADD 1 TO LINECTR
         STM   2,3,PRTLN
         AP    LNSPRNED,=P'1'          ADD 1 TO LINES PRINTED COUNTER
         LM    1,11,PRTSTM
         BR    11
*
PRINTIO  MVC   0(121,2),0(1)
PRTPUT   L     R1,=A(PRTDCB)
         PUT   (1)
         LR    2,1                     LOAD NEXT TO INTO REG 2
         BR    11
*
HDRRTN   MVI   0(2),B'10001001'        WRITE,SKIP TO 1 AFTER PRINT
         MVI   1(2),C' '               BLANK FIELD
         MVC   2(119,2),1(2)
         BAL   11,PRTPUT
         LR    R1,R5                   LOAD ADDR OF HEADER LINE
         AP    PGCTRP,=P'1'            ADD 1 TO PAGE CTR
         UNPK  118(3,R1),PGCTRP
         OI    120(R1),X'F0'           REMOVE STD SIGN
         BAL   R11,PRINTIO
         LA    R3,3(R0)                SET LINE CTR = 3
         L     R1,PRTSTM
         B     HDRRET
*
PRTSTM   DS    11F
PRTLN    DS    F
LINECTR  DC    A(MAXLINES+1)
         DC    A(MAXLINES)             MAX LINE COUNT
         DC    A(PRTHDR)
PGCTRP   DC    P'000'                  PAGE COUNTER - PACKED
         EJECT
* PRINT LOGIC AREAS ***************************************************
PRTHDR   DC    X'11'                   SPACE 2 AFTER PRINT
         DC    C'V1M2-07/18/67'        VERSION, MODIFICATION, & DATE
         DC    21C' '
HDRTIME  DC    C'TIME = 00.000'
         DC    13C' '
         DC    C'COBOL CROSS-REFERENCE'
         DC    8C' '
HDRDATE  DC    C'DATE XX.XXX = 99/99/99  PAGE 000'
PRTLINE  DC    X'09'                   WRITE, SPACE 1 AFTER PRINT
SEQNOD   DC    C'XXXX'
         DC    C' '
CPYLBFLG DC    C' '
         DC    C' '
CDIMGPRT DS    CL80
         DC    33C' '
         SPACE 5
         ORG   PRTLINE+1+(30-MAXNAME)
IONAME   DS    CL(MAXNAME)
         ORG   PRTLINE+33
IOFLG    DS    CL2
         ORG   PRTLINE+36
IODEFN   DS    CL4
         ORG   PRTLINE+42
IOREF    DS    CL4
         ORG
         EJECT
* REGISTER USAGE ******************************************************
         SPACE
X0       EQU   0
X1       EQU   1
X2       EQU   2
X3       EQU   3    POINTER TO LEFT OF ARRAY
X4       EQU   4    POINTER TO LEFT-MOST INSERTION IN ARRAY
X5       EQU   5    POINTER TO RIGHT OF ARRAY (ONCE LOADED-DECREMENTED)
X6       EQU   6    POINTER TO UTILITY OUTPUT DCB
X7       EQU   7    POINTER TO UTILITY INPUT DCB
X8       EQU   8    LENGTH OF EACH ENTRY IN ARRAY
X9       EQU   9
*                   (CONSTANT = ADDR OF MAINLINE ENTRY POINT)
*                   (CONSTANT = 256 (MAXIMUM MOVE LENGTH)
*                   (UTILITY  = ADDR OF UTILITY OUTPUT I/O AREA)
X10      EQU   10
*                   (UTILITY  = DEVELOPED LENGTH FOR SLIDE)
*                   (UTILITY  = ADDR OF UTILITY INPUT I/O AREA)
X11      EQU   11
*                   (UTILITY  = ADDR OFR INTERNAL RETURN)
*                   (UTILITY  = ADDR OF RECEIVING FIELD FOR SLIDE)
X12      EQU   12   BASE
X13      EQU   13   POINTER TO SAVE AREA
X14      EQU   14   RETURN ADDRESS
X15      EQU   15   ENTRY ADDRESS
         SPACE 2
* DISPOSE LOGIC *******************************************************
PUT      DS    0H
DISPOSE  DS    0H
         STM   R2,R11,REGSAVE
         AP    RECCTR,=P'1'            ADD ONE TO RECORD COUNTER
         OC    ORNAME,WORK             TO SHOW LONGEST NAME
         MVC   HOLD(MAXNAME),WORK      MOVE NAME
         MVC   HOLD+MAXNAME+2(2),SEQNOB MOVE SEQ NO
         MVC   HOLD+MAXNAME(2),FLAG    MOVE FLAG
         CLI   WORK+MAXNAME,X'FF'      THIS IS NECESSARY INCASE MAXNAME
         BE    BYPASS                  EQUALS 30 WHICH MAKES FOLLOWING
*                                      TEST INVALID
         CLI   WORK+MAXNAME,C' '       TEST FOR NAME EXCEEDING MAX
         BE    BYPASS                  BYPASS ERROR MESSAGE
         MVC   MSG(30),WORK            MOVE NAME TO ERROR MESSAGE
         MVC   MSG+30(24),MSG5         MOVE ERROR MESSAGE
         AP    ERRCTR,=P'1'            ADD ONE TO ERROR COUNTER
         LA    R1,ERRMSG               LOAD ADDR OF ERROR MESSAGE
         BAL   R11,PRINTIT             GO TO PRINT ROUTINE
BYPASS   EQU   *
         EJECT
* LOAD REGISTERS
FINALENT EQU   *
         LM    X2,X9,CX2 REG 2 = ADDR OF PHYSICAL PUT
*                        REG 3 = POINTER TO LEFT OF ARRAY
*                        REG 4 = POINTER TO LEFT-MOST INSERTION IN ARRA
*                        REG 5 = POINTER TO RIGHT OF ARRAY
*                        REG 6 = POINTER TO UTILITY OUTPUT DCB
*                        REG 7 = POINTER TO UTILITY INPUT DCB
*                        REG 8 = LENGTH OF EACH ENTRY IN ARRAY
*                        REG 9 = ADDR OF ENTRY
         BR    X9
DISPI    MVC   CX9,=A(DISPO)           SET TO BY-PASS NEXT TIME
         BAL   X11,INITIALR            RTN TO OPEN & INITIALIZE ARRAY
DISPO    CLI   0(X3),X'00'             TEST FOR FULL ARRAY
         BE    DISPD                   BR ON NOT FULL
         BAL   X11,DUMP                DUMP ARRAY
         BAL   X11,FLIP                DO OPEN & INITIALIZE ARRAY
DISPD    EQU   *
         SPACE 2
* FIND, SLIDE, AND INSERT LOGIC ***************************************
         LA    X9,256(0)               LOAD CONSTANT OF 256 IN REG 9
         B     COMPR
*                                      FIND LOGIC *********************
COMPRTOP SR    X5,X8                   DECREMENT ARRAY INSERT POINTER
COMPR    CLC   HOLD,0(X5)              COMPR W/ ARRAY
         BC    12,COMPRTOP             BRANCH LOW OR EQUAL
*                                      DEVELOP LENGTH OF SLIDE ********
         LR    X10,X5                  LOAD INSERT POINTER
         SR    X10,X4                  SUBTRACT LEFT-MOST POINTER
         LA    X10,MVCLENGT(X10)       ADD LENGTH (-1) FOR EXECUTED MVC
*                                      DEVELOP RECEIVING ADDR *********
         LR    X11,X4                  LOAD REC REG W/ LEFT-MOST
         SR    X11,X8                  DECREMENT REC REG
         ST    X11,CX4                 STORE NEW LEFT-MOST VALUE
         B     SLIDEIT
*                                      SLIDE LOGIC ********************
SLIDETOP MVC   0(256,X11),0(X4)        MOVE 256 CHARACTERS
         AR    X11,X9                  INCREMENT RECEIVING REG
         AR    X4,X9                   INCREMENT SENDING REG
SLIDEIT  SR    X10,X9                  SUBTRACT 256 FROM SLIDE LENGTH
         BC    10,SLIDETOP             BRANCH IF ZERO OF PLUS
         AR    X10,X9                  ADD 256 TO SLIDE LENGTH
         EX    X10,MOVEINST            EXECUTE MOVE TO FINISH SLIDE
*                                      INSERT LOGIC *******************
         MVC   0(LENGTH,X5),HOLD       INSERT NEW FIELD
* RETURN
         LM    R2,R11,REGSAVE
         BR    R11
         EJECT
MOVEINST MVC   0(0,X11),0(X4)          EXECUTED MOVE
         SPACE 2
HOLD     DS    CL(LENGTH)
         SPACE 2
REGSAVE  DS    10F
         SPACE 2
CX2      DC    A(PHYSPUT)              PHYSICAL PUT ADDRESS
CX3      DS    F
CX4      DS    F
CX5      DS    F
CX6      DS    F
CX7      DS    F
CX8      DC    A(LENGTH)
CX9      DC    A(DISPI)
RECCTR   DC    P'00000'
ORNAME   DC    CL30' '
         DC    C' '                    ONE BLANK MUST FOLLOW ORNAME
HOLDTIME DS    F
         EJECT
* DUMP ARRAY TO UTILITY DS ********************************************
NEXTDUMP DC    A(FIRSTDMP)             ADDR FOR NEXT ENTRY
DUMP     ST    X11,REG11SV             SAVE RETURN ADDR
         L     X1,NEXTDUMP
         BR    X1
* FIRST ENTRY - DUMP W/O MERGE
FIRSTDMP MVC   NEXTDUMP,=A(OTHERDMP)   SET ADDR FOR NEXT ENTRY
TOPDUMP  AR    X4,X8                   ADD LENGTH OF FIELD IN ARRAY
*                                      (THIS WILL SET POINTER ABOVE
*                                       X'00' FIELD FIRST TIME THROUGH)
         BALR  X11,X2                  GO TO PHYSICAL PUT
         MVC   0(LENGTH,X1),0(X4)      MOVE RECORD
         CLI   0(X1),C'9'              TEST FOR LAST RECORD
         BNE   TOPDUMP
         BALR  X11,X2                  GO TO PHYSICAL PUT (WILL NOT
*                                      RETURN IF PRINTING)
         MVI   0(X1),C'9'              FLAG END
         CLOSE (UT1DCB,REREAD)
         L     X11,REG11SV             RESTORE RETURN ADDR
         BR    X11                     EXIT
* PHYSICAL PUT (TO UTILITY) LOGIC
PHYSPUT  LR    X1,X6                   LOAD ADDR OF OUTPUT DCB
         PUT   (1)
         BR    X11                     RETURN
* OTHER THAN FIRST ENTRY - DUMP W/ MERGE
OTHERDMP LR    X1,X7                   ADDR OF INPUT DCB
         GET   (1)
         LR    X10,X1                  SAVE ADDR OF INPUT
         BALR  X11,X2                  GO TO PHYSICAL PUT
         LR    X9,X1                   SAVE ADDR OF OUTPUT
         AR    X4,X8                   BUMP LEFT-MOST ABOVE X'00' ENTRY
         B     DUMPCLC
* ARRAY LOW OR EQUAL LOGIC
ARRAYLOW MVC   0(LENGTH,X9),0(X4)      MOVE FROM ARRAY
         AR    X4,X8                   BUMP ARRAY POINTER
ENDTEST  CLI   0(X9),C'9'              TEST FOR END
         BE    DUMPEND
         BALR  X11,X2                  GO TO PHYSICAL PUT
         LR    X9,X1                   SAVE ADDR OF NEXT OUTPUT
DUMPCLC  CLC   0(LENGTH,X10),0(X4)     CMPR UTILITY REC W/ ARRAY
         BNL   ARRAYLOW                BRANCH IF ARRAY EQUAL OR LOW
* UTILITY LOW LOGIC
         MVC   0(LENGTH,X9),0(X10)     MOVE FROM UTILITY
         LR    X1,X7                   ADDR OF INPUT DCB
         GET   (1)
         LR    X10,X1                  SAVE ADDR OF INPUT
         B     ENDTEST
* CLOSE LOGIC
DUMPEND  DS    0H
         BALR  X11,X2                  GO TO PHYSICAL PUT (WILL NOT
*                                      RETURN IF PRINTING)
         MVI   0(X9),C'9'              FLAG END
         CLOSE (UT1DCB,REREAD)
         CLOSE (UT2DCB,REREAD)
         L     X11,REG11SV             RESTORE RETURN ADDR
         BR    X11                     EXIT
REG11SV  DS    F                       RETURN ADDR SAVE AREA
         SPACE 2
* INITIALIZE OUTPUT DS AND ARRAY **************************************
INITIALR DS    0H
         OPEN  (UT1DCB,(OUTPUT))
         MVC   CX6,=A(UT1DCB)          SAVE ADDR OF OUTPUT DCB
         ST    X11,SAVE11              SAVE RETURN
         BAL   X11,INITARRY            INITIALIZE ARRAY
         L     X11,SAVE11              RESTORE RETURN
         BR    X11                     EXIT
SAVE11   DS    F
         EJECT
* FLIP INPUT/OUTPUT DCB'S LOGIC ***************************************
NEXTFLIP DC    A(ODDFLIP)              ADDR FOR NEXT ENTRY
FLIP     L     X1,NEXTFLIP
         BR    X1
* ODD ENTRY ROUTINE
ODDFLIP  MVC   NEXTFLIP,=A(EVENFLIP)   SET ADDR FOR NEXT ENTRY
         OPEN  (UT1DCB,)
         OPEN  (UT2DCB,(OUTPUT))
         MVC   CX6,=A(UT2DCB)          SAVE ADDR OF OUTPUT DCB
         MVC   CX7,=A(UT1DCB)          SAVE ADDR OF INPUT DCB
         B     BOTHFLIP
* EVEN ENTRY ROUTINE
EVENFLIP MVC   NEXTFLIP,=A(ODDFLIP)    SET ADDR FOR NEXT ENTRY
         OPEN  (UT2DCB,)
         OPEN  (UT1DCB,(OUTPUT))
         MVC   CX6,=A(UT1DCB)          SAVE ADDR OF OUTPUT DCB
         MVC   CX7,=A(UT2DCB)          SAVE ADDR OF INPUT DCB
* CONVERGE
BOTHFLIP ST    X11,SAVE11              SAVE RETURN
         BAL   X11,INITARRY            INITIALIZE ARRAY
         L     X11,SAVE11              RESTORE RETURN
         BR    X11                     EXIT
         SPACE 2
* INITIALIZE ARRAY LOGIC
INITARRY DS    0H
         L     X3,=A(CORE)             LEFT OF ARRAY TO REG 3
         L     X4,=A(CORETOP)          LEFT-MOST ENTRY TO REG 4
         LR    X5,X4                   RIGHT OF ARRAY TO REG 5
         STM   X3,X5,CX3               SAVE POINTERS
         MVI   0(X3),X'00'             FLAG BOTTOM OF TABLE
         MVI   0(X5),X'00'             TO GIVE LOW COMPARE
         MVI   LENGTH(X5),C'9'         TO MARK END OF ARRAY
         BR    X11                     EXIT
         EJECT
* PRINT CROSS REFERENCE LOGIC
PRTXREF  DS    0H
         CLI   WKNAME,C'9'             TEST FOR END
         BE    ENDJOB
         L     X15,PRTENTRY
         BR    X15
PRTENTRY DC    A(PRT1ST)
         SPACE 5
* FIRST ENTRY (FALSE PUT) LOGIC
PRT1ST   DS    0H
         MVC   PRTENTRY,=A(PRT2ND)     SET NEXT ENTRY
         LA    X1,WKNAME               GIVE CALLER ADDR
         BR    X11                     EXIT
         SPACE 5
* SECOND ENTRY (FIRST W/ LIVE DATA) LOGIC
PRT2ND   DS    0H
         ST    X11,LIST11              SAVE RETURN
         MVC   PRTENTRY,=A(PRT3RD)     SET NEXT ENTRY
         MVI   PRTLINE+1,C' '          CLEAR PRINTER AREA
         MVC   PRTLINE+2(119),PRTLINE+1
         MVC   IONAME(4),=C'NAME'
         MVC   PRTHDR+1(30),PRTLINE+1
         MVC   PRTHDR+34(19),=C'DEFIN    REFERENCES'
         MVC   LINECTR,=A(MAXLINES+1)  FORCE NEW LINE
         B     LISTE2
         EJECT
PRT3RD   DS    0H
         ST    X11,LIST11              SAVE RETURN
         CLC   WKNAME,SAVENAME
         BE    LISTB3
         LA    X1,PRTLINE              ADDR FOR PRINT ROUTINE
         BAL   X11,PRINTIT             DO PRINT
         MVI   PRTLINE+1,C' '          CLEAR PRINTER AREA
         MVC   PRTLINE+2(119),PRTLINE+1
         MVC   BUCKETAD,=A(IOREF-6)    INITIALIZE BUCKET POINTER
LISTE2   MVC   SAVENAME,WKNAME
         CLI   WKFLG,C'9'              TEST FOR DEFINING OR USING
         BNE   LISTF3                  BRANCH ON DEFINING
         MVC   IONAME,WKNAME
         MVC   IODEFN-4(9),=C'UNDEFINED'
         AP    ERRCTR,=P'1'            ADD ONE TO ERROR COUNTER
LISTH2   L     X1,BUCKETAD             LOAD BUCKET ADDRESS
         LA    X1,6(X1)                BUMP REG 1 BY 6
         CL    X1,=A(IOREF+(12*6))     TEST FOR END OF BUCKET STRING
         BNH   LISTK2                  BRANCH IF MORE AVAILABLE
         LA    X1,PRTLINE
         BAL   X11,PRINTIT
         MVI   PRTLINE+1,C' '          CLEAR PRINTER AREA
         MVC   PRTLINE+2(119),PRTLINE+1
         LA    X1,IOREF                SET BUCKET POINTER
LISTK2   NI    WKNOB,X'7F'             AND OFF FLAG
         LH    X0,WKNOB                LOAD BINARY SEQ NO
         CVD   X0,DBLWD
         UNPK  0(4,X1),DBLWD           PLACE IN I/O
         OI    3(X1),X'F0'
         ST    X1,BUCKETAD             SAVE BUCKET ADDR
         B     LISTG3
LISTB3   CLI   WKFLG,C'9'              TEST FOR DEFINING OR USING
         BE    LISTH2                  BRANCH IF NOT DEFINING
         MVC   IOREF(9),=C'DUPLICATE'
         LA    X1,PRTLINE
         BAL   X11,PRINTIT
         MVI   PRTLINE+1,C' '          CLEAR PRINTER AREA
         MVC   PRTLINE+2(119),PRTLINE+1
LISTF3   MVC   IONAME,WKNAME
         MVC   IOFLG,WKFLG             MOVE DEFINING FLAG
         LH    X0,WKNOB
         CVD   X0,DBLWD
         UNPK  IODEFN,DBLWD
         OI    IODEFN+3,X'F0'          REMOVE STD SIGN
* EXIT
LISTG3   LA    X1,WKNAME               FURNISH USER AN AREA
         L     X11,LIST11              LOAD RETURN ADDR
         BR    X11
LIST11   DS    F
BUCKETAD DC    A(IOREF-6)
         ORG   *+MAXNAME
         DS    0H
         ORG   *-MAXNAME
WKNAME   DS    CL(MAXNAME)
WKFLG    DS    CL2
WKNOB    DS    CL2
SAVENAME DS    CL(MAXNAME)
         SPACE 2
* END OF JOB LOGIC
ENDJOB   DS    0H
         LA    X1,PRTLINE              PRINT FINAL LISTING LINE
         BAL   X11,PRINTIT
* SET UP STATISTICS LINE
         UNPK  FLRECCNT,RECCTR         NUMBER OF NAMES COUNTER
         OI    FLRECCNT+4,X'F0'
         ZAP   RECCTR,=P'1'            INITIALIZE CTR FOR LONGEST NAME
         LA    R1,ORNAME+1             INITIALIZE POINTER
TOPLGSTN CLI   0(R1),X'40'             TEST FOR END
         BE    ENDLGSTN
         LA    R1,1(R1)                ADD ONE TO POINTER
         AP    RECCTR,=P'1'            ADD ONE TO COUNTER
         B     TOPLGSTN
ENDLGSTN EQU   *
         UNPK  FLLNGNAM,RECCTR         NUMBER CHARACTERS IN LONG NAME
         OI    FLLNGNAM+1,X'F0'
         TIME BIN                      GET TIME IN REG 0
         S     R0,HOLDTIME             SUBTRACT STARTING TIME
         CVD   R0,DBLWD                NUMBER OF SECONDS (VALUE = 0.01)
         UNPK  DBLWD(5),DBLWD
         OI    DBLWD+4,X'F0'           REMOVE STD SIGN
         MVC   FLSECOND,DBLWD          MOVE SECONDS
         MVC   FLDECIMA,DBLWD+3        MOVE DECIMAL
         UNPK  FLERRCT,ERRCTR          MOVE ERROR COUNTER
         OI    FLERRCT+2,X'F0'
         UNPK  FLLNCTR,LNSPRNED        MOVE LINE COUNTER
         OI    FLLNCTR+3,X'F0'
         L     R1,PRTLN                LOAD LAST ADDR GIVEN BY PUT
         MVC   0(121,R1),FINALLIN      THIS WILL PRINT AT CLOSE
         CLOSE (PRTDCB,REREAD)
         CLOSE (CARDDCB,,PDSDCB,)
         CLOSE (UT1DCB,REREAD,UT2DCB,REREAD,UT3DCB,REREAD)
         L     13,4(13)                ADDR OF CALLING SAVE AREA
         RETURN (14,12),RC=0
         EJECT
DBLWD    DS    D
SAVEREG  DS    18F
         LTORG
         EJECT
EODADU1  ABEND 4096,DUMP
EODADU2  ABEND 4092,DUMP
         EJECT
FINALLIN DC    B'10001001'             WRITE, SKIP TO 1 AFTER PRINT
         DC    C'NUMBER OF NAMES = '   18
FLRECCNT DC    C'00000'                 5
         DC    C'; LONGEST NAME = '    17
FLLNGNAM DC    C'00'                    2
         DC    C'; TIME(SECONDS) = '   18
FLSECOND DC    C'000'                   3
         DC    C'.'                     1
FLDECIMA DC    C'00'                    2
         DC    C'; ERROR COUNT = '     16
FLERRCT  DC    C'000'                   3
         DC    C'; LINES PRINTED = '   18
FLLNCTR  DC    C'0000'                  4
         DC    13C' '
         EJECT
* CARD DCB ************************************************************
CARDDCB  DCB   DSORG=PS,                                               +
               MACRF=GL,                                               +
               DDNAME=SYSIN,                                           +
               DEVD=DA,                                                +
               RECFM=FB,                                               +
               LRECL=80,                                               +
               BFTEK=S,                                                +
               EODAD=PHASIEOD
         SPACE 2
* PDS DCB - SYSLIB (COPYLIB) ******************************************
PDSDCB   DCB   DSORG=PO,                                               +
               MACRF=R,                                                +
               DDNAME=SYSLIB,                                          +
               RECFM=F,                                                +
               LRECL=80,                                               +
               BLKSIZE=80,                                             +
               NCP=1,                                                  +
               BUFNO=2,                                                +
               EODAD=PDSEOD
         SPACE 2
* PRINTER DCB *********************************************************
PRTDCB   DCB   DSORG=PS,                                               +
               MACRF=PL,                                               +
               DDNAME=HHHPRINT,                                        +
               DEVD=DA,                                                +
               RECFM=FM,                                               +
               LRECL=121,                                              +
               BLKSIZE=121,                                            +
               BFTEK=S
         SPACE 2
UT1DCB   DCB   DSORG=PS,                                               +
               MACRF=(GL,PL),                                          +
               DDNAME=HHHUT1,                                          +
               DEVD=DA,                                                +
               BUFNO=2,                                                +
               RECFM=FB,                                               +
               LRECL=(CLRECL),                                         +
               BLKSIZE=(CBLKSIZE),                                     +
               BFTEK=S,                                                +
               EODAD=EODADU1
         EJECT
UT2DCB   DCB   DSORG=PS,                                               +
               MACRF=(GL,PL),                                          +
               DDNAME=HHHUT2,                                          +
               DEVD=DA,                                                +
               BUFNO=2,                                                +
               RECFM=FB,                                               +
               LRECL=(CLRECL),                                         +
               BLKSIZE=(CBLKSIZE),                                     +
               BFTEK=S,                                                +
               EODAD=EODADU2
         SPACE 2
UT3DCB   DCB   DSORG=PS,                                               +
               MACRF=(PL),                                             +
               DDNAME=HHHUT3,                                          +
               DEVD=DA,                                                +
               BUFNO=20,                                               +
               RECFM=FB,                                               +
               LRECL=80,                                               +
               BLKSIZE=(UT3BLKSZ),                                     +
               BFTEK=S
         SPACE 2
* TRANSLATE  AND  TRANSLATE & TEST  TABLES ****************************
TRTTBL   DC    125X'00'
         DC    X'FF'                   QUOTE POSITION
         DC    130X'00'
TRTBL    DC    96X'40'
         DC    X'60'                   DASH
         DC    96X'40'
         DC    C'ABCDEFGHI'
         DC    7X'40'
         DC    C'JKLMNOPQR'
         DC    8X'40'
         DC    C'STUVWXYZ'
         DC    6X'40'
         DC    C'0123456789'
         DC    6X'40'
         EJECT
*COBOL  WORDS *********************************************************
COBWDS   EQU   *-16+2048
 DC C'ACCEPT          ACCESS          ACTUAL          ADD             '
 DC C'ADVANCING       AFTER           ALL             ALPHABETIC      '
 DC C'ALTER           ALTERNATE       AND             APPLY           '
 DC C'ARE             AREA            AREAS           ASCENDING       '
 DC C'ASSIGN          AT              AUTHOR          BEFORE          '
 DC C'BEGINNING       BLANK           BLOCK           BY              '
 DC C'CALL            CF              CH              CHANGED         '
 DC C'CHARACTERS      CHECKING        CLOCK-UNITS     CLOSE           '
 DC C'COBOL           CODE            COLUMN          COMMA           '
 DC C'COMPUTATIONAL   COMPUTATIONAL-1 COMPUTATIONAL-2 COMPUTATIONAL-3 '
 DC C'COMPUTE         CONFIGURATION   CONSOLE         CONTAINS        '
 DC C'CONTROL         CONTROLS        COPY            CORRESPONDING   '
 DC C'CREATING        CYCLES          DATA            DATE-COMPILED   '
 DC C'DATE-WRITTEN    DE              DECIMAL-POINT   DECLARATIVES    '
 DC C'DEPENDING       DESCENDING      DETAIL          DIRECT          '
 DC C'DIRECT-ACCESS   DISPLAY         DISPLAY-ST      DIVIDE          '
 DC C'DIVISION        ELSE            END             ENDING          '
 DC C'ENTER           ENTRY           ENVIRONMENT     EQUAL           '
 DC C'ERROR           EVERY           EXAMINE         EXHIBIT         '
 DC C'EXIT            FD              FILE            FILE-CONTROL    '
 DC C'FILE-LIMIT      FILLER          FINAL           FIRST           '
 DC C'FOOTING         FOR             FORM-OVERFLOW   FROM            '
 DC C'GENERATE        GIVING          GO              GREATER         '
 DC C'GROUP           HEADING         HIGH-VALUE      HIGH-VALUES     '
 DC C'HOLD            I-O             I-O-CONTROL     IBM-360         '
 DC C'IDENTIFICATION  IF              IN              INCLUDE         '
 DC C'INDEXED         INDICATE        INITIATE        INPUT           '
 DC C'INPUT-OUTPUT    INSTALLATION    INTO            INVALID         '
 DC C'IS              JUSTIFIED       KEY             LABEL           '
 DC C'LABELS          LAST            LEADING         LEFT            '
 DC C'LESS            LIMIT           LIMITS          LINE            '
 DC C'LINE-COUNTER    LINES           LINKAGE         LOCK            '
 DC C'LOW-VALUE       LOW-VALUES      MODE            MORE-LABELS     '
 DC C'MOVE            MULTIPLY        NAMED           NEGATIVE        '
 DC C'NEXT            NO              NOT             NOTE            '
 DC C'NUMERIC         '
*DC C'OBJECT-COMPUTER '                MAKE COMMENT
 DC C'OCCURS          OF              '
 DC C'OMITTED         ON              OPEN            OR              '
 DC C'ORGANIZATION    OTHERWISE       OUTPUT          OVERFLOW        '
 DC C'PAGE            PAGE-COUNTER    PERFORM         PF              '
 DC C'PH              PICTURE         PLUS            POSITIVE        '
 DC C'PRINT-SWITCH    PROCEDURE       PROCEED         PROCESS         '
 DC C'PROCESSING      PROGRAM-ID      PROTECTION      QUOTE           '
 DC C'QUOTES          RANDOM          RD              READ            '
 DC C'READY           RECORD          RECORDING       RECORDS         '
 DC C'REDEFINES       REEL            RELATIVE        RELEASE         '
 DC C'REMARKS         REPLACING       REPORT          REPORTING       '
 DC C'REPORTS         RERUN           RESERVE         RESET           '
 DC C'RESTRICTED      RETURN          REVERSED        REWIND          '
 DC C'REWRITE         RF              RH              RIGHT           '
 DC C'ROUNDED         RUN             SA              SAME            '
 DC C'SD              SEARCH          SECTION         SECURITY        '
 DC C'SELECT          SENTENCE        SEQUENTIAL      SIZE            '
 DC C'SORT            SOURCE          SOURCE-COMPUTER SPACE           '
 DC C'SPACES          SPECIAL-NAMES   STANDARD        STOP            '
 DC C'SUBTRACT        SUM             SYMBOLIC        SYSIN           '
 DC C'SYSOUT          SYSPUNCH        TALLY           TALLYING        '
 DC C'TERMINATE       THAN            THEN            THRU            '
 DC C'TIMES           TO              TRACE           TRACK-AREA      '
 DC C'TRACKS          TRANSFORM       TRY             TYPE            '
 DC C'UNIT            UNIT-RECORD     UNITS           UNTIL           '
 DC C'UPON            USAGE           USE             USING           '
 DC C'UTILITY         VALUE           VARYING         VIA             '
 DC C'WHEN            WITH            WORKING-STORAGE WRITE           '
 DC C'WRITE-ONLY      ZERO            ZEROES          ZEROS           '
         EJECT
* CORE FOR ARRAY ******************************************************
         DS    0D
         ORG   *+LENGTH                SPACE AT LEFT TO ABSORB SLIDE
CORE     EQU   *                       ADDR OF LEFT OF ARRAY
ARRBKCT  EQU   (ARRAYLGH/LENGTH)-2
         ORG   *+(LENGTH*ARRBKCT)      ALLOCATE SPACE FOR ARRAY
CORETOP  EQU   *-LENGTH                ADDR OF RIGHT ENTRY
         ORG   *+LENGTH                SPACE AT RIGHT TO ALLOW MOVE
         EJECT
HHH80000 CSECT
         SPACE 2
* PURPOSE:  PLACE IN CALLERS 12 BYTE AREA, POINTED TO BY REG 1 UPON
* ENTRY, THE DATE IN THE FORMAT 'MM/DD/YY.JJJ', WHERE 'MM' IS THE
* MONTH; 'DD' THE DAY OF THE MONTH; 'YY' THE YEAR; AND 'JJJ' THE JULIAN
* DATE
         SPACE 2
         USING *,15                    TELL ASSEMBLER BASE
         ST    1,HHH80008              SAVE ADDRESS OF CALLERS AREA
         ST    14,HHH80005             SAVE RETURN ADDRESS
         TIME  BIN
         BALR  15,0                    SET BASE REGISTER
         USING *,15                    AND TELL ASSEMBLER
         L     14,HHH80005             RESTORE RETURN ADDRESS
         ST    1,HHH80005              FRMT='00YYDDDF'
         SRL   1,12(0)                 SHIFT 1 12 BITS TO RIGHT
         ST    1,HHH80007+4            FRMT='00000YYD'
         OI    HHH80007+7,X'0F'        INSERT STD SIGN
         UNPK  HHH80013,HHH80007+6(2)  PACKED TO ZONE (YEAR)
         UNPK  HHH80014,HHH80005+2(2)  MOVE JULIAN DATE
         CVB   1,HHH80007              BINARY YEAR IN REG 1
         N     1,=F'3'                 TEST TWO LOW ORDER BITS
         BC    7,HHH80001              BRANCH IF NOT LEAP YEAR
         AP    HHH80009,=P'1'          ADD ONE TO CHECK CONSTANT (=365)
         AP    HHH80015-1,=P'1'        ADD ONE TO FEBRUARY
HHH80001 CP    HHH80005+2(2),HHH80009  CHECK FOR DAY GREATER THAN 365
         BH    HHH80004                BRANCH IF DAY GREATER THAN 365
         LA    1,HHH80015              INITIALIZE INDEXING REGISTER
HHH80002 SP    HHH80006,0(1,1)         SUBTRACT DAYS OF MONTH FROM
         SP    HHH80006,=P'30'         ARGUMENT
         BC    12,HHH80003             BRANCH ON ZERO OR LESS
         BCTR  1,0                     SUBTRACT ONE FROM INDEXING REG
         AP    HHH80010,=P'1'          ADD ONE TO MONTH
         B     HHH80002                LOOP AGAIN
HHH80003 AP    HHH80006,0(1,1)         ADD BACK DAYS THAT CAUSED LESS
         AP    HHH80006,=P'30'         THAN ONE CONDITION
         UNPK  HHH80011,HHH80010       UNPACK MONTH
         OI    HHH80011+1,X'F0'        REMOVE STANDARD SIGN
         UNPK  HHH80012,HHH80006       UNPACK DAYS
         OI    HHH80012+1,X'F0'        REMOVE STANDARD SIGN
HHH80004 L     1,HHH80008              LOAD ADDRESS OF CALLERS AREA
         MVC   0(12,1),HHH80011        MOVE DATA TO USERS AREA
         BR    14                      EXIT
HHH80005 DS    F                       1ST SAVE RETURN - 2D WORK AREA
         ORG   *-2
HHH80006 DS    H                       CONTAINS DAYS
HHH80007 DC    D'0'                    CONVERTING DBL WD
HHH80008 DS    F                       SAVE AREA FOR USERS ADDRESS
HHH80009 DC    P'365'                  COMPR FOR MAX NO OF DAYS
HHH80010 DC    P'001'                  MONTH CTR
HHH80011 DC    C'00'                   MONTH
         DC    C'/'
HHH80012 DC    C'00'                   DAY
         DC    C'/'
HHH80013 DC    C'00'                   YEAR
         DC    C'.'
HHH80014 DC    C'000'                  JULIAN DAY
         DC    P'1'
         DC    P'0'
         DC    P'1'
         DC    P'0'
         DC    P'1'
         DC    P'1'
         DC    P'0'
         DC    P'1'
         DC    P'0'
         DC    P'1'
         DC    P'-2'
HHH80015 DC    P'1'
         LTORG
         DROP  15
         END
