         LCLB  &FLOATPT,&DAPRINT,&MULTIPH,&OPAFTER,&PRINTEB
         LCLB &SVCNAME,&MNEMONS,&TRUNCAT,&PROCHK1,&PROCHK2,&RXPRINT
         LCLB &NOPACKS
&SVCNAME SETB 1
&MNEMONS SETB 1
&TRUNCAT SETB 1
&PROCHK1 SETB 1
&PROCHK2 SETB 1
&RXPRINT SETB 1
&NOPACKS SETB 1
&PRINTEB SETB 1
&OPAFTER SETB 1
&FLOATPT SETB 1
&DAPRINT SETB 1
&MULTIPH SETB 1
***                          SPRINT.
***                         *********
***
***  SELECTIVE-PRINTOUT-INSTRUCTION-TRACE.
***  *************************************
***  SPRINT IS A PROGRAM TESTING AND DE-BUGGING AID COMPILED TO RUN
***  UNDER 360-OPERATING SYSTEM.(PCP OR MFT)
***  IT MAY BE USED TO TEST LOAD-MODULES WHICH ARE HELD IN A SEQUENTIAL
***  OR PARTITIONED DATA SET.
***  REQUIREMENTS.
***                1.-HARDWARE.
***                ANY MODEL SYSTEM-360.
***                STANDARD INSTRUCTION SET.
***                INTERVAL-TIMER(OPTIONAL).
***                SPRINT REQUIRES APPROX. 5K OF CORE FOR EXECUTION.
***                UNIVERSAL INSTRUCTION SET IS SUPPORTED.
***                STORAGE PROTECTION IS OPTIONAL.
***                2.-SOFTWARE.
***                PCP OR MFT ENVIRONMENT.SPRINT HAS NOT BEEN TESTED
***                IN A MVT ENVIRONMENT,BUT SHOULD OPERATE PROPERLY.
***
         PRINT NOGEN,NODATA
         AIF   (&TRUNCAT EQ 1).CTLSK1
         &PRINTEB SETB 0
.CTLSK1  ANOP
         TITLE 'OS TRACE PROGRAM INITIALISE ROUTINES'
********** * * * * * * * * * * * * * * * * * * * * * * * * * **********
*        INITIALISATION ROUTINE.                                      *
*                                                                     *
*        THIS ROUTINE READS IN PARAMETER DATA,CONVERTS DATA TO USABLE *
*        FORMAT,STORES DATA AND STARTS TIMER INTERVAL.                *
*        IT THEN LOADS THE PROGRAM TO BETRACED INTO CORE AND          *
*        RELATIVISES ALL PARAMETERS TO THE ENTRY POINT.               .
*        IT THEN INITIALISES THE MAIN PROCESSING ROUTINE AND BRANCHES *
*        TO PRINT HEADINGS AND TRACE FIRST INSTRUCTION.               *
*        THIS ROUTINE IS OVERLAID BY A SAVE-AREA AND PRINT BUFFER.    *
*                                                                     *
********** * * * * * * * * * * * * * * * * * * * * * * * * * **********
SPRINTER START
BASE     LR    3,15               ESTABLISH ADDRESSABILITY.
         USING BASE,3             APPLY BASE REGISTER.
         ST    4,INSTRCT          STORE INSTRUCTION-PRINT COUNT.
         ST    5,LOLIMIT          STORE LOWER TRACING LIMIT.
         ST    6,HILIMIT          STORE UPPER LIMIT.
         ST    7,RELATIVE         STORE RELATIVISOR.
         STH   8,PROCHEKS         STORE PROGRAM-CHECK COUNT.
         ST    9,ADDR1            STORE TIMER INTERVAL.
         MVC   TIME(4),ADDR1      MOVE INTERVAL TO STORAGE.
         ST    10,INSTRADD         STORE ENTRY-POINT.
         ST    11,REGSAVE+4       POINT TO USERS PARAMETERS.
         ST    10,REGSAVE+60      PROVIDE USERS ENTRY POINT IN R15.
         STH   2,BRCHONLY         SET BR-ONLY SWITCH.
         ST    13,REGSAVE+52      SAVE R13 IN USERS REGISTER STORE.
         LA    13,SAVEAREA        POINT TO SAVE AREA.
         STIMER REAL,TIMEUP,DINTVL=LIMITIME
         MVI   PR1,X'8B'          SET UP INITIAL ASA PRINT CHARACTER.
         OPEN  (PRINTER,(OUTPUT))      OPEN PRINTER DCB.
         LA    8,CLEAR            SET SUBROUTINE EXIT REGISTER.
         AIF   (&PROCHK2 EQ 0).PR2SK1
         LA    1,PIE              POINT TO PIE ELEMENT.
         SVC   14                 ISSUE SPIE SVC.
.PR2SK1  ANOP
         B     ONCE               GO TO HEADING PRINT AND START.
         TITLE 'OS TRACE CONSTANTS SECTION'
         ORG   BASE
SAVEAREA DS    18F
PR1      DS    CL1
PRINT    DS    CL120
DATA     DS    CL26
         ORG
PRINTER DCB DSORG=PS,MACRF=PM,DDNAME=TRACEOUT,RECFM=FM,BFTEK=S,        C
               LRECL=121,BLKSIZE=121,BUFL=121
OPCODE   EQU   *-16
         DC    C'SPM BALRBCTRBCR SSK ISK SVC         '
         DC    C'            LPR LNR LTR LCR NR  CLR OR  XR  LR  CR  ARC
                 SR  MR  DR  ALR SLR LPDRLNDRLTDRLCDRHDR             '
         DC    C'LDR CDR NADRNSDRNMDRNDDRAWR SWR LPERLNERLTERLCERHER '
         DC    C'            LER CER NAERNSERNMERNDERAUR SUR STH LA  '
         DC    C'STC IC  EX  BAL BCT BC  LH  CH  AH  SH  MH      CVD '
         DC    C'CVB ST              N   CL  O   X   L   C   A   S   '
         DC    C'M   D   AL  SL  STD                             LD  '
         DC    C'CD  NAD NSD NMD NDD AW  SW  STE                     '
         DC    C'        LE  CE  NAE NSE NME NDE AU  SU  SSM     LPSW'
         DC    C'    WRD RDD BXH BXLESRL SLL SRA SLA SRDLSLDLSRDASLDA'
         DC    C'STM TM  MVI TS  NI  CLI OI  XI  LM              SIO '
         DC    C'TIO HIO TCH '
         DS    49CL4
         DC    C'MVN MVC MVZ NC  CLC OC  XC                  TR  TRT '
         DC    C'ED  EDMK                                            '
         DC    C'                        MVO PACKUNPK                '
         DC    C'ZAP CP  AP  SP  MP  DP  '
TABLEF   DC    X'FAFBFCFDFEFF'
         DS    CL41
         DC    C'0123456789ABCDEF'
         ORG   OPCODE+700
TITLE    DC    C' ADDRESS  INSTRUCTION CODE             1ST OP.DATA BEFC
               ORE EXECUTE 2ND OP.DATA BEFORE EXECUTE '
         DC C'1ST OP.DATA AFTER EXECUTE  '
         ORG   OPCODE+324
         DC    A(BASE)
INSTRADD DS    F I-ADDRESS REGISTER
         DS    F
         ORG   OPCODE+612
HILIMIT  DS    F
         ORG   OPCODE+36
RELATIVE DC    F'0'
         ORG   OPCODE+938
PCLINE   DC  C'******(           )*******'  MESSAGE.
         ORG   PCLINE+7
SVCLIT   DC    C'REGS.0,1'
PROCHEKS DS H
         ORG   OPCODE+148
HALF6    DC    H'6'
ADDRESS  DC    X'F0F0F0F0F0F0'
          DC   X'FF'
ABKA     DC   AL3(BKA+4)
         ORG   OPCODE+212
TESTE    DC  8C'0'
         DS    CL2
         ORG   OPCODE+308
BLKCT    DC    H'11'
LINECT   DC    H'4'
         ORG
OPCODEG  DC    X'FFFFFFFFFF100818FFFF'
         DC    X'28FFFFFFFFFF'
         DC    X'0000000000FF000000FF'
         DC    6X'00'
   DC     X'0000000000FFFFFF00FF0000000000000000000000FFFFFF00FF0000000C
               00000FF'
         DC    X'00FF00240C041400FF000000FFFF00'
         DC    X'FFFFFFFF00FF000000FF'
         DC    6X'00'
         DC    X'FFFFFFFFFFFFFFFF00FF000000000000FFFFFFFFFFFFFFFF00FF00C
               0000000000FFFFFFFFFFFF1C20'
         DC    8X'00'
         DC    8X'FF'
         DC    X'38'
         DC    68X'FF'
         DC    X'34FF34'
         DC    32X'FF'
         ORG   OPCODE+988
LOLIMIT  DS    F
         ORG   OPCODEG+113
ADDR1    DS    F
         ORG  OPCODEG+224
         DS    0F
CONSTANT DC   X'0000000F'
TRUNCINS MVC   0(1,9),DATA
SSLEN    DS    H
INSPECT  DS    CL1
         ORG
CONCODE  DS    F
         DS    0D                 ALIGNMENT.
STORY    DC    4C'0'
TESTA    DC    4C'0'
ABENDCON DC    X'0000006F'        ABEND CONSTANT CODE 111.
         AIF   (&MNEMONS EQ 0).MNEMSK1
COMPS    DC    X'00D5D6D720C2C84040C2D34070C2D5C580C2C540B0C2D5D3D0C2D5C
               C8F0C24040'
TMS      DC    X'00D5D6D710C2D64020C2D74040C2D44080C2E940F0C24040'
.MNEMSK1 ANOP
         ORG   OPCODE+984
CONVERT  DS    F
         ORG
PFLAG    DC    C'P*'
         ORG   OPCODE+680
LASTCODE DS    CL2
BXLEINST DC X'1A00'
PADDER   DC    X'18331833'
         ORG   OPCODE+640
OPCODEF  DC  A(BCTB)
         DC    A(BCTBR)
         DC    A(BRLINK)
         DC    A(BRLINKR)
         DC    A(BCBR1)
         DC    A(BCONDR)
         DC    A(BXHBR)
         DC    A(BXLEBR)
         DC    A(EXCTR)
         DC    A(SVCRTN)
         DS   2F
         DC    A(TRTEDMK)
         DC    A(LMRTN)
INSTRCT  DC    F'0'
         ORG   OPCODEG+191
EDITMASK DC    X'4D0000005D6B'
EDITOUT  DC    X'00F1F2F3F4F5F6F7F8F9'
         ORG   OPCODEG+97
PIE      DC    X'0F'
         DC    AL3(PROCHK)
         DC    X'7FFF'
         ORG
SIEDIT   DC    X'6BE74DF0F05D'    EDIT WORD FOR SI TYPE.
         ORG   OPCODEG
AEOJ     DC    AL3(EOJRTN)
         ORG   OPCODE+196
SPIECON  DC    C'SUPPRESSED'
RXLIT    DC    C'RX='
         ORG   OPCODEG+11
HALF11   DC    H'11'
SFLAG    DC    C'S*'
         ORG   OPCODE+412
R2STORE  DS  F
         TITLE 'OS TRACE INSTRUCTION SIMULATORS'
********** * * * * * * * * * * * * * * * * * * * * * * * * * **********
*        INSTRUCTION SIMULATORS.                                      *
*                                                                     *
*        THESE ROUTINES SIMULATE INSTRUCTIONS WHICH CANNOT BE EXECUTED*
*        BECAUSE OF LOSS OF CONTROL BY SPRINT IF BRANCHING SHOULD     *
*        OCCUR,INSTRUCTIONS ARE-BC,BCR,BCT,BCTR,BAL,BALR,BXH,BXLE,EX. *
*        THE LABEL OF EACH ROUTINE INDICATES WHICH INSTRUCTION IT     *
*        SIMULATES.ROUTINES OFTEN ENTER OTHER ROUTINES TO SAVE CORE,  *
*        AND A COMMON SUBROUTINE EXISTS AT 'NEXTD'.                   *
*                                                                     *
********** * * * * * * * * * * * * * * * * * * * * * * * * * **********
         ORG   OPCODEG+153
NEXTD    B     NEXTA              GO TO PROCESS NEXT INSTRUCTION.
         XC    PRINT+39(79),PRINT+39   CLEAR PARTIAL PRINT LINE.
         B     BKA+4              GO TO FINISH PRINTOUT EDITING.
         SPACE
BCTB     IC    2,1(4)             LOAD R2 WITH 2ND INSTRUCTION BYTE.
         SRL   2,4                LOSE INDEX REGISTER BITS
         SLL   2,2                MULTIPLY REGISTER NO.BY 4
         L     7,REGSAVE(2)       LOAD R7 WITH REGISTERS CONTENTS.
         BCT   7,BRBA             SIMULATE BCT INSTRUCTION.
         B     BRBC               GO IF DROP-THRU FROM BCT.
         ORG   OPCODE+388
BRBA     MVC   INSTRADD,ADDR1     MOVE BRANCH ADDRESS TO ADDRESS REGIST
BRBC     ST    7,REGSAVE(2)       RESTORE REG.CONTENTS TO USER STORE.
INSTRU   B     NEXTA              DROP IF PRINTING INSTRUCTION.
         XC    PRINT+66(8),PRINT+66    CLEAR PARTIAL PRINT LINE.
         B     OTHER              GO TO CONTINUE INSTRUCTION EDITING.
         SPACE
         ORG  OPCODE+896
BCTBR    LH    6,0(4)             LOAD R6 WITH INSTRUCTION HALFWORD.
         N    6,CONSTANT          CLEAR OUT ALL BUT BRANCH REGISTER.
         SLL   6,2                MULTIPLY REG.NO.BY 4.
         TM    1(4),X'0F'         TEST FOR 'BR 0'
         BZ    *+16               GO IF EQUAL TEST.
         L     7,REGSAVE(6)       ELSE OBTAIN REGISTER CONTENTS AND
         ST    7,ADDR1            STORE IN ADDRESS REGISTER.
         B     BCTB               GO TO BCT SIMULATOR.
         MVC   ADDR1(4),INSTRADD       FORCE NO-BRANCH SIMULATE,
         B     BCTB               GO TO BCT SIMULATOR.
         ORG
         SPACE
BRLINK   OI    CONCODE,X'80'      SET INSTRUCTION LENGTH COUNT.
         NI    CONCODE,X'BF'      CLEAR OLD ILC OUT.
         IC    2,1(4)             LOAD 2ND INSTRUCTION BYTE.
         SRL   2,4                CLEAR OUT INDEX REGISTER BITS.
         SLL   2,2                MULTIPLY REG.NO.BY 4,
         MVC   INSTRADD(1),CONCODE     MOVE IN 1ST PSW BYTE.
         L     7,INSTRADD         LOAD R7 WITH NEXT INSTR.ADDRESS,
         B     BRBA               GO TO SIMULATE BAL.
         SPACE
         ORG   TABLEF+6
BRLINKR  TM    1(4),X'0F'         TEST FOR BALR X,0
         BZ    INSTRF             GO IF CORRECT TEST.
         LH    6,0(4)             LOAD INSTRUCTION HALFWORD IN R6.
         N    6,CONSTANT          CLEAR OUT ALL BUT BRANCH REGISTER NO.
         SLL   6,2                MULTIPLY REG.NO.BY 4.
         L     7,REGSAVE(6)       OBTAIN REGISTER CONTENTS.
         ST    7,ADDR1            STORE CONTENTS IN ADDRESS STORE.
         B     BRLINK+8           GO TO SIMULATE BAL.
         ORG   OPCODE+628
INSTRF   MVC   ADDR1(4),INSTRADD       ENSURE NO-BRANCH SIMULATION.
         B     BRLINK+8           GO TO SIMULATE BAL.
         ORG
EXCTR    L     4,ADDR1
         MVC   TYPECODE(2),0(4)   MOVE INSTR.HALFWORD TO STORE.
         MVI   LIVEXIT+1,X'F0'
         MVC   R2STORE+3(1),0(4)  MOVE OPCODE TO STORE.
         TR    R2STORE+3(1),OPCODEG     LOOK UP TABLE.
         L     2,R2STORE          LOAD INTO REGISTER 2.
         B     AWAY
         SPACE
BXLEBR    EQU    *
BXHBR    IC    9,1(4)
         STC   9,ADDB+1
         STC   9,COMPB+1
         OI    COMPB+1,X'01'
         LM    0,15,REGSAVE       LOAD USERS REGISTERS.
ADDB     AR    0,0
COMPB    CR    0,0
         BALR   3,0
         L     3,BASECON-*(3)
         LM    4,5,INSTRADD-4
         BH    RTNB1
         CLI   TYPECODE,X'87'
         BNE   OUTB1
         MVC    INSTRADD(4),ADDR1
OUTB1    MVC   INSTRY(6),BXLEINST MOVE SIMULATED INSTR. TO EXECUTOR.
         MVC   INSTRY+1(1),1(4)   MOVE IN CORRECT REGISTERS.
         B    BXOUT
         ORG   OPCODE+820
RTNB1    CLI    TYPECODE,X'86'
         BNE    OUTB1
         B    OUTB1-6
         ORG
         SPACE
BCOND    NI    TYPECODE+1,X'F0'   CLEAR INDEX REGISTER IN SIMULATOR.
         L     15,CONCODE         LOAD R15 WITH CONDITION CODE WORD.
         SPM   15                 SET CONDITION CODE.
TYPECODE B     *+8                SIMULATE BC INSTRUCTION.
         B     NEXTD              GO TO COMMON DISPATCHER.
         MVC   INSTRADD,ADDR1     MOVE BRANCH ADDRESS TO ADDRESS REG.
         B     NEXTD              GO TO COMMON DISPATCHER.
         SPACE
BCONDR   TM    1(4),X'0F'         TEST FOR NOPR INSTRUCTION.
         MVI   TYPECODE,X'47'     SET UP BC SIMULATOR TO HANDLE BCR.
         BZ    BCBR1              GO IF NOPR.
         LH    6,0(4)             LOAD R6 WITH INSTRUCTION HALFWORD.
         N    6,CONSTANT          CLEAR OUT ALL BUT BRANCH REGISTER.
         SLL   6,2                MULTIPLY REG.NO.BY J.
         L     7,REGSAVE(6)       OBTAIN REGISTER CONTENTS.
         ST    7,ADDR1            STORE CONTENTS AS ADDRESS STORE.
BCBR1    B     BCOND              GO TO SIMULATE BC INSTRUCTION.
         AIF   (&MNEMONS EQ 0).MNEMSK2
********** * * * * * * * * * * * * * * * * * * * * * * * * * **********
*        EXTENDED-MNEMONIC GENERATOR.                                 *
*                                                                     *
*        THIS ROUTINE ATTEMPTS TO OBTAIN AN EXTENDED MNEMONIC TO      *
*        REPLACE A BC OR BCR INSTRUCTION ON PRINTOUT.IF NOT SUCCESSFUL*
*        INSTRUCTION PRINTS AS NORMAL.IF A SUITABLE MNEMONIC IS FOUND,*
*        IT REPLACES INSTRUCTION CODE ON PRINTOUT.                    *
*        DIFFERENT MNEMONICS ARE PRINTED DEPENDING ON CONDITION CODE  *
*        TEST,AND ON INSTRUCTION TYPE WHICH LAST SET CONDITION CODE.  *
*        EG-BC 8 PRINTS AS BE AFTER A CLC,BUT AS BZ AFTER TM.         *
*                                                                     *
********** * * * * * * * * * * * * * * * * * * * * * * * * * **********
         LA    6,TMS              POINT TO MNEMONIC STRING 1.
         CLI   LASTCODE,C'C'
         BNE   *+8                UNEQUAL PATH.
         LA    6,COMPS
PUTIT    MVN   0(1,6),1(4)
         CLC   0(1,6),1(4)
         BE    OUTIT
         BH    BCOND
         LA    6,4(6)
         B     PUTIT
OUTIT    MVC   PRINT+10(3),1(6)
         MVC  PRINT+15(9),PRINT+18
         B     BCOND
.MNEMSK2 ANOP
     TITLE 'OS TRACE COMMON SUBROUTINE BANK'
********** * * * * * * * * * * * * * * * * * * * * * * * * * **********
*        HIGH-SPEED LOOP.                                             *
*                                                                     *
*        THIS LOOP IS ENTERED FROM THE ROUTINE AT 'NEXTA' WHEN AN     *
*        INSTRUCTION IS FOUND TO BE OUTSIDE PRINTING LIMITS.          *
*        ROUTINE DETERMINES IF INSTRUCTION MUST                       *
*        BE SIMULATED,AND PROVIDES IN R2 INDEX TO OBTAIN SIMULATOR    *
*        ADDRESS.IF NOT SIMULATED,INSTRUCTION PROCEEDS DIRECT TO      *
*        EXECUTION ROUTINE.                                           *
*        SIMULATED INSTRUCTIONS PROCEED TO 'LIVE' TO CALCULATE 1ST    *
*        OPERAND ADDRESS FOR BRANCHING PURPOSES.ON RETURN,INSTRUCTION *
*        PROCEEDS TO ITS SIMULATOR.                                   *
*                                                                     *
********** * * * * * * * * * * * * * * * * * * * * * * * * * **********
AWAY     STM   4,5,INSTRADD-4
         TM    R2STORE+3,X'FF'    TEST FOR SPECIALS.
         BO    CARRYON2           GO IF INSTR.DOES NOT ALTER REGS.
         BZ    CONTINUE           GO IF IT DOES.
         TM    TYPECODE,X'C0'     TEST FOR RR TYPE SPECIAL.
         BC    9,LIVEBACK+8       EQUAL PATH.
         B      LIVE              ELSE GO TO CALCULATE BRANCH ADDRESS.
LIVEBACK L     2,R2STORE          LOAD R2 WITH ADDRESS TABLE INDEX.
         LM    4,5,INSTRADD-4     RESTORE REGS.4,5.
         L     9,OPCODEF-4(2)     GET SIMULATOR ADDRESS.
         BR    9                  GO TO SIMULATOR.
********** * * * * * * * * * * * * * * * * * * * * * * * * * **********
*        PRINTING ROUTINE.                                            *
*                                                                     *
*        ROUTINE PRINTS A LINE AND RETURNS VIA REGISTER 9.            *
*                                                                     *
********** * * * * * * * * * * * * * * * * * * * * * * * * * **********
         ORG   OPCODE+44
PRINTER2 LA    13,SAVEAREA
         PUT   PRINTER,PR1
         BR    9
         ORG
********** * * * * * * * * * * * * * * * * * * * * * * * * * **********
*        TIMER INTERRUPT HANDLER.                                     *
*                                                                     *
*        ROUTINE ESTABLISHES ADDRESSABILITY,SETS UP ABEND CODE AND    *
*        GOES TO ABEND ROUTINE.                                       *
*                                                                     *
********** * * * * * * * * * * * * * * * * * * * * * * * * * **********
         ORG   OPCODE+616
TIMEUP   L     3,BASECON-*(15)
         AIF   (&PROCHK2 EQ 0).TIMSK1
         MVI   ABENDCON+3,X'DE'   MOVE USER CODE TO ABEND CONSTANT.
         B     DUD+8              GO TO ABEND ROUTINE.
         AGO   .TIMSK2
.TIMSK1    ANOP
         ABEND 0002
.TIMSK2 ANOP
         ORG
         EJECT
********** * * * * * * * * * * * * * * * * * * * * * * * * * **********
*        DATA TRUNCATION ROUTINE.                                     *
*                                                                     *
*        ROUTINE TRUNCATES OPERAND DATA FOR SS TYPE INSTRUCTIONS TO   *
*        LENGTH IN INSTRUCTION AND MOVES DATA TO PRINT-LINE.          *
*        AT ENTRY,R6 CONTAINS LENGTH IN BINARY,                       *
*                 R9 CONTAINS ADDRESS ON PRINT-LINE FOR DATA MOVE.    *
*        IF MORE THAN 24 BYTES ARE INDICATED,ROUTINE TRUNCATES TO 24. *
*                                                                     *
********** * * * * * * * * * * * * * * * * * * * * * * * * * **********
TRUNCRTN EQU   *
         AIF   (&TRUNCAT EQ 0).TRUSK1
         CH    6,HALF11           TEST IF LENGTH OVER 9 BYTES.
         BC    10,OVER
         LA    6,1(6)
         STC   6,INSPECT
         AR  6,6
         CLI   INSPECT,X'05'      5 BYTES OR MORE TO PRINT,
         BL    *+8
         LA    6,1(6)
         CLI   INSPECT,X'09'      9 BYTES OR MORE TO PRINT,
         BL    *+8
         LA    6,1(6)
         BCT   6,*+8              DECREMENT COUNT BY ONE AND JUMP.
.TRUSK1  ANOP
OVER     LA    6,25               LOAD MAXIMUM COUNT VALUE.
         EX    6,TRUNCINS         MOVE DATA TO PRINT-LINE.
         BR    10
********** * * * * * * * * * * * * * * * * * * * * * * * * * **********
*        HEADING ROUTINE.                                             *
*                                                                     *
*        PRINTS PAGE HEADINGS BY LINKS TO PRINTING ROUTINE,AND RETURNS*
*        VIA REGISTER8.                                               *
*                                                                     *
********** * * * * * * * * * * * * * * * * * * * * * * * * * **********
HEADRTN  MVI   PR1,X'89'
         BAL   7,LINER
ONCE     BAL   9,PRINTER2         LINK TO PRINT A LINE.
         MVC   PRINT(120),TITLE   MOVE HEADING LINE TO PRINT.
         MVI   PR1,X'09'
         BAL   9,PRINTER2
         BAL   7,LINER
         LR    9,8
         B     PRINTER2
         EJECT
********** * * * * * * * * * * * * * * * * * * * * * * * * * **********
*        PRINT REGISTER CONTENTS.                                     *
*                                                                     *
*        ROUTINE SUPPLIES IN'TESTE' PRINTABLE CONTENTS OF A GIVEN     *
*        USERS REGISTER,OR FULLWORD AT GIVEN ADDRESS.                 *
*        REGISTER NO.IS PASSED IN R6 IN BINARY.                       *
*        ENTRY IS MADE AT 'REGPRINT+8' TO PRINT FULLWORD AT ADDRESS   *
*        PASSED IN REGISTER 9.RETURN IS VIA REGISTER 10.              *
*                                                                     *
********** * * * * * * * * * * * * * * * * * * * * * * * * * **********
         ORG   OPCODE+512
REGPRINT SLL   6,2
         LA    9,REGSAVE(6)
         UNPK  TESTE(9),0(5,9)
         TR    TESTE(8),TABLEH
         BR    10
         ORG
********** * * * * * * * * * * * * * * * * * * * * * * * * * **********
*        STATIONERY SETUP ROUTINE.                                    *
*                                                                     *
*        ROUTINE WILL CONSTRUCT UNDERLINING PRINT LINE IN PRINT AREA  *
*        AND RETURN VIA REGISTER 7.ENTRY AT 'DIVIDERS' WILL SET UP    *
*        VERTICAL FIELD DIVIDERS ON AN INSTRUCTION PRINT-LINE.        *
*                                                                     *
********** * * * * * * * * * * * * * * * * * * * * * * * * * **********
LINER    MVI   PRINT+1,X'60'
         MVC   PRINT+2(117),PRINT+1
         MVI   PRINT,C'O'
DIVIDERS MVC   PRINT+38(1),PRINT
         MVC   PRINT+65(1),PRINT
         MVC   PRINT+92(1),PRINT
         MVC   PRINT+119(1),PRINT
         MVC   PRINT+7(1),PRINT
         BR    7
         AIF   (&FLOATPT EQ 0).FLOSK3
FPRINT   MVC   *+11(1),TYPECODE+1 GET REGISTER NO.
         NI    *+5,X'F0'          ZEROISE INDEX REGISTER.
         STD   0,STORY            GET REGISTER CONTENTS.
         LA    9,STORY            POINT TO CONTENTS.
         BAL   8,DATAPULL         GO TO TRANSLATE TO PRINTABLE FORM.
         MVC   0(17,10),DATA      MOVE DATA TO PRINT.
         MVI FLPSW,X'FF'          SET SWITCH
         BR    11                 RETURN TO ROUTINE.
FLPSW    DC    X'00'
.FLOSK3  ANOP
         TITLE 'OS TRACE MAIN LINE'
********** * * * * * * * * * * * * * * * * * * * * * * * * * **********
*        TRACE INSTRUCTION LENGTH CALCULATOR AND DATA MOVER.          *
*                                                                     *
*        THIS ROUTINE CALCULATES THE LENGTH OF THE CURRENT INSTRUCTION*
*        AND MOVES THE APPROPRIATE NUMBER OF INSTRUCTION BYTES TO THE *
*        EXECUTION AREA. THE ROUTINE ALSO STORES ADDRESS OF NEXT      *
*        SEQUENTIAL INSTRUCTION AND DECIDES IF INSTRUCTION SHOULD BE  *
*        PRINTED.IF NOT,ROUTINE TRANSFERS CONTROL TO A HIGH-SPEED     *
*        EXECUTION INSTRUCTION PATH.OTHERWISE ROUTINE DROPS THROUGH   *
*        TO THE LOW-SPEED PATH TO FORMAT AND EDIT THE INSTRUCTION     *
*        IMAGE,AND 1ST AND 2ND OPERAND DATA.                          *
*                                                                     *
********** * * * * * * * * * * * * * * * * * * * * * * * * * **********
NEXTA    L     4,INSTRADD         POINT AT NEXT INSTRUCTION
         LH    7,0(4)             LOAD 1ST INSTR.HALFWORD,
         STH   7,TYPECODE         SAVE FOR FUTURE REFERENCE.
         LA    6,INSTRZ           POINT R6 AT EXECUTION AREA 1.
         SR    2,2                CLEAR R2 FOR TRT.
         IC    2,0(4)             INSERT 1ST OPCODE BYTE.
         LA    12,OPCODEG(2)      PERFORM TABLE LOOKUP INDEXING.
         IC    2,0(12)            LOAD TABLE BYTE.
         TM    0(12),X'FF'        TEST IF CHANGES REGS.
         BO    *+8                UNEQUAL PATH.
         LA    6,INSTRY           AND POINT AT EXECUTION AREA 2.
         TM    0(4),X'C0'         TEST FOR INSTRUCTION TYPE.
         BO    MOVESS             GO IF SS TYPE ONLY.
         L     9,PADDER           ELSE LOAD DUMMY INSTRS INTO R9.
         STH   7,0(6)             STORE 1ST INSTR.HALFWORD IN EXECUTOR.
         ST    9,2(6)             STORE DUMMIES TO PAD EXECUTOR.
         LA    5,2(4)             BUMP R5 TO INSTR.ADDRESS+2.
         BZ    MOVEIN             RR TYPE ARE COMPLETE,RX TYPES DROP.
         LH    7,2(4)             LOAD 2ND INSTRUCTION HALFWORD.
         STH   7,2(6)             STORE IN EXECUTION AREA.
         LA    5,2(5)             BUMP R5 BY 2 FOR RX,RS,SI TYPES.
         B     MOVEIN             SKIP OVER SS TYPE ROUTINE.
MOVESS   LA    5,6(4)             POINT R5 AT NEXT SEQUENTIAL INSTR.
         MVC   0(6,6),0(4)        MOVE SS TYPE TO EXECUTOR.
MOVEIN   EQU   *
         ST    2,R2STORE          SAVE R2 CONTENTS.
         LA    4,0(4)             STRIP BITS 0-7 FOR COMPARE.
         C     4,LOLIMIT          TEST IF UNDER LOW LIMIT.
         BC    4,AWAY             GO IF UNDER.
         C     4,HILIMIT          TEST IF OVER TOP LIMIT.
         BC    2,AWAY             GO IF OVER.
         EJECT
********** * * * * * * * * * * * * * * * * * * * * * * * * * **********
*        LOW-SPEED PATH.                                              *
*                                                                     *
*        THIS ROUTINE SPLITS OFF RR TYPE INSTRUCTIONS TO AN RR TYPE   *
*        FORMATTER ROUTINE,THEN CALCULATES INSTRUCTION 1ST OPERAND    *
*        ADDRESS FOR ALL OTHER TYPES,AND STORES ADDRESS.ROUTINE THEN  *
*        SPLITS INSTRUCTIONS DOWN INTO TYPES,EACH OF WHICH HAS ITS OWN*
*        FORMATTING ROUTINE.                                          *
*        THE HIGH-SPEED ROUTINE ENTERS THIS ROUTINE AT'LIVE' IN ORDER *
*        TO CALCULATE ADDRESSES FOR BRANCH-TYPE INSTRUCTIONS.         *
*        DROP-THRU SWITCHES ARE SET BY THIS ROUTINE TO SAY INSTRUCTION*
*        WILL PRINT.SWITCHES ARE RESET AT END OF INSTRUCTION TRACER SO*
*        THAT IF NEXT INSTRUCTION DOES NOT PRINT,ALL SWITCHES ARE SET *
*        TO DIRECT BRANCHING WITHOUT NEED TO TEST.THIS TECHNIQUE SLOWS*
*        LOW-SPEED ROUTINE UP BUT SPEEDS UP CRITICAL HIGH-SPEED       *
*        ROUTINE SIGNIFICANTLY.                                       *
*                                                                     *
********** * * * * * * * * * * * * * * * * * * * * * * * * * **********
PRINTIT  MVI   LIVEXIT+1,X'00'    *
         MVI  NEXTD+1,X'00'       *
         AIF   (&MNEMONS EQ 0).MNEMSK5
         MVI  BCBR1+1,X'00'       **SET OFF DROP-THRU SWITCHES
.MNEMSK5 ANOP
         MVI   INSTRW+1,X'00'     *
         MVI   INSTRU+1,X'00'     *
         STM   4,5,INSTRADD       STORE NEXT INSTRUCTION ADDRESS.
         TM    TYPECODE,X'C0'     TEST FOR RR TYPE.
         BZ    RR                 EQUAL PATH.
LIVE     LH    6,2(4)             *MOVE BASE-ADDRESS FROM
         STH   6,LOADADDR+2       *INSTRUCTION TO CALCULATOR.
         CLI   TYPECODE,X'7F'     TEST FOR RX TYPE
         BH    *+10               UNEQUAL PATH.
         MVN   LOADADDR+1(1),1(4) MOVE INDEX TO CALCULATOR.
         LR    0,3                SAVE BASE REGISTER.
         LM    1,15,REGSAVE+4     LOAD USERS REGISTERS FOR CALCULATION.
LOADADDR LA    6,*                CALCULATE FIRST ADDRESS.
         LR    3,0                RESTORE BASE REGISTER.
         MVI   LOADADDR+1,X'60'   CLEAR CALCULATOR INDEX.
         ST    6,ADDR1            SAVE CALCULATED ADDRESS.
LIVEXIT  B     LIVEBACK           GO IF NON-PRINTING INSTRUCTION ONLY.
         LM    4,5,INSTRADD       RESTORE R4,R5.
         LR    9,6                LOAD ADDRESS INTO R9.
         S     6,RELATIVE         RELATIVISE.
         BC    2,*+8              BRANCH IF STILL > 0.
         A     6,RELATIVE         ELSE DE-RELATIVISE.
         ST   6,CONVERT           STORE RELATIVISED ADDRESS.
         UNPK  ADDRESS(7),CONVERT+1(4) CONVERT TO SEMI-PRINTABLE.
         TR    ADDRESS(6),TABLEH  CONVERT TO ALPHA-NUMERIC FORMAT.
         LA    8,LABR             ESTABLISH EXIT FROM SUBROUTINE.
DATAPULL UNPK  DATA(9),0(5,9)     CONVERT 1ST 8 BYTES TO SEMI-PRINTABLE
         UNPK  DATA+9(9),4(5,9)   CONVERT 2ND 8 BYTES TO SEMI-PRINTABLE
         UNPK  DATA+18(9),8(5,9)  CONVERT 3RD 8 BYTES TO SEMI-PRINTABLE
         TR    DATA(26),TABLEH    CONVERT ALL DATA TO PRINTABLE HEX.
         MVI   DATA+8,X'40'       MOVE IN SEPARATOR BLANK.
         MVI   DATA+17,X'40'      MOVE IN SEPARATOR BLANK.
         BR    8                  EXIT FROM SUBROUTINE.
LABR     SR    6,6                CLEAR R6.
         IC    6,1(4)             LOAD 2ND.INSTRUCTION BYTE.
         TM    TYPECODE,X'C0'     TEST FOR SS TYPE.
         BO    SS                 EQUAL PATH.
         TM    TYPECODE,X'80'     TEST FOR RX TYPE.
         BZ    RX                 EQUAL     PATH.
         CLI   TYPECODE,X'98'     TEST FOR 'LM'.
         BE    RS1                GO IF EQUAL.
         CLI   TYPECODE,X'90'     TEST FOR 'STM'.
         BH    SI                 GO IF SI TYPE.
         BE    RS1                EQUAL PATH.
********** * * * * * * * * * * * * * * * * * * * * * * * * * **********
*        PRINT FORMATTERS.                                            *
*                                                                     *
*        THESE ROUTINES FORMAT AND EDIT INSTRUCTION CODE AND OPERAND  *
*        DATA INTO THE PRINT-LINE. AFTER FORMATTING INSTRUCTION,      *
*        ALL ROUTINES GO TO 'GATHER' IN COMMON INSTRUCTION FORMATTER. *
*                                                                     *
********** * * * * * * * * * * * * * * * * * * * * * * * * * **********
RS       CLI   TYPECODE,X'88'     TEST FOR SHIFT-TYPE INSTRUCTIONS.
         BL    RS3                GO IF BXH OR BXLE.
         XC    DATA(26),DATA      ENSURE NO DATA PRINT FOR ADDRESS.
         CLI   TYPECODE,X'8C'     TEST FOR DOUBLE SHIFT.
         BL    RX                 UNEQUAL PATH.
         SRL   6,4                DROP R2 OPERAND.
         LA    6,1(6)             BUMP REGISTER TO NEXT HIGHEST.
         BAL   10,REGPRINT        GO TO GET REGISTER CONTENTS.
         MVC   PRINT+48(8),TESTE  MOVE DATA TO PRINT.
         IC   6,1(4)
RX       SRL   6,4                REMOVE INDEX REGISTER NO.
         CVD   6,STORY
         BAL   10,REGPRINT
         MVC   PRINT+39(8),TESTE
         UNPK  PRINT+15(2),STORY+6(2)  UNPACK REGISTER NO.TO PRINT.
         OI    PRINT+16,X'F0'     ENSURE NUMERIC CODE.
         TR    PRINT+15(1),EDITOUT-240 ZERO-SUPPRESSION.
         MVI   PRINT+17,X'6B'
         MVC   PRINT+18(6),ADDRESS
         CLI  0(4),X'41'
         BE    RXTEST
         CLI   0(4),X'4E'
         BL    *+18
         CLI   0(4),X'4F'
         BH    *+10
         MVC   PRINT+75(8),DATA+9
         MVC   PRINT+66(8),DATA
         AIF   (&FLOATPT EQ 0).FLOSK2
         TM    TYPECODE,X'60'     TEST FOR RX F-P INSTR.
         BC    14,RXTEST          UNEQUAL PATH.
         MVC   PRINT+75(8),DATA+9      MOVE DATA TO PRINT-LINE.
         LA    10,PRINT+39        POINT TO DATA PRINT-AREA.
         BAL   11,FPRINT          LINK TO PRINT F-P REGISTER.
.FLOSK2  ANOP
RXTEST   EQU   *
         AIF   (&RXPRINT EQ 0).RXPSK1
         TM    1(4),X'0F'         TEST IF BASE REGISTER=0.
         BZ    GATHER
         TM    2(4),X'F0'
         BZ    GATHER
         MVC   PRINT+34(3),RXLIT
         LR    9,4
         BAL   10,REGPRINT+8
         MVC   PRINT+37(1),TESTE+3
.RXPSK1  ANOP
         B     GATHER
         ORG   OPCODE+452
RS3      SRL   6,4                REMOVE R2 NUMBER.
         LA    6,1(6)             BUMP TO NEXT HIGHEST REGISTER.
         BAL   10,REGPRINT        GO TO GET REGISTER CONTENTS.
         MVC   PRINT+75(8),TESTE  MOVE DATA TO PRINT.
         B     RS2                RETURN TO MAIN RS-TYPE LOOP.
         ORG
RS1      MVC   PRINT+66(26),DATA
RS2      MVC   PRINT+21(6),ADDRESS     MOVE ADDRESS TO PRINT LINE.
         MVI   PRINT+20,X'6B'
RR       IC    6,1(4)             LOAD 2ND INSTRUCTION BYTE.
         N     6,CONSTANT         REMOVE R2 NUMBER.
         CVD   6,STORY            CONVERT TO DECIMAL.
         CLI   TYPECODE,X'8F'     TEST FOR LM OR STM.
         BH    *+14               GO IF LM OR STM.
         BAL   10,REGPRINT
         MVC   PRINT+66(8),TESTE
         UNPK  PRINT+18(2),TESTA+2(2)  GET REGISTER NO.
         OI    PRINT+19,X'F0'     ENSURE NUMERIC CODE.
         TR    PRINT+18(1),EDITOUT-240 ZERO-SUPPRESS.
         MVI   PRINT+17,X'6B'
         IC    6,1(4)
         SRL   6,4
         CVD   6,STORY            CONVERT TO DECIMAL.
         BAL   10,REGPRINT
         MVC   PRINT+39(8),TESTE
         UNPK  PRINT+15(2),TESTA+2(2)  GET REGISTER NO.
         OI    PRINT+16,X'F0'     ENSURE NUMERIC CODE.
         TR    PRINT+15(1),EDITOUT-240 ZERO-SUPPRESS.
         AIF   (&FLOATPT EQ 0).FLOSK1
         TM    TYPECODE,X'20'     TEST FOR F-P RR INSTRUCTION.
         BZ    GATHER             NO,GO TO COMMON FORMATTER.
         LA    10,PRINT+39        POINT TO PRINT AREA.
         BAL   11,FPRINT          GET F-P REGISTER CONTENTS.
         MVO   FPRINT+11(1),TYPECODE+1(1)   MOVE REG.NO.TO ROUTINE.
         LA    10,PRINT+66        POINT TO PRINT AREA.
         BAL   11,FPRINT          GET F-P REGISTER CONTENTS.
.FLOSK1  ANOP
         B     GATHER
SS       MVC   PRINT+15(6),ADDRESS
         LA    9,PRINT+39
         TM    0(4),X'F0'
         BC    12,UNPACK1
         SRL   6,4
UNPACK2  BAL   10,TRUNCRTN
         STH   6,SSLEN
         LH    6,4(4)
         STH   6,LDADDR+2
         LR    0,3
         LM    1,15,REGSAVE+4
LDADDR   LA    6,*
         LR    3,0
         LM    4,5,INSTRADD
         LR    9,6
         S     6,RELATIVE
         BC    2,*+8
         A     6,RELATIVE
         ST    6,CONVERT
         UNPK  ADDRESS(7),CONVERT+1(4)
         TR    ADDRESS(6),TABLEH
         BAL   8,DATAPULL
         MVC   PRINT+21(6),EDITMASK
         LR    7,9
         LA    9,PRINT+66
         AIF   (&NOPACKS EQ 0).NOPSK2
         TM    0(4),X'F0'
         BO    SSP
.NOPSK2  ANOP
         LH    6,SSLEN
         AIF   (&PRINTEB EQ 0).PRISK2
         MVI   PRINT+83,C'='
         EX    0,MOVEUNPK
.PRISK2  ANOP
         EX    6,TRUNCINS
         IC    6,1(4)
BRBACK   LA    6,1(6)
         CVD   6,STORY
         UNPK  PRINT+22(3),TESTA+2(2)  GET INSTRUCTIONS LENGTH.
         OI    PRINT+24,X'F0'     ENSURE NUMERIC CODE.
         TR    PRINT+22(2),EDITOUT-240 ZERO-SUPPRESS.
         MVC   PRINT+27(6),ADDRESS
         B     GATHER
SSP      EQU   *
         AIF   (&NOPACKS EQ 0).NOPSK1
         IC    6,1(4)             LOAD 2ND.INSTR.BYTE.
         N     6,CONSTANT
         LA    6,1(6)
         CVD   6,STORY
         MVC   PRINT+33(5),EDITMASK
         ED    PRINT+33(4),TESTA+2
         UNPK  PRINT+34(3),TESTA+2(2)  GET INSTRUCTION LENGTH.
         OI    PRINT+36,X'F0'     ENSURE NUMERIC CODE.
         TR    PRINT+34(2),EDITOUT-240 ZERO-SUPPRESS.
         BCTR  6,0
         BAL   10,TRUNCRTN
         MVI   PRINT+33,X'4D'
         IC    6,1(4)
         SRL   6,4
.NOPSK1  ANOP
         B     BRBACK
         AIF   (&PRINTEB EQ 0).PRISK1
UNPACK1  MVI   MOVEUNPK+1,X'00'
         LA    8,UNPACK2
         CLI   1(4),X'07'
         BCR   2,8
         L     7,ADDR1
         MVI   17(9),C'='
         STC   6,MOVEUNPK+1
MOVEUNPK MVC   18(0,9),0(7)
         BCR   15,8
.PRISK1  ANOP
SI       MVC   PRINT+15(6),ADDRESS
         MVC   PRINT+39(2),DATA
         MVC   PRINT+21(6),SIEDIT MOVE EDIT WORD TO PRINT.
         LR    9,4                POINT R9 AT INSTRUCTION CODE.
         BAL   10,REGPRINT+8      GO TO PRINT-FORMAT INSTRUCTION.
         MVC   PRINT+24(2),TESTE+2     MOVE DATA TO PRINT.
*
********** * * * * * * * * * * * * * * * * * * * * * * * * * **********
*        COMMON INSTRUCTION FORMATTER.                                *
*                                                                     *
*        THIS ROUTINE IS COMMON TO ALL PRINTING INSTRUCTIONS.         *
*        IT FORMATS THE OPCODE AND INSTRUCTION ADDRESS TO PRINT-LINE. *
*                                                                     *
********** * * * * * * * * * * * * * * * * * * * * * * * * * **********
GATHER   SR    6,6                CLEAR R6.
         IC    6,0(4)             INSERT OPCODE.
         SLL   6,2                MULTIPLY BY 4.
         LA    6,OPCODE(6)        FIND OPCODE-NAME ADDRESS.
         MVC   PRINT+10(4),0(6)   MOVE TO PRINT.
         LR    6,4                LOAD R6 WITH INSTR-ADDRESS.
         S     6,RELATIVE         RELATIVISE.
         BC    10,*+8             BRANCH IF STILL POSITIVE,
         A     6,RELATIVE         ELSE DE-RELATIVISE.
         ST    6,ADDRESS+2        MOVE ADDRESS TO WORK-AREA.
         UNPK  PRINT+1(7),ADDRESS+3(4) CONVERT TO ZONED-FORMAT.
         TR    PRINT+1(6),TABLEH  CONVERT ZONED TO ALPHA-NUMERIC FORM.
         TR    PRINT+1(1),EDITOUT-240
         EJECT
********** * * * * * * * * * * * * * * * * * * * * * * * * * **********
*        TRACE EXECUTION ROUTINE.                                     *
*                                                                     *
*        ROUTINE DETERMINES IF INSTRUCTION MUST BE                    *
*        SIMULATED,AND PROVIDES BRANCHING ADDRESS TO SIMULATOR.       *
*        HAVING DISPATCHED SIMULATORS,ROUTINE TESTS IF                *
*        INSTRUCTION CAN POSSIBLY CHANGE REGISTER CONTENTS.IF NOT,    *
*        INSTRUCTION IS DIRECTED TO AN EXECUTOR WHICH DOES NOT SAVE   *
*        REGISTER CONTENTS AFTER EXECUTION.                           *
*        THIS HAS A SIGNIFICANT TIMING EFFECT,REDUCING EXECUTION TIME *
*        BY ABOUT ONE-FIFTH,AND IS ONE OF THE MOST POWERFUL WEAPONS OF*
*        THE HIGH-SPEED LOOP.                                         *
*        IF INSTRUCTION DOES CHANGE REGISTER CONTENTS,ROUTINE TESTS IF*
*        R15 COULD BE CHANGED.IF NOT,ANOTHER TIME-SAVING IS PRODUCED  *
*        BY ABANDONING R15 CONTENTS AFTER EXECUTION.                  *
*        IF R15 IS ALTERED,INSTRUCTION IS EXECUTED TWICE,SAVING R15   *
*        CONTENTS AFTER FIRST TIME,OTHERS AFTER SECOND TIME.          *
*        THIS IS ANOTHER INSTANCE OF SLOWING DOWN A FEW INSTRUCTIONS  *
*        IN ORDER TO SPEED UP MANY MORE.                              *
*                                                                     *
********** * * * * * * * * * * * * * * * * * * * * * * * * * **********
         STM   4,5,INSTRADD-4     SAVE R4,R5.
CHECKOUT BC    0,JUMP             BRANCH IF PROGRAM CHECK RE-RUN.
         TM    R2STORE+3,X'FF'    TEST FOR SPECIALS.
         BO    CARRYON2           GO IF INSTR.DOES NOT ALTER REGS.
         BZ    CONTINUE           GO IF IT DOES.
         L     2,R2STORE          RESTORE R2 CONTENTS.
         L     9,OPCODEF-4(2)     OBTAIN SIMULATOR ADDRESS.
         BR    9                  GO TO SIMULATOR.
CONTINUE EQU   *
BXOUT    TM    TYPECODE+1,X'E0'   TEST IF R14 OR R15 ARE ALTERED.
         BC    12,CARRYON1        GO IF THEY ARE NOT.
LMRTN    MVI   INSTRV+1,X'00'     SET DROP-THRU TO TRAP R15 CONTENTS.
         MVC   INSTRX(4),INSTRY   MOVE INSTRUCTION TO EXECUTION AREA.
         LM    0,15,REGSAVE       RESTORE EXECUTION REGISTERS.
INSTRX   DS    CL4                2ND EXECUTION AREA-EXECUTE.
         BALR  2,0                ESTABLISH TEMPORARY BASE.
         L     3,BASECON-*(2)     RE-ESTABLISH NORMAL BASE.
         ST    15,STORE15         SAVE R15 CONTENTS.
         CNOP  0,4
CARRYON1 L     15,CONCODE         LOAD IN 1ST PSW BYTE.
         SPM   15                 SET CONDITION CODE.
         LM    0,15,REGSAVE       LOAD USERS REGISTERS.
INSTRY   DS    CL6                3RD EXECUTION AREA-EXECUTE.
         BALR  15,0               ESTABLISH TEMPORARY BASE.
         STM   0,14,REGSAVE-*(15) SAVE CONTENTS OF REGS.0-14.
         L     3,BASECON+4-*(15)  RE-ESTABLISH NORMAL BASE.
INSTRV   B     BCKZ               GO TO CONDITION-CODE TRAP.
         MVI   INSTRV+1,X'F0'     RESET DROP-THRU SWITCH.
         L     9,STORE15          MOVE R15 CONTENTS TO USERS STORE VIA
         ST    9,REGSAVE+60       REGISTER 9 FOR SPEED.
         B     BCKZ               GO TO CONDITION-CODE TRAP.
REGSAVE  DC    14F'0'
         DC   A(EOJRTN)           RETURN-ADDRESS.
         DC   F'0'
         CNOP  0,4
CARRYON2 L     15,CONCODE         LOAD IN 1ST PSW BYTE.
         SPM   15                 SET CONDITION CODE.
         LM    0,15,REGSAVE       LOAD USERS REGISTERS.
INSTRZ   DS    CL6                PRIME EXECUTION AREA-EXECUTE.
         BALR  15,0               ESTABLISH TEMPORARY BASE.
         L     3,BASECON-*(15)    RE-ESTABLISH NORMAL BASE.
********** * * * * * * * * * * * * * * * * * * * * * * * * * **********
*        POST-EXECUTION ROUTINE.                                      *
*                                                                     *
*        CONDITION CODE IS CAPTURED HERE AND STORED.                  *
*        NON-PRINTING INSTRUCTIONS THEN LOOP TO PROCESS NEXT INSTR.   *
*        IF INSTRUCTION IS PRINTING,ROUTINE FORMATS AND MOVES TO PRINT*
*        1ST OPERAND DATA AFTER EXECUTE.FOR REGISTER-TYPE INSTRUCTIONS*
*        DATA IS NOT PRINTED IF IT COULD NOT BE CHANGED DURING        *
*        EXECUTION.THIS REDUCES AMMOUNT OF IRRELEVANT DATA ON PRINTOUT*
*        IF BRANCH-ONLY PRINTOUT WAS SPECIFIED,ROUTINE COMPARES NEXT  *
*        SEQUENTIAL INSTRUCTION ADDRESS WITH NEXT INSTRUCTION ADDRESS.*
*        UNEQUAL COMPARE CONSTITUTES A BRANCH TO SPRINT,RATHER THAN A *
*        BRANCH-TYPE INSTRUCTION.THIS ELIMINATES WASTEFUL PRINTOUT OF *
*        DROPPED-THRU BRANCHES.IF NOT BRANCH-ONLY,SAME CONDITION      *
*        WILL MOVE A BRANCHING FLAG TO PRINT.THIS ENABLES BRANCHES TO *
*        BE PICKED OUT EASILY ON A SPRINT-PRINT.                      *
*        AFTER FORMAT,INSTRUCTION IS PRINTED,STATIONERY IS PRINTED    *
*        IF NECESSARY,AND ROUTINE LOOPS TO NEXT INSTRUCTION TRACE.    *
*                                                                     *
********** * * * * * * * * * * * * * * * * * * * * * * * * * **********
BCKZ     ST    15,CONCODE         TRAP CONDITION CODE.
INSTRW   B     NEXTA              SWITCH.DROP IF PRINTING THIS INSTRUCT
         AIF   (&MNEMONS EQ 0).MNEMSK3
         CLI   PRINT+10,C'B'      TEST IF LAST INSTR.WAS A BRANCH.
         BE    *+10               YES,SKIP NEXT INSTRUCTION.
         MVC   LASTCODE(1),PRINT+10    SAVE OPCODE FOR MNEMONIC GENER.
.MNEMSK3 ANOP
         AIF   (&OPAFTER EQ 0).OPASK1
         TM    TYPECODE,X'C0'     TEST FOR SS TYPE.
         BO    SSA                EQUAL PATH.
OTHER    CLI   R2STORE+3,X'24'    TEST IF INSTRUCTION CHANGES REGS.
         BH    BKA+4              UNEQUAL PATH.
         SR   6,6                 CLEAR R6.
         IC    6,TYPECODE+1            OBTAIN 2ND BYTE.
         SRL   6,4                R6 NOW CONTAINS 1ST REG NO.
         BAL   10,REGPRINT        GET CONTENTS.
         MVC   PRINT+93(8),TESTE  MOVE DATA TO PRINT-LINE.
         AIF   (&FLOATPT EQ 0).FLOSK4
         CLI   FLPSW,X'FF'        TEST FOR F-P INSTRUCTION.
         BNE   BKA+4              UNEQUAL PATH.
         LA    10,PRINT+93        POINT TO PRINT AREA.
         BAL   11,FPRINT          GO TO PRINT F-P REGISTER.
         MVI   FLPSW,X'00'        RESET F-P SWITCH.
.FLOSK4  ANOP
         B     BKA+4              SKIP TO CONTINUE.
SSA      L     9,ADDR1            LOAD R9 WITH 1ST OP. ADDRESS.
         LR    7,9                LOAD R7 WITH 1ST OPERAND ADDRESS.
         BAL   8,DATAPULL         GET DATA.
         LH    6,SSLEN            GET DATA LENGTH,
         LA    9,PRINT+93         POINT R9 AT PRINT AREA.
         AIF   (&PRINTEB EQ 0).PRISK3
         CLI   TYPECODE,X'F0'     TEST FOR DECIMAL INSTRUCTION.
         BH    *+12               EQUAL PATH.
         MVI   17(9),C'='         MOVE = TO PRINT.
         EX    0,MOVEUNPK         MOVE DATA TO PRINT.
.PRISK3  ANOP
         EX    6,TRUNCINS         MOVE IN DATA.
.OPASK1 ANOP
BKA      EQU   *-4
         MVI   LIVEXIT+1,X'F0'    *
         MVI   NEXTD+1,X'F0'      *
         AIF   (&MNEMONS EQ 0).MNEMSK6
         MVI   BCBR1+1,X'F0'      **RESET DROP-THRU SWITCHES TO SAY
.MNEMSK6 ANOP
         MVI   INSTRW+1,X'F0'     *
         MVI   INSTRU+1,X'F0'     *
         LM    8,9,INSTRADD       LOAD NEXT ADDR. AND NEXT SEQ.ADDRESS.
         CR    8,9                COMPARE TO SEE IF BRANCH WAS MADE.
         BE    *+10               GO IF NO BRANCH WAS MADE.
         MVC   PRINT+8(2),BFLAG   ELSE MOVE BRANCH FLAG TO PRINT.
         MVI   PRINT,X'C9'        **
         BAL   7,DIVIDERS         GO TO SET UP SPACERS ON PRINTOUT.
BRCHONLY NOP   *+12               GO IF NOT BRANCH-ONLY PRINTOUT.
         TM    PRINT+8,X'10'      TEST IF BRANCH OR PROGRAM-CHECK.
         BZ    CLEAR              UNEQUAL PATH.
         BAL   9,PRINTER2         GO TO PRINT A LINE.
         L     9,INSTRCT          LOAD INSTR.PRINT COUNT.
         BCT   9,*+8              BRANCH IF COUNT POSITIVE.
         B     TIMEUP+4           GO TO TERMINATE TRACE.
         ST    9,INSTRCT          STORE DECREMENTED COUNT.
         LH    9,LINECT           LOAD PARAGRAPH-LINE-COUNT.
         BCT   9,XXX              BRANCH IF UNEXPIRED.
         MVI  LINECT+1,X'04'      RESTORE COUNT.
         LH    8,BLKCT            LOAD PAGE-LINE-COUNT.
         BCT   8,YYY              BRANCH IF UNEXPIRED.
         MVI   BLKCT+1,X'0B'      RESTORE PARAGRAPH NO.COUNT.
         BAL   8,HEADRTN          GO TO HEADING ROUTINE.
CLEAR    XC    PRINT(120),PRINT   CLEAR PRINT AREA.
         B     NEXTA              GO TO NEXT INSTRUCTION.
         ORG  OPCODE+864
YYY      BAL   7,LINER            DRAW STATIONERY LINE.
         BAL   9,PRINTER2         GO TO PRINT A LINE.
         STH   8,BLKCT            STORE PAGE-LINE-COUNT.
         B     CLEAR              BRANCH.
         ORG   TABLEF+38
XXX      STH   9,LINECT           STORE PARAGRAPH-LINE-COUNT.
         B     CLEAR              GO TO CLEAR PRINT LINE.
         ORG
         AIF   (&PROCHK2 EQ 0).PR2SK2
         TITLE 'OS TRACE PROG-CHECK ROUTINE'
********** * * * * * * * * * * * * * * * * * * * * * * * * * **********
*        PROGRAM CHECK HANDLER.                                       *
*                                                                     *
*        THIS ROUTINE ESTABLISHES NORMAL ADDRESSABILITY AFTER         *
*        PROGRAM CHECK INTERRUPT. IF INTERRUPT IS DUE TO PROGRAM      *
*        REACHING END-OF-JOB,SPRINT IS TERMINATED.                    *
*        IF NOT EOJ,ROUTINE TESTS IF INSTRUCTION WAS PRINTING. IF NOT *
*        INSTRUCTION IS RE-PROCESSED AS A PRINTING INSTRUCTION IN     *
*        ORDER TO GIVE MORE INFORMATION ON CAUSE OF CHECK.            *
*        ROUTINE THEN MOVES A FLAG AND REASON CODE TO PRINT,AND CHECKS*
*        IF CHECK WAS OPERATION,EXECUTE OR PRIVILEDGED OP. IF NOT,    *
*        CHECK COUNT IS DECREMENTED,AND JOB ABENDED IF ZERO.OTHERWISE *
*        CONTROL IS RETURNED TO CONTROL PROGRAM TO PRINT INSTRUCTION  *
*        AND CONTINUE TRACE. OTHERWISE,INSTRUCTION IS PRINTED AND     *
*        TRACE IS TERMINATED.                                         *
*                                                                     *
********** * * * * * * * * * * * * * * * * * * * * * * * * * **********
PROCHK   L     3,BASECON-*(15)    RE-ESTABLISH NORMAL BASE.
         CLC   INSTRADD-3(3),AEOJ TEST FOR PROGRAM END.
         BE    DUD+8              EQUAL PATH.
         C     4,INSTRADD         TEST IF SPRINT CHECK,
         BCR   8,14               YES,WAS ADDRESSING DUE TO USER.
         CLI   SWCLEAR,X'F0'      TEST FOR PRINT FLAG OFF.
         BNE   JUMP+8
         LM    4,5,INSTRADD-4     POINT BACK FOR INSTRUCTION RE-RUN.
         ST    4,INSTRADD
         OI    CHECKOUT+1,X'F0'   SET RETURN BRANCH ON.
         STM   14,2,PROGSAVE      SAVE REGS.14-2 FOR RESTORING.
         B     PRINTIT                 RE-RUN INSTRUCTION.
JUMP     NI    CHECKOUT+1,X'0F'   CLEAR RETURN BRANCH.
         LM    14,2,PROGSAVE
         AIF   (&PROCHK1 EQ 0).PRISK1
         IC    6,7(1)             CAPTURE INTERRUPTION CODE.
         N    6,CONSTANT          STRIP EXTRANEOUS BITS.
         MH    6,HALF11           POINT R6 AT REASON TABLE.
         LA    6,PCNAME-11(6)     R6 POINTS TO CHECK TYPE.
         MVC   PRINT+93(26),PCLINE     MOVE MESSAGE TO PRINT.
         MVC   PRINT+100(11),0(6) MOVE REASON TO PRINT.
.PR1SK1  ANOP
         MVC   PRINT+8(2),PFLAG   MOVE CHECK FLAG TO PRINT.
         TM    7(1),X'0C'         TEST FOR SUPPRESS CHECK TYPE.
         BZ   DUD                 UNEQUAL PATH TO ABEND ROUTINE.
         LH    9,PROCHEKS         LOAD CHECK COUNT.
         BCT   9,NOTOUT           BRANCH IF UNEXPIRED.
DUD      BAL   9,PRINTER2         PRINT LAST LINE.
         MVI   ABENDCON,X'80'     FORCE A DUMP AT ABEND.
         BAL   7,LINER            CONSTRUCT STATIONERY UNDERLINER.
         BAL   9,PRINTER2         PRINT.
         CLOSE  PRINTER           CLOSE PRINTER DCB.
         L     1,ABENDCON         LOAD ABEND CONSTANT.
         LM    2,15,REGSAVE+8     RESTORE USERS 2-15 FOR DUMP.
         SVC   13
NOTOUT   STH   9,PROCHEKS         STORE CHECK COUNT.
         MVC   9(3,1),ABKA        SET RETURN ADDRESS.
         BR    14                 RETURN TO CONTROL PROGRAM.
         ORG   PRINT+93
PROGSAVE DS    5F
         ORG
         AIF   (&PROCHK1 EQ 0).PR2SK2
PCNAME   DC    C'OPERATION  PRIVLGD.OP.EXECUTE    PROTECTION '
         DC    C'ADDRESSING SPECIFICTN.DATA-PACKEDFIX-PT.OFLO'
         DC    C'FIX-PT.DIV.DEC.OFLO.  DEC.DIVIDE EXPON.OFLO.'
         DC    C'EXPON.UFLO.SIGNIFICNCEFLTG-PT.DIV'
.PR2SK2 ANOP
         TITLE 'OS TRACE SVC SIMULATOR'
********** * * * * * * * * * * * * * * * * * * * * * * * * * **********
*        SVC FORMATTER AND EXECUTOR.                                  *
*                                                                     *
*        IF INSTRUCTION IS PRINTING,ROUTINE MOVES SVC NUMBER AND A    *
*        MACRO-NAME TO PRINT.                                         *
*        CONTENTS OF REGISTERS 0,1 ARE PRINTED,AND SPIE SVC IS        *
*        SUPPRESSED AND FLAGGED IN PRINT LINE.                        *
*        ROUTINE THEN EXECUTES SVC,AND RETURNS TO MAIN PROCESSING LOOP*
*                                                                     *
********** * * * * * * * * * * * * * * * * * * * * * * * * * **********
SVCRTN   CLI   SWCLEAR,X'F0'      TEST IF PRINT FLAG ON.
         BE    TYPETEST           UNEQUAL PATH.
         IC    2,1(4)             LOAD SVC CODE IN R2.
         CVD   2,STORY            CONVERT TO DECIMAL.
         AIF   (&SVCNAME EQ 0).SVCSK1
         MH    2,HALF6            CALCULATE DISPLACEMENT ON TYPE TABLE.
         LA    2,SVCNAME-SVCRTN(9,2)   CALCULATE ADDRESS ON TYPE TABLE
         MVC  PRINT+19(6),0(2)    MOVE TYPE TO PRINT.
         MVI   PRINT+18,C'='      MOVE = TO PRINT
.SVCSK1  AIF   (&SVCNAME EQ 1).SVCSK3
         XC    PRINT+18(2),PRINT+18    CLEAR SOME PRINT DATA.
.SVCSK3  ANOP
         UNPK  PRINT+15(2),STORY+6(2)  MOVE CODE TO PRINT
         OI   PRINT+16,X'F0'      ENSURE NUMERIC CODE.
         MVC   PRINT+8(2),SFLAG   MOVE SVC FLAG TO PRINT.
         LA    9,REGSAVE          *FIND CONTENTS OF
         BAL   8,DATAPULL         *REGISTERS 0,1.
         MVC   PRINT+39(8),SVCLIT MOVE LITERAL TO PRINT.
         MVC   PRINT+48(17),DATA  MOVE REG.CONTENTS TO PRINT.
         XC    PRINT+66(26),PRINT+66
TYPETEST EQU   *
         AIF   (&PROCHK2 EQ 0).SVCSK4
         CLI   1(4),X'0E'         TEST FOR SPIE SVC.
         BE    SPIERTN            EQUAL PATH.
.SVCSK4  AIF   (&MULTIPH EQ 0).MULSK1
         CLI   1(4),X'06'         TEST FOR LINK,
         BE    LOADER             YES,GO TO SIMULATOR.
         CLI   1(4),X'07'         TEST FOR XCTL,
         BE    LOADER             YES,GO TO SIMULATOR.
         CLI   1(4),X'2A'         TEST FOR ATTACH,
         BE    LOADER             YES,GO TO SIMULATOR.
.MULSK1  ANOP
         LM    0,2,REGSAVE        LOAD REGS 0,2.
         LM    5,15,REGSAVE+20    LOAD 5-15.
         EX    0,0(4)
         STM   0,2,REGSAVE        SAVE REGS.0-2.
         STM   5,15,REGSAVE+20    SAVE REGS.5-15.
         B     INSTRW             RETURN TO MAIN-LINE.
         AIF   (&PROCHK2 EQ 0).SVCSK5
SPIERTN  MVC   PRINT+28(10),SPIECON    MOVE LITERAL TO PRINT.
         B     INSTRW             RETURN TO MAIN-LINE.
.SVCSK5  AIF   (&MULTIPH EQ 0).MULSK2
LOADER   L     2,REGSAVE+60       GET USERS REGISTER 15.
         LM    8,9,0(2)           LOAD NAME AND DCB ADDRESSES.
         LA    8,0(8)             CLEAR TOP BYTE.
         TM    0(2),X'80'         TEST FOR DE OPERAND.
         BZ    *+6                NO,SKIP OVER.
         LNR   8,8                SIMULATE DE PARAMETER.
         LR    0,8                LOAD R0.
         LR    1,9                LOAD R1.
         SVC   8                  LOAD MODULE INSTEAD.
         ST    0,REGSAVE+60       STORE ENTRY POINT AS USERS R15.
         ST    0,INSTRADD         STORE ENTRY POINT AS NEXT INSTR.
         ST    5,REGSAVE+56       STORE NEXT INSTR. AS RETURN ADDRESS.
         LPR   8,8                RESET R8 TO POSITIVE VALUE.
         MVC   PRINT+30(8),0(8)   MOVE MODULE-NAME TO PRINT.
         B     INSTRW             RETURN TO MAIN-LINE.
.MULSK2  ANOP
BASECON  DC    A(BASE)
         AIF   (&SVCNAME EQ 0).SVCSK2
SVCNAME  DC    C'EXCP  WAIT  POST  EXIT  GTMAINFRMAIN'
         DC    C'LINK  XCTL  LOAD  DELETEGET/FRTIME  '
         DC    C'SYNCH ABEND SPIE  EREXCPPURGE RESTOR'
         DC    C'BLDL  OPEN  CLOSE STOW  OPENJ TCLOSE'
         DC    C'DEVTYPTK-BALCATLG.OBTAINCVOL  SCRTCH'
         DC    C'RENAMEFEOV  ALLOC.IOHALTM-EXCPWTO   '
         DC    C'      OVLY  TSTRANLABEL EXTRCTIDNTFY'
         DC    C'ATTACHCIRB        OVLY  TTIMERSTIMER'
         DC    C'      TTOPN1      ABDUMP            '
         DC    C'DSABLEEOV         FRDBUF            '
         DC    C'      SAVE              RDJFCB      '
         DC    C'                  BACKSPGSERV ASNBUF'
         DC    C'      SPAR  DAR   DEQ   '
.SVCSK2 ANOP
TABLEH   EQU   TABLEF-193
EOJRTN   EQU   CONSTANT
BFLAG    EQU   PCLINE
SWCLEAR EQU LIVEXIT+1
STORE15 EQU TESTA
LIMITIME EQU STORY
TIME     EQU   LIMITIME+2
TRTEDMK  EQU   CARRYON1
         AIF   (&PRINTEB EQ 1).PRISK4
UNPACK1  EQU   UNPACK2
.PRISK4  AIF   (&OPAFTER EQ 1).OPASK2
OTHER    EQU   BKA+4
.OPASK2  ANOP
         END
