EDIT     ZCSECT 12,9,GETMAIN=1,WKLEN=WALENGTH
         USING WDSECT,REG13        ADDRESSABILITY FOR DSECT
         LR    REG8,REG1           LOAD ADDRESS OF PARAMETER AREA
         USING USERPARM,REG8       ADDRESSABILITY FOR IT
         ST    REG13,UPEDITWK      SAVE ADDRESS OF EDIT WORK AREA
         EJECT
***********************************************************************
*        INITIALISE THE DATA STACK AREA
***********************************************************************
         SPACE 2
RESTART1 DS    0H
         LA    REG3,DUMMY          LOAD ADDRESS OF DUMMY STAK ENTRY
         LA    REG4,DUMMY2         LOAD ADDRESS OF DUMMY END
         ST    REG4,4(REG3)        DOWN POINTER FROM TOP
         ST    REG4,8(REG3)        UP POINTER FROM TOP
         ST    REG3,4(REG4)        DOWN POINTER FROM END
         ST    REG3,8(REG4)        UP POINTER FROM END
         MVI   0(REG3),X'FF'       IDENTIFY TOP OF FILE
         MVI   0(REG4),X'EE'       IDENTIFY END OF FILE
         MVC   CURRENT(12),0(REG3) INITIALISE TOF AS CURRENT
         XC    DATASTAK,DATASTAK   CLEAR THE STACK POINTER
         EJECT
***********************************************************************
*        FIRST ESTABLISH THE NAME OF THE DATA SET                     *
***********************************************************************
         SPACE 2
         MVI   RETCODE,0           INITIALISE THE UT501 RETCODE
         MVC   JCLDATA(JCLMLEN),JCLMASK INITIALISE THE JCL CARD
RETRYDSN DS    0H
         LR    REG1,REG8           ADDRESS OF USER PARM AREA
         LINK  EP=GETDSN           INVOKE THE GET DATA SET NAME ROUTINE
         LTR   REG15,REG15         DOES HE WANT TO EXIT
         BNZ   SUPREXIT            YES. RETURN TO CALLRE
         EJECT
***********************************************************************
*        TEST FOR EDIT DATA SET ENTRY
***********************************************************************
         SPACE 2
         CLI   EDITDSN,C' '        EDIT DATA SET NAME ENTERED
         BE    TRYOSDS             NO. GO TRY FOR OS EDIT
         MVC   EDITNAME,EDITDSN    INITIALISE WORK AREA
         LA    REG6,1              TELL HIM TO START AT RECORD 1
         XR    REG7,REG7           AND READ ALL THE RECORDS
         STM   REG6,REG7,READPRMS  UPDATE THE PARAMETER FIELDS
         CALL  SRLREAD,(DUMMY,(8)),VL,MF=(E,CALLLIST) READ THE EDIT DS
         B     DSLOADED            DATA SET IS LOADED. CONTINUE
         EJECT
***********************************************************************
*        INVOKE THE OS FILE LOAD ROUTINE
***********************************************************************
         SPACE 2
TRYOSDS  DS    0H
         LA    REG6,1              SIGNAL TO START AT FIRST RECORD
         XR    REG7,REG7           AND READ ALL OF THEM
         STM   REG6,REG7,READPRMS  AND STORE PARAMETERS
         MVC   JCLDATA+JCLMLEN(54),DSNAME PREPARE THE DATA SET NAME
         CALL  READOSDS,(DUMMY,(8)),VL,MF=(E,CALLLIST)
         LTR   REG15,REG15         LOAD SUCCESSFUL ?
         BNZ   RETRYDSN            NO. GO ASK FOR DSN AGAIN
         EJECT
**********************************************************************
*        GETMAIN AND PREPARE THE SCREEN AREA
**********************************************************************
         SPACE 2
DSLOADED DS    0H
         GETMAIN R,LV=SCLENGTH    GETMAIN SOME CORE
         STM   REG0,REG1,SCRNREGS  SAVE GETMAIN REGISTERS
         ST    REG1,SCREEN         SAVE ADDRESS OF THE SCREEN
         L     REG0,SCREEN         PREPARE FOR CLEAR
         LA    REG1,SCLENGTH       PREPARE FOR CLEAR
         XR    REG14,REG14         PREPARE FOR CLEAR
         XR    REG15,REG15         PREPARE FOR CLEAR
         MVCL  REG0,REG14          CLEAR THE ENTIRE SCREEN AREA
         L     REG1,SCREEN         RELOAD ADDRESS OF SCREEN AREA
         MVC   0(9,REG1),=X'40115D7F1140401DE8' IDENTIFY FIELD
         LA    REG1,9(REG1)        ADDRESS OF FIRST FIELD
         ST    REG1,ERRMSG         SAVE ITS ADDRESS
         LA    REG1,20(REG1)       ADDRESS OF NEXT AREA
         MVC   0(5,REG1),=X'1140D41DE8' IDENTIFY DSNAME FIELD
         LA    REG1,5(REG1)        STEP OVER THE CONTROL CHARS
         ST    REG1,DSNAREA        SAVE ADDRESS OF DSNAME AREA
         LA    REG1,138(REG1)      ADDRESS OF DATA AREA
         MVC   0(5,REG1),=X'11C25F1D60' IDENTIFY DATA FIELD
         LA    REG1,5(REG1)        STEP OVER THE CONTROL CHARS
         ST    REG1,DATAAREA       SAVE ADDRESS OF DATA AREA
         A     REG1,SCREENLN       ADDRESS OF END OF FIELD
         MVC   0(6,REG1),=X'115B5F1DC913' IDENTIFY COMMAND FIELD
         LA    REG1,6(REG1)         LOAD ADDRESS OF THE BUFFER ADDRESS
         ST    REG1,CMNDLINE       SAVE ADDRESS OF COMMAND AREA
         LA    REG1,120(REG1)      EMD OF COMMAND AREA
         MVC   0(15,REG1),=X'114B4F1DE8114C5F1D60115DD71DF0'
         LA    REG1,45(REG1)       ADDRESS OF END OF AREA
         S     REG1,SCREEN         GET LENGTH OF THAT AREA
         ST    REG1,TPUTLEN        AND SAVE IT FOR TPUT
         L     REG15,DSNAREA       LOAD ADDRESS OF DATA SET NAME AREA
         CLI   EDITDSN,C' '        EDIT OR OS DATA SET
         BE    STOWOSDS            OS.GO FETCH OS DATA SET NAME
         MVC   0(16,REG15),EDITDSN MOVE EDIT DATA SET NAME IN
         B     SCDONE              EXIT FROM THIS ROUTINE
STOWOSDS EQU   *
         MVC   0(54,REG15),DSNAME  MOVE DATA SET NAME TO OUT AREA
SCDONE   EQU   *
         EJECT
***********************************************************************
*        GETMAIN AND INITIALISE THE CONSOLE STACK
***********************************************************************
         SPACE 2
         GETMAIN R,LV=STACKLEN
         STM   REG0,REG1,STACKREG  SAVE GETMAIN REGISTERS
         ST    REG1,FREESTAK       INITIALISE THE FREE STACK
         AR    REG0,REG1           CALCULATE ADDRESS OF END OF AREA
INITLOOP LA    REG14,STKLENTH(REG1)   ADDRESS OF NEXT ENTRY
         CR    REG14,REG0          END OF AREA REACHED YET
         BNL   INITENDS            YES. TERMINATE INITIALISATION
         ST    REG14,0(REG1)       UPDATE CHAIN POINTER THIS AREA
         LR    REG1,REG14          ADDRESS OF NEXT BUFFER
         B     INITLOOP            PROCESS THE WHOLE AREA
INITENDS XC    0(4,REG1),0(REG1)   CLEAR THE LAST POINTER
         XC    STACKTOP,STACKTOP   'EMPTY' THE CONSOLE STACK
         LA    REG1,COMMAND+L'COMMAND ADDRESS OF END OF COMMAND AREA
         ST    REG1,CMNDENDS       AND SAVE THIS ADDRESS
         EJECT
***********************************************************************
*        WRITE OUT THE FIRST SCREEN OF DATA AND PROCESS EACH INPUT CMD*
***********************************************************************
         SPACE 2
         MVI   WORKFLAG,0          CLEAR THE WORK FLAG FIRST
         MVC   CURRENT(12),DUMMY   RE-INITIALISE THE TOF MARKER
         XAL   REG11,OUTPUTIT      CALL SERVICE ROUTINE
REREAD   L     REG1,STACKTOP       LOAD ADDRESS OF NEXT STACK ENTRY
         LTR   REG1,REG1           ANYTHING IN IT
         BNZ   GOTSTACK            YES. GO PROCESSIT
         XAL   REG11,CONSREAD      NO. GO READ ANOTHER COMMAND
         B     REREAD              AND GO PROCESSIT
GOTSTACK MVC   STACKTOP,0(REG1)    UPDATE THE STACK CHAIN
         LR    REG3,REG1           LOAD A MORE PERMANENT BASE
         USING STKENTRY,REG3       AND GET ADDRESSABILITY FOR IT
         MVC   COMMANDX,STKAID     MOVE ALL THE DATA TO A WORK AREA
         MVC   DATALNTH,STKLEN     THEN UNLOAD THE LENGTH OF THIS FIELD
         MVC   0(4,REG3),FREESTAK  UPDATE MY CHAIN POINTER
         ST    REG3,FREESTAK       AND UPDATE THE FREE STACK
         XAL   REG11,PROCSTAK      GO PROCESS THE STACK ENTRY
         B     REREAD              AND THEN FETCH THE NEXT ONE
         EJECT
***********************************************************************
*        ANALYSE THE INPUT COMMAND                                    *
***********************************************************************
         SPACE 2
ANALCMND DS    0H
         LA    REG1,COMMAND        LOAD START ADDRESS OF COMMAND
         ST    REG1,ERROPNDS       UPDATE START OF OPERANDS FIELD
         L     REG1,=A(CMDTABLE)   LOAD ADDRESS OF COMMAND TABLE
CMDLOOP  CLI   0(REG1),X'FF'       TEST FOR END OF TABLE
         BE    INVLDCMD            YES. COMMAND NOT KNOWN
         XR    REG15,REG15         CLEAR LENGTH REGISTER
         IC    REG15,0(REG1)       LOAD LENGTH OF ID
         LA    REG1,1(REG1)        ADDRESS OF COMMAND ID
         BCT   REG15,*+10          SUBTRACT 1 FROM LENGTH
         CLC   0(0,REG1),COMMAND   TEST FOR THIS COMMAND
         EX    REG15,*-6           EXECUTE THE COMPARE
         BE    FOUNDCMD            YES. GO PROCESS IT
         LA    REG1,3+1(REG15,REG1) UPDATE TO NEXT ENTRY
         B     CMDLOOP             PROCESS ALL THE ENTRIES
FOUNDCMD LA    REG14,COMMAND+1(REG15) LOAD ADDRESS OF OPERANDS
         ST    REG14,OPERANDS      SAVE ADDRESS OF OPERAND FIELD
         ST    REG14,ERROPNDS      SAVE ADDRESS OF OPERAND FIELD
         CLI   COMMAND,C'='        IS THIS A REPEAT REQUEST ?
         BE    *+10                YES. THEN DONT SAVE IT
         MVC   SAVECMND,COMMAND    SAVE THE COMMAND AREA
         LA    REG1,1(REG15,REG1)  LOAD ADDRESS OF PROCESSOR ADDRESS
         ICM   REG1,7,0(REG1)      LOAD ADDRESS OF THE ROUTINE
         XAL   REG11,0(REG1)       AND PASS CONTROL TO IT
         BR    REG11               RETURN TO CALLER
         EJECT
***********************************************************************
*        PROCESS '=' COMMAND BY RESTORING PREVIOUS COMMAND
***********************************************************************
         SPACE 2
SAMAGAIN DS    0H
         L     REG3,FREESTAK       LOAD THE ADDRESS OF A STAK ELEMENT
         USING STKENTRY,REG3       ADDRESSABILITY FOR IT
         MVC   FREESTAK,0(REG3)    UPDATE THE CHAIN
         MVC   STKAID,AID          GIVE IT SOME CTL INFO
         MVC   STKDATA,SAVECMND    MOVE THE SAVED COMMAND TO IT
         LA    REG1,80             SIMULATE A LENGTH
         STH   REG1,STKLEN         AND SAVE THAT
         MVC   0(4,REG3),STACKTOP  CHAIN REST OF CONSOLE STACK TO THIS
         ST    REG3,STACKTOP       AND PUT THIS AT TOP
         L     REG1,OPERANDS       LOAD ADDRESS OF ANY OPERANDS
         CLI   0(REG1),C'I'        IS LAST LINE TO BE INPUT
         BNE   NOTREINP            NO. NOT RE-INPUT OF DATA
         L     REG3,FREESTAK       LOAD A SPARE CONSOLE STAK ENTRY
         MVC   FREESTAK,0(REG3)    UPDATE THE CONSOLE STAK
         USING STKENTRY,REG3       ADDRESSABILITY FOR IT
         MVC   STKAID,AID          GIVE IT A SUITABLE AID
         MVI   STKDATA,C'I'        SET UP AN INPUT COMMAND
         LA    REG1,1              GET A SUITABLE LENGTH
         STH   REG1,STKLEN         AND UPDATE THE LENGTH FIELD
         MVC   0(4,REG3),STACKTOP  CHAIN TOP OF CONSOLE STACK HERE
         ST    REG3,STACKTOP       AND CHAIN THIS TO CONSOLE STACK
NOTREINP EQU   *
         BR    REG11               RETURN TO CALLER
         EJECT
***********************************************************************
*        PROCESS THE 'NEXT' COMMAND'                                  *
***********************************************************************
         SPACE 2
NEXT     DS    0H
         LA    REG10,1             LOAD THE DEFAULT
         XAL   REG11,NUMBERS       GO FETCH THE NUMBR COUNT
         LM    REG2,REG4,CURRENT   LOAD CURRENT RECORD DETAILS
NEXTLOOP EQU   *
         CLM   REG2,8,=X'EE'       END OF DATA ?
         BE    NEXIT               YES. TERMINATE
         LM    REG2,REG4,0(REG3)   LOAD DETAILS NEXT RECORD
         BCT   REG1,NEXTLOOP       NO. KEEP GOING
NEXIT    EQU   *
         STM   REG2,REG4,CURRENT   MAKE THIS THE CURRENT RECORD
         XAL   REG11,OUTPUTIT      AND SHOW HIM THE RESULT
         BR    REG11               RETURN TO CALLER
         EJECT
***********************************************************************
*        PROCESS THE UP COMMAND                                       *
***********************************************************************
         SPACE 2
UP       DS    0H
         LA    REG10,1             LOAD THE DEFAULT
         XAL   REG11,NUMBERS       GO FETCH THE NUMBR COUNT
         LM    REG2,REG4,CURRENT   LOAD CURRENT RECORD DETAILS
UPLOOP   EQU   *
         CLM   REG2,8,=X'FF'       TOP OF DATA ?
         BE    UPEXIT              YES. TERMINATE
         LM    REG2,REG4,0(REG4)   LOAD DETAILS PREVIOUS RECORD
         BCT   REG1,UPLOOP         NO. KEEP GOING
UPEXIT   EQU   *
         STM   REG2,REG4,CURRENT   MAKE THIS THE CURRENT RECORD
         XAL   REG11,OUTPUTIT      AND SHOW HIM THE RESULT
         BR    REG11               RETURN TO CALLER
         EJECT
***********************************************************************
*        PROCESS THE DELETE COMMAND                                  *
*********************************************************************
         SPACE 2
DELETE   DS    0H
         CLI   CURRENT,X'FF'       ARE WE AT THE TOP OF THE FILE
         BNE   DELNOTOP            NO. CARRY ON NORMALLY
         L     REG1,CURRENT+4      OTHERWISE LOAD ADDRESS OF NEXT REC
         MVC   CURRENT(12),0(REG1) AND MAKE THIS THE CURRENT
DELNOTOP EQU   *
         CLI   CURRENT,X'EE'       ARE WE AT END OF FILE ?
         BE    DELEXIT             YES. RETURN TO CALLER IMMEDIATELY
         LA    REG10,1             LOAD DEFAULT NUMBER TO DELETE
         XAL   REG11,NUMBERS       GO EXTRACT THE REQUESTED REANGE
         LR    REG7,REG1           AND LOAD UP A WORK REGISTER
         L     REG3,CURRENT+8      SAVE ADDRESS OF PREVIOUS RECORD
         L     REG4,4(REG3)        REAL ADDRESS OF 1ST AFFECTED RECORD
         LA    REG1,CURRENT        PREPARE FOR NEXT LITTLE LOOP
DELOOP   EQU   *                   BUZZ DOWN CHAIN FOR RECS TO BE DLTD
         L     REG1,4(REG1)        ADDRESS OF NEXT RECORD DOWN CHAIN
         CLI   0(REG1),X'EE'       HAVE WE HIT END OF FILE
         BE    DLOOPEND            YES. STOP GOING DOWN CHAIN
         BCT   REG7,DELOOP         BUZZ DOWN AS MANY AS TO BE DELETED
DLOOPEND EQU   *                   R1 POINTS AT REC AFTER LAST 2B DELTD
         L     REG2,4(REG1)        SAVE ONE AFTER THAT FOR 'CURRENT'
         ST    REG1,4(REG3)        CHAIN THIS ONE TO VERY FIRST ONE
         L     REG5,8(REG1)        LOAD ADDRESS OF LAST BLK BEING DLTD
         ST    REG3,8(REG1)        CHAIN FIRST BLK TO THIS END BLK
         L     REG1,0(REG1)        ADDRESS OF DATA FOR NEW 'CURRENT'
         STM   REG1,REG3,CURRENT   UPDATE THE LOCATION COUNTER
         CR    REG5,REG3           IF THESE EQUAL, NO DATA WAS REMOVED
         BE    DELEXIT             YES. RETURN TO CALLER
         MVC   4(4,REG5),DATASTAK  CHAIN FREE STAK ONTO LAST DLTD BLK
         ST    REG4,DATASTAK       AND MAKE 1ST BLK NEW TOP OF STAK
DELEXIT  EQU   *
         XAL   REG11,OUTPUTIT      GO SHOW HIM THE RESULT
         BR    REG11               RETURN TO CALLER
         EJECT
***********************************************************************
*         PROCESS THE INPUT COMMAND
***********************************************************************
         SPACE     2
INPUT    DS        0H
         L     REG1,OPERANDS       LOAD START ADDRESS OF ANY OPERANDS
         XAL   REG11,SETDELIM      GO FIND END ADDRESS OF OPERANDS
         L     REG1,OPERENDS       LOAD ADDRESS OF END OF DATA
         MVI   0(REG1),C' '        BLANK OUT THE ARTIFICIAL DELIM
         CLC   OPERANDS,OPERENDS   ANY OPERANDS EXIST IN FACT ?
         BNL   INSBLOCK            NO. HE WANTS BLOCK INSERT
         OI    WORKFLAG,IN1LINE    SIGNAL INPUT FOR 1 LINE
         L     REG1,OPERANDS       LOAD ADDRESS OF FIRST BYTE
         CLI   0(REG1),C' '        IS IT A BLANK ?
         BNE   INNOSUBT            NO. ASSUME IT IS START OF DATA
         LA    REG1,1(REG1)        OTHERWISE START AT NEXT ADDRESS
INNOSUBT EQU   *
         MVC   COMMAND,0(REG1)     EXTRACT THE INPUT DATA
         B     IN1LINEX            GO START PROCESSING OF THE LINE
INSBLOCK EQU   *
         L     REG5,ERRMSG         LOAD ADDRESS OF SCREEN MSG AREA
         MVC   0(5,REG5),=C'INPUT' IDENTIFY THIS AS INPUT MODE
         XAL   REG11,OUTPUTIT      REWRITE A COMPLETE SCREEN
INREADLP XAL   REG11,READSTAK      GO FETCH NEXT STACK ENTRY
         CLI   AID,X'7D'           WAS THAT NORMAL INPUT ?
         BE    INGOESON            YES. CONTINUE
         XAL   REG11,PROCSTAK      NO. GO PROCESS WHATEVER IT WAS
         B     INREADLP            AND GO TRY AGAIN
INGOESON EQU   *
         NC    DATALNTH,DATALNTH   IS THIS AN END OF BLOCK
         BZ    INSENDS             CERTAINLY IS. EXIT QUICK
         L     REG5,ERRMSG         LOAD ADDRESS OF SCREEN MESSAGE AREA
         MVC   0(5,REG5),=C'INPUT' IDENTIFY THIS AS STILL INPUT MODE
IN1LINEX EQU   *
         LM    REG1,REG3,CURRENT   LOAD CURRENT LINE DETAILS
         L     REG14,4(REG3)       LOAD ADDRESS OF CURRENT LINE
         CALL  GETDATAQ,((14),(8)),VL,MF=(E,CALLLIST)
         MVC   CURRENT(12),0(REG1) UPDATE THE CURRENT LOCATION ADDRESS
         L     REG0,CURRENT        LOAD ADDRESS OF THE CURRENT ENTRY
         LH    REG1,LRECL          LOAD THE LENGTH OF A RECORD
         AR    REG1,REG0           ADDRESS OF END OF RECORD
         A     REG0,COLSTART       ADD THE STAR ADDRESS
         SR    REG1,REG0           LENGTH OF REST OF RECORD
         C     REG1,=F'80'         IS THERE 80 BYTES LEFT ?
         BNH   INNOT80             NO. TAKE WHAT LENGTH THERE IS
         LA    REG1,80             OTHERWISE JUST TAKE 80
INNOT80  EQU   *
         LA    REG14,COMMAND       LOAD ADDRESS OF INPUT DATA
         L     REG15,ENDZONE       LOAD LENGTH HE WANTS CHANGED
         ICM   REG15,8,=C' '       LOAD A PADDING CHARACTER
         MVCL  REG0,REG14          MOVE HIS DATA TO FILE AREA
         TM    WORKFLAG,IN1LINE    WAS THAT A SINGLE INSERT
         BO    INSENDS             YES. RETURN TO CALLER
         XAL   REG11,OUTPUTIT      LET HIM SEE THE NEW LINE
         B     INREADLP            GO FETCH NEXT INPUT RECORD
INSENDS  XAL   REG11,OUTPUTIT      GIVE HIM ONE LAST LOOK
         NI    WORKFLAG,255-IN1LINE RESET THE LOGIC FLAG
         BR    REG11               RETURN TO CALLER
         EJECT
***********************************************************************
*        PROCESS THE TOP AND BOTTOM COMMANDS                          *
***********************************************************************
         SPACE 2
TOPOFIT  DS    0H
         LM    REG14,REG0,DUMMY    LOAD UP TOF DETAILS
         STM   REG14,REG0,CURRENT  UPDATE CURRENT POINTER
         XAL   REG11,OUTPUTIT      GO WRITE OUT THE SCREEN
         BR    REG11
         SPACE 2
BOT      DS    0H
         L     REG1,DUMMY+8        LOAD ADDRESS OF LAST  ENTRY
         LM    REG14,REG0,0(REG1)  LOAD UP LAST RECORD DETAILS
         STM   REG14,REG0,CURRENT  MAKE LAST RECORD CURRENT RECORD
         XAL   REG11,OUTPUTIT      GO WRITE OUT THE SCREEN
         BR    REG11               RETURN  TO CALLER
         EJECT
***********************************************************************
*        PROCESS THE LEFT AND RIGHT COMMANDS
***********************************************************************
         SPACE 2
LEFT     DS    0H
         LA    REG10,1             LOAD THE DEFAULT SHIFT LEFT
         XAL   REG11,NUMBERS       GO FETCH THE OPERAND
         L     REG15,COLSTART      LOAD THE CURRENT DISPLAY COLUMN
         SR    REG15,REG1          AND SUBTRACT HIS SHIFT
         BP    SUBTROK             OK STILL GOT A POSITIVE NUMBER
         LA    REG15,0             NOT OK. RESET TO START OF RECORD
SUBTROK  EQU   *
         ST    REG15,COLSTART      UPDATE THE CONTROL AREA
         XAL   REG11,OUTPUTIT      SHOW HIM THE RESULT
         BR    REG11               AND RETURN TO CALLER
         SPACE 2
RIGHT    DS    0H
         LA    REG10,1             LOAD DEFAULT SHIFT RIGHT
         XAL   REG11,NUMBERS       GO FIND THE VALUE CODED
         L     REG15,COLSTART      LOAD THE CURRENT VALUE
         AR    REG15,REG1          CALCULATE THE NEW VALUE
         CH    REG15,LRECL         HAS HE GONE OFF END OF RECORD ?
         BL    NOTOFFND            NO. ALL IS OK
         LH    REG15,LRECL         YES. THEN GIVE HIM LAST BYTE
         BCTR  REG15,0             ALLOW FOR OFFSET EFFECT
NOTOFFND EQU   *
         ST    REG15,COLSTART      UPDATE THE CONTROL AREA
         XAL   REG11,OUTPUTIT      SHOW HIM THE RESULT
         BR    REG11               AND RETURN TO CALLER
         EJECT
***********************************************************************
*        PROCESS THE CHANGE DATA COMMANDS                             *
***********************************************************************
         SPACE 2
CHANGE   DS    0H
         LA    REG1,1              LOAD DEFAULT FOR OPTIONAL FIELDS
         ST    REG1,CARDCNT        SET DEFAULT CHANGES PER CARD
         ST    REG1,RECCNT         SET DEFAULT RECORDS TO CHANGE
         L     REG5,ERRMSG         LOAD ADDRESS OF MSG AREA
         MVC   0(20,REG5),=CL20'NOT FOUND????' PREPARE A MESSAGE
         L     REG1,OPERANDS       LOAD ADDRESS OF OPERAND STRING
CHLOOP1  CLI   0(REG1),C' '        BLANK CHARACTER ?
         BNE   GOTSTART            GO PROCESS THE CHANGE PARAMETERS
         LA    REG1,1(REG1)        ADDRESS OF NEXT BYTE
         C     REG1,CMNDENDS END OF INPUT AREA
         BNL   OVLYMODE            YES. HE WANTS TO OVERLAY IT
         B     CHLOOP1             NO. CONTINUE LOOPING
GOTSTART XAL   REG11,SETDELIM      GO SUPPLY ANY MISSING DELIMITERS
         LR    REG14,REG1          LOAD WORK REGISTER
         IC    REG15,0(REG14)      LOAD HIS DELIMITER CH
         LA    REG14,1(REG14)      ADDRESS FIRST DATA BYTE
         ST    REG14,INSTRING      SAVE IST ADDRESS
         XR    REG1,REG1           CLEAR LENGTH REGISTER
         ST    REG14,ERROPNDS      UPDATE OPERAND ERR POINTER
LOOP1    EX    REG15,CLIINST       TEST FOR DELIMITER
         BE    FOUNDIT             YES END OF ARGUMENT STRING
         LA    REG1,1(REG1)        INCREMENT DATA COUNT
         LA    REG14,1(REG14)      ADDRESS NEXT BYET
         C     REG14,CMNDENDS END OF DATA ?
         BNL   CHERROR2            YES. OPERANDS MISSING
         B     LOOP1               RETURN FOR NEXT BYTE
FOUNDIT  EQU   *
         ST    REG1,INLENGTH       SAVE LENGTH OF INPUT DATA
         L     REG1,ENDZONE        LOAD END ZONE OFFSET
         S     REG1,STRTZONE       GET LENGTH OF ZONE FIELD
         C     REG1,INLENGTH       WILL THAT FIT ANYWAY
         BL    ZONERR              NO. ZONE ERROR
         XR    REG1,REG1           CLEAR LENGTH REGISTER
         LA    REG14,1(REG14)      FIRST BYTE OF REPLACE DATA
         ST    REG14,OUSTRING      SAVE ITS ADDRESS
LOOP2    EX    REG15,CLIINST       TESTFOR FINAL DELIMITER
         BE    FOUNDIT2            YES. THERE IT IS
         LA    REG1,1(REG1)        NO.INCREMENT DATA COUNT
         LA    REG14,1(REG14)      ADDRESS NEXT INPUT BYET
         C     REG14,CMNDENDS END OF DATA ?
         BNL   CHERROR2            OPERAND OR DELIMITER MISSING
         B     LOOP2               PROCESS REST OF DATA
FOUNDIT2 EQU   *
         ST    REG1,OULENGTH       SAVE LENGTH OF OUTPUT STRING
         L     REG1,ENDZONE        LOAD OFFSET TO END ZONE
         S     REG1,STRTZONE       GET LENGTH OF ZONE FIELD
         C     REG1,OULENGTH       WILL OUTPUT DATA FIT ?
         BL    ZONERR              NO. ZONE ERROR
         L     REG3,OPERENDS       LOAD ADDRESS OF STORED DELIMITER
         MVI   0(REG3),C' '        RESTORE INPUT TO WHAT IT WAS
         SPACE 3
         LA    REG14,1(REG14)      ADDRESS OF FIELD AFTER DELIMITER
         ST    REG14,OPERANDS      SAVE START ADDRESS OF ANY OPERANDS
         LA    REG10,1             LOAD DEFAULT FOR OCCURRENCES
         XAL   REG11,NUMBERS       GO FETCH OCCURRENCE COUNT
         ST    REG1,CARDCNT        AND UPDATE CONTROL FIELD
         LA    REG10,1             DEFAULT NUMBER OF CARDS TO DO
         XAL   REG11,NUMBERS       GO FETCH NUMBER OF CARDS
         ST    REG1,RECCNT         AND UPDATE CONTROL FIELD
         SPACE 3
CHNORMAL L     REG7,RECCNT         LOAD NUMBER OF RECORDS TO DO
         B     INITIAL             START PROCESSING ON THIS CARD
RECLOOP  EQU   *
         L     REG1,CURRENT+4      ADDRESS OF NEXT RECORD
         MVC   CURRENT(12),0(REG1) UPDATE THE POINTER
INITIAL  EQU   *
         L     REG1,CURRENT        LOAD START ADDRESS OF RECORD
         A     REG1,COLSTART       LOAD START ADDRESS OF REAL AREA
         A     REG1,STRTZONE       CALCULATE START ADDRESS OF CHANGE
         ST    REG1,RESTART        UPDATE RESTART ADDRESS POINTER
         L     REG6,CARDCNT        LOAD NUMBER OF OCCURRENCES
CARDLOOP EQU   *
         L     REG14,INSTRING      LOAD ADDRESS OF INPUT STRING
         L     REG3,CURRENT        LOAD START ADDRESS OF RECORD
         CLM   REG3,8,=X'FF'       ARE WE AT TOP OF FILE ?
         BE    RECLEND               YES. CANNOT CHANGE HERE
         CLM   REG3,8,=X'EE'       ARE WE AT THE VERY END
         BE    CHEXIT              YES. CANNOT CHANGE HERE
         A     REG3,COLSTART       ADD START OF 'SCREEN RECORD'
         A     REG3,ENDZONE        DETERMINE FINAL LIMITS OF CHANGE
         S     REG3,INLENGTH       TERMINATE SCAN AT END POINT
         L     REG4,RESTART        START ADDRESS FOR NEW COMPARE
         CR    REG4,REG3           HAVE WE HIT END OF CARD YET
         BH    RECLEND             YES. NO POINT CONTINUING
LOOP3    L     REG15,INLENGTH      LOAD LENGTH OF INPUT DATA
         LR    REG1,REG15          LOAD CLCL REGISTER 1
         LR    REG0,REG4           LOAD CLCL REGISTER 2
         L     REG14,INSTRING      LOAD ADDRESS OF INPUT STRING
         CLCL  REG0,REG14          TEST FOR IN STRING
         BE    GOTSTRNG              YES. GO PROCESS IT
         LA    REG4,1(REG4)        ADDRESS NEXT BYET
         CR    REG4,REG3           GONE OFF THE END OF RECORD
         BNH   LOOP3               NO. TRY AGAIN
         B     RECLEND             DATA IS NOT FOUND
GOTSTRNG ST    REG4,POINT          AND SET UP ADDRESS OF FOUND DATA
         L     REG5,ERRMSG         LOAD ADDRESS OF ERROR MSG AREA
         MVC   0(20,REG5),=120C' ' CLEAR THE ERROR MESSAGE AREA
         LR    REG14,REG4          LOAD MVCL REGISTER
         A     REG14,INLENGTH      ADDDRESS OF 'REST' OF CARD
         L     REG15,ENDZONE       LOAD LENGTH OF 'RECORD'
         A     REG15,COLSTART      ADD OFFSET TO REAL RECORD ADDRESS
         A     REG15,CURRENT       ADDRESS OF END OF RECORD
         SR    REG15,REG14         LENGTH OF REST OF DATA
         LA    REG0,WORKAREA       ADDRESS OF DATA SAVE AREA
         LA    REG1,L'WORKAREA     LENGTH OF SAVE AREA
         ICM   REG15,8,=C' '       LOAD PADDING CHARACTER
         MVCL  REG0,REG14          MOVE OUT REST OF CARD
         L     REG0,POINT          LOAD ADDRESS OF INPUT AREA
         L     REG1,CURRENT        LOAD ADDRESS OF RECORD
         A     REG1,COLSTART       START OF SCREEN RECORD
         A     REG1,ENDZONE        ADDRESS OF END OF ACTIVE AREA
         SR    REG1,REG0           LENGTH OF SPACE REMAINING IN ZONE
         C     REG1,OULENGTH       IS THIS LESS THAN DATA TO GO IN
         BL    TRUNCATE            YES. JUST LEAVE IT AS THE LENGTH
         L     REG1,OULENGTH       OTHERWISE LET HIM HAVE HIS OWN
TRUNCATE EQU   *
         L     REG14,OUSTRING      LOAD ADDRESS OF OUTPUT STRING
         LR    REG15,REG1          LOAD SECOND LENGTH REGISTER
         MVCL  REG0,REG14          MOVE IN REPLACE DATA
         ST    REG0,RESTART        SAVE START ADDRESS OF NEXT COMPARE
         L     REG1,CURRENT        RELOAD ADDRESS OF CARD
         A     REG1,COLSTART       ADDRESS OF SCREEN RECORD
         A     REG1,ENDZONE        LOAD ADDRESS OF END OF CARD
         SR    REG1,REG0           LENGTH REMAIN ON CARD
         LA    REG14,WORKAREA      ADDRESS OF DATA REMOVED
         LA    REG15,L'WORKAREA    LENGTH OF WORK AREA
         ICM   REG15,8,=C' '       LOAD A PADDING CHARACTER
         MVCL  REG0,REG14          REPLACE REST OF DATA
CARDLEND BCT   REG6,CARDLOOP       PROCESS ALL REQUIRED OCCURRENCES
RECLEND  BCT   REG7,RECLOOP        PROCESS ALL REQUIRED OCCURRENCES
CHEXIT   EQU   *
         XAL   REG11,OUTPUTIT      SHOW HIM THE NEW CARD
         BR    REG11               RETURN TO CALLER
         SPACE 2
         EJECT
***********************************************************************
*        PROCESS THE OVERLAY MODE FORM OF CHANGE
***********************************************************************
         SPACE 2
OVLYMODE DS    0H
         L     REG5,ERRMSG         LOAD ADDRESS OF MESSAGE AREA
         CLI   CURRENT,X'FF'       ARE WE AT TOP ?
         BE    MINEMINE            THATS MINE. LEAVE IT ALONE
         CLI   CURRENT,X'EE'       ARE WE AT END OF DATA
         BE    MINEMINE            SO'S THAT YOU BRUTE
         MVC   0(19,REG5),=CL19'CHANGE RECORD'
         L     REG1,CMNDLINE       LOAD ADDRESS OF COMMAND LINE ON SCR
         XC    0(120,REG1),0(REG1) CLEAR THIS AREA TO NULLS
         L     REG14,CURRENT       LOAD ADDRESS OF CURRENT LINE
         A     REG14,COLSTART      LOAD START ADDRESS FOR SCREEN DATA
         LH    REG15,LRECL         LOAD THE LENGTH OF A RECORD
         A     REG15,CURRENT       GET ADDRESS OF END OF RECORD
         SR    REG15,REG14         LENGTH OF REMAINING DATA
         C     REG15,=A(80)        MORE THEN 80 BYTES
         BNH   CHNOTO80            NO. LEAVE IT ALONE
         LA    REG15,80            YES. JUST TAKE 80 BYTES
CHNOTO80 EQU   *
         ICM   REG15,8,=C' '       LOAD A PADDING CHARACTER
         L     REG0,CMNDLINE       LOAD ADDRESS OF COMMAND LINE
         LA    REG1,80             LOAD LENGTH OF COMMAND LINE
         MVCL  REG0,REG14          AND MOVE THAT DATA TO IT
         XAL   REG11,OUTPUTIT      GO WRITE OUT THE SCREEN
CHREADLP XAL   REG11,READSTAK      GO IDENTIFY THE NEXT INPUT
         CLI   AID,X'7D'           NORMAL INPUT ?
         BE    CHGOESON             YES. CARRY ON WITH IT
         XAL   REG11,PROCSTAK      NO. GO PROCESS WHATEVER IT WAS
         B     CHREADLP            AND START AGAIN
CHGOESON EQU   *
         NC    DATALNTH,DATALNTH   ANYTHIN THERE TO CHANGE
         BZ    OVLYEXIT            NO. RETURN TO CALLER
         L     REG0,CURRENT        LOAD ADDRESS OF CURRENT RECORD
         A     REG0,COLSTART       CALCULATE THE REAL START ADDRESS
         LH    REG1,LRECL          LOAD LENGTH OF DATA
         A     REG1,CURRENT        END ADDRESS OF RECORD
         SR    REG1,REG0           LENGTH OF RECORD REMAINING
         L     REG14,ENDZONE       LOAD LENGTH TO BE CHANGED
         CR    REG1,REG14          WHICH OF THESE IS GREATER
         BL    OVTAKEIT            REG14. TAKE THE REMAINING LENGTH
         LR    REG1,REG14          REG1. TAKE THE DEFINED ZONES
OVTAKEIT EQU   *
         LA    REG14,COMMAND       ADDRESS OF SOURCE DATA
         LA    REG15,L'COMMAND     LENGTH OF SOURCE DATA
         MVCL  REG0,REG14          REPLACE THE INPUT DATA
OVLYEXIT L     REG1,CMNDLINE       LOAD ADDRESS OF COMMAND AREA
         XC    0(120,REG1),0(REG1) CLEAR THE COMMAND AREA
         L     REG5,ERRMSG         LOAD ADDRESS OF MESSAGE AREA
         MVC   0(20,REG5),=120C' ' CLEAR THE MESSAGE AREA
         B     OUTPUTIT            OUTPUT THE NEW DATA
         EJECT
***********************************************************************
*        PROCESS ABBREVIATED FORM OF LOCATE
***********************************************************************
         SPACE 1
*        THIS ROUTINE IS A PRE-PROCESSOR FOR THE
*         ABBREVIATED VERSION OF LOCATE WHEREBY THE CHARACTER '/' IS
*         BOTH THE LOCATE OPERATION CODE AND THE FIRST STRING DELIMITER
         SPACE 1
MINILOC  DS    0H
         L     REG1,OPERANDS       LOAD ADDRESS OF OPERAND STRING
         BCTR  REG1,0              DECREMENT TO PREVIOUS BYTE
         ST    REG1,OPERANDS       PRESERVE UPDATED OPERAND ADDRESS
         ST    REG1,ERROPNDS       ALOS UPDATE ERROR OPERAND FIELD
         B     LOCATE              GO TO NORMAL LOCATE PROCESSING
         EJECT
***********************************************************************
*        PROCESS THE LOCATE COMMAND
***********************************************************************
         SPACE 2
LOCATE   DS    0H
         L     REG1,OPERANDS       LOAD ADDRESS OF OPERAND STRING
         XAL   REG11,SETDELIM      GO INSERT FINAL DELIMITER
         L     REG1,CURRENT+4      LOAD ADDRESS OF NEXT LINE AREA
         MVC   CURRENT(12),0(REG1) UPDATE LOCATION POINTER
         CLI   CURRENT,X'EE'       ARE WE AT END OF FILE
         BNE   NOTATEND            NO. CARRY ON AS NORMAL
         L     REG1,CURRENT+4      LOAD ADDRESS OF NEXT (TOP) RECORD
         L     REG1,4(REG1)        JUMP PAST THE TOF MARKER
         MVC   CURRENT(12),0(REG1) AND REPOSITION TO TOF
NOTATEND L     REG14,OPERANDS      LOAD START ADDRESS OF OPERAND
         IC    REG15,0(REG14)      LOAD HIS DELIMITER CHARACTER
         LA    REG14,1(REG14)      FIRST BYTE OF ARGUMENT
         ST    REG14,LOCDATA       SAVE ADDRESS OF LOCATE DATA
         XR    REG1,REG1           CLEAR LENGTH REGISTER
CNTLOOP  EX    REG15,CLIINST       TEST FOR END OF ARGUMENT
         BE    GOTLSTR             FOUND IT. GO PROCESS
         LA    REG1,1(REG1)        INCREMENT LENGTH REGISTER
         LA    REG14,1(REG14)      LOAD ADDRESS NEXT DATA BYTE
         C     REG14,CMNDENDS END OF INPUT DATA ?
         BNL   LCERROR1            YES. ERROR CONDITION
         B     CNTLOOP             GO TRY NEXT BYTE
GOTLSTR  ST    REG1,LOCLENTH       SAVE LENGTH OF DATA STRING
LOOP6    L     REG14,LOCDATA       LOAD ADDRESS OF INPUT DATA
         L     REG4,CURRENT        LOAD ADDRESS OF CURRENT CARD
         A     REG4,COLSTART       ADDRESS OF SCREEN RECORD
         LR    REG3,REG4           LOAD SECOND REGISTER
         A     REG3,ENDZONE        CALCULATE END ADDRESS OF COMPARE
         A     REG4,STRTZONE       CALCULATE START ADDRESS OF SCAN
         S     REG3,LOCLENTH       TERMINATE SCAN AT END POINT
LOOP5    L     REG15,LOCLENTH      LOAD LENGTH OF INPUT DATA
         LR    REG1,REG15          LOAD CLCL REGISTER 1
         LR    REG0,REG4           LOAD CLCL REGISTER 2
         L     REG14,LOCDATA       LOAD ADDRESS OF INPUT DATA
         CLCL  REG0,REG14          TEST FOR DATA FOUND
         BE    LOCGOTIT            YES. GO PROCESS
         LA    REG4,1(REG4)      LOAD ADDRESS FOR NEXT COMPARE
         CR    REG4,REG3           END OF CARD YET
         BNH   LOOP5               NO. CONTINUE
         L     REG1,CURRENT+4      ADDRESS OF NEXT RECORD
         MVC   CURRENT(12),0(REG1) UPDATE CURRENT POINTER
         CLI   CURRENT,X'EE'       END OF DATA DETECTED
         BNE   LOOP6               NO. GO PROCESS NEXT CARD
LOCGOTIT XAL   REG11,OUTPUTIT      GO SHOW HIM HIS DATA
         BR    REG11               RETURN TO CALLER
         EJECT
***********************************************************************
*        DUPLICATE A NUMBER OF LINES
***********************************************************************
         SPACE 2
$DUP     DS    0H
         CLI   CURRENT,X'FF'       ARE WE AT TOP OF FILE
         BE    MINEMINE            YES. GO COMPLAIN AT HIM
         CLI   CURRENT,X'EE'       ARE WE AT END OF DATA
         BE    MINEMINE            YES. GO COMPLAIN AT HIM
         LA    REG10,1             LOAD THE DEFAULT NUMBER OF DUP'S
         XAL   REG11,NUMBERS       GO EXTRACT NUMBER TO DUP
         LTR   REG1,REG1           CHACK FOR ZERO COUNT
         BZ    DUPEXIT             YES. RETURN IMMEDIATELY
         LR    REG5,REG1           LOAD THE COUNT OF DUP'S
DUPLOOP  EQU   *
         LM    REG15,REG1,CURRENT  LOAD CURRENT LINE DETAILS
         L     REG14,4(REG1)       LOAD ADDRESS OF CURRETN LINE
         CALL  GETDATAQ,((14),(8)),VL,MF=(E,CALLLIST)
         MVC   CURRENT(12),0(REG1) AND MAKE THIS A CURRENT ENTRY
         L     REG1,CURRENT+8      LOAD ADDRESS OF CURRENT DATA
         L     REG0,0(REG1)        ADDRESS OF OLD DATA AREA
         LH    REG1,LRECL          LOAD THE LENGTH OF DATA
         LR    REG15,REG1          LOAD MVCL SECOND REGISTER
         L     REG14,CURRENT       ADDRESS OF NEW DATA AREA
         MVCL  REG14,REG0          COPY THE RECORD TO THIS AREA
         BCT   REG5,DUPLOOP        AND REPEAT
DUPEXIT  XAL   REG11,OUTPUTIT      GO SHOW HIM THE RESULT
         BR    REG11               RETURN TO CALLER
         EJECT
***********************************************************************
*        MOVE A RANGE OF LINES
***********************************************************************
         SPACE 2
$DUPMOVE DS    0H
         NI    $DPFLAG,255-$DPMOVE SHOW THAT NO MOVE REQUIRED
         B     $DPSTART            GO ENTER THE MAIN ROUTINE
$MOVE    DS    0H
         OI    $DPFLAG,$DPMOVE     SET FLAG TO SHOW MOVE OPERATION
$DPSTART EQU   *
         CLI   CURRENT,X'FF'       ARE WE AT TOP
         BNE   $MNOTTOP            NO. CARRY ON THEN
         L     REG1,CURRENT+4      ADDRESS OF NEXT RECORD
         MVC   CURRENT(12),0(REG1) AND UPDATE THE LOCATION
$MNOTTOP EQU   *
         CLI   CURRENT,X'EE'       ARE WE AT END ?
         BE    GENERAL             YES. STUPID
         XAL   REG11,SKIPBLNK      LOCATE START OF FIRST OPERAND
         XAL   REG11,NUMBERS       GO FETCH RECORD COUNT
         LR    REG7,REG1           SAVE THAT COUNT
         XAL   REG11,SKIPBLNK      LOCATE DIRECTION
         LA    REG14,8             LOAD UP OFFSET
         CLC   0(2,REG1),=C'U '    IS IT TO BE UP ?
         BE    GOTDIRCT            YES. GOT THE DIRECTION
         LA    REG14,4             GET DOWN OFFSET
         CLC   0(2,REG1),=C'D '    IS IT DOWN THEN ?
         BE    GOTDIRCT            YES. GO PROCESS
         B     $DPERR              AH SHAME
GOTDIRCT EQU   *
         ST    REG14,$DPOFFST      SAVE THE DIRECTION INDICATOR
         LA    REG1,1(REG1)        STEP OVER THE NEXT CHARACTER
         ST    REG1,OPERANDS       AND UPDATE THE OPERAND ADDRESS
         LA    REG10,1             LOAD DEFAULT DISTANCE TO MOVE
         XAL   REG11,NUMBERS       GO FETCH THE DISTANCE
         LR    REG6,REG1           AND SAVE IT
         L     REG3,CURRENT+8      ADDRESS OF THE RECORD BEFORE
         L     REG4,4(REG3)        ADDRESS OF FIRST RECORD AFFECTED
         LA    REG1,CURRENT        SET UP FOR THE LOOP
$MLOOP1  EQU   *                   BUZZ DOWN TO THE LAST RECORD WANTED
         L     REG1,4(REG1)        ADDRESS OF NEXT RECORD AREA
         CLI   0(REG1),X'EE'       END OF FILE
         BE    $MLOOP1X            YES. EXIT FROM THE LOOP
         BCT   REG7,$MLOOP1        NO. KEEP GOING DOWN THE RECORDS
$MLOOP1X EQU   *
         L     REG5,8(REG1)        ADDRESS OF LAST RECORD TO BE MOVED
         TM    $DPFLAG,$DPMOVE     IS THIS REALLY A MOVE ?
         BZ    $MNOMVE1            NO. LEAVE CURRENT CHAINING
         ST    REG1,4(REG3)        UPDATE THE CHAIN TO REMOVE BLOCKS
         ST    REG3,8(REG1)        UPDATE THE CHAIN TO REMOVE BLOCKS
         B     $DPMOVE1
$MNOMVE1 EQU   *
         CLC   $DPOFFST,=F'4'      ARE WE GOING DOWN ?
         L     REG1,8(REG1)        GO BACK 1 SPACE
         BE    $DPNOSWT            LEAVE START OF DOWN CHAIN AFTER DATA
$DPMOVE1 EQU   *
         LR    REG1,REG3           START CHAINING FROM ORIGINAL REC
$DPNOSWT EQU   *
         L     REG14,$DPOFFST      RESTORE THE DIRECTION INDICATOR
         LTR   REG6,REG6           IS THERE A MOVE DISTANCE PRESENT
         BZ    $MLOOP2X            NO. LEAVE ALL CHAINS AS ARE
$MLOOP2  EQU   *
         TM    0(REG1),X'80'       IS THIS THE TOP OR THE BOTTM ?
         BNZ   $MLOOP2X            ONE OR THE OTHER. EXIT FROM LOOP
         L     REG1,0(REG14,REG1)  LOAD ADDRESS OF NEXT BLOCK UP OR DN
         BCT   REG6,$MLOOP2        FIND THE INSERT POINT
$MLOOP2X EQU   *
         CLI   0(REG1),X'EE'       HAVE WE ARRIVED AT END OF FILE ?
         BNE   *+8                 NO. INSERT POINT IS OK
         L     REG1,8(REG1)        YES. GO BACK 1. DO NOT COLLECT $200
         TM    $DPFLAG,$DPMOVE     IS THIS A MOVE OR A DUPMOVE
         BZ    $MNOMVE2            DUPMOVE GO TO COPY ROUTINE
         L     REG2,4(REG1)        ADDRESS OF RECORD AFTER INSERT POINT
         ST    REG4,4(REG1)        LINK THE NEW BLOCK IN AT TOP
         ST    REG1,8(REG4)        AND THE BACK POINTER AT TOP
         ST    REG2,4(REG5)        LINK THE NEW BLOCK IN AT BOTTOM
         ST    REG5,8(REG2)        AND THE BACK POINTRE AT BOTTOM
         MVC   CURRENT(12),0(REG4) SET UP NEW LOCATION POINTER
$DPEXIT  EQU   *
         NI    $DPFLAG,255-$DPMOVE RESET THE FLAG
         XAL   REG11,OUTPUTIT      SHOW HIM THE RESULT
         BR    REG11               RETURN TO CALLER
$MNOMVE2 EQU   *
         MVC   CURRENT(12),0(REG1) MAKE INSERT POINT CURRENT FOR NOW
$MLOOP3  EQU   *
         LR    REG14,REG1          LOAD PARAMTER REGISTER
         CALL  GETDATAQ,((14),(8)),VL,MF=(E,CALLLIST)
         LM    REG14,REG0,0(REG1)  LOAD UP ALL THE AREA DETAILS
         LH    REG15,LRECL         LOAD LENGTH OF DATA
         L     REG6,0(REG4)        ADDRESS OF SOURCE DATA
         LR    REG7,REG15          SECOND LENGTH REGISTER
         MVCL  REG14,REG6          COPY THE CURRENT RECORD
         CR    REG4,REG5           ANY MORE TO COPY
         BE    $MLOOP3X            NO. TERMINATE THE COPY
         L     REG4,4(REG4)        ADDRESS OF NEXT BLOCK
         B     $MLOOP3             AND CONTINUE
$MLOOP3X EQU   *
         L     REG1,CURRENT+8      ADDRESS OF RECORD BEFORE INSRT PNT
         L     REG1,4(REG1)        ADDRESS OF INSERT RECORD
         L     REG1,4(REG1)        ADDRESS OF FIRST NEW RECORD
         MVC   CURRENT(12),0(REG1) UPDATE CURRENT LOCATION COUNTER
         B     $DPEXIT             RETURN TO CALLER
         EJECT
***********************************************************************
*        RENUMBER THE ENTIRE FILE
***********************************************************************
         SPACE 2
RENUM    DS    0H
         LA    REG10,100           LOAD THE DEFAULT
         XAL   REG11,NUMBERS       GO GET START NUMBER
         LR    REG2,REG1           LOAD WORK REGISTER
         LA    REG10,100           LOAD THE DEFAULT
         XAL   REG11,NUMBERS       GO GET INCREMENT
         LR    REG3,REG1           LOAD WORK REGISTER
         LA    REG10,73            LOAD DEFAULT START COL
         XAL   REG11,NUMBERS       GO LOAD THE NUMBER
         LR    REG4,REG1           LOAD WORK REGISTER
         LA    REG10,8             LOAD DEFAULT LENGTH
         XAL   REG11,NUMBERS       GO LOAD THE NUMBER
         LR    REG5,REG1           LOAD WORK REGISTER
         BCTR  REG4,0              CONVERT COL NUMBER TO OFFSET
         BCTR  REG5,0              EXECUTABLE LENGTH
         L     REG6,DUMMY+4        ADDRESS OF FIRST LINE AFFECTED
         CLI   0(REG6),X'EE'       SNEAKY ONE WITH A NULLFILE ?
         BE    RENEXIT             SURE IS. THAT FOOLED YA.
RENLOOP  CVD   REG2,DBLWORD        CONVERT FIRST NUMBER TO DECIMAL
         OI    DBLWORD+L'DBLWORD-1,X'0F' LAST SIGN BYTE A GUDUN
         UNPK  RENWORK,DBLWORD+3(5) UNPACK THAT NUMBER
         LA    REG1,RENWORK+L'RENWORK-1 LAST BYTE OF NUMBER
         SR    REG1,REG5           START ADDRESS OF NUMBER
         L     REG15,0(REG6)       ADDRESS OF DATA AREA OF RECORD
         LA    REG15,0(REG4,REG15) START ADDRESS OF NUMBER COL
         EX    REG5,RENMVC         MOVE NUMBER TO CARD
         L     REG6,4(REG6)        FETCH NEXT RECORD PARM
         CLI   0(REG6),X'EE'       END OF FILE REACHED ?
         BE    RENEXIT             YES. EXIT FROM LOOP
         AR    REG2,REG3           CALCULATE NEXT LINE NUMBER
         B     RENLOOP             PROCESS ALL THE RECORDS
RENEXIT  EQU   *
         XAL   REG11,OUTPUTIT      GO SHOW HIM THE SCREEN
         BR    REG11               RETURN TO CALLER
RENMVC   MVC   0(0,REG15),0(REG1)  MOVE NUMBER TO CARD
         EJECT
***********************************************************************
*        INITIALISE THE ZONE RANGES
***********************************************************************
         SPACE 2
ZONE     DS    0H
         XAL   REG11,NUMBERS       LOCATE FIRST NUMBER
         CH    REG1,=H'80'         IS IT A RIDICULOUS NUMBER
         BH    ZONERR              YES GIVE HIM AN ERROR
         BCTR  REG1,0              CONVERT TO AN OFFSET
         ST    REG1,STRTZONE       SAVE START ZONE
         XAL   REG11,NUMBERS       GET NEXT ZONE FIELD
         CH    REG1,=H'80'         RIDICULOUS NUMBER AGAIN
         BH    ZONERR              YES. GO TELL HIM ABOUT IT
         ST    REG1,ENDZONE        SAVE ENDING ZONE ADDRESS
         CLC   STRTZONE,ENDZONE    SEE IF THE VALUES MAKE SENSE
         BNL   ZONERR
         B     OUTPUTIT            GO SHOW HIM THE SCREEN
         EJECT
***********************************************************************
*        PROCESS THE TAB KEY
***********************************************************************
         SPACE 2
TAB      DS    0H
         NC    DATALNTH,DATALNTH   DID ANY DATA COME IN WITH THAT ?
         BZ    NOTBDATA            NO. NONE EXISTS SO FAR
         OI    WORKFLAG,DANGER     YES. SO TURN ON A FLAG
         MVC   IOAREA,COMMAND      MOVE ANY DATA READ BACK TO IO AREA
NOTBDATA EQU   *
         LA    REG3,4(REG3)        STEP OVER THE TAB KEYWORD
         MVC   COMMAND,=120C' '     CLEAR THE COMMAND AREA
         MVC   COMMAND(76),0(REG3)  MOVE THE OPERANDS TO COMMAND AREA
         LA    REG1,COMMAND          LOAD ADDRESS OF SIRST OPERAND
         ST    REG1,OPERANDS        AND UPDATE THE 'NUMBERS' POINTER
         LA    REG1,CURSORID        LOAD ADDRESS OF CURRENT CURSOR ADDR
         XAL   REG11,GETOFFST       AND CONVERT THAT TO AN OFFSET
         LR    REG3,REG1           LOAD A WORK REGISTER
         S     REG3,=A(80*22-1)     IS THAT CURSOR IN RANGE
         BP    YESITIS              YESITIS
         XR    REG3,REG3           PRETEND THAT ITS IN RANGE
YESITIS  EQU   *
         OI    WORKFLAG,TABCOL1    SET ON FLAG JUST IN CASE
TABLOOP  XR    REG10,REG10          SET DEFAULT REGISTER
         XAL   REG11,NUMBERS        GO FETCH FIRST  TAB COLUMN
         LTR   REG1,REG1           ANY MORE POSITIONS TO TEST
         BZ    INSERTIT            NO. GO INSERT THE CURSOR
         BCTR  REG1,0               SUBTRACT 1 FOR AN INSERT
         CR    REG1,REG3            IS THAT BEYOND OUR CURRENT ADDRESS
         BL    TABLOOP              NO. TRY THE NEXT ONE
         NI    WORKFLAG,255-TABCOL1 RESET THE FLAG WHICH SAYS COL 1
INSERTIT EQU   *                    SET UP PARAMETER REGISTER
         XAL   REG11,GETBUFF        GO RECONVERT TO A BUFFER ADDRESS
         STCM  REG1,3,CURSLOC       SET UP THE INSERT CURSOR SBA ADDRES
         LA    REG3,INCURS          LOAD ADDRESS OF COMMAND STRING
         LA    REG4,INCURLEN        LOAD THE LENGTH OF IT
         TPUT  (3),(4),FULLSCR,WAIT GO INSERT THE CURSOR
         BR    REG11               RETURN TO CALLER
         EJECT
***********************************************************************
*        CALCULATE A BUFFER OFFSET FROM A BUFFER ADDRESS
***********************************************************************
         SPACE 2
GETOFFST DS    0H
         XR    REG14,REG14         CLEAR WORK REGISTER
         XR    REG15,REG15         CLEAR WORK REGISTER
         IC    REG14,0(REG1)        LOAD FIRST PART OF ADDRESS
         IC    REG15,1(REG1)        LOAD SECOND PART OF ADDRESS
         N     REG14,=F'63'         STRIP ALL BUT LAST SIX BITS
         N     REG15,=F'63'         STRIP ALL BUT LAST SIX BITS
         SLL   REG14,6              MOVE HIGH ORDER BITS OVER
         AR    REG14,REG15          AND ADD THEM TOGETHER
         LR    REG1,REG14           LOAD INTO RETURN REGISTER
         BR    REG11                RETURN TO CALLER
         EJECT
***********************************************************************
*        CONVERT AN OFFSET TO A COMMAND LINE ADDRESS
***********************************************************************
         SPACE 2
GETBUFF  DS    0H
         A     REG1,=A(80*22)      ADD THE OFFSET TO COMMAND FIELD
         LR    REG14,REG1          LOAD UP A WORK REGISTER
         SRDL  REG14,6             TAKE OUT SIX BITS
         SLL   REG14,2             'GAIN' TWO BITS AT END
         SLDL  REG14,6             AND PICK UP THE OTHER BITS AGAIN
         STCM  REG14,3,DBLWORD     STORE RESULT IN WORK AREA
         L     REG15,=A(BUFFTABL)   LOAD ADDRESS OF BUFFER ADDRESS TAB
         TR    DBLWORD(2),0(REG15) CONVERT TO VALID CODES
         ICM   REG1,3,DBLWORD      AND RELOAD PARAMETER REGISTER
         BR    REG11                RETURN TO CALLER
         EJECT
***********************************************************************
*        INITIALISE THE PROGRAM FUNCTION KEYS
***********************************************************************
         SPACE 2
SET      DS    0H
         XAL   REG11,SKIPBLNK      FIND FIRST OPERAND
         CLC   0(2,REG1),=C'PF'    PFK IDENTIFIER ?
         BNE   SETERROR            INVALID PARMS
         LA    REG1,2(REG1)        OK. STEP OVER IT
         ST    REG1,OPERANDS        AND UPDATE THE OPERAND POINTER
         XR    REG10,REG10         CLEAR DEFAULT REGISTER
         XAL   REG11,NUMBERS       EXTRACT THE PFK NUMBER
         LR    REG2,REG1           SAVE PFK ID
         LTR   REG1,REG1           TEST FOR INVALID ENTRY
         BZ    SETERROR            YES. SIGNAL THE ERROR
         CH    REG1,=H'24'         HIGHER THAN MAXIMUM ALLOWED
         BH    SETERROR             SORRY. NOCANDO
         BCTR  REG1,0              SUBTRACT 1 FOR AN OFFSET
         LA    REG2,PFKDIST        LOAD LENGTH OF EACH ENTRY
         MR    REG0,REG2           CALCULATE OFFSET TO ENTRY
         LA    REG2,PFAREA1(REG1)  ADDRESS OF PFK DATA FIELD
         MVI   0(REG2),X'00'       CLEAR THE PFK FLAGS
         XAL   REG11,SKIPBLNK      GO FIND NEXT OPERAND
         CLC   0(4,REG1),=C'IMM '  IS IT TO BE AN IMMEDIATE KEY ?
         BNE   NOTANIMM            NO. BYPASS BIT SETTING ETC
         OI    0(REG2),PFIMM       SET ON IMMEDIATE FLAG
         LA    REG1,4(REG1)        STEP OVER THE IMM OPERAND
         ST    REG1,OPERANDS       UPDATE THE OPERAND FIELD
         XAL   REG11,SKIPBLNK      AND GO FIND THE DATA STRING
NOTANIMM EQU   *
         CLC   0(4,REG1),=C'TAB '  IS THIS TO BE A TAB KEY ?
         BNE   NOTATAB             NO. BYPASS TAB PROCESSING
         OI    0(REG2),PFTAB       SET ON THE TAB FLAG
NOTATAB  EQU   *
         OI    0(REG2),PFSET       TURN ON THE PFK SET FLAG
         LA    REG2,1(REG2)        LOAD ADDRESS OF PFK DATA FIELD
         LA    REG3,80               LENGTH OF PFK AREA
         L     REG0,OPERANDS       LOAD ADDRESS OF SOURCE FIELD
         LA    REG1,COMMAND+L'COMMAND ADDRESS OF END OF DATA
         SR    REG1,REG0           LENGTH OF PFK DATA
         ICM   REG1,8,=X'00'       AND SET UP A PADDING CHARACTER
         MVCL  REG2,REG0            MOVE THE COMMAND STRING TO BUFFER
SETEXIT  L     REG5,ERRMSG         LOAD ADDRESS OF MESSAGE AREA
         MVC   0(20,REG5),=CL20'PFK IS SET.' TELL HIM ITS DONE
         XAL   REG11,OUTPUTIT      AND SHOW HIM A NEW SCREEN
         BR    REG11               RETURN TO CALLER
         EJECT
***********************************************************************
*        DISPLAY ALL THE PFK'S READY FOR CHANGE
***********************************************************************
         SPACE 2
PFK      DS    0H
         B     REREAD              AND GO READ HIS RESPONSE
         EJECT
***********************************************************************
*        SUPPLY ANY MISSING DELIMITERS
***********************************************************************
         SPACE 2
SETDELIM DS    0H
         IC    REG15,0(REG1)       LOAD THE SPECIFIED DELIMITER
         LA    REG3,COMMAND+L'COMMAND END OF INPUT DATA
DLMLOOP  BCTR  REG3,0              ADDRESS PREVIOUS BYTE
         CLI   0(REG3),C' '        STILL BLANK DATA
         BE    DLMLOOP             YES. KEEP LOOPING
         LA    REG3,1(REG3)        GO BACK TO THAT BLANK
         STC   REG15,0(REG3)       ADD A DELIMITER JUST IN CASE
         ST    REG3,OPERENDS       SAVE EFFECTIVE END OF OPERANDS
         BR    REG11               RETURN TO CALLER
         EJECT
***********************************************************************
*        WRITE A FULL SCREEN OF DATA                                  *
***********************************************************************
         SPACE 2
OUTPUTIT DS    0H
         NC    STACKTOP,STACKTOP   TEST FOR ANY MORE COMMANDS TO DO
         BNZ   OUTPEXIT            YES. WAIT BEFORE REWRITE
         L     REG14,DATAAREA      LOAD ADDRESS OF SCREEN DATAAREA
         L     REG15,SCREENLN      LOAD THE LENGTH OF IT
         XR    REG0,REG0           CLEAR A WORK REGISTER
         XR    REG1,REG1           CLEAR A WORK REGISTER
         MVCL  REG14,REG0          SET THE SCREEN AREA TO NULLS
         SPACE 2
         L     REG5,DATAAREA       LOAD ADDRESS OF SCREEN DATA AREA
         LR    REG7,REG5           PREPARE BXLE END REGISTER
         A     REG7,SCREENLN       ADDRESS OF END OF THE AREA
         BCTR  REG7,0              SUBTRACT 1 TO ADDRESS LAST BYTE
         A     REG5,MIDPOINT       ADDRESS OF CURRENT LINE AREA
         LA    REG6,80             LOAD AN INCREMENT REGISTER
         L     REG4,CURRENT+4      ADDRESS OF PREVIOUS RECORD
         L     REG4,8(REG4)        AND GET REAL ADDRESS OF CURRENT
         B     SCLOOP1X            JUMP OVER FIRST LOAD
SCLOOP1  EQU   *
         XAL   REG11,SCLOADUP      LOAD UP THIS AREA
SCLOOP1X EQU   *
         CLI   0(REG4),X'EE'       ARE WE AT END OF DATA ?
         BE    SCDOTOP             YES. GO PROCESS TOP OF SCREEN
         L     REG4,4(REG4)        ADDRESS NEXT RECORD AREA
         BXLE  REG5,REG6,SCLOOP1   FILL IN THE BOTTOM OF SCREEN
SCDOTOP  EQU   *
         L     REG4,CURRENT+8      ADDRESS OF PREVIOUS RECORD
         L     REG4,4(REG4)        REAL ADDRESS OF CURRENT RECORD
         L     REG5,DATAAREA       LOAD ADDRESS OF SCREEN AREA
         LR    REG7,REG5           LOAD BXH END REGISTER
         BCTR  REG7,0              SUBTRACT 1 FOR LAST BYTE AREA ABOVE
         A     REG5,MIDPOINT       ADDRESS OF CURRENT MIDPOINT
         LNR   REG6,REG6           MAKE +80 INTO -80
SCLOOP2  EQU   *
         XAL   REG11,SCLOADUP      GO LOAD UP THIS AREA
         CLI   0(REG4),X'FF'       ARE WE AT TOP OF FILE
         BE    LOADENDS            YES. FINISHED LOADING SCREEN
         L     REG4,8(REG4)        ADDRESS OF PREVIOUS DATA
         BXH   REG5,REG6,SCLOOP2   PROCESS AL THE WAY TO TOP
LOADENDS EQU   *
         L     REG3,SCREEN         RELOAD FOR SECOND WRITE
         L     REG4,TPUTLEN        LOAD LENGTH OF SCREEN DATA
         TPUT  (3),(4),FULLSCR,WAIT   REWRITE ALL BUT LAST LINE
         L     REG1,ERRMSG         LOAD ADDRESS OF ERROR MESSAGE AREA
         XC    0(20,REG1),0(REG1)  CLEAR THE ERROR MESSAGE AREA
         L     REG1,CMNDLINE       LOAD ADDRESS OF THE COMMAND LINE
         XC    0(120,REG1),0(REG1) AND SET IT TO NULLS
         MVC    0(80,REG1),=120C' ' SET UP 80 BYTES OF BLNKS
OUTPEXIT BR    REG11               RETURN TO CALLER
         SPACE 2
SCLOADUP DS    0H                  SUB-SUBROUTINE OF OUTPUTIT
         CLI   0(REG4),X'FF'       TOP OF FILE ?
         BE    SCTOPS              YES. GO ENTER THE TOF MARK
         CLI   0(REG4),X'EE'       END OF FILE ?
         BE    SCEOFS              YES. GO ENTER THE EOFMARK
         L     REG1,0(REG4)        LOAD DATA ADDRESS
         A     REG1,COLSTART       ADD OFFSET TO PART WE ARE USING
         LH    REG3,LRECL          LOAD THE LENGTH OF A RECORD
         S     REG3,COLSTART       GET LENGTH OF DATA AFTER THAT
         CH    REG3,=H'80'         IS THERE ENOUGH TO FILL A SCREEN ?
         BL    SCRSHORT            NO. JUST TAKE THAT LENGTH
         LA    REG3,80             OTHERWISE TAKE THE NEXT 80 BYTES
SCRSHORT EQU   *
         L     REG15,=A(SCTABLE)   LOAD ADDRESS OF TRANSLATE TABLE
         BCT   REG3,SCOVER         SUBTRACT 1 FOR EXECUTE
SCMOVE   MVC   0(0,REG5),0(REG1)   MOVE THE DATA TO SCREEN
SCTR     TR    0(0,REG5),0(REG15)  CONVERT ALL BAD CHARS TO '*'
SCOVER   EX    REG3,SCMOVE         EXECUTE THE MOVE
         EX    REG3,SCTR           EXECUTE THE TRANSLATE
         BR    REG11               RETURN TO CALLER
SCTOPS   EQU   *
         MVC   0(L'TOFMARK,REG5),TOFMARK LOAD UP THE TOF MARKER
         BR    REG11               RETURN TO CALLER
SCEOFS   EQU   *
         MVC   0(L'EOFMARK,REG5),EOFMARK LOAD UP THE END OF FILE MARK
         BR    REG11               RETURN TO CALLER
         EJECT
***********************************************************************
*        READ IN ALL OR PART OF ANOTHER FILE
***********************************************************************
         SPACE 2
GET      DS    0H
         XAL   REG11,SKIPBLNK      LOCATE START OF DATA SET NAME
         LR    REG2,REG1           SAVE THIS ADDRESS
         LA    REG1,1(REG1)        ADDRESS OF NEXT BYTE
         CLI   0(REG1),C' '        END OF DATA SET NAME
         BNE   *-8                 NO. KEEP LOOPING
         ST    REG1,OPERANDS       AND UPDATE THE WORK AREA
         SR    REG1,REG2           GET LENGTH OF DATA SET NAME
         MVC   WORKAREA,=120C' '   CLEAR WORK AREA
         BCT   REG1,*+10           SUBTRACT 1 FROM NEW DSN LENGTH
         MVC   WORKAREA(0),0(REG2) MOVE ENTERED NAME TO WORK AREA
         EX    REG1,*-6            EXECUTE THE MOVE
         LA    REG10,1             LOAD DEFAULT STATR RECORD NUMBER
         XAL   REG11,NUMBERS       GO FETCH NEXT OPERAND
         LR    REG6,REG1           START RECORD NUMBER IN THE FILE
         XR    REG10,REG10         SET NULL DEFAULT PARAMETER
         XAL   REG11,NUMBERS       GO FETCH NUMBER OF RECORDS TO COPY
         LR    REG7,REG1           NUMBER OF RECORDS TO READ FROM IT
         STM   REG6,REG7,READPRMS  AND UPDATE WORK AREA
         L     REG3,CURRENT+8      ADDRESS OF PREVIOUS AREA
         L     REG3,4(REG3)        GIVES ADDRESS OF CURRENT AREA
         CLI   WORKAREA,C''''      NAME BEGINS WITH A QUOTE ?
         BNE   GETEDIT             NO. MUST BE AN EDIT FILE NAME
         MVC   JCLDATA+JCLMLEN(54),WORKAREA INITIALISE WORK AREA
         CALL  READOSDS,((3),(8)),VL,MF=(E,CALLLIST) READ IN DATA
         LTR   REG15,REG15         READ WAS SUCCESSFUL ?
         BNZ   GETERROR            NO. GO TELL HIM ABOUT IT
         B     GETOVER             GO TIDY UP AND RETURN
GETEDIT  EQU   *
         MVC   EDITNAME,WORKAREA   LOAD WORK AREA WITH NAME
         CALL  SRLREAD,((3),(8)),VL,MF=(E,CALLLIST) READ EDIT FILE
GETOVER  EQU   *
         L     REG3,CURRENT+8      ADDRESS OF PREVIOUS BLOCK
         L     REG3,4(REG3)        ADDRESS OF CURRENT ONE
         L     REG3,4(REG3)        ADDRESS OF NEW ONE
         MVC   CURRENT(12),0(REG3) RESET LOCATION ADDRESS
         XAL   REG11,OUTPUTIT      SHOW HIM THE RESULT
         BR    REG11               RETURN TO CALLER
         EJECT
***********************************************************************
*    REPLACE THE DATA ON FILE
***********************************************************************
         SPACE 2
SAVE     DS    0H                  BORROW SOME CODE FROM FILE
         OI    WORKFLAG,SAVEFLG    SIGNAL THAT SAVE IS IN PROGRESS
FILE     DS    0H
         MVC   EDITNAME,EDITDSN    INITIALISE NORMAL FILE NAME
         MVC   JCLDATA+JCLMLEN(54),DSNAME AND INITIALISE THE NORMAL OS
         MVC   WORKAREA,=120C' '   CLEAR WORK AREA
         L     REG1,OPERANDS       LOAD ADDRESS OF ANY OPERANDS
         XAL   REG11,SETDELIM      FIND THE END OF THEM
         CLC   OPERANDS,OPERENDS   TEST FOR PRESCENCE OF THEM
         BNL   SFNORMAL            NONE SAVE/FILE IS NORMAL
         XAL   REG11,SKIPBLNK      FIND START OF OPERANDN
         MVC   WORKAREA(56),0(REG1) SAVE THE ENTERED NAME
         CLI   WORKAREA,C''''      IS THAT AN OS DATA SET NAME ?
         BE    SETNEWOS            YES. MOVE IT TO WORK AREA
         MVC   EDITNAME,WORKAREA   OTHERWISE ASSUME EDIT NAME AND...
         B     STOREDIT            GO PROCESS IT
SETNEWOS EQU   *
         MVC   JCLDATA+JCLMLEN(54),WORKAREA MOVE NEW NAME TO WORK AREA
         B     OSREADGO            AND GO PROCESS OS DATA SET
SFNORMAL EQU   *
         CLI   EDITDSN,C' '        ARE WE EDITTING AN EDIT FILE ?
         BNE   STOREDIT            YES. GO PROCESS IT
OSREADGO EQU   *
         CALL  WRITOSDS,((8)),VL,MF=(E,CALLLIST) WRITE THE FILE
         LTR   REG15,REG15         OPERATION WAS SUCCESSFUL ?
         BNZ   SFERROR             NO. GIVE AN ERROR MESSAGE
SAVERENT EQU   *                   REENTER FROM EDIT DATA SET SAVE
         TM    WORKFLAG,SAVEFLG     WAS THAT A SAVE OR A FILE
         BZ    QUIT                 FILE. GO RETURN TO CALLER
         NI    WORKFLAG,255-SAVEFLG RESET THE SAVE FLAG
         L     REG5,ERRMSG         LOAD ADDRESS OF MESSAGE AREA
         MVC   0(20,REG5),=CL20'SAVED:' TELL HIM WHAT I'VE DONE
         XAL   REG11,OUTPUTIT      GO DISPLAY THE AREA
         BR    REG11               RETURN TO CALLER
         EJECT
***********************************************************************
*        RETURN AN EDIT FILE TO THE EDIT DATA SET
***********************************************************************
         SPACE 2
STOREDIT DS    0H
         CALL  SRLWRITE,((8)),VL,MF=(E,CALLLIST) WRITE OUT THE DATA
         B     SAVERENT            AND GO REENTER SAVE
         EJECT
**********************************************************************
*        FREE THE FILE, WORK AREAS, AND RETURN                       *
**********************************************************************
         SPACE 2
QUIT     DS    0H
         FREEMAIN R,SP=120         FREE UP THE CORE
         LM    REG0,REG1,STACKREG  RELOAD GETMAIN REGISTERS FROM GETMN
         FREEMAIN R,LV=(0),A=(1)   FREE UP THE CONSOLE STACK
         LM    REG0,REG1,SCRNREGS  LOAD GATMAIN REGISTERS
         FREEMAIN R,LV=(0),A=(1)   FREEMAIN THE SCREEN AREA
         CLC   COMMAND(5),=C'EXIT ' REQUEST TO TERMINATE ?
         BNE   RESTART1            LOOP BACK TO ASK FOR NEXT FILE NAME
SUPREXIT EQU   *
         TPUT  CLOSEDWN,CLOSELEN,FULLSCR,WAIT
         ZRETURN RC=0
         EJECT
***********************************************************************
*        SPOOL HIS FILE TO INTERNAL READER
***********************************************************************
         SPACE 2
SUBMIT   DS    0H
         CALL  OSSUBMIT,((8)),VL,MF=(E,CALLLIST) INVOKE SERVICE RTN
         L     REG5,ERRMSG         LOAD ADDRESS OF MESSAGE AREA
         MVC   0(10,REG5),=CL10'SUBMITTED:'
         XAL   REG11,OUTPUTIT      GO OUTPUT A SCREEN
         BR    REG11               RETURN TO CALLER
         EJECT
***********************************************************************
*        GENERAL NUMERIC CONVERSION AND TEST                          *
***********************************************************************
         SPACE 2
NUMBERS  DS    0H
         L     REG1,OPERANDS       LOAD ADDRESS OF OPERAND FIELD
         ST    REG1,ERROPNDS       UPDATE THE ERROR FIELD POINTER
         LTR   REG1,REG1           TEST FOR ANY MORE DATA FIELDS
         BZ    SETDEFLT            NONE SET A DEFAULT VALUE
         B     ENDTEST             CHECK FOR INVALID CALL FIRST
NUMLOOP  CLI   0(REG1),C' '        FILLING CHARACTER HERE   ?
         BNE   STARTSCN            NO. GO START EXTRACTING DATA
         LA    REG1,1(REG1)        ADDRESS NEXT BYTE OF DATA
ENDTEST  C     REG1,CMNDENDS END OF ALL DATA ?
         BL    NUMLOOP             NO. TEST NEXT BYTE
SETDEFLT XC    OPERANDS,OPERANDS   CLEAR OPERAND POINTER
         LR    REG1,REG10          LOAD THE DEFAULT VALUE
         BR    REG11               RETURN TO CALLER
STARTSCN EQU   *
         CLI   0(REG1),C'*'        IS THIS AN ASTERISK TYPE OPERAND
         BNE   SORRY               NO. MUST BE A REAL NUMBER
         LA    REG1,1(REG1)        LOAD ADDRESS OF NEXT BYTE
         ST    REG1,OPERANDS       UPDATE THE CURRENT OPERAND POINTER
         LA    REG1,1              LOAD A NUMBER
         LCR   REG1,REG1           MAKE IT LOOK VERY LARGE INDEED
         LA    REG1,0(REG1)        BUT MAKE SURE IT IS POSITIVE
         BR    REG11               AND RETURN TO CALLER
SORRY    EQU   *                   CANNOT PROCESS ALL OCCURRENCES
         LR    REG14,REG1          LOAD START ADDRESS OF FIELD
         LA    REG1,1(REG1)        ADDRESS NEXT BYTE OF DATA
NUMLOOP2 CLI   0(REG1),C' '        END OF THIS DATA YET
         BE    TESTNUMR            YES GO GET LENGTH AND TEST
         CLI   0(REG1),C'*'        OR HAS HE FOLLOWED WITH AN ASTERISK
         BE    TESTNUMR            YES. GO PROCESS THOSE SQUEEZED DIGIT
         LA    REG1,1(REG1)        ADDRESS NEXT DATA BYTE
         C     REG1,CMNDENDS END OF DATA AREA
         BNE   NUMLOOP2            NO. CARRY ON ALONF DATA
TESTNUMR ST    REG1,OPERANDS       SAVE ADDRESS OF NEXT OPERAND
         SR    REG1,REG14          LENGTH OF THIS FIELD
         L     REG15,=A(NUMTABLE)  LOAD ADDRESS OF NUMERIC TEST TABLE
         BCT   REG1,OVERTHEM       SUBTRACT ONE FROM IT
TRTINST  TRT   0(0,REG14),0(REG15) TEST FOR NUMERIC DATA
PCKINST  PACK  DBLWORD,0(0,REG14)  CONVERT TO PADKED DECIMAL
OVERTHEM EX    REG1,TRTINST        EXECUTE THE NUMERIC TEST
         BNZ   BADNUMBR            INVALID DATA . ERROR
         EX    REG1,PCKINST        EXECUTE THE CONVERT TO PD
         CVB   REG1,DBLWORD        GET IT IN BINARY
         BR    REG11     RETURN TO CALLER
         EJECT
***********************************************************************
*        SKIP ALONG OPERANDS FOR NEXT ONE
***********************************************************************
         SPACE 2
SKIPBLNK DS    0H
         L     REG1,OPERANDS       LOAD CURRENT POINTER ADDRESS
SKIPLOOP CLI   0(REG1),C' '        START OF NEXT OPERAND
         BNE   SKIPEXIT            YES RETURN TO CALLER
         LA    REG1,1(REG1)        ADDRESS NEXT BYTE
         C     REG1,CMNDENDS END OF INPUT AREA ?
         BNL   MISSNGOP            MUST BE MISSING OPERAND
         B     SKIPLOOP            OK. TRY NEXT BYTE
SKIPEXIT ST    REG1,OPERANDS       SAVE CURRENT OPERAND ADDRESS
         BR    REG11               RETURN TO CALLER
         EJECT
***********************************************************************
*        READ THE CONSOLE AND UPDATE STACK
***********************************************************************
         SPACE 2
CONSREAD DS    0H
         LA    REG3,IOAREA-6       ADDRESS OF INPUT IO FIELD
         LA    REG4,L'IOAREA+6     LENGTH OF DATA TO READ
         TGET  (3),(4),ASIS,WAIT   READ THE NEXT COMMAND
         LTR   REG15,REG15         WAS THE READ SUCCESSFUL ?
         BNZ   GENERAL             NO. GIVE A VAGUE IBM TYPE ERROR
         OC    IOAREA,=120C' '     CONVERT EVERYTHING TO UPPER CASE
CONSRD2  LA    REG3,STACKTOP       LOAD ADDRESS OF TOP OF STACK
STAKTEST NC    0(4,REG3),0(REG3)   IS THERE ANYTHING THERE ?
         BZ    ATENDSTK            NO, REG3 IS END OF STACK
         L     REG3,0(REG3)        LOAD ADDRESS OF NEXT ENTRY
         B     STAKTEST            AND GO SEARCH FOR THE END
ATENDSTK EQU   *
         CH    REG1,=H'6'          IS THERE ANY INPUT DATA
         BNH   JUSTAKEY            APPARENTLY NOT. GO TAKE SPECIAL ACT
         SH    REG1,=H'6'          SUBTRACT THE LENGTH OF CONTROL DATA
         LA    REG4,IOAREA-1       START ADDRESS OF SOURCE DATA
         LA    REG6,IOAREA         START ADDRESS FOR FIRST STRING
CONSLOOP LA    REG4,1(REG4)        STEP TO NEXT BYTE
         CLI   0(REG4),DELIM       IS IT A DELIMITER BYTE ?
         BE    SETLEND             YES. GO SET LINE END
         CLI   0(REG4),ESCAPE      IS IT AN ESCAPE CHARACTER
         BNE   NOESCAPE            NO. """""""""""""""""""""
         LA    REG15,IOAREA+L'IOAREA ADDRESS OF END OF DATA
         SR    REG15,REG4          LENGTH OF REMAINING DATA
         BCTR  REG15,0             LENGTH I AM INTERESTED IN
         BCT   REG15,*+10          SUBTRACT 1 FOR ECECUTE
         MVC   0(0,REG4),1(REG4)   SHUFFLE EVERYTHING UP
         EX    REG15,*-6           AND EXECUTE THE MOVE
         BCT   REG1,*+8            SUBTRACT ONE FROM LENGTH FOR IT
         B     BCTEXIT             JUST IN CASE....
NOESCAPE EQU   *
         BCT   REG1,CONSLOOP       PROCESS ALL THE INPUT DATA
BCTEXIT  EQU   *
         LA    REG1,1              MAKE SURE NEXT BCT WORKS
         LA    REG4,1(REG4)        PRETEND TO HAVE A LAST EDLIMITER
SETLEND  LR    REG5,REG4           LOAD ADDRESS OF THAT DELIMITER
         SR    REG5,REG6           GET LENGTH OF THE DATA
         L     REG14,FREESTAK      LOAD ADDRESS OF NEXT FREE ENTRY
         MVC   FREESTAK,0(REG14)   AND UPDATE THE CHAIN
         XC    0(4,REG14),0(REG14) CLEAR MY OWN CHAIN FIELD
         ST    REG14,0(REG3)       UPDATE THE CONSOLE STACK ITSELF
         LR    REG3,REG14          MAKE THIS ENTRY THE LAST
         USING STKENTRY,REG3       ADDRESSABILITY FOR STACK ENTRY
         MVC   STKAID,IOAID        SHOW HIM WHAT THE AID DATA WAS
         MVI   STKAID,X'7D'        BUT MAKE IO CODE LOOK NORMAL
         STH   REG5,STKLEN         GIVE HIM THE LENGTH OF DATA
         LA    REG14,STKDATA       LOAD MVCL REGISTER
         LA    REG15,L'STKDATA     LOAD THE LENGTH REGISTER
         LR    REG7,REG5           LOAD A LENGTH REGISTER
         ICM   REG7,8,=C' '        AND LOAD A PADDING CHARACTER
         MVCL  REG14,REG6          MOVE THE COMMAND TO STACK AREA
         LA    REG6,1(REG4)        SET UP FOR NEXT LOOP
         BCT   REG1,CONSLOOP       AND GO PROCESS THE REST
         MVC   STKAID,IOAID        TAG REAL IOCODE ONTO LAST FIELD
         B     READENDS                 END OF INPUT DATA
JUSTAKEY EQU   *
         TM    WORKFLAG,DANGER     ANY CHANCE OF CHANGED DATA AFTER TAB
         BZ    NOWORRY             NO. CARRY ON AS NORMAL
         CLC   CURSORID,CMNDCURS   IS CURSOR AT START OF LINE ?
         BNE   TAKEIT              NO. GO USE THE PREVIOUSLY SAVED DATA
         TM    WORKFLAG,TABCOL1    DID WE JUST TAB TO COLUMN 1 THEN
         BZ    NOWORRY             NO. HE DID IT. SO FORGET DATA
TAKEIT   EQU   *                   USE WHAT I THINK IS WHAT HE ENTERED
         LA    REG1,86             LOAD A SUITABLE LENGTH REGISTER
         B     ATENDSTK            AND GO PROCESS AS IF I READ IT
NOWORRY  EQU   *                   IGNORE ANY HELD DATA
         L     REG14,FREESTAK      GET A STACK ENTRY FROM CHAIN
         MVC   FREESTAK,0(REG14)   AND UPDATE CHAIN BEHIND ME
         XC    0(4,REG14),0(REG14) CLEAR MY OWN CHAIN POINTER
         ST    REG14,0(REG3)       UPDATE THE REAL CONSOLE STACK
         LR    REG3,REG14          AND MAKE THIS THE END
         MVC   STKAID,IOAID        UPDATE THE AID FIELDS
         XC    STKLEN,STKLEN       SET THE LENGTH FIELD TO ZERO
         XC    STKDATA,STKDATA     AND THE STACK DATA
READENDS EQU   *
         NI    WORKFLAG,255-TABCOL1-DANGER RESET THE LOGIC FLAG
         BR    REG11               RETURN TO CALLER
         EJECT
***********************************************************************
*        LOCATE THE NEXT ENTRY IN THE CONSOLE STACK
***********************************************************************
         SPACE 2
READSTAK DS    0H
READSTK2 EQU   *
         L     REG14,STACKTOP      LOAD ADDRESS OF TOP OF STACK
         LTR   REG14,REG14         ANYTHING THERE
         BNZ   GOTASTAK            YES. GO PROCESS IT
         XAL   REG11,CONSREAD      NO. GO READ SOME MORE DATA
         B     READSTK2            AND GO TRY AGAIN
GOTASTAK EQU   *
         MVC   STACKTOP,0(REG14)   UPDATE THE CURRENT STACK
         LR    REG3,REG14          LOAD A BASE REGISTER
         USING STKENTRY,REG3       ADDRESSABILIYT FOR IT
         MVC   COMMANDX,STKAID     UPDATE THE NORMAL RESPONSE AREA
         MVC   DATALNTH,STKLEN     AND UPDATE THE LENGTH AREA
         MVC   STKCHAIN,FREESTAK   CHAIN FREE STACK ONTO ME
         ST    REG3,FREESTAK       AND THEN UPDATE THE FREE CHAIN
         BR    REG11               RETURN TO CALLER
         EJECT
***********************************************************************
*         PROCESS THE CURRENT STACK ENTRY FOR A COMMAND OR A PFK
***********************************************************************
         SPACE 2
PROCSTAK DS    0H
         L     REG2,=A(AIDTABLE)  TABLE OF POSSIBLE AID CODES
         LA    REG14,AIDTLEN        LENGTH OF AN AID TABLE ENTRY
         L     REG15,=A(AIDTENDS-1) ADDRESS OF END OF TABLE
AIDLOOP  CLC   AID(1),0(REG2)     IS THIS THE CODE
         BE    FOUNDAID           YES. GO PROCESS IT
         BXLE  REG2,REG14,AIDLOOP  NO. TRY NEXT ONE
         B     GENERAL            BEATS ME....
FOUNDAID TM    1(REG2),AIDRTN      DOES A PROGRAM ROUTINE EXIST
         BO    GETPROG            YES. GO PASS CONTROL TO IT
         TM    WORKFLAG,PFKCASE     ASKING FOR UPPER CASE PFK ?
         BZ    PFKLOWER             NO. CARRY ON AS NORMAL
         A     REG2,CASEOFFS        INCREMENT TO UPPER CASE ENTRY
PFKLOWER EQU   *
         NI    WORKFLAG,255-PFKCASE RESET THE UPPER CASE FLAG
         L     REG15,1(REG2)       LOAD PFK ID
         LA    REG15,0(REG15)      STRIP OFF TOP BYTE
         BCTR  REG15,0             SUBTRACT 1 FOR AN OFFSET
         LA    REG0,PFKDIST        LOAD DISTANCES APART OF PFK ENTRIES
         MR    REG14,REG0          GET OFFSET TO CORRECT ENTRY
         LA    REG2,PFAREA1(REG15) ADDRESS OF PFK ENTRY
         LA    REG3,1(REG2)        LOAD ADDRESS OF DATA FIELD
         TM    0(REG2),PFSET       IS THIS PFK INITIALISED
         BZ    PFKNOTON            NO. GO ISSUE AN ERROR MESSAGE
         TM    0(REG2),PFTAB       IS THIS A TAB KEY
         BO    TAB                 YES. GO SHIFT THE CURSOR ABOUT
         TM    0(REG2),PFIMM      IMMEDIATE EXECUTION
         BZ    PFKNOTIM           NO. GO LOAD UP COMMAND AREA
         MVC   IOAREA(80),0(REG3)  PRETEND THAT WE HAVE JUST READ IT
         LA    REG1,86             GET AN ARTIFICIAL LENGTH
         MVI   IOAID,X'7D'         MAKE IT LOOK NORMAL
         B     CONSRD2             GO TO SPECIAL ENTRY IN CONSREAD
         SPACE 2
GETPROG  L     REG15,1(REG2)       LOAD ADDRESS OF THE PROCESSOR
         XAL   REG11,0(REG15)      CALL THE ROUTINE
         B     PRCEXIT             AND RETURN TO CALLER IF HE RETURNS
PFKNOTIM EQU   *
         L     REG1,CMNDLINE       LOAD ADDRESS OF COMMAND AREA
         XC    0(120,REG1),0(REG1) CLEAR IT TO BE SURE
         MVC   0(80,REG1),0(REG3) AND MOVE THE DATA TO IT
         MVC   IOAREA,0(REG1)      AND ALSO SAVE A COPY FOR ME
         OI    WORKFLAG,DANGER     AND SET UP IN CASE HE JUST HITS EOB
         LA    REG1,80(REG1)       ADDRESS OF END OF AREA
PFKLOOPZ BCTR  REG1,0              SUBTRACT 1
         CLI    0(REG1),C' '       TEST FOR STILL BLANK
         BNE   DOCURSOR            NO. GO INSERT THE CURSOR
         MVI   0(REG1),X'00'       SET IT TO NULLS
         B     PFKLOOPZ            GO PROCESS EACH BYTE
DOCURSOR EQU   *
         MVI   1(REG1),X'13'       INSERT THE CURSOR
         XAL   REG11,OUTPUTIT      GO WRITE THE SCREEN
PRCEXIT  EQU   *
         BR    REG11               RETURN TO CALLER
         EJECT
***********************************************************************
*        PROGRAM ACCESS AND AUXILIARY ROUTINES
***********************************************************************
         SPACE 2
PA2KEY   DS    0H
         OI    WORKFLAG,PFKCASE    SIGNAL UPPER CASE PFK ENTRY
         BR    REG11               RETURN TO CALLER
         EJECT
***********************************************************************
*        DATA CONTROL BLOCK EXIT ROUTINES                             *
***********************************************************************
         SPACE 2
EXLST    DS    0F
         DC    X'11'               DCB ABEND EXIT
         DC    AL3(DCBABEND)       ADDRESS OF THE ABEND EXIT
         DC    X'85'
         DC    AL3(*+3)
         PUSH  USING
         USING *,REG15
         USING IHADCB,REG1         ADDRESSABILITY FOR DCB
         NC    DCBLRECL,DCBLRECL   IS THERE AN LRECL CODED ?
         BNZ   LRECLOK             YES. ACCEPT IT THEN
         LA    REG2,80             OTHERWISE LOAD A SUITABLE DEFAULT
         STH   REG2,DCBLRECL       AND STORE IT IT THE DCB
LRECLOK  EQU   *
         NC    DCBBLKSI,DCBBLKSI   ANY BLOCKSIZE AVAILABLE
         BNZ   NOMOVELR            YES. ACCEPT IT THEN
         MVC   DCBBLKSI,DCBLRECL   NO. THEN TAKE LRECL AS BLOCKSIZE
NOMOVELR BR    REG14               AND RETURN TO CALLER
         POP   USING               RESTORE ORIGINAL ADDRESSABILITY
         EJECT
***********************************************************************
*        DCB ABEND EXIT ROUTINE
***********************************************************************
         SPACE 2
         PUSH  USING               SAVE OLD ADDRESSABILITY
         USING *,REG12             ADDRESSABILITY FOR THIS ROUTINE
DCBABEND DS    0H
         LR    REG12,REG15         LOAD BASE ADDRESS REGISTER
         CLC   0(2,REG1),=X'0130'  OPEN TYPE EXIT
         BNE   *+8                 NO. THEN TAKE ABEND
         MVI   3(REG1),X'04'       TURN ON REQUEST TO IGNORE
         BR    REG14               RETURN TO SYSTEM
         POP   USING               RESTORE OLD ADDRESSABILITY
         EJECT
***********************************************************************
*        ERROR ROUTINES
***********************************************************************
         SPACE 2
*
*        ODD KEYS NOT YET CODED
*
TESTREQ  DS    0H
PA1KEY   DS    0H
CLEARKEY DS    0H
PA3KEY   DS    0H
         BAL   REG1,TPUTERR          KEY IS NOT SUPPORTED
         DC    CL20'KEY NOT SUPPORTED'
*
*
GENERAL  DS    0H                    GENERAL ERROR MESSAGE
CHERROR1 DS    0H                    NO FIRST OPERAND FOR CHANGE
CHERROR2 DS    0H                    NO SECND OPERAND FOR CHANGE
LCERROR1 DS    0H                    NO FIRST OPERAND FOR CHANGE
INVLDCMD BAL   REG1,TPUTERR
         DC    CL20'??????'
PFKNOTON BAL   REG1,TPUTERR           PFK HAS NOT BEEN DEFINED
         DC    CL20'PFK NOT DEFINED'
TGETATTN BAL   REG1,TPUTERR           TELL OF INTERVENING ATTENTION
         DC    CL20'INTER. ATTENTION'
SETERROR BAL   REG1,TPUTERR           SET COMMAND OPERAND INVALID
         DC    CL20'INVALID PFK OPERAND'
BADNUMBR BAL   REG1,TPUTERR
         DC    CL20'OPERAND(S) INVALID'
ZONERR   BAL   REG1,TPUTERR            ZONE OPERANDS INVALID
         DC    CL20'INVALID ZONE RANGE'
MISSNGOP BAL   REG1,TPUTERR            EXPECTED OPERAND IS MISSING
         DC    CL20'OPERAND MISSING!'
MINEMINE BAL   REG1,TPUTERR          TRYING TO CHANGE TOP OR BOTTOM
         DC    CL20'THAT''S MINE !!!'
SFERROR  BAL   REG1,TPUTERR            SAVE/FILE DSN ALLOCATION FAILED
         DC    CL20'ALLOCATION FAILED'
$DPERR   BAL   REG1,TPUTERR        DUP/MOVE DIRECTION WRONG
         DC    CL20'ONLY ''U'' OR ''D'' !!'
GETERROR BAL   REG1,TPUTERR        BAD RETURN FROM EDITCOPY
         DC    CL20'ALLOCATION FAILED !'
         EJECT
***********************************************************************
*        WRITE THE ERROR MESSAGE AND POSITION CURSOR
***********************************************************************
         SPACE 2
TPUTERR  LA    REG15,ERRMSG2          LOAD ADDRESS OF MSG AREA
         MVC   0(20,REG15),0(REG1)    MOVE MESSAGE TO OUT AREA
         MVI   WORKFLAG,0              RESET THE WORK FLAG
         L     REG1,ERROPNDS       LOAD ADDRESS LAST OPERAND DELIMITED
         LA    REG15,COMMAND       START OF FIELD CONTAINING CURSOR
         SR    REG1,REG15          GET ITS OFFSET
         XAL   REG11,GETBUFF       GET A COMMAND LINE BUFFER ADDRESS
         STCM  REG1,REG3,ECURSOR   UPDATE ERROR CURSOR ADDRESS
         LA    REG3,ERRTPUT        LOAD ADDRESS OF ERROR SCREEN
         LA    REG4,ERRTPUTL       LOAD LENGTH OF IT
         TPUT  (3),(4),FULLSCR,WAIT GO TELL OF THE ERROR
         B     REREAD              AND READ HIS NEXT COMMAND
         EJECT
***********************************************************************
*        CONSTANTS NOT CHANGED BY THE PROGRAM
***********************************************************************
         SPACE 2
DELIM    EQU   C'#'                NEW LINE SYMBOL
ESCAPE   EQU   C'"'                ESCAPE CHARACTER FOR NEW LINE
CASEOFFS DC    A(PFKAENDS-PFKAREA) SHIFT DISTANCE FOR UPPER CASE PFK
CLIINST  CLI   0(REG14),0          EXECUTED CLI INSTRUCTION
MIDPOINT DC    F'560'              OFFSET TO MIDDLE OF SCREEN
SCREENLN DC    F'1600'
SCLENGTH EQU   2200                LENGTH OF A COMPLETE SCREEN
UT501S   LINK  EP=UT501,SF=L
CMNDCURS DC    X'5B60'             ADDRESS OF START OF COMMAND AREA
DSNERROR DC    C'** NOT AVAILABLE ** PLEASE RE-ENTER.'
CLOSEDWN DS   0C                   TERMINATION MESSAGE
         DC   X'40115D7E11C1501140403C4040401D60'
         DC   CL20'SUPREDIT TERMINATED'
         DC    X'11C14F1DC8'
CLOSELEN EQU   *-CLOSEDWN          LENGTH OF CLOSE DOWN MESSAGE
FUNCTION DC    C'A'                FUNCTIUON CODE FOR UT501
FUNCTIO2 DC    C'D'                FUNCTION CODE FOR UT501
EOFMARK  DC    C':END OF DATA'
TOFMARK  DC    C':TOP OF FILE'
DCBMASK  DCB   DDNAME=SYSUT1,DSORG=PS,MACRF=(GM,PM),                   X
               EXLST=EXLST
LISTMASK OPEN  (0,INPUT),MF=L      GENERATE OPEN PARM LIST
HEXTABLE DC    C'0123456789ABCDEF' CONVERT UNPACKED DATA TO GOOD HEX
HEXTABL2 DC    256AL1(*-HEXTABL2)  AND HEX BACK TO GOOD DATA
         ORG   HEXTABL2+C'A'
         DC    X'FAFBFCFDFEFF'     MAKE HEX LETTERS LOOK GOOD
         ORG
JCLMASK  DC    H'80'
         DC    C'//SYSUT1 DD DISP=SHR,DSN='
JCLMLEN  EQU   *-JCLMASK           LENGTH OF JCL CARD INITIAL CONSTANT
         EJECT
***********************************************************************
*        SCREEN FORMAT AREAS
***********************************************************************
         SPACE 2
ERRTPUT  DS    0F
         DC    X'40115D7F1140401DE8'
ERRMSG2  DC    CL20' '             ERROR MESSAGE AREA
         DC    X'11'
ECURSOR  DC    X'0000'
         DC    X'13'
ERRTPUTL EQU   *-ERRTPUT           LENGTH OF ERROR MESSAGE WRITE
INCURS   DC    X'40115D7F11'
CURSLOC  DC    X'0000'
         DC    X'13'
INCURLEN EQU   *-INCURS            LENGTH OF INSERT CURSOR WRITE
NAMEQERY DC    X'40115D7F1140403C4040401140401D60'
         DC    C'DATA SET NAME =====>'
         DC    X'1DC8'
         DC    X'13'               INSERT CURSOR
DSNERR1  DC    CL54' '
         DC    X'1D60'             END OF DSN FIELD
         DC    X'11C260'
         DC    X'1D60'
         DC    C'OR'
         DC    X'11C2E31DC9'
         DC     C'EXIT'
         DC    X'11C2E81D60'
         DC    C'TO TERMINATE SUPREDIT'
         DC    X'11C6D91D60'
         DC    CL70' THIS VERSION ONLY WORKS UNDER ''MOPE'''
NAMEQLEN EQU   *-NAMEQERY
         LTORG
         EJECT
***********************************************************************
*        WORK AREAS
***********************************************************************
         SPACE 2
AIDTABLE DS    0F                   TABLE OF AID CODES
         DC    X'7D',AL1(AIDRTN),AL3(ANALCMND)     ENTER
AIDRTN   EQU   X'80'   EQUATE FOR SECOND BYTE OF ENTRY - RTN EXISTS
PFKENTY  EQU   X'40'   EQUATE FOR SECOND BYTE OF ENTRY - PFK EXISTS
AIDTLEN  EQU   *-AIDTABLE                          LENGTH OF AN ENTRY
PFKAREA  DC    X'F1',AL1(PFKENTY),AL3(1)           PFK1
         DC    X'F2',AL1(PFKENTY),AL3(2)           PFK2
         DC    X'F3',AL1(PFKENTY),AL3(3)           PFK3
         DC    X'F4',AL1(PFKENTY),AL3(4)           PFK4
         DC    X'F5',AL1(PFKENTY),AL3(5)           PFK5
         DC    X'F6',AL1(PFKENTY),AL3(6)           PFK6
         DC    X'F7',AL1(PFKENTY),AL3(7)           PFK7
         DC    X'F8',AL1(PFKENTY),AL3(8)           PFK8
         DC    X'F9',AL1(PFKENTY),AL3(9)           PFK9
         DC    X'7A',AL1(PFKENTY),AL3(10)          PFK10
         DC    X'7B',AL1(PFKENTY),AL3(11)          PFK11
         DC    X'7C',AL1(PFKENTY),AL3(12)          PFK12
PFKAENDS EQU   *                                  END OF BASIC PFK AREA
         DC    X'FF',AL1(PFKENTY),AL3(13)                       PFK13
         DC    X'FF',AL1(PFKENTY),AL3(14)                       PFK14
         DC    X'FF',AL1(PFKENTY),AL3(15)                       PFK15
         DC    X'FF',AL1(PFKENTY),AL3(16)                       PFK16
         DC    X'FF',AL1(PFKENTY),AL3(17)                       PFK17
         DC    X'FF',AL1(PFKENTY),AL3(18)                       PFK18
         DC    X'FF',AL1(PFKENTY),AL3(19)                       PFK19
         DC    X'FF',AL1(PFKENTY),AL3(20)                       PFK20
         DC    X'FF',AL1(PFKENTY),AL3(21)                       PFK21
         DC    X'FF',AL1(PFKENTY),AL3(22)                       PFK22
         DC    X'FF',AL1(PFKENTY),AL3(23)                       PFK23
         DC    X'FF',AL1(PFKENTY),AL3(24)                 PFK24
         DC    X'F0',AL1(AIDRTN),AL3(TESTREQ)      TEST REQUEST
         DC    X'6D',AL1(AIDRTN),AL3(CLEARKEY)     SCREEN CLEAR
         DC    X'6C',AL1(AIDRTN),AL3(PA1KEY)       PROGRAM ACCESS 1
         DC    X'6E',AL1(AIDRTN),AL3(PA2KEY)       PROGRAM ACCESS 2
         DC    X'6B',AL1(AIDRTN),AL3(PA3KEY)       PROGRAM ACCESS 3
AIDTENDS EQU   *                                   END OF TABLE
         EJECT
***********************************************************************
*        DATA AREAS NOT ADDRESSABLE FROM THE MAIN CSECT
***********************************************************************
         SPACE 2
DATA     CSECT
CMDTABLE DS     0F
         DC    AL1(3),CL3'GET',AL3(GET)
         DC    AL1(2),CL2'LE',AL3(LEFT)
         DC    AL1(2),CL2'RI',AL3(RIGHT)
         DC    AL1(4),CL4'NEXT',AL3(NEXT)
         DC    AL1(1),CL1'N',AL3(NEXT)
         DC    AL1(2),CL2'UP',AL3(UP)
         DC    AL1(1),CL1'U',AL3(UP)
         DC    AL1(3),CL3'TOP',AL3(TOPOFIT)
         DC    AL1(1),CL1'T',AL3(TOPOFIT)
         DC    AL1(3),CL3'BOT',AL3(BOT)
         DC    AL1(1),CL1'B',AL3(BOT)
         DC    AL1(1),CL1'C',AL3(CHANGE)
         DC    AL1(6),CL6'DELETE',AL3(DELETE)
         DC    AL1(3),CL3'DEL',AL3(DELETE)
         DC    AL1(5),CL5'INPUT',AL3(INPUT)
         DC    AL1(1),CL1'I',AL3(INPUT)
         DC    AL1(4),CL4'FILE',AL3(FILE)
         DC    AL1(4),CL4'QUIT',AL3(QUIT)
         DC    AL1(4),CL4'EXIT',AL3(QUIT)
         DC    AL1(6),CL6'LOCATE',AL3(LOCATE)
         DC    AL1(1),CL1'L',AL3(LOCATE)
         DC    AL1(4),CL4'ZONE',AL3(ZONE)
         DC    AL1(1),CL1'Z',AL3(ZONE)
         DC    AL1(5),CL5'RENUM',AL3(RENUM)
         DC    AL1(4),CL4'SAVE',AL3(SAVE)
         DC    AL1(6),CL6'SUBMIT',AL3(SUBMIT)
         DC    AL1(1),CL1'=',AL3(SAMAGAIN)
         DC    AL1(8),CL8'$DUPMOVE',AL3($DUPMOVE)
         DC    AL1(3),CL3'$DM',AL3($DUPMOVE)
         DC    AL1(5),CL5'$MOVE',AL3($MOVE)
         DC    AL1(2),CL2'$M',AL3($MOVE)
         DC    AL1(4),CL4'$DUP',AL3($DUP)
         DC    AL1(2),CL2'$D',AL3($DUP)
         DC    AL1(1),CL1'/',AL3(MINILOC)
         DC    AL1(3),CL3'SET',AL3(SET)
         DC    AL1(3),CL3'PFK',AL3(PFK)
         DC     X'FF'               END OF TABLE INDICATOR
SCTABLE  DC    256AL1(*-SCTABLE)
NUMTABLE DC    256X'FF'
         ORG   NUMTABLE+C'0'
         DC    10X'00'
         ORG
BUFFTABL DS    0F                  CONVERTS OFFSETS TO VALID IO CODES
         DC    X'40C1C2C3C4C5C6C7C8C9'
         DC    X'4A4B4C4D4E4F50D1D2D3D4D5D6D7D8D9'
         DC    X'5A5B5C5D5E5F6061E2E3E4E5E6E7E8E9'
         DC    X'6A6B6C6D6E6FF0F1F2F3F4F5F6F7F8F9'
         DC    X'7A7B7C7D7E7F'
         EJECT
***********************************************************************
*        DSECTS
***********************************************************************
         SPACE 2
STKENTRY DSECT
STKCHAIN DS    F                   CHAIN FIELD FOR CONSOLE STACK
STKLEN   DS    H                   APPARENT LENGTH OF DATA ENTERED
STKAID   DS    CL6                 CONTROL INFORMATION
STKDATA  DS    CL120               SINGLE LINE OF INPUT
STKLENTH EQU   *-STKENTRY          LENGTH OF A STACK ENTRY
STACKLEN EQU   60*STKLENTH         LENGTH OF GATMAINED AREA
         SPACE 2
         USERPARM
         SPACE 2
         EDITWK2
         PRINT NOGEN
         DCBD  DSORG=QS,DEVD=DA    DCB DSECT
         PRINT GEN
         END
