FAIR     TITLE 'O.S. FILE ACCESS INTERFACE ROUTINES'
***********************************************************************
*RECORD OF CHANGES MADE TO THIS MODULE
***********************************************************************
*
*08/27/75  MASTMOD RETURNS A SPECIAL CODE IN REG 0 IF A PROD2 MODULE
*          IS RETRIEVED (THIS IS NEEDED BY ROSCOE ROSDATA PROGRAM)
***********************************************************************
         SPACE 3
*MACRO FOR USE AT START OF EACH FAIR ROUTINE.  IT SAVES REGISTERS,
*ESTABLISHES COVER REGISTER, AND SETS UP SAVE AREA LINKAGES
         MACRO
         SETUP &NAME
         ENTRY &NAME
&NAME    STM   14,12,12(13)    SAVE REGISTERS
         USING &NAME,15        SET TEMP COVER (FOR NEXT LINE)
         L     RBAS1,=A(COVER) ESTABLISH PERMANENT COVER
         DROP  15
         BAL   REX,SAVE        SET UP SAVE AREA LINKAGE + 2ND COVER REG
         MEND
         EJECT
FAIR     CSECT
         SPACE 2
         PRINT NOGEN,NODATA
         SPACE 2
*REGISTER DEFINITIONS
         SPACE 1
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
REX      EQU   10
RBAS1    EQU   11
RBAS2    EQU   12
RSAV     EQU   13
R14      EQU   14
R15      EQU   15
         SPACE 2
*FOLLOWING REGISTER DEFINITIONS ARE FOR USE WITH ROUTINES TAKEN FROM
*REGULAR LIBRARIAN PROGRAM.  DO NOT USE FOR OTHER PURPOSES
***** REGISTERS 2, 3, 11, AND 12 MUST NOT BE REDEFINED IN ORDER TO
***** AVOID ANY CONFLICTS WITH THE USE OF THE DEFINITIONS ABOVE
         SPACE 1
RWK      EQU   4
RW1      EQU   5
RW2      EQU   6
RW3      EQU   7
RLNK     EQU   8
RGO      EQU   9
RMAST    EQU   10
*SKIP REDEFINING REGS 11 AND 12 (THEY ARE COVER REGISTERS)
RP2      EQU   13
RT1      EQU   14
RT2      EQU   15
         EJECT
*LIST OF ENTRY POINTS FOR THOSE USERS WHO WISH TO LINK EDIT THE FAIR
*ROUTINES AS A SEPARATE LOAD MODULE RATHER THAN WITH THE DRIVER.
         SPACE 1
         ENTRY NTRYLIST
NTRYLIST DC    A(MASTOPN)
         DC    A(MASTMOD)
         DC    A(MASTRCD)
         DC    A(MASTHST)
         DC    A(MASTCLS)
         SPACE 2
         DC    C'VERSION 1.3'
         SPACE 2
COVER    DS    0D              1ST COVER REGISTER IS SET TO THIS POINT
         SPACE 1
         USING COVER,RBAS1
         USING COVER+4096,RBAS2
         SPACE 3
***********************************************************************
*SOME NOTES ON REGISTER USAGE
*RBASE IS USED AS A BASE REGISTER AND MAY NEVER BE DESTROYED
*REGISTERS R2, R3, AND R4 GENERALLY HOLD USER PARAMETER ADDRESSES AND
*SHOULD NOT BE DESTROYED.  PRESERVATION OF R3 IS ESPECIALLY IMPORTANT
*SINCE THE CODING AT LABEL 'HELP' DEPENDS ON THIS BEING SET TO A
*RETURN CODE ADDRESS.  FOR SOME ROUTINES, R5 AND R6 MAY ALSO HOLD
*PARAMETER ADDRESSES AND SHOULD BE PRESERVED AS NECESSARY.
***********************************************************************
         SPACE 5
*SUBROUTINE MASTOPN
*OPEN MASTER FILE.  ARGUMENTS ARE -
*        16 BYTE AREA FOR VOLSER AND DATE/TIME IF TAPE MASTERS
*        RETURN CODE (1 EBCIDIC BYTE)
*        16 BYTE AREA FOR MASTER AND CYCLE DD NAMES
*        NUMBER OF BUFFERS (1 EBCIDIC BYTE)
*        LIST OF BUFFER ADDRESSES IF USER WISHES TO PROVIDE BUFFERS
         SPACE 1
         SETUP MASTOPN         ESTABLISH COVER, SET UP SAVE AREAS
         SPACE 1
         BAL   REX,PARM        PICK UP USER PARAMETERS
*        CALLING ARGUMENTS ARE NOW IN REGISTERS STARTING WITH R2
         SPACE 1
         TM    GFLG,BMOP       IF A MASTER IS ALREADY OPEN, TAKE
         BO    OPN12              ERROR PATH
         NI    GFLG,255-BMDM   SET DISK MASTER FLAG OFF
         MVI   MFLG,X'00'      SET MISC FLAG BITS = 0
         LTR   R4,R4           JUMP IF USER OMITTED DD NAMES
         BZ    OPN8
         CLI   8(R4),C' '      JUMP IF 2ND DDNAME IS NOT BLANKS
         BNE   OPN4
         SPACE 1
*DISK MASTER
         SPACE 1
         MVC   DMAST+40(8),0(R4) PUT DDNAME INTO DCB
         RDJFCB DMAST          READ DISK MASTER JFCB
OPN2     MVC   DSN(44),JF      SAVE DSNAME FOR ENQ/DEQ OPERATIONS
         EXTRACT WORK,FIELDS=TIOT  GO THROUGH THE TIOT AND OBTAIN THE
         L     R14,WORK              UCB ADDRESS FOR THE MASTER FILE.
         LA    R14,24(R14)           THIS IS NEEDED FOR THE 'RESERVE'
OPN2B    CLC   DMAST+40(8),4(R14)    OF THE MASTER FILE.
         BE    OPN2D
         XR    R15,R15
         IC    R15,0(R14)
         AR    R14,R15
         CLC   0(4,R14),=A(0)
         BE    OPN10           JUMP IF DD STATEMENT FOR MASTER OMITTED
         B     OPN2B
OPN2D    LA    R8,16(R14)      SET R8 TO POINT TO WORD WITH UCB ADDRESS
         ENQ   (QNAME,DSN,S,44,SYSTEM)  ,  ENQ MASTER FILE
         SPACE 1
         OPEN  DMAST           OPEN DISK MASTER
         TM    DMAST+48,X'10'  JUMP IF DD STATEMENT OMITTED
         BZ    OPN10
         MVC   BLSIZ,DMAST+62  GET MASTER FILE BLOCK SIZE
         OI    GFLG,BMDM       SET FLAG TO INDICATE DISK MASTER
         BAL   REX,OPN20       ALLOCATE MASTER FILE BUFFERS
         L     R0,ABUF         READ 1ST BLOCK OF DISK MASTER
         LA    R1,=AL3(0)
         BAL   REX,READ
         BAL   REX,CHK         CHECK THE READ
         L     R1,ABUF         SET R1 TO START OF 1ST BLOCK
         CLC   0(11,R1),=C'ADR LIBRF01'
         BNE   OPN11           JUMP IF IMPROPER FORMAT ON DISK MASTER
         OI    USEBL2,QUSEBL2  MISC INITIALIZATION
         XC    SDMC,SDMC
         MVC   SDNB,=AL3(3)
         MVC   SDBF,ABUF
         SPACE 1
*BOTH TAPE AND DISK MASTERS COME HERE
         SPACE 1
OPN3     OI    GFLG,BMOP       SET OPEN FLAG
         NI    GFLG,255-BMOM   MISC INITIALIZATION
         MVI   0(R3),C'0'      SET RETURN CODE OF '0'
         LH    R1,BLSIZ        PUT BLOCK SIZE IN R1 FOR A/F AND M/C
         B     RET             TO RETURN PATH
         SPACE 2
*TAPE MASTER
         SPACE 1
OPN4     MVC   CYCLE+40(8),0(R4)  PUT DD NAMES INTO DCB BLOCKS
         MVC   TMAST+40(8),8(R4)
         MVI   JF,X'FF'        SET FLAG TO TEST FOR MISSING JFCB
         RDJFCB TMAST          READ THE INPUT TAPE JFCB
         CLI   JF,X'FF'        JUMP IF NO JFCB READ IN (MISSING DD)
         BE    OPN10
         CLI   0(R4),C' '      JUMP IF USER OMITTED THE DD NAME OF THE
         BE    OPN6               CYCLE FILE (MEANS NO CYCLE CONTROL)
         OPEN  CYCLE           OPEN CYCLE CONTROL FILE
         TM    CYCLE+48,X'10'  JUMP IF CYCLE DD STATEMENT OMITTED
         BZ    OPN14
         READ  CYCDECB,SF,CYCLE,CYCA,12 READ 1ST 12 BYTES OF THE
         CHECK CYCDECB                     CYCLE CONTROL FILE
         CLOSE CYCLE           CLOSE CYCLE FILE
         CLI   CYCA,C'F'       JUMP IF 1ST BYTE OF CYCLE FILE INVALID
         BNE   OPN11
         MVC   JF+118(6),CYCA+3 FILL IN VOLSER OF INPUT TAPE
         MVI   JF+117,X'01'
         MVI   JF,C' '         SET DSNAME OF 'DS' FOLLOWED BY
         MVC   JF+1(43),JF        THE VOLUME SERIAL NUMBER
         MVC   JF(2),=C'DS'
         MVC   JF+2(6),JF+118
OPN6     OPEN  TMAST,TYPE=J    OPEN TAPE MASTER
         TM    TMAST+48,X'10'  JUMP IF NO DD CARD (THIS TEST REDUNDANT
         BZ    OPN10             FOR CYCLE CONTROL - NEEDED FOR NO CYC)
         MVC   BLSIZ,TMAST+62  GET MASTER FILE BLOCK SIZE
         BAL   REX,OPN20       ALLOCATE MASTER FILE BUFFERS
         MVC   LOC,EBT         FORCE READ OF NEW BLOCK IN ROUTINE GET
         BAL   REX,GET         GET TAPE CONTROL RECORD
         CLI   0(R4),C' '      IF NO CYCLE FILE, SKIP CHECK FOR
         BE    OPN7               CORRECT TAPE
         CLC   12(2,R8),=CL2'$$'  UNCYCLED TAPE CHECK
         BE    OPN7
         CLC   JF+118(6),12(R8) JUMP IF INCORRECT TAPE MOUNTED
         BNE   OPN11
OPN7     MVC   0(6,R2),12(R8)  PUT VOLSER AND DATE/TIME IN USER AREA
         MVC   6(10,R2),2(R8)
         XC    TMLR,TMLR       INITIALIZE FIELD TMLR
         B     OPN3
         SPACE 2
*USER DID NOT SPECIFY ANY DD NAMES.  DETERMINE IF TAPE OR DISK MASTERS
*ON THE BASIS OF THE DD STATEMENTS PRESENT
         SPACE 1
OPN8     MVC   DMAST+40(8),=CL8'MASTER' SET DEFAULT DDNAME FOR DISK
         MVI   JF,X'FF'        SET FLAG TO TEST IF JFCB WAS READ
         RDJFCB DMAST          TRY AND READ DISK MASTER JFCB
         CLI   JF,X'FF'        JUMP IF DISK MASTER DD PRESENT
         BNE   OPN2
*        NO DD FOR THE DISK MASTER.  ASSUME A TAPE MASTER
         LA    R4,OPN9         SET R4 TO DEFAULT DDNAMES FOR TAPE
         B     OPN4            PROCESS AS TAPE MASTER
OPN9     DC    CL16'CYCLE   MASTIN'  DEFAULT DDNAMES FOR TAPE MASTERS
         SPACE 3
*DD STATEMENT OMITTED OR ELSE INCORRECT PARAMETER SPECIFIED
OPN10    MVI   0(R3),C'1'      SET RETURN CODE
         B     RET
         SPACE 1
*MASTER FILE (OR CYCLE FILE) HAS INCORRECT FORMAT
*CONTROL ALSO COMES HERE IF WRONG TAPE MASTER IS MOUNTED
OPN11    MVI   0(R3),C'2'      SET RETURN CODE
         BAL   REX,RBF         RETURN BUFFERS
         B     RET
         SPACE 1
*MASTER FILE IS ALREADY OPEN
OPN12    MVI   0(R3),C'3'      SET RETURN CODE
         B     RET
         SPACE 1
*INSUFFICIENT CORE AVAILABLE
OPN13    MVI   0(R3),C'4'      SET RETURN CODE
         B     RET
         SPACE
*DD CARD FOR CYCLE FILE OMITTED.  IF USER DID NOT CHANGE DDNAME OF
*CYCLE FILE, ASSUME HE WISHES TO RUN WITHOUT CYCLE CONTROL.
OPN14    CLC   OPN9(8),0(R4)   JUMP IF DDNAME FOR CYCLE FILE IS DEFAULT
         BE    OPN6              VALUE
         B     OPN10           NOT EQUAL DEFAULT - TREAT AS ERROR
         SPACE 3
*SUBROUTINE OPN20.  ALLOCATE BUFFERS FOR MASTER FILE.
         SPACE 1
OPN20    MVI   BUFNO,C'1'      ASSUME SINGLE BUFFERING
         LTR   R5,R5           IF USER SPECIFIED THE NUMBER OF BUFFERS,
         BZ    OPN21              PICK UP THE NUMBER
         MVC   BUFNO,0(R5)
OPN21    LTR   R6,R6           JUMP IF THE USER SPECIFIED THE ADDRESSES
         BNZ   OPN24              OF THE BUFFERS TO BE USED
         LH    R9,BLSIZ        PICK UP THE BLOCK SIZE
         CLI   BUFNO,C'2'      DOUBLE IF 2 BUFFERS SPECIFIED
         BNE   *+6
         AR    R9,R9
         STH   R9,FREEML       SAVE LENGTH FOR FREEMAIN
         GETMAIN EC,LV=(9),A=FREEMA  GET CORE FOR BUFFERS
         LTR   R15,R15         JUMP IF INSUFFICIENT CORE
         BNZ   OPN13
         L     R1,FREEMA       STORE ADDRESS OF 1ST BUFFER
         ST    R1,CBUF
         CLI   BUFNO,C'2'      IF 2 BUFFERS WERE SPECIFIED, COMPUTE
         BNE   OPN23              ADDRESS OF 2ND BUFFER
         AH    R1,BLSIZ
OPN23    ST    R1,ABUF         SET ADDRESS OF ALT BUFFER AREA
         BR    REX             EXIT
         SPACE 1
*USER SPECIFIED THE BUFFER ADDRESSES
         SPACE 1
OPN24    MVC   CBUF+1(3),1(R6) STORE ADDRESS OF 1ST BUFFER
         CLI   BUFNO,C'2'      IF 2 BUFFERS SPECIFIED, BUMP PARAMETER
         BNE   OPN25              ADDRESS TO POINT TO NEXT ADDRESS
         LA    R6,4(R6)
OPN25    MVC   ABUF+1(3),1(R6) SET ADDRESS OF ALT BUFFER AREA
         BR    REX             EXIT
         EJECT
*SUBROUTINE MASTMOD
*LOCATE A MODULE ON THE MASTER FILE.  ARGUMENTS ARE -
*        8 BYTE MODULE NAME FIELD (IF BLANK, GET NEXT MODULE ON FILE)
*        RETURN CODE (1 EBCIDIC BYTE)
*        100 BYTE AREA CONTAINING VARIOUS MODULE PARAMETERS
*        FLAG FOR -INC PROCESSING
*        400 BYTE AREA FOR COMPLETE MODULE PARAMETERS
         SPACE 1
         SETUP MASTMOD         ESTABLISH COVER, SET UP SAVE AREAS
         SPACE 1
         BAL   REX,PARM        PICK UP USER PARAMETERS
*        CALLING ARGUMENTS ARE NOW IN REGISTERS STARTING WITH R2
         SPACE 1
         TM    GFLG,BMOP       JUMP IF MASTER FILE IS NOT OPEN
         BZ    MOD8
         MVC   INCPNT,INCA1    INIT POINTER FOR -INC SAVE AREA
         NI    GFLG,255-BMOM   RESET 'MODULE OPEN' FLAG
         TM    GFLG,BMDM       JUMP IF TAPE MASTER
         BZ    MOD20
         SPACE 1
*DISK MASTER
         SPACE 1
         BAL   REX,CDQ         DEQUE PREVIOUS MODULE (IF ANY ENQUED)
         CLI   0(R2),C' '      JUMP IF USER DID NOT SPECIFY THE NAME
         BE    MOD10              OF A SPECIFIC MODULE
         MVC   NAMENQ,0(R2)    ENQUE THIS MODULE (MUST BE DONE PRIOR
         LA    R1,NAMENQ         TO THE INDEX SEARCH)
         BAL   REX,EQM
         LR    R1,R2           LOOK UP MODULE NAME IN INDEX
         BAL   REX,DFIND
         CLI   NNT,X'00'       JUMP IF MODULE NAME NOT FOUND IN INDEX
         BE    MOD7
MOD2     MVI   MFLG,X'00'      SET MISC FLAG BITS OFF
         MVC   NBLK+1(3),NNT2  SET BLOCK NO. OF 1ST BLOCK OF MODULE
         MVC   LOC,EBT         FORCE READ OF NEW BLOCK IN ROUTINE GET
         SPACE 1
*NOW READ IN THE MODULE CONTROL RECORDS AND STORE THE MODULE
*PARAMETER INFORMATION IN THE USER AREAS IF THE USER SO SPECIFIED
         SPACE 1
MOD3     BAL   REX,SMP         READ 1ST CONTROL RCD, SET MISC PARAMS
         MVC   MSTAT,33(R8)    SAVE BYTE CONTAINING PROD2 STATUS BIT
         TM    GFLG,BMDM       IF DISK MASTER, MOVE CORRECT CARD COUNT
         BZ    *+10              FROM INDEX ENTRY TO 1ST CONTROL RECORD
         MVC   30(3,R8),NNT6
         LA    R9,5            SET LOOP CONTROL (NO. OF CONTROL RCDS)
         LTR   R4,R4           IF USER PROVIDED A 3RD ARGUMENT, MOVE
         BZ    MOD4               VARIOUS PARAMETERS FROM THE 1ST
         MVC   0(23,R4),10(R8)    CONTROL RECORD INTO HIS AREA
         MVC   23(23,R4),41(R8)
MOD4     LTR   R6,R6           IF THE USER PROVIDED A 5TH PARAMETER
         BZ    MOD4B              (AREA FOR ALL PARAMETERS), MOVE THE
         MVC   0(72,R6),2(R8)     INFORMATION FROM THIS CONTROL RCD
         LA    R6,72(R6)          INTO HIS AREA
MOD4B    BCT   R9,*+8          TEST IF ALL CONTROL RECORDS PROCESSED
         B     MOD5            YES
         BAL   REX,GET         GET NEXT CONTROL RECORD
         B     MOD4
         SPACE 1
MOD5     LTR   R4,R4           JUMP IF USER DID NOT PROVIDE A 3RD
         BZ    MOD6               ARGUMENT (100 BYTE AREA FOR PARAMS)
         SPACE 1
*FINISH THE SETUP OF THE USER'S 100 BYTE AREA FOR MODULE PARAMETERS
         SPACE 1
         MVC   46(30,R4),44(R8) MOVE MODULE DESCRIPTION
         SR    R1,R1           MOVE SEQUENCE NUMBER PARAMETERS
         IC    R1,SEQ
         LA    R1,1(R1)
         STC   R1,76(R4)
         IC    R1,SEQ+1
         LA    R1,1(R1)
         STC   R1,77(R4)
         MVC   78(4,R4),SEQ+2
         MVC   82(4,R4),40(R8) MOVE NUMBER OF ACCESSES AND UPDATES
         TM    GFLG,BMDM       JUMP IF TAPE MASTER
         BZ    MOD6
         MVC   82(2,R4),NNT3   MOVE NUMBER OF ACCESSES
         MVC   84(2,R4),NNT7   MOVE NUMBER OF UPDATES
         MVC   86(1,R4),NNT4   MOVE NUMBER OF EXTENTS
         MVC   87(1,R4),NNT5   MOVE NUMBER OF BLOCKS
         MVC   20(3,R4),NNT6   MOVE NUMBER OF CARDS
         LH    R15,NNT8        PICK UP DATE OF LAST ACCESS
         N     R15,=X'0000FFFF'   CLEAR ANY PROPIGATED SIGN BITS.
         LTR   R15,R15         JUMP IF DATE = 0
         BZ    MOD6
         BAL   REX,DATE1       CONVERT TO MM/DD/YY (R1 SET TO RESULT)
         MVC   88(2,R4),0(R1)  MOVE MMDDYY TO USER'S AREA
         MVC   90(2,R4),3(R1)
         MVC   92(2,R4),6(R1)
         SPACE 1
MOD6     MVI   INCFL,C'0'      IF USER PROVIDED AN ARGUMENT FOR -INC
         LTR   R5,R5              PROCESSING, SAVE IT FOR MASTRCD
         BZ    *+10               (USE '0' IF NO ARGUEMENT PROVIDED)
         MVC   INCFL,0(R5)
         SPACE 1
         OI    GFLG,BMOM       SET FLAG TO INDICATE MODULE IS OPEN
         SR    R0,R0           IF THIS IS A PROD2 MODULE, INSERT A
         TM    MSTAT,X'10'       SPECIAL FLAG INTO R0 FOR USE BY THE
         BZ    *+8               ROSDATA PROGRAM OF ROSCOE
         LH    R0,PRD2CON
         MVI   0(R3),C'0'      SET RETURN CODE
         B     RET             TO RETURN PATH
         SPACE 2
*COULD NOT FIND A SPECIFIC MODULE, OR NO MODULES LEFT IF SEQUENTIAL
         SPACE 1
MOD7     MVI   0(R3),C'1'      SET RETURN CODE
         B     RET             TO RETURN PATH
         SPACE 1
*MASTER FILE IS NOT OPEN
         SPACE 1
MOD8     MVI   0(R3),C'2'      SET RETURN CODE
         B     RET             TO RETURN PATH
         SPACE 2
*DISK MASTER.  USER DID NOT SPECIFY MODULE NAME
         SPACE 1
MOD10    LH    R8,SDMC         GET COUNT OF ENTRIES LEFT IN CURRENT
         SH    R8,=H'1'           INDEX BLOCK AND SUBTRACT 1
         BNM   MOD12           FALL THRU IF NO ENTRIES LEFT
MOD11    CLC   SDNB,=AL3(0)    JUMP IF NO INDEX BLOCKS LEFT
         BE    MOD15
         MVC   SDCB,SDNB       SET BLK NO. OF NEXT INDEX BLOCK
MOD12    L     R0,SDBF         READ INDEX BLOCK INTO CORE
         LA    R1,SDCB
         BAL   REX,READ
         BAL   REX,CHK         CHECK READ
         LTR   R8,R8           FALL THRU IF THIS WAS A NEW INDEX BLOCK
         BNM   MOD13
         L     R1,SDBF         SET R1 TO START OF THE INDEX BLOCK
         MVC   SDNB,9(R1)      SAVE BLK NO. OF NEXT INDEX BLOCK
         LH    R8,12(R1)       PICK UP COUNT OF ENTRIES IN BLOCK
         SH    R8,=H'1'        SUBT 1 FOR ENTRY WE'RE ABOUT TO PROCESS
         BM    MOD11           JUMP IF THIS BLOCK HAS NO ENTRIES
         LA    R1,16(R1)       BUMP R1 TO 1ST ENTRY IN THE BLOCK AND
         ST    R1,SDBP            STORE IN BLOCK POINTER
MOD13    STH   R8,SDMC         STORE ENTRY COUNT (REDUCED BY 1)
         L     R8,SDBP         GET ADDRESS OF NEXT ENTRY TO PROCESS
         MVC   NNT,0(R8)       MOVE ENTRY TO WORK AREA
         MVC   0(8,R2),NNT1    PUT MODULE NAME IN USER'S AREA
         LA    R8,22(R8)       BUMP POINTER FOR NEXT TIME THROUGH
         ST    R8,SDBP
         MVC   NAMENQ,NNT1     ENQUE MODULE NAME IN CASE DISP=SHR WAS
         LA    R1,NAMENQ         SPECIFIED (THIS IS NOT A COMPLETE
         BAL   REX,EQM            SUBSTITUTE FOR DISP=OLD)
         B     MOD2            TO COMMON PATH
         SPACE 1
*WE'VE REACHED THE END OF THE INDEX
MOD15    NI    GFLG,255-BMOP   RESET 'MASTER OPEN' FLAG
         B     MOD7
         SPACE 2
*TAPE MASTER
         SPACE 1
MOD20    CLI   0(R2),C' '      JUMP IF USER DID NOT SPECIFY A SPECIFIC
         BE    MOD23              MODULE BY NAME
         SPACE 1
*USER WANTS A SPECIFIC MODULE BY NAME FROM A TAPE MASTER
         SPACE 1
         CLC   TMLR,0(R2)      FALL THRU IF MODULE SPECIFIED IS PRIOR
         BL    MOD21              TO LAST MODULE READ
*        START SEARCHING FROM FRONT OF TAPE
         BAL   REX,CHK         CHECK ANY OUTSTANDING READS
         MVI   MFLG,X'00'      SET MISC FLAG BITS OFF
         LA    R0,=A(1)        REPOSITION TAPE AT THE START
         POINT TMAST,(0)
         MVC   LOC,EBT         FORCE READ OF NEW BLOCK IN ROUTINE GET
         BAL   REX,GET         SKIP OVER TAPE CTRL RCD AT FRONT OF TAPE
         SPACE 1
MOD21    BAL   REX,GET         SKIP TO START OF NEXT MODULE
         TM    1(R8),X'08'
         BZ    MOD21
         MVC   TMLR,2(R8)      SAVE NAME OF MODULE
         CLC   2(8,R8),0(R2)   COMPARE MODULE NAME TO NAME WE WANT
*        NOTE-HIGH MODULE NAME OF FF PREVENTS REACHING END-OF-FILE
         BL    MOD21           IF LOW, KEEP ON LOOKING
         BH    MOD7            IF HIGH, MODULE WE WANT IS NOT ON TAPE
*PATH FOR NEXT MODULE IN SEQUENCE COMES IN HERE
MOD22    OI    MFLG,BMRR       SET FLAG TO REREAD CONTROL RECORD
         B     MOD3            TO COMMON PATH
         SPACE 1
*USER WANTS NEXT MODULE IN SEQUENCE ON A TAPE MASTER
         SPACE 1
MOD23    BAL   REX,GET         SKIP TO START OF NEXT MODULE
         TM    1(R8),X'08'
         BZ    MOD23
         MVC   TMLR,2(R8)      SAVE NAME OF MODULE
         CLI   2(R8),X'FF'     JUMP IF END OF TAPE REACHED (LAST MOD
         BE    MOD7               NAME IS DUMMY HI ENTRY OF 'FF')
         MVC   0(8,R2),2(R8)   PUT MODULE NAME IN USER AREA
         B     MOD22           TO COMMON PATH
         EJECT
*SUBROUTINE MASTRCD
*RETRIEVE NEXT CARD IMAGE OF A MODULE.  ARGUMENTS ARE -
*        AREA FOR CARD IMAGE, SEQUENCE NUMBER, AND DATE
*        RETURN CODE (1 EBCIDIC BYTE)
*        -INC FLAG
         SPACE 1
         SETUP MASTRCD         ESTABLISH COVER, SET UP SAVE AREAS
         SPACE 1
         BAL   REX,PARM        PICK UP USER PARAMETERS
*        CALLING ARGUMENTS ARE NOW IN REGISTERS STARTING WITH R2
         SPACE 1
         TM    GFLG,BMOM       JUMP IF MODULE NOT CURRENTLY 'OPEN'
         BZ    RCD4
RCD1     BAL   REX,GET         PUT ADDRESS OF NEXT RECORD IN R8
         TM    1(R8),X'04'     JUMP IF END-OF-MODULE RECORD
         BO    RCD5
         TM    1(R8),X'01'     JUMP IF NOT DATA RECORD (COULD BE CTRL
         BZ    RCD1               RCD FROM 'INCLUDED' MODULE)
         BAL   REX,UNPK        CREATE CARD IMAGE IN USER'S AREA
         BAL   REX,DATE        PUT DATE FIELD (IF ANY) INTO BYTES 91-98
         MVC   90(8,R2),0(R1)     OF THE USER'S AREA
         CLI   INCFL,C'0'      FALL THRU IF USER WANTS -INC EXPANSION
         BE    RCD2
         CLC   0(5,R2),=C'-INC '  JUMP IF -INC CARD
         BE    RCD8
RCD2     LTR   R4,R4           JUMP IF USER FAILED TO PROVIDE AN
         BZ    RCD3               ADDRESS FOR THE -INC FLAG
         MVI   0(R4),C'1'      SET -INC FLAG TO '1' IF CURRENTLY
         CLC   INCPNT,INCA1      EXPANDING -IN TO '0' IF NOT
         BNE   RCD3
RCD2B    MVI   0(R4),C'0'
RCD3     MVI   0(R3),C'0'      SET RETURN CODE
         B     RET             TO RETURN PATH
         SPACE 2
*MODULE IS NOT CURRENTLY 'OPEN'
         SPACE 1
RCD4     MVI   0(R3),C'2'      SET RETURN CODE
         B     RET             TO RETURN PATH
         SPACE 1
*END-OF-MODULE RECORD FOUND
         SPACE 1
RCD5     CLC   INCPNT,INCA1    JUMP IF CURRENTLY EXPANDING -INC CARD
         BNE   RCD6
         NI    GFLG,255-BMOM   RESET 'MODULE OPEN' FLAG
         TM    GFLG,BMDM       JUMP IF TAPE MASTER
         BZ    RCD5B
         LA    R1,NAMENQ       DEQUE THE MODULE NAME
         BAL   REX,DQM
RCD5B    MVI   0(R3),C'1'      SET RETURN CODE
         B     RET             TO RETURN PATH
         SPACE 1
*END OF AN INCLUDED MODULE
         SPACE 1
RCD6     BAL   R7,RCD15        RESET I/O SO NEXT RCD IS ONE AFTER -INC
         B     RCD1            CONTINUE PROCESSING OF ORIGINAL MODULE
         SPACE 2
*THIS IS AN -INC CARD
         SPACE 1
RCD8     TM    GFLG,BMDM       JUMP IF TAPE MASTER
         BZ    RCD2
         CLC   INCPNT,INCA2    JUMP IF ALREADY AT MAX LEVEL OF NESTING
         BE    RCD11
*        EXTRACT NAME OF MODULE TO BE INCLUDED
         LA    R9,5(R2)        SET R9 TO 6TH BYTE OF -INC CARD
         LA    R14,40          SET LOOP CONTROL TO PREVENT RUNAWAY
RCD9     CLI   0(R9),C' '      LOCATE 1ST NON-BLANK AFTER -INC
         BNE   RCD10
         LA    R9,1(R9)
         BCT   R14,RCD9
         B     RCD11           ERROR CONDITION
RCD10    LR    R1,R9             SAVE 1ST CHARACTER ADDR
         LA    R14,8             ALLOW 8 CHARACTER NAME
RCD10L   LA    R9,1(R9)          BUMP TO NEXT POSITION
         CLI   0(R9),C' '
         BE    RCD10M            BRANCH IF LAST CHARACTER
         BCT   R14,RCD10L
         B     RCD11             ERROR IF NAME EXCEEDS 8 CHARACTERS
RCD10M   SR    R9,R1             GET LENGTH OF NAME
         BCTR  R9,0              DECREMENT BY 1
         MVC   INCNAME,=CL8' '     CLEAR INCNAME
         EX    R9,MOVE1          EXEC VARIABLE MOVE
         L     R1,INCPNT         GET POINTER FOR -INC SAVE AREA
         MVC   0(MPL,R1),MP    SAVE CURRENT MODULE PARAMETERS
         LA    R1,MPL(R1)      ADVANCE POINTER AND STORE
         ST    R1,INCPNT
         LA    R1,INCSAV         SET UP SCAN OF INC NAMES
ENQCHK   CLC   0(8,R1),INCNAME
         BNE   ENQADV            BR TO NEXT NAME
         BAL   R7,RCD15A         ERROR EQUAL NAME IN LIST
         B     RCD11             RESET POINTERS, DO NOT DEQ
*                                GIVE ERROR RETURN CODE.
ENQADV   DS    0H
         LA    R1,MPL(R1)        BUMP TO NEXT NAME
         C     R1,INCPNT
         BL    ENQCHK
         LA    R1,INCNAME        NAME NOT PREVIOUSLY ENQUED.
         BAL   REX,EQM
         LA    R1,INCNAME
         MVC   NAMENQ,INCNAME    SET R1 TO MODULE NAME AND ADV NAME
*                                IN LIST
         BAL   REX,DFIND       FIND MODULE ON MASTER
         CLI   NNT,X'00'       JUMP IF MODULE NOT FOUND
         BE    RCD12
         MVI   MFLG,X'00'      SET MISC FLAG BITS OFF
         MVC   NBLK+1(3),NNT2  SET BLOCK NO. OF 1ST BLOCK OF MODULE
         MVC   LOC,EBT         FORCE READ OF NEW BLOCK IN ROUTINE GET
         BAL   REX,SMP         READ 1ST CTRL RCD, SET MISC PARAMETERS
         CLI   INCFL,C'1'      JUMP IF USER DOESN'T WANT -INC CARD
         BE    RCD1              PASSED ON (GO START EXPANSION INSTEAD)
*        -INC CARD IS TO BE PASSED ON TO THE USER
         LTR   R4,R4           JUMP IF USER DID NOT PROVIDE AN ADDRESS
         BZ    RCD3               OF THE -INC FLAG
         LA    R1,INCSAV+MPL   IF THIS IS AN OUTER -INC (I.E. PART
         C     R1,INCPNT         OF THE OPRIGINAL MODULE), SET -INC
         BE    RCD2B             FLAG TO 0
         MVI   0(R4),C'1'      SET -INC FLAG TO 1
         B     RCD3
         SPACE 1
MOVE1    MVC   INCNAME(0),0(R1)  INITIALIZE INCNAME
*ERROR CONDITION FOUND ON -INC
         SPACE 1
RCD11    LTR   R4,R4           JUMP IF USER FAILED TO PROVIDE THE
         BZ    RCD3               ADDRESS OF AN -INC FLAG
         MVI   0(R4),C'2'      SET -INC FLAG PARAMETER TO '2'
         B     RCD3            PASS -INC CARD ON TO USER
         SPACE 1
*COULD NOT FIND THE MODULE NAMED ON AN -INC CARD
         SPACE 1
RCD12    BAL   R7,RCD15        RESET I/O SO NEXT RCD IS ONE AFTER -INC
         B     RCD11
         SPACE 2
*SUBROUTINE RCD15.  RESET THE I/O LOGIC SO NEXT RECORD RETRIEVED IS
*THE ONE THAT FOLLOWS THE LATEST -INC CARD
*THIS ROUTINE ALSO DEQUES THE NAME OF THE INCLUDED MODULE
***** NOTE THAT R7 CONTAINS THE RETURN LINKAGE RATHER THAN REX *****
         SPACE 1
RCD15    LA    R1,NAMENQ       DEQUE THE MODULE NAMED IN LATEST -INC
         BAL   REX,DQM
RCD15A   DS    0H
         L     R1,INCPNT       RESTORE PARAMETERS SO WE RESUME
         SH    R1,=Y(MPL)        PROCESSING THE MODULE THAT CONTAINED
         MVC   MP(MPL),0(R1)     THE LATEST -INC CARD
         ST    R1,INCPNT       STORE UPDATED SAVE AREA POINTER
         MVI   NAMENQ-MP(R1),C' ' CLEAR NAME FIELD IN TABLE ENTRY
*        ABOVE NECESSARY TO AVOID EXTRA DEQUE BY ROUTINE CDQ
         SPACE
*        CBLK NOW HAS NO. OF BLOCK CONTAINING THE -INC CARD AND CBUF
*        HAS ADDRESS OF THE BUFFER INTO WHICH THAT BLOCK HAD BEEN READ
         L     R0,CBUF         REREAD BLOCK WITH -INC CARD INTO SAME
         LA    R1,CBLK+1          BUFFER IT OCCUPIED EARLIER
         BAL   REX,READ
         BAL   REX,CHK         CHECK THE READ
         BR    R7              EXIT
         EJECT
*SUBROUTINE MASTHST
*OBTAIN NEXT HISTORY RECORD OF A MODULE.  ARGUMENTS ARE -
*        ADDRESS OF AREA FOR CARD AND DATE
*        RETURN CODE (1 EBCIDIC BYTE)
         SPACE 1
         SETUP MASTHST         ESTABLISH COVER, SET UP SAVE AREAS
         SPACE 1
         BAL   REX,PARM        PICK UP USER PARAMETERS
*        CALLING ARGUMENTS ARE NOW IN REGISTERS STARTING WITH R2
         SPACE 1
         TM    GFLG,BMOM       JUMP IF A MODULE IS NOT CURRENTLY 'OPEN'
         BZ    HST6
HST2     BAL   REX,GET         GET NEXT MASTER FILE RECORD
         TM    1(R8),X'01'     JUMP IF DATA RECORD
         BO    HST4
         TM    1(R8),X'02'     FALL THRU IF HISTORY RECORD
         BZ    HST2
         SPACE 1
*THIS IS A HISTORY RECORD
         SPACE 1
         BAL   REX,UNPK        CREATE CARD IMAGE IN USER'S AREA
         BAL   REX,DATE        PUT DATE IN USER'S AREA
         MVC   80(8,R2),0(R1)
         MVI   0(R3),C'0'      SET RETURN CODE
         B     RET             TO RETURN PATH
         SPACE 1
*THIS IS A DATA RECORD.  NO HISTORY RECORDS LEFT
HST4     MVI   0(R3),C'1'
         OI    MFLG,BMRR       SET FLAG TO REPROCESS THE RECORD
         B     RET             TO RETURN PATH
         SPACE 1
*NOT CURRENTLY WITHIN A MODULE
HST6     MVI   0(R3),C'2'      SET RETURN CODE
         B     RET             TO RETURN PATH
         EJECT
*SUBROUTINE MASTCLS
*CLOSE THE MASTER FILE.  NO PARAMETERS NEEDED.
         SPACE 1
         SETUP MASTCLS         ESTABLISH COVER, SET UP SAVE AREAS
         SPACE 1
         LA    R3,GW           SET R3 TO WORK AREA IN CASE GO TO 'HELP'
*        R3 NORMALLY POINTS TO RETURN CODE, WHICH MASTCLS DOESN'T HAVE
         BAL   REX,CHK         CHECK ANY OUTSTANDING READS LEFT OVER
         BAL   REX,CDQ         DEQUE ANY MODULES CURRENTLY ENQUED
         BAL   REX,RBF         RETURN BUFFER AREAS TO THE SYSTEM
         LA    R5,DMAST        GET DCB ADDRESS FOR TAPE OR DISK MASTER
         TM    GFLG,BMDM
         BO    *+8
         LA    R5,TMAST
         CLOSE ((R5))          CLOSE THE MASTER FILE
         TM    GFLG,BMDM       IF THIS IS A DISK MASTER, DEQUE IT
         BZ    CLS2
         DEQ   (QNAME,DSN,44,SYSTEM)  DEQUE THE MASTER FILE
CLS2     NI    GFLG,255-BMOP   RESET THE OPEN FLAG
         LA    R3,EBZERO       SET R3 TO POINT TO 0 (FOR PATH 'RET')
         B     RET             TO RETURN PATH
         SPACE 5
         LTORG
         EJECT
*SUBROUTINE SAVE
*THIS ROUTINE SETS UP SAVE AREA LINKAGE AND ALSO SETS 2ND COVER REG
***** THIS ROUTINE MAY NOT DESTROY R1 (PARM FIELD ADDRESS)
***** THIS ROUTINE MUST BE LOCATED WITHIN 4096 BYTES OF LABEL 'COVER'
         SPACE 1
SAVE     DS    0H
         LA    RBAS2,2048(RBAS1)  SET 2ND COVER REGISTER
         LA    RBAS2,2048(RBAS2)
         ST    13,REGSAV+4     SET UP SAVE AREA LINKAGE
         LR    R14,13
         LA    13,REGSAV
         ST    13,8(R14)
         BR    REX             EXIT
         SPACE 5
*SUBROUTINE GET
*LOCATE NEXT RECORD OF A BLOCK, PLACE ITS ADDRESS IN R8
         SPACE 1
GET      DS    0H
         ST    REX,GET16       SAVE LINKAGE REGISTER
         TM    MFLG,BMRR       JUMP IF REREAD FLAG IS ON
         BO    GET10
         L     R8,LOC          GET ADDRESS OF NEXT RECORD IN BLOCK
         C     R8,EBT          JUMP IF REACHED END OF BLOCK
         BNL   GET4
GET2     SR    R1,R1           UPDATE LOCATOR FOR NEXT TIME THROUGH
         IC    R1,0(R8)
         AR    R1,R8
         ST    R1,LOC
         ST    R8,GET15        SAVE RECORD ADDRESS IN CASE OF REREAD
GET3     L     REX,GET16       PICK UP LINKAGE REGISTER
         BR    REX             EXIT
         SPACE 1
*NEW BLOCK OF DATA IS NEEDED
         SPACE 1
GET4     TM    GFLG,BMRP       JUMP IF NO READ IS IN PROGRESS
         BZ    GET9
GET5     BAL   REX,CHK         CHECK THE CURRENT READ
         MVC   CBLK,NBLK       SAVE BLOCK NO. OF BLOCK JUST READ
         L     R8,ABUF         SWAP BUFFERS, SETTING R8 TO THE ADDRESS
         MVC   ABUF,CBUF          OF THE BUFFER CONTAINING THE BLOCK
         ST    R8,CBUF            JUST READ
         LR    R7,R8           SET R7 TO END+1 OF BLOCK JUST READ
         AH    R7,0(R8)
         CLI   2(R8),X'FF'     JUMP IF BLOCK WAS LAST BLOCK OF EXTENT
         BE    GET8               (NEVER JUMP FOR TAPE MASTER)
         L     R1,NBLK         BUMP BLOCK NUMBER BY 1
         LA    R1,1(R1)
         ST    R1,NBLK
GET6     CLI   BUFNO,C'2'      JUMP IF ONLY 1 BUFFER IN USE
         BNE   GET7
         TM    GFLG,BMDM       JUMP IF A DISK MASTER
         BO    GET6B
         LR    R1,R7           THIS IS TAPE. IF BLOCK JUST READ WAS
         SH    R1,=H'18'          LAST BLOCK ON TAPE, SKIP NEW READ.
         CLC   0(2,R1),=X'FFFF'   (THIS SKIPS END-FILE AND ALLOWS MORE
         BE    GET7               PROCESSING WITHOUT OPEN/CLOSE)
GET6B    L     R0,ABUF         INITIATE A NEW READ
         LA    R1,NBLK+1
         BAL   REX,READ
GET7     LA    R8,4(R8)        BUMP R8 TO 1ST RECORD IN THE BLOCK
         ST    R8,LOC          STORE STARTING AND ENDING ADDRESS
         ST    R7,EBT             OF THE NEW BLOCK
         B     GET2
         SPACE 1
*BLOCK JUST READ WAS THE FINAL BLOCK OF AN EXTENT
         SPACE 1
GET8     MVC   NBLK+1(3),0(R7) GET BLK NUMBER OF START OF NEXT EXTENT
         CLC   NBLK+1(3),=X'000000'  JUMP IF NO EXTENTS LEFT (REACHED
         BE    GET7                    END OF MODULE)
         B     GET6
         SPACE 1
*NO READ IS CURRENTLY IN PROGRESS
         SPACE 1
GET9     L     R0,ABUF         START A NEW READ
         LA    R1,NBLK+1
         BAL   REX,READ
         B     GET5
         SPACE 1
*REREAD FLAG IS ON.  REPROCESS PREVIOUS RECORD
         SPACE 1
GET10    NI    MFLG,255-BMRR   RESET REREAD FLAG
         L     R8,GET15        GET ADDRESS OF PREVIOUS RECORD
         B     GET3
         SPACE 1
GET15    DS    1F              ADDRESS OF MOST RECENT RECORD
GET16    DS    1F              STORAGE FOR REX
         SPACE 5
*SUBROUTINE READ
*READ NEXT BLOCK FROM TAPE OR DISK MASTER
*R0 HAS BUFFER ADDRESS, R1 POINTS TO 3 BYTE BLOCK NO. IF DISK MASTER
********** THIS ROUTINE MAY NOT DESTROY REGISTERS 2-12 **********
         SPACE 1
READ     DS    0H
         ST    REX,GW          SAVE RETURN
         STM   R2,R3,GW+4      SAVE SOME REGISTERS
         LR    R2,R0           MOVE BUFFER ADDRESS INTO R2
         LR    R3,R1           MOVE BLOCK NO. POINTER INTO R3
         BAL   REX,CHK         CHECK ANY OUTSTANDING READS
*        ABOVE CHECK FLUSHES ALT BUFFER READ ON -INC PROCESSING OR
*        IF THE USER TERMINATES PROCESSING OF A MODULE BEFORE THE END
         TM    GFLG,BMDM       JUMP IF TAPE MASTER
         BZ    READ4
         READ  DDECB,DI,DMAST,(R2),'S',0,(R3)   BDAM READ MACRO
READ2    OI    GFLG,BMRP       SET 'READ IN PROGRESS' FLAG
         LM    R2,R3,GW+4      RESTORE REGISTERS USED
         L     REX,GW          PICK UP RETURN
         BR    REX             EXIT
         SPACE 1
READ4    READ  TDECB,SF,TMAST,(R2),'S'  BSAM READ MACRO FOR TAPE
         B     READ2
         EJECT
*SUBROUTINE DFIND
*R1 POINTS TO THE MODULE NAME TO BE LOOKED UP.
*MODULE NAME AND BLOCK ADDRESS PUT IN AREA NNT (00S IF NOT FOUND)
***** THIS ROUTINE CAN'T USE REG RP2 (R13) DUE TO I/O MACROS *****
         SPACE 1
DFIND    STM   4,10,IRSAV          SAVE REGISTERS
         LR    RW3,R1              SET RW3 TO MODULE NAME
         XC    NNT,NNT             CLEAR RESULT AREA.
         MVC   RNAME(44),DSN   ENQUE THE INDEX USING DSNAME + '.2'
         MVC   RNAME+44(2),=C'.2'  (NOTE - RNAME FIELD MUST REMAIN
         ENQ   (QNAME,RNAME,S,46,SYSTEM)  INTACT TILL DEQ AT 'OUT')
         MVC   IBLAD,IBLAD1        SET UP TO READ FIRST BLOCK OF MODULE
         TM    USEBL2,QUSEBL2      IS MASTER INDEX USEFUL?
         BZ    GIB                 BRANCH IF NOT.
         LA    RW1,TWO+1           POINT TO DISK ADDRESS OF MASTER
         BAL   RLNK,READIB         INDEX.  READ MASTER INDEX
         CLC   0(2,RW2),TWO+2      DOES MASTER INDEX CONTAIN MORE THAN
         BH    MUSE                TWO ENTRIES? BRANCH IF IT DOES.
         NI    USEBL2,255-QUSEBL2  INDICATE MASTER INDEX NOT USEFUL.
MUSE     LA    RT2,L'NNT1+L'NNT2   LOAD LENGTH OF A MASTER INDEX ENTRY.
         LR    RT1,RT2             SAVE FOR SCAN OF INDEX.
         MH    RT2,0(0,RW2)        POINT TO BYTE FOLLOWING LAST ENTRY
         AR    RW2,RT2             IN MASTER INDEX (MINUS 4).
MOP      SR    RW2,RT1             SCAN BACKWARD UNTIL RW2 POINTS TO
         CLC   0(8,RW3),4(RW2)     FOURTH BYTE PRECEDING LAST ENRTY FOR
         BL    MOP                 MODULE NAME NOT GREATER THAN SOUGHT.
         MVC   IBLAD,4+L'NNT1(RW2) SET DISK ADDRESS FOR READ OF MODULE
GIB      LA    RW1,IBLAD           INDEX. POINT TO DISK ADDRESS FIELD.
GIB1     BAL   RLNK,READIB         READ MODULE INDEX BLOCK
         CLC   0(8,RW3),0(RW2)     IS SOUGHT MODULE NAME OUTSIDE RANGE
         BL    GOTIB               OF THIS BLOCK? BRANCH IF NOT.
         MVC   IBLAD,9(RW2)        SET TO READ SUCCESSOR TO THIS BLOCK
         B     GIB1
         SPACE 2
*SUBROUTINE TO READ AND CHECK AN INDEX BLOCK
READIB   ST    REX,SAVREX      SAVE REX
         L     R0,ABUF         SET BUFFER ADDRESS FOR THE READ ROUTINE
         LR    R1,RW1          SET BLOCK NUMBER POINTER
         BAL   REX,READ        CALL READ ROUTINE
         BAL   REX,CHK         CHECK THE READ
         L     REX,SAVREX      RESTORE REX
         L     RW2,ABUF        SET RW2 TO BLOCK
         BR    RLNK            EXIT
SAVREX   DS    1F              STORAGE FOR REGISTER REX
         SPACE 3
GOTIB    LH    RT2,12(0,RW2)       LOAD NUMBER OF ENTRIES IN INDEX
         LTR   RWK,RT2             BLOCK AND TEST FOR ZERO.
         BNP   OUT                 BRANCH IF BLOCK IS EMPTY.
         BCTR  RT2,0               COMPUTE RELATIVE NUMBER OF LAST
         LA    RLNK,12             ENTRY. SET SEARCH LOOP LIMIT.
         SR    RT1,RT1             INDICATE SCAN MAY GO BACK TO FIRST
PLOP     SRA   RWK,1               ENTRY. SET MIDDLE ENTRY CURRENT.
         LR    RGO,RWK             COMPUTE (IN RGO) ADDRESS (-16) OF
         MH    RGO,LNNT            ENTRY THAT WE WANT TO LOOK AT.
         AR    RGO,RW2             COMPARE MODULE NAME IN INDEX ENTRY
         CLC   0(8,RW3),16(RGO)    WITH MODULE NAME THAT WE SEEK.
         BL    BACK                BRANCH IF WE ARE TOO FAR DOWN.
         BH    FORWARD             BRANCH IF WE ARE TOO FAR UP.
         MVC   NNT,16(RGO)         MOVE FOUND ENTRY TO RESULT AREA.
         SPACE 1
OUT      DEQ   (QNAME,RNAME,46,SYSTEM)  DEQUE THE INDEX
         LM    4,10,IRSAV      RESTORE REGISTERS
         BR    REX                 EXIT
         SPACE 1
BACK     CR    RWK,RT1             ARE WE BACKED UP AS FAR AS POSSIBLE?
         BE    OUT                 BRANCH IF WE ARE. MODULE NOT FOUND.
         LR    RT2,RWK             SET THIS SLOT AS NEW BOTTOM OF SCAN.
         AR    RWK,RT1             BACK UP HALFWAY TO TOP OF SCANNABLE
         BCT   RLNK,PLOP           AREA AND CONTINUE SEARCH.
         B     OUT                 EXIT IF WE ARE OSCILLATING.
FORWARD  CR    RWK,RT2             HAVE WE GONE AS FAR DOWN THE BLOCK
         BE    OUT                 AS WE CAN? BRANCH IF WE HAVE.
         LR    RT1,RWK             SET THIS SLOT AS NEW TOP OF SCAN.
         LA    RWK,1(RT2,RWK)      MOVE HALFWAY DOWN TO END OF
         BCT   RLNK,PLOP           SCANNABLE AREA AND CONTINUE SEARCH.
         B     OUT                 EXIT IF WE ARE OSCILLATING.
         SPACE 2
*WORK AREAS, CONSTANTS, ETC USED BY ROUTINE DFIND
         SPACE 1
TWO      DC    F'2'            ADDRESS OF MASTER INDEX
IBLAD1   DC    AL3(3)          ADDRESS OF 1ST MODULE INDEX BLOCK
IBLAD    DC    AL3(3)          ADDRESS OF NEXT MODULE INDEX BLOCK
USEBL2   DC    X'00'
QUSEBL2  EQU   X'40'
         SPACE 1
*FORMAT OF INDEX TABLE ENTRY (ROUTINE DFIND PLACES ENTRY HERE)
         DS    0H
NNT      DS    0CL22
NNT1     DS    CL8                 MODULE NAME (HEX 00S IF NOT FOUND)
NNT2     DS    XL3                 REL BLOCK ADDRESS OF THE MODULE
NNT4     DS    XL1                 NO. OF EXTENTS
NNT3     DS    H                   NO. OF ACCESSES
NNT5     DS    XL1                 NO. OF BLOCKS
NNT6     DS    PL3                 NO. CARDS IN MODULE
NNT7     DS    H                   NO. OF UPDATES
NNT8     DS    H                   DATE OF LAST ACCESS
         SPACE 1
LNNT     DC    AL2(L'NNT)          LENGTH OF INDEX TABLE ENTRY
         EJECT
*SUBROUTINE UNPK
*FROM MASTER RECORD, CREATE CARD IMAGE (WITH DATE AND SEQ NUMBER)
*R8 POINTS TO START OF MASTER RECORD
*R2 POINTS TO AREA IN WHICH TO PLACE THE CARD IMAGE
         SPACE 1
UNPK     STM   4,13,IRSAV          RESTORE REGISTERS
         LR    RMAST,R8            SET RMAST TO THE MASTER RECORD
         LR    RW2,R2              SET RW2 AS O/P AREA POINTER
         MVI   0(RW2),C' '         CLEAR OUTPUT AREA
         MVC   1(79,RW2),0(RW2)
         LA    RW1,2(0,RMAST)  SET RW1 TO MASTER RCD BEYOND FLAG BYTE
         CLI   SEQR,C'1'       ADVANCE RW1 OVER SEQ NO. IF IN RECORD
         BNE   *+8
         LA    RW1,3(RW1)
         TM    1(RMAST),X'80'  ADVANCE RW1 OVER DATE FIELD IF IN RCD
         BZ    *+8
         LA    RW1,2(0,RW1)
         SR    RT2,RT2            SET RW3 TO RHE+1 OF MASTER RECORD
         IC    RT2,0(0,RMAST)
         LR    RW3,RMAST
         AR    RW3,RT2
         CLI   0(RMAST),150       IS LENGTH REASONABLE?
         BNL   H2                  NO.
         SPACE 1
         TM    1(RMAST),X'20'    UNCOMPRESSED CARD??
         BO    UNPK10P            YES
UNPK2    CR    RW1,RW3
         BNL   UNPK10             TRA IF END OF MASTER RECORD
         LA    RT1,134(R2)        ERROR IF END OF CARD IMAGE BECOMES
         CR    RW2,RT1               UNREASONABLY LONG
         BNL   H2                  NO.
*        RW1 NOW POINTS TO A CONTROL BYTE
         IC    RT2,0(0,RW1)       PUT CONTROL BYTE INTO RT2
         TM    0(RW1),X'C0'
         BNZ   UNPK8              BRANCH IF BLANKS COUNT OR RES. WORD
         SPACE 1
*        CONTROL BYTE MARKS START OF DATA STRING. RT2 HAS STRING LNGTH
         LR    RGO,RT2            SAVE STRING LENGTH IN RGO
         TM    1(RMAST),X'40'
         BO    UNPK7              TRA IF 8 BIT PACKING
         SPACE 1
*        6 BIT PACKING
         SLL   RT2,2              MULTIPLY LENGTH BY 4/3 TO GET NO. OF
         SR    RT1,RT1               6-BIT BYTES. RESULT IS PLACED IN
         D     RT1,=F'3'             REGISTER RT2
         LTR   RT1,RT1            TEST REMAINDER FOR 0.  IF 0, THEN
         BNZ   UNPK3                 STRING IN MASTER RCD IS A MULTIPLE
         LR    1,RW1                 OF 3.  THE POSSIBILITY THEN EXISTS
         AR    1,RGO                 THAT LAST 6 BITS OF LAST BYTE MAY
         TM    0(1),X'3F'            BE FILLER INSTEAD OF A VALID BYTE.
         BNZ   UNPK3                 IF LAST 6 BITS = 0, IT IS FILLER
         BCTR  RT2,0                 AND O/P BYTE COUNT IS REDUCED BY 1
UNPK3    LR    RLNK,RW2           SAVE O/P LOCATOR FOR TR INSTRUCTION
         LR    1,RT2              PUT LENGTH - 1 OF O/P FIELD INTO
         BCTR  1,0                   TRANSLATE INSTRUCTION
         STC   1,UNPK6A+1
         LA    RW1,1(0,RW1)       ADVANCE RW1 OVER CONTROL BYTE AND
         LR    RP2,RW1            SET RP2 TO FIRST DATA BYTE IN STRING
UNPK4    LA    RT1,4              SET LOOP CONTROL FOR SHIFTING
         LA    1,2
         CR    RT2,1
         BH    SUB0
         BE    SUB1
         BCTR  1,0
SUB1     BCTR  1,0
SUB0     EX    1,MOVE
         L     1,WA2WD               (LEFTMOST 24 BITS)
UNPK5    SR    0,0                SHIFT 1 BYTE INTO REG 0 AND STORE IN
         SLDL  0,6                   CARD IMAGE
         STC   0,0(0,RW2)
         LA    RW2,1(0,RW2)       ADVANCE CARD IMAGE LOCATOR
         BCT   RT2,UNPK6          BRANCH IF NOT END OF STRING
UNPK6A   TR    0(0,RLNK),CONV8BIT TRANSLATE STRING TO EBCIDIC
         AR    RW1,RGO            ADVANCE RW1 BY LENGTH OF STRING
         B     UNPK2
UNPK6    BCT   RT1,UNPK5          FALL THRU AT END OF 3-BYTE GROUP
         LA    RP2,3(0,RP2)       ADVANCE TO NEXT 3-BYTE GROUP
         B     UNPK4
         SPACE 1
MOVE     MVC   WA2WD(0),0(RP2)    MOVE PACKED FIELD INTO WORK AREA
         SPACE 1
*        8 BIT PACKING.  RT2 HAS FIELD LENGTH
UNPK7    BCTR  RT2,0              REDUCE STRING LENGTH BY 1 AND STORE
         STC   RT2,*+5               IN MVC INSTRUCTION
         MVC   0(0,RW2),1(RW1)    MOVE DATA FIELD TO CARD IMAGE
         AR    RW2,RGO            ADVANCE CARD IMAGE LOCATOR
         LA    RW1,1(RGO,RW1)     ADVANCE RW1 BY LENGTH OF STRING PLUS
         B     UNPK2                 CONTROL BYTE
         SPACE 1
*        CONTROL BYTE IS FOR BLANKS STRING OR RESERVED WORD
UNPK8    N     RT2,UNPK21         MASK FLAG BITS OUT OF REGISTER
         TM    0(RW1),X'80'
         BO    UNPK9              BRANCH IF RESERVED STRING CODE
         AR    RW2,RT2            ADVANCE CARD LOCATOR BY NO. OF BLANKS
         LA    RW1,1(0,RW1)       ADVANCE RW1 OVER CONTROL BYTE
         B     UNPK2
         SPACE 1
*        CONTROL BYTE IS FOR A RESERVED STRING
*        RT2 HAS INDEX TO RESERVED STRING ADDRESS TABLE (RWADDR)
UNPK9    CH    RT2,RWENT           VALID RESERVED WORD??
         BH    H2                  NO.
         LR    1,RT2              MOVE RESERVED-WORD CODE TO REGISTER
         SLL   1,2                   1 AND MULTIPLY BY 4
         LA    RT1,RWADDR        ADD BASE ADDRESS OF TABLE
         AR    1,RT1
         IC    RT2,0(0,1)         PUT LENGTH-1 OF STRING IN RT2
         L     RT1,0(0,1)         PUT ADDRESS OF STRING IN RT1
         STC   RT2,*+5            STORE LENGTH-1 IN MVC INSTRUCTION
         MVC   0(0,RW2),0(RT1)    MOVE STRING TO CARD IM1GE
         LA    RW2,1(RT2,RW2)     ADVANCE CARD LOCATOR BY STRING LENGTH
         LA    RW1,1(0,RW1)       ADVANCE RW1 OVER CONTROL BYTE
         B     UNPK2
         SPACE 1
*        UNCOMPRESSED CARD
UNPK10P  MVC   0(80,R2),1(RW1)   MOVE CARD IMAGE TO USER AREA
         SPACE 1
*        CARD IMAGE IS NOW COMPLETE EXCEPT FOR SEQUENCE NUMBER
UNPK10   TM    1(RMAST),X'02'
         BO    UNPK14             TRA IF HISTORY RECORD
         CLI   SEQR,C'1'       JUMP IF SEQ NO. IS WITHIN MASTER RCD
         BE    UNPK11
         L     R1,SEQWK        COMPUTE SEQ NO. FOR THIS CARD
         AH    R1,SEQ+2
         ST    R1,SEQWK
         B     UNPK11B
UNPK11   MVC   WA2WD+1(3),2(RMAST)  MOVE SEQ NO. FROM MASTER RCD TO R1
         MVI   WA2WD,X'00'
         L     R1,WA2WD
UNPK11B  CVD   R1,WA2WD        CONVERT SEQ NO. TO 10 BYTE EBCIDIC
         UNPK  GW(10),WA2WD       NUMBER IN AREA GW
         OI    GW+9,X'F0'
         MVC   80(8,R2),GW+2   PUT SEQ NO. INTO 81-88 OF USER AREA
         SPACE 1
*        NOW INSERT THE SEQUENCE NUMBER INTO THE CARD IMAGE ITSELF
         CLI   SEQ,X'50'
         BE    UNPK14          JUMP IF SEQ NO. OUTSIDE OF CARD
         CLI   SEQ,X'47'
         BH    UNPK12          JUMP IF SEQ NO. STARTS AFTER COL 72
*        SEQ NO. STARTS PRIOR TO COL 72.  MAY WANT TO FORCE 73-80
         CLI   0(R2),X'02'
         BE    UNPK16          JUMP IF RELOC DECK
         CLI   0(R2),C'/'
         BE    UNPK16          JUMP IF JCL CARD
         CLI   0(R2),X'6C'
         BE    UNPK16          JUMP IF PERCENT IN COLUMN 1
         CLI   79(R2),X'6C'
         BE    UNPK16          JUMP IF PERCENT IN COLUMN 80
*        INSERT SEQ NO. AS SPECIFIED IN SEQ NO. PARAMETER
UNPK12   LR    RW1,R2          SET RW1 TO ADDRESS OF 1ST BYTE
         SR    RT2,RT2
         IC    RT2,SEQ
         AR    RW1,RT2
         IC    RT2,SEQ+1       LOAD LENGTH-1 OF SEQ NO. FIELD AND
         STC   RT2,UNPK13+1          PUT IT IN MVC INSTRUCTION
         LA    RW2,GW+9        SET RW2 TO LEFTMOST BYTE OF SEQ NO.
         SR    RW2,RT2               IN 10-BYTE WORK AREA
UNPK13   MVC   0(0,RW1),0(RW2)    MOVE SEQ NO. TO CARD IMAGE
         SPACE 1
UNPK14   LM    4,13,IRSAV      RESTORE REGISTERS
         BR    REX             EXIT
         SPACE 1
*        CARD IS TO BE SEQUENCED IN 73-80 REGARDLESS OF SEQ PARAMETER
UNPK16   MVC   72(8,R2),GW+2   PUT SEQ NO. INTO COLUMNS 73-80
         B     UNPK14
         SPACE 1
UNPK21   DC    F'63'
         EJECT
*SUBROUTINE DATE
*CONVERT DATE FROM 2 BYTE BINARY FORMAT TO MM/DD/YY
*R8 POINTS TO START OF MASTER RECORD CONTAINING THE DATE FIELD
*R1 IS SET TO THE 8 BYTE EBCIDIC RESULT
*IF RECORD HAS NO DATE FIELD, 8 BYTE AREA BECOMES BINARY 0S
         SPACE
*ALTERNATE ENTRY POINT IS 'DATE1', WITH DATE FIELD ALREADY IN R15.
         SPACE 1
DATE     DS    0H
         MVI   GW,C' '         CLEAR RESULT AREA IN CASE NO DATE
         MVC   GW+1(7),GW
         TM    1(R8),X'80'     JUMP IF NO DATE FOR THIS CARD
         BZ    DATE2
         LA    R14,2(R8)
         CLI   SEQR,C'1'
         BNE   *+8
         LA    R14,3(R14)
         XC    WORK(2),WORK    PUT 2 BYTE DATE FIELD INTO R15
         MVC   WORK+2(2),0(R14)
         L     R15,WORK
*ALTERNATE ENTRY POINT IS HERE (DATE ALREADY IN R15)
DATE1    SR    R14,R14         CONVERT AND STORE MONTH
         SLDL  R14,20
         CVD   R14,WORK
         UNPK  GW(2),WORK
         SR    R14,R14         CONVERT AND STORE DAY
         SLDL  R14,5
         CVD   R14,WORK
         UNPK  GW+3(2),WORK
         SR    R14,R14         CONVERT AND STORE YEAR
         SLDL  R14,7
         CVD   R14,WORK
         UNPK  GW+6(2),WORK
         OI    GW+1,X'F0'
         OI    GW+4,X'F0'
         OI    GW+7,X'F0'
         MVI   GW+2,C'/'
         MVI   GW+5,C'/'
DATE2    LA    R1,GW           SET R1 TO RESULT
         BR    REX             EXIT
         EJECT
*SUBROUTINE SMP
*READ IN 1ST CONTROL RECORD OF MODULE, SET UP MISCELLANEOUS PARAMETERS
         SPACE 1
SMP      DS    0H
         LR    R9,REX          SAVE EXIT
         BAL   REX,GET         GET 1ST CONTROL RECORD OF MODULE
         TM    1(R8),X'08'     ERROR IF NOT A CONTROL RECORD
         BZ    H1
         MVC   SEQ,35(R8)      INITIALIZE SEQUENCE NUMBER PARAMETERS
         MVC   SEQR,34(R8)
         LH    R1,SEQ+4
         ST    R1,SEQWK
         BR    R9              EXIT
         SPACE 5
*SUBROUTINE CHK
*CHECK ANY OUTSTANDING READS
***** DO NOT USE ANY REGISTERS OR AREAS EXCEPT R0 AND R1 *****
         SPACE 1
CHK      DS    0H
         TM    GFLG,BMRP       JUMP IF NO READS IN PROGRESS
         BZ    CHK2
         LA    R1,DDECB        GET PROPER DECB ADDRESS FOR DISK OR TAPE
         TM    GFLG,BMDM
         BO    *+8
         LA    R1,TDECB
         CHECK (R1)            CHECK THE READ
         NI    GFLG,255-BMRP   RESET 'READ IN PROGRESS' FLAG
CHK2     BR    REX             EXIT
         SPACE 5
*SUBROUTINE DQM
*DEQUE A MODULE NAME.  R1 POINTS TO AREA CONTAINING NAME.
*A BLANK IS PLACED INTO THE AREA THAT CONTAINS THE MODULE NAME
         SPACE 1
DQM      CLI   0(R1),C' '      CHECK IF THERE IS NO NAME TO DEQUE
         BE    DQM2               JUMP IF NONE
         MVC   RNAME(44),DSN   CONSTRUCT RNAME (DSNAME+MOD NAME)
         MVC   RNAME+44(8),0(R1)
         MVI   0(R1),C' '      SET AREA CONTAINING NAME TO A BLANK
         DEQ   (QNAME,RNAME,52,SYSTEM)  DEQUE MODULE
DQM2     BR    REX             EXIT
         SPACE 5
*SUBROUTINE EQM
*ENQUE A MODULE NAME.  R1 POINTS TO AREA CONTAINING NAME.
         SPACE 1
EQM      MVC   RNAME(44),DSN   CONSTRUCT RNAME (DSNAME+MOD NAME)
         MVC   RNAME+44(8),0(R1)
         ENQ   (QNAME,RNAME,S,52,SYSTEM)  ENQUE THE MODULE
         BR    REX             EXIT
         SPACE 5
*SUBROUTINE CDQ
*DEQUE ANY MODULES WHICH ARE CURRENTLY ENQUED
*THIS ROUTINE SERVES TO DEQUE MODULES WHEN A USER DISCONTINUES THE
*PROCESSING OF A MODULE BEFORE THE FINAL RECORD IS REACHED.
         SPACE 1
CDQ      LR    R7,REX          SAVE RETURN
         LA    R1,NAMENQ       DEQUE MODULE CURRENTLY BEING PROCESSED
         BAL   REX,DQM
         L     R8,INCA1        SET R8 TO START OF -INC SAVE AREA
CDQ2     C     R8,INCA2        FOR EACH ENTRY IN THE SAVE AREA, DEQUE
         BNL   0(R7)             MODULE REFERENCED BY THAT ENTRY
         LA    R1,NAMENQ-MP(R8)  (EXIT WHEN ALL ENTRIES PROCESSED)
         BAL   REX,DQM
         LA    R8,MPL(R8)
         B     CDQ2
         SPACE 5
*SUBROUTINE RBF
*RETURN BUFFER AREAS TO SYSTEM (IF BUFFERS WERE GOTTEN FROM SYSTEM)
         SPACE 1
RBF      DS    0H
         L     R1,FREEMA       PICK UP ADDRESS OF START OF BUFFERS
         LTR   R1,R1           JUMP IF NO BUFFERS WERE OBTAINED
         BZ    RBF2
         LH    R0,FREEML       PICK UP SIZE OF AREA
         FREEMAIN R,LV=(R0),A=(R1)  RETURN CORE TO THE SYSTEM
         XC    FREEMA,FREEMA   SET POINTER = 0 TO SHOW AREA RETURNED
RBF2     BR    REX             EXIT
         SPACE 5
*SUBROUTINE PARM
*PICK UP USER PARAMETERS, PLACE IN REGISTERS STARTING WITH R2
*IF OPTIONAL PARAMETERS ARE OMITTED, CORRESPONDING REGS ARE SET TO 0
         SPACE 1
PARM     DS    0H
         XC    GW(PARM6*4),GW  INITIALIZE WORK AREA
         LA    R14,PARM6       SET LOOP CONTROL
         LA    R15,GW
PARM2    MVC   1(3,R15),1(1)   MOVE ADDRESS OF A PARAMETER TO WORK AREA
         TM    0(1),X'80'
         BO    PARM4           JUMP IF THIS WAS LAST PARAMETER
         LA    1,4(1)          ADVANCE POINTERS
         LA    R15,4(R15)
         BCT   R14,PARM2       TEST IF REACHED MAX NO. OF PARAMS
         SPACE 1
PARM4    LM    R2,R2+PARM6-1,GW  PUT PARAMETERS INTO REGISTERS
         BR    REX             EXIT
         SPACE 1
PARM6    EQU   6               MAX NUMBER OF PARAMETERS ALLOWED
         SPACE 5
*COME HERE UPON ILLOGICAL CONDITION ON MASTER FILE.
*R3 MUST POINT TO 1 BYTE EBCIDIC RETURN CODE FIELD
         SPACE 1
HELP     DS    0H
         MVI   0(R3),C'9'      SET RETURN CODE
         B     RET             RETURN TO USER
         SPACE 2
*VARIOUS ILLOGICAL CONDITIONS COME TO THESE LABELS IN ORDER TO SET
*'DBCOD' TO A DIGIT IDENTIFYING THE TYPE OF ERROR.  THIS IS REALLY FOR
*DIAGNOSTIC PURPOSES ONLY.  THESE PATHS EVENTUALLY ALL GO TO 'HELP'
         SPACE 1
H1       MVI   DBCOD,C'1'
         B     HELP
H2       MVI   DBCOD,C'2'
         B     HELP
H3       MVI   DBCOD,C'3'
         B     HELP
         SPACE 1
DBCOD    DC    C'Z'            DEBUGGING CODE
         SPACE 5
*RETURN TO CALLING PROGRAM
*R3 CONTAINS ADDRESS OF EBCIDIC RETURN CODE (PLACED IN R15 IN BINARY)
***** DO NOT DESTROY R0 OR R1 (CERTAIN PATHS SET THESE REGS)
         SPACE 1
RET      DS    0H
         IC    15,0(R3)        PUT RETURN CODE IN REGISTER 15
         N     15,=F'15'       CLEAR BITS 00-27 OF REG 15
         L     13,REGSAV+4     GET ADDRESS OF ORIGINAL SAVE AREA
         L     14,12(13)       LOAD RETURN ADDRESS
         LM    2,12,28(13)     RESTORE REGISTERS 2-12
         BR    14              RETURN TO USER
         EJECT
*THE LABEL 'DEBUG' IS REFERENCED BY THE TEST DRIVER FOR DEBUGGING
         ENTRY DEBUG
DEBUG    DS    0H
         SPACE 2
REGSAV   DS    18F             SAVE AREA FOR REGISTERS
WORK     DS    1D              GENERAL WORK AREA OF A DOUBLEWORD
INCPNT   DC    A(0)            POINTER FOR AREA 'INCSAV'
INCA1    DC    A(INCSAV)       ADDRESS OF START OF SAVE AREA
INCA2    DC    A(INCSAVX)      ADDRESS OF END OF SAVE AREA
WA2WD    EQU   WORK            REDEFINES AREA 'WORK'
QNAME    DC    CL8'ADRPRDCT'   QNAME FOR ENQ/DEQ OPERATIONS
FREEMA   DC    A(0)            USED BY FREEMAIN MACRO
FREEML   DC    H'0'            USED BY FREEMAIN MACRO
PRD2CON  DC    C'P2'           CONSTANT DENOTING PROD2 MODULE
BLSIZ    DC    H'0'            MASTER FILE BLOCK SIZE
EBZERO   DC    C'0'            CONSTANT OF EBCIDIC ZERO
GFLG     DC    X'00'           FLAG BITS FOR VARIOUS FUNCTIONS
BUFNO    DC    C'0'            NO. OF BUFFERS (EBCIDIC)
INCFL    DS    CL1             -INC FLAG FROM LATEST CALL ON MASTMOD
DSN      DS    CL44            DSNAME FOR DISK MASTER
TMLR     DS    CL8             TAPE MASTER - NAME OF LAST MODULE READ
RWENT    DC    Y(RWADDRL/4)    NUMBER OF ENTRIES IN TABLE RWADDR
MSTAT    DC    X'00'           MODULE STATUS BITS (FROM CONTROL RCD)
INCNAME  DC    CL8' '            SAVE AREA FOR INC NAME.
         SPACE 2
         DS    0F              EXIT LIST FOR READING JFCB BLOCKS
JFEX     DC    X'87'
         DC    AL3(JF)
         SPACE 2
*NEXT SET OF FIELDS PERTAINS TO SEQUENTIAL PROCESSING OF DISK MASTER
SDCB     DC    AL3(0)          BLOCK NO. OF CURRENT INDEX BLOCK
SDNB     DC    AL3(0)          BLOCK NO. OF NEXT INDEX BLOCK
SDMC     DC    H'0'            NO. OF ENTRIES LEFT IN CURRENT BLOCK
SDBP     DC    A(0)            POINTER TO NEXT ENTRY IN INDEX BLOCK
SDBF     DC    A(0)            BUFFER ADDRESS FOR READING IN INDEX BLKS
         SPACE 2
JF       DS    CL176           JFCB BLOCKS (ALSO GENERAL WORK AREA)
GW       EQU   JF              REDEFINE JF FOR USE AS GENERAL WORK AREA
IRSAV    EQU   JF+100          INTERNAL REG SAVE AREA (OVERLAYS JF)
RNAME    EQU   JF+32           RNAME AREA FOR ENQ/DEQ (OVERLAYS JF)
         EJECT
***********************************************************************
*ALL FIELDS BETWEEN LABELS MP AND MPE PERTAIN TO THE MODULE CURRENTLY
*BEING ACCESSED.  WHEN AN -INC CARD IS TO BE PROCESSED, THESE MUST BE
*SAVED AND RESTORED. THEREFORE, DON'T MOVE ANY OF THESE FIELDS.
         SPACE 1
MP       DS    0F              DEFINES START OF FIELDS TO BE SAVED
NAMENQ   DC    CL8' '          NAME OF MODULE (FOR ENQ PURPOSES)
LOC      DC    F'0'            BLOCK POINTER (ADDRESS OF CURRENT RCD)
EBT      DC    F'0'            ADDRESS OF END+1 OF CURRENT BLOCK
NBLK     DC    F'0'            BLOCK NO. OF BLOCK CURRENTLY BEING READ
CBLK     DC    F'0'            BLOCK NO. OF BLOCK BEING PROCESSED
CBUF     DC    A(0)            BUFFER CURRENTLY BEING PROCESSED
ABUF     DC    A(0)            BUFFER CURRENTLY BEING READ INTO
*        NOTE - FOR SINGLE BUFFERING, CBUF AND ABUF HAVE SAME ADDRESS
SEQWK    DC    F'0'            SEQUENCE NUMBER WORK AREA
SEQ      DS    CL6             SEQUENCE NUMBER PARAMETERS
SEQR     DS    CL1             = '1' IF SEQ NO. IS IN MASTER RCDS
MFLG     DS    CL1             FLAG BITS FOR VARIOUS FUNCTIONS
MPL      EQU   *-MP            DEFINES # OF BYTES TO BE SAVED
***********************************************************************
         SPACE 1
*AREA FOR SAVING VARIOUS PARAMETERS DURING PROCESSING OF INCLUDED
*MODULES.  THERE IS ROOM FOR UP TO 5 LEVELS OF -INC NESTING.
*NOTE: TO INCREASE LEVEL OF NESTING, SIMPLY ADD MORE AREAS.  NO
*OTHER CHANGES ARE NEEDED ANYWHERE IN THE ROUTINES.
*NOTE: ENTRIES ARE SET TO BLANKS SO SUBFIELD NAMENQ IS BLANK
INCSAV   DS    0C
         DC    CL(MPL)' '
         DC    CL(MPL)' '
         DC    CL(MPL)' '
         DC    CL(MPL)' '
         DC    CL(MPL)' '
INCSAVX  EQU   *               DEFINES END OF AREA
         SPACE 2
CYCA     EQU   INCSAV+8        REDEFINE INCSAV FOR USE IN MASTOPN
*NOTE: AREA CYCA MAY NOT OVERLAP THE 1ST BYTE OF INCSAV (1ST BYTE OF
*EACH SUBFIELD IN INCSAV IS USED AS ENQ/DEQ FLAG FOR MODULES)
         SPACE 2
*EQUATES FOR BIT VALUES IN FIELD MFLG
BMRR     EQU   X'01'           = 1 TO REPROCESS CURRENT RECORD
         SPACE 2
*EQUATES FOR BIT VALUES IN FIELD GFLG
BMOP     EQU   X'01'           = 1 IF A MASTER IS CURRENTLY OPEN
BMDM     EQU   X'02'           = 1 IF DISK MASTER, 0 IF TAPE
BMOM     EQU   X'04'           = 1 IF A MODULE IS CURRENTLY 'OPEN'
BMRP     EQU   X'10'           = 1 IF UNCHECKED READ OUSTANDING
         SPACE 2
*DCB BLOCKS
         SPACE 1
TMAST    DCB   DDNAME=MASTIN,DSORG=PS,MACRF=RP,BUFNO=0,EXLST=JFEX,     X
               RECFM=U,EODAD=H3
         SPACE 1
DMAST    DCB   DDNAME=MASTER,DSORG=DA,MACRF=RIC,BUFNO=0,RECFM=F,       X
               OPTCD=R,EXLST=JFEX
         SPACE 1
CYCLE    DCB   DDNAME=CYCLE,DSORG=PS,MACRF=R,BUFNO=0,RECFM=U,          X
               BLKSIZE=500
         SPACE 5
         LTORG
         EJECT
CONV8BIT DS    0F
         DC    X'E9404A4B4C4D4E4F505A5B5C5D5E5F60'
         DC    X'616B6C6D6E6F7A7B7C7D7E7FC1C2C3C4'
         DC    X'C5C6C7C8C9D1D2D3D4D5D6D7D8D9E2E3'
         DC    X'E4E5E6E7E8E9F0F1F2F3F4F5F6F7F8F9'
         SPACE 3
RWADDR   DS    0F
         DC    AL1(L'RWC1-1)
         DC    AL3(RWC1)
         DC    AL1(L'RWC2-1)
         DC    AL3(RWC2)
         DC    AL1(L'RWC3-1)
         DC    AL3(RWC3)
         DC    AL1(L'RWC4-1)
         DC    AL3(RWC4)
         DC    AL1(L'RWC5-1)
         DC    AL3(RWC5)
         DC    AL1(L'RWC6-1)
         DC    AL3(RWC6)
         DC    AL1(L'RWC7-1)
         DC    AL3(RWC7)
         DC    AL1(L'RWC8-1)
         DC    AL3(RWC8)
         DC    AL1(L'RWC9-1)
         DC    AL3(RWC9)
         DC    AL1(L'RWC10-1)
         DC    AL3(RWC10)
         DC    AL1(L'RWC11-1)
         DC    AL3(RWC11)
         DC    AL1(L'RWC12-1)
         DC    AL3(RWC12)
         DC    AL1(L'RWC13-1)
         DC    AL3(RWC13)
         DC    AL1(L'RWC14-1)
         DC    AL3(RWC14)
         DC    AL1(L'RWC15-1)
         DC    AL3(RWC15)
         DC    AL1(L'RWC16-1)
         DC    AL3(RWC16)
         DC    AL1(L'RWC17-1)
         DC    AL3(RWC17)
         DC    AL1(L'RWC18-1)
         DC    AL3(RWC18)
         DC    AL1(L'RWC19-1)
         DC    AL3(RWC19)
         DC    AL1(L'RWC20-1)
         DC    AL3(RWC20)
         DC    AL1(L'RWC21-1)
         DC    AL3(RWC21)
         DC    AL1(L'RWC22-1)
         DC    AL3(RWC22)
         DC    AL1(L'RWC23-1)
         DC    AL3(RWC23)
         DC    AL1(L'RWC24-1)
         DC    AL3(RWC24)
         DC    AL1(L'RWC25-1)
         DC    AL3(RWC25)
         DC    AL1(L'RWC26-1)
         DC    AL3(RWC26)
         DC    AL1(L'RWC27-1)
         DC    AL3(RWC27)
         DC    AL1(L'RWC28-1)
         DC    AL3(RWC28)
         DC    AL1(L'RWC29-1)
         DC    AL3(RWC29)
         DC    AL1(L'RWC30-1)
         DC    AL3(RWC30)
         DC    AL1(L'RWC31-1)
         DC    AL3(RWC31)
         DC    AL1(L'RWC32-1)
         DC    AL3(RWC32)
         DC    AL1(L'RWC33-1)
         DC    AL3(RWC33)
         DC    AL1(L'RWC34-1)
         DC    AL3(RWC34)
         DC    AL1(L'RWC35-1)
         DC    AL3(RWC35)
         DC    AL1(L'RWC36-1)
         DC    AL3(RWC36)
         SPACE 1
RWADDRX  EQU   *               DEFINES END OF TABLE
         SPACE 1
RWADDRL  EQU   RWADDRX-RWADDR  DEFINES LENGTH OF TABLE RWADDR
         SPACE 5
RWC1     DC    C'FILLER '
RWC2     DC    C'PICTURE '
RWC3     DC    C'USAGE '
RWC4     DC    C'VALUE '
RWC5     DC    C'PERFORM '
RWC6     DC    C'SUBTRACT '
RWC7     DC    C'COMPUTE '
RWC8     DC    C'COMPUTATIONAL'
RWC9     DC    C'COMP'
RWC10    DC    C'REDEFINES '
RWC11    DC    C'RENAMES '
RWC12    DC    C'JUSTIFIED '
RWC13    DC    C'GIVING '
RWC14    DC    C'USING '
RWC15    DC    C'CALL '
RWC16    DC    C'ALTER '
RWC17    DC    C'EQUAL '
RWC18    DC    C'GREATER '
RWC19    DC    C'POSITIVE '
RWC20    DC    C'NEGATIVE '
RWC21    DC    C'ELSE '
RWC22    DC    C'OTHERWISE '
RWC23    DC    C'TO PROCEED TO '
RWC24    DC    C'VARYING '
RWC25    DC    C'FROM '
RWC26    DC    C'UNTIL '
RWC27    DC    C'THRU '
RWC28    DC    C'ROUNDED '
RWC29    DC    C'GO TO '
RWC30    DC    C'MOVE '
RWC31    DC    C'ZERO '
RWC32    DC    C'ZEROS '
RWC33    DC    C'DEPENDING '
RWC34    DC    C'PIC '
RWC35    DC    C'BLANK '
RWC36    DC    C'OCCURS '
         SPACE 3
         PRINT DATA
PATCH    DC    36S(*)          PATCH AREA
         SPACE 2
         END
